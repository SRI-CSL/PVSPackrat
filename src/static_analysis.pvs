

static_analysis [
    V_T   : TYPE+,
    <=    : (total_order?[V_T]),
    V_N_b : posnat
    ]:THEORY
BEGIN
  IMPORTING wf_peg[V_T, <=, V_N_b]
	IMPORTING c_topological_sort[V_N] % From nasalib
	IMPORTING interval_list

  V_N_not_empty : LEMMA EXISTS (x: V_N): TRUE

  A, B, C : VAR V_N
  σ, σ_p: VAR order
	σ_id : order = LAMBDA (A:V_N): A

  P_exp: VAR interp
  G: VAR Δ
  δ : VAR bool

  orderly_WF_nT?(P_exp): bool = EXISTS σ: strong_WF(σ, P_exp)


  every_iff_member[T :TYPE]: LEMMA ∀ (l: list[T], P:PRED[T]): every(P)(l) ⇔ (∀ (x:T): member(x,l) ⇒ P(x))

  l, l1, l2 : VAR list[nat]
	n,m : VAR nat
  node_ls : TYPE = {l : list[nat] | (no_repetitions?(l)) ∧ (∀ n : member(n,l) ⇒ 0 <= n <= V_N_b - 1)}
	node_ls_list_V_N : JUDGEMENT node_ls SUBTYPE_OF list[V_N]

  no_rep_cdr_iff: LEMMA ∀ l, n : no_repetitions?(cons(n,l)) ⇔ no_repetitions?(l) AND NOT member(n,l)
  no_repetitions_add_ls : LEMMA ∀ l, n : no_repetitions?(l) ⇒ no_repetitions?(add_sl(n,l))
  no_repetitions_union_ls : LEMMA ∀ l1, l2 : no_repetitions?(l1) ∧ no_repetitions?(l2) ⇒ no_repetitions?(union_sl(l1,l2))
	V_N_no_add_ls : JUDGEMENT ∀ (l:list[V_N]), A : add_sl(A,l) HAS_TYPE list[V_N]
	V_N_union_ls : JUDGEMENT ∀ (l1, l2:list[V_N]) : union_sl(l1,l2) HAS_TYPE list[V_N]

	V_N_list_subtype_nat_list : JUDGEMENT list[V_N] SUBTYPE_OF list[nat]
	V_N_no_repetition_subtype : JUDGEMENT (no_repetitions?[V_N]) SUBTYPE_OF list[nat]

  idx_V_N_nat : LEMMA ∀(l: list[V_N], (x:V_N|member(x,l))): idx[V_N](l,x) = idx[nat](l,x)


  % Compute the set of non-terminals that could be used before a character is consumed
	% (all those non-terminals are supposed to have a lower index in a wellforming order σ)
  sub_nT(G, (P_0: [Δ -> bool])): RECURSIVE node_ls =
    CASES G
      OF ε: null,
         any: null,
         terminal(a): null,
         range(a, b): null,
         nonTerminal(B): cons(B, null),
         seq(e1, e2):
           IF (P_0(e1)) THEN union_sl(sub_nT(e1, P_0), sub_nT(e2, P_0))
           ELSE sub_nT(e1, P_0)
           ENDIF,
         prior(e1, e2): union_sl(sub_nT(e1, P_0), sub_nT(e2, P_0)),
         star(e): sub_nT(e, P_0),
         plus(e): sub_nT(e, P_0),
         opt(e): sub_nT(e, P_0),
         notP(e): sub_nT(e, P_0),
         andP(e): sub_nT(e, P_0)
      ENDCASES
     MEASURE pegMeasure(G)

  sub_nT_and_wellformedness: LEMMA
    ∀ G, (A: V_N), (P_0: [Δ -> bool]):
      g_wf(σ, G, A, P_0, strong) ⇔
       (g_wf(σ, G, A, P_0, complete) ∧
         (∀ (B: V_N): member(B, sub_nT(G, P_0)) ⇒ σ(B) < σ(A)))

  % Construction of the digraph
	nodes(P_exp): node_ls = interval_list(0, V_N_b - 1)
	adjacents(P_exp)(A): node_ls =
     sub_nT(P_exp(A), P_0c?(P_exp))
  dependency_graph(P_exp): c_digraph[nat] =
      (# data := nodes(P_exp),
         adjs := map(adjacents(P_exp))(nodes(P_exp)) #)

  % Some lemmas before the main result
	strong_WF_edge: LEMMA ∀ P_exp, σ :
	   strong_WF(σ, P_exp) ⇒
		 ∀ A, B : (edges(dependency_graph(P_exp))(A, B) ⇒
		 σ(B) < σ(A))

	strong_WF_path: LEMMA ∀ P_exp, σ :
	   strong_WF(σ, P_exp) ⇒
		 ∀ (n:nat , w:Walk(dependency_graph(P_exp)), i, j: below(length(w))): i+n+1=j ⇒
		 σ(w`seq(j)) < σ(w`seq(i))

  % Main theorem
  dependency_graph_wf_iff_dag :
	   THEOREM ∀ P_exp :
		 orderly_WF_nT?(P_exp) ⇔
		 (IN?_2(topological_sort[V_N](dependency_graph(P_exp))) ∧ complete_WF(σ_id, P_exp))




END static_analysis
