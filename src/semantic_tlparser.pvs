% ————————————————————————————–
% semantic_tlparser.pvs
%  |– semantic_tlparser THEORY
%     Defines a tail-recursive semantic packrat parser
% ————————————————————————————–


semantic_tlparser [
      V_T   : TYPE+,
      <=    : (total_order?[V_T]),
      V_N_b : {k : nat | k > 0},
      bound : posnat,
      V_S   : TYPE
      ]: THEORY
  BEGIN
  IMPORTING semantic_parser[V_T, <=, V_N_b, bound, V_S]

  b : VAR inp_bound


  status, status1, status2, status0 : VAR astType
  T, T0, T1, T2, T_B, Ts : VAR pre_ast

  sem_result(P_inp: semantic_interp, P_exp: WF_nT, A: below(V_N_b),
             G: {e: Δ | subterm(e, P_exp(A))}, inp: input, s: upto(bound),
             s_T:
               {k: upto(s) |
                  (k = s) ⇒ g_wf(G, A, P_0c?(P_exp), strong)}): TYPE =
        {T: pre_ast | T = s_inp(P_inp, parsing(P_exp, A, G, inp, s, s_T))}


  % Semantic tail-recursive packrat parser - equivalent with reference parser modulo semantic interpretation
  semtlpp(P_exp: WF_nT, P_inp: semantic_interp, A: below(V_N_b),
          G: {e: Δ | subterm(e, P_exp(A))}, inp: input, s: upto(bound),
          s_T: {k: upto(s) | (k = s) ⇒ g_wf(G, A, P_0c?(P_exp), strong)},
          res: results(P_exp, P_inp, inp),
          cont:
            [[astType, pre_ast, results(P_exp, P_inp, inp)] ->
               [astType, pre_ast, results(P_exp, P_inp, inp)]]): RECURSIVE
        {x: [astType, pre_ast, results(P_exp, P_inp, inp)] |
           x = cont(sempp(P_exp, P_inp, A, G, inp, s, s_T, res))} =
    CASES G
      OF ε: cont(success, ε(s, s), res),
         any:
           IF (s + 1 > bound) THEN cont(failure, fail(s, s), res)
           ELSE cont(success, any(s, s + 1, inp(s)), res)
           ENDIF,
         terminal(a):
           IF (s + 1 <= bound AND inp(s) = a)
             THEN cont(success, terminal(s, s + 1, a, a), res)
           ELSE cont(failure, fail(s, min(s + 1, bound)), res)
           ENDIF,
         range(a, b):
           IF (s + 1 <= bound AND in_range(a, b)(inp(s)))
             THEN cont(success, range(s, s + 1, a, b, inp(s)), res)
           ELSE cont(failure, fail(s, min(s + 1, bound)), res)
           ENDIF,
         nonTerminal(B):
           CASES res(B, s)
             OF known(status, T_B): cont(status, T_B, res),
                unknown:
                  semtlpp(P_exp, P_inp, B, P_exp(B), inp, s, s, res,
                          (LAMBDA status, T_B, (res: results(P_exp, P_inp, inp)):
                             IF (status = success)
                               THEN LET sem_T = semantic (s, e(T_B), B, P_inp(B, T_B))
                                    IN  cont (success, sem_T, res WITH [(B, s) := known(success, sem_T)])
                             ELSE LET fail_T = fail(s, e(T_B)) IN
                                    cont (failure, fail_T, res WITH [(B, s) := known(failure, fail_T)])
                             ENDIF))
             ENDCASES,
         seq(e1, e2):
           semtlpp(P_exp, P_inp, A, e1, inp, s, s_T, res,
                   (LAMBDA status1, T1, (res: results(P_exp, P_inp, inp)):
                      IF (status1 = failure)
                        THEN cont(failure, fail(s, e(T1)), res)
                      ELSE semtlpp(P_exp, P_inp, A, e2, inp, e(T1), s_T,
                                   res,
                                   (LAMBDA
                                    status2,
                                    T2, (res: results(P_exp, P_inp, inp)):
                                    IF (status2 = failure)
                                    THEN cont(failure, fail(s, e(T2)), res)
                                    ELSE cont
                                         (success,
                                          seq(s, e(T2), T1, T2),
                                          res)
                                    ENDIF))
                      ENDIF)),
         prior(e1, e2):
           semtlpp(P_exp, P_inp, A, e1, inp, s, s_T, res,
                   (LAMBDA status1, T1, (res: results(P_exp, P_inp, inp)):
                      IF (status1 = success)
                        THEN cont(success,
                                  prior(s, e(T1), T1, skip(s, s, e2)), res)
                      ELSE semtlpp(P_exp, P_inp, A, e2, inp, s, s_T, res,
                                   (LAMBDA
                                    status2,
                                    T2, (res: results(P_exp, P_inp, inp)):
                                    IF (status2 = success)
                                    THEN cont
                                         (success,
                                          prior(s, e(T2), T1, T2),
                                          res)
                                    ELSE cont(failure, fail(s, e(T2)), res)
                                    ENDIF))
                      ENDIF)),
         star(e):
           semtlpp(P_exp, P_inp, A, e, inp, s, s_T, res,
                   (LAMBDA status0, T0, (res: results(P_exp, P_inp, inp)):
                      IF (status0 = failure)
                        THEN cont(success,
                                  star(s,
                                       s,
                                       T0,
                                       skip(e(T0), e(T0), star(e))),
                                  res)
                      ELSE semtlpp(P_exp, P_inp, A, star(e), inp, e(T0),
                                   s_T, res,
                                   (LAMBDA
                                    status2,
                                    Ts, (res: results(P_exp, P_inp, inp)):
                                    cont
                                    (success,
                                     star(s, e(Ts), T0, Ts),
                                     res)))
                      ENDIF)),
         plus(e):
           semtlpp(P_exp, P_inp, A, e, inp, s, s_T, res,
                   (LAMBDA status0, T0, (res: results(P_exp, P_inp, inp)):
                      IF (status0 = failure)
                        THEN cont(failure, fail(s, s), res)
                      ELSE semtlpp(P_exp, P_inp, A, plus(e), inp, e(T0),
                                   s_T, res,
                                   (LAMBDA
                                    status2,
                                    Ts, (res: results(P_exp, P_inp, inp)):
                                    cont
                                    (success,
                                     plus(s, e(Ts), T0, Ts),
                                     res)))
                      ENDIF)),
         opt(e):
           semtlpp(P_exp, P_inp, A, e, inp, s, s_T, res,
                   (LAMBDA status, T, (res: results(P_exp, P_inp, inp)):
                      IF (status = failure)
                        THEN cont(success, opt(s, s, T), res)
                      ELSE cont(success, opt(s, e(T), T), res)
                      ENDIF)),
         notP(e):
           semtlpp(P_exp, P_inp, A, e, inp, s, s_T, res,
                   (LAMBDA status, T, (res: results(P_exp, P_inp, inp)):
                      IF (status = failure)
                        THEN cont(success, notP(s, s, T), res)
                      ELSE cont(failure, fail(s, s), res)
                      ENDIF)),
         andP(e):
           semtlpp(P_exp, P_inp, A, e, inp, s, s_T, res,
                   (LAMBDA status, T, (res: results(P_exp, P_inp, inp)):
                      IF (status = success)
                        THEN cont(success, andP(s, s, T), res)
                      ELSE cont(failure, fail(s, s), res)
                      ENDIF))
      ENDCASES
     MEASURE lex4(bound - s_T, bound - s, A, pegMeasure(G))


    semantic_tlparser_correct :
      THEOREM
        ∀  (P_exp : WF_nT),
  	   (P_inp : semantic_interp),
  	   (A     : below(V_N_b)),                   % Current non Terminal
           (G     : {e : Δ | subterm(e, P_exp(A))}), % Grammar node
           (inp   : input),                          % Input array
  	   (s     : upto(bound)),                      % Starting index
  	   (s_T   : {k : upto(s) | (k=s) ⇒ g_wf(G, A, P_0c?(P_exp), strong)}),
  	   (res   : results(P_exp, P_inp, inp)) :
		    semtlpp(P_exp, P_inp, A, G, inp, s, s_T, res,
		    % Identity continuation
		    (λ (x : [astType, pre_ast, results(P_exp, P_inp, inp)])
		     : (x`1, x`2, x`3)))`2 = s_inp(P_inp, parsing(P_exp, A, G, inp, s, s_T))



    semantic_tlparser
           (P_exp : WF_nT,
  	    P_inp : semantic_interp,
  	    A     : below(V_N_b),                % Current non Terminal
            G     : {e : Δ | subterm(e, P_exp(A))}, % Grammar node
            inp   : input,                          % Input array
  	    s     : upto(bound),                      % Starting index
  	    s_T   : {k : upto(s) | (k=s) ⇒ g_wf(G, A, P_0c?(P_exp), strong)},
  	    res   : results(P_exp, P_inp, inp)) : astType =
		    semtlpp(P_exp, P_inp, A, G, inp, s, s_T, res,
		    % Identity continuation
		    (λ (x : [astType, pre_ast, results(P_exp, P_inp, inp)])
		     : (x`1, x`2, x`3)))`1


END semantic_tlparser
