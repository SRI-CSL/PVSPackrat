(semantic_tlparser
 (results_TCC1 0
  (results_TCC1-1 nil 3804395188
   ("" (assert) (("" (expand "subterm") (("" (propax) nil nil)) nil))
    nil)
   ((subterm adt-def-decl "boolean" peg nil)) nil
   (results subtype "semantic_tlparser.P_exp(semantic_tlparser.A)"
    "{e: wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].Δ | peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].subterm(e, semantic_tlparser.P_exp(semantic_tlparser.A))}")))
 (results_TCC2 0
  (results_TCC2-1 nil 3804395188 ("" (subtype-tcc) nil nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil) (peg type-decl nil peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (<= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (strong const-decl "bool" wf_peg nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (results subtype "semantic_tlparser.s"
    "{k: naturalnumbers.upto(semantic_tlparser.s) | booleans.⇒((k = semantic_tlparser.s), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].g_wf(semantic_tlparser.P_exp(semantic_tlparser.A), semantic_tlparser.A, wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].P_0c?(semantic_tlparser.P_exp), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].strong))}")))
 (sem_result_TCC1 0
  (sem_result_TCC1-1 nil 3804417092 ("" (subtype-tcc) nil nil) nil nil
   (sem_result subtype "semantic_tlparser.A"
    "naturalnumbers.upto(semantic_tlparser.V_N_b)")))
 (semtlpp_TCC1 0
  (semtlpp_TCC2-1 nil 3804395188 ("" (subtype-tcc) nil nil)
   ((int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (semtlpp subtype
    "(number_fields.-)(semantic_tlparser.bound, semantic_tlparser.s_T)"
    "nat")))
 (semtlpp_TCC2 0
  (semtlpp_TCC3-1 nil 3804395188 ("" (subtype-tcc) nil nil)
   ((int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (semtlpp subtype
    "(number_fields.-)(semantic_tlparser.bound, semantic_tlparser.s)"
    "nat")))
 (semtlpp_TCC3 0
  (semtlpp_TCC4-1 nil 3804395188
   ("" (skeep)
    (("" (assert)
      (("" (typepred "z`6")
        (("" (typepred "z`7") (("" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (below type-eq-decl nil naturalnumbers nil)
    (peg type-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (saved_result type-decl nil semantic_tlparser nil)
    (known? adt-recognizer-decl "[saved_result -> boolean]"
     semantic_tlparser nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (astType type-decl nil ast nil) (pre_ast type-decl nil pre_ast nil)
    (astType? def-decl "astType" ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil) (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (valuedTree? const-decl "bool" semantic_interp nil)
    (T adt-accessor-decl "[(known?) -> (valuedTree?)]"
     semantic_tlparser nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail adt-constructor-decl "[[below, below] -> (fail?)]" pre_ast
     nil)
    (semantic? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (semantic adt-constructor-decl
     "[[below, below, V_N[V_N_b], V_S] -> (semantic?)]" pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (status adt-accessor-decl
            "[(known?) -> astType[V_T, <=, V_N_b, bound, V_S]]"
            semantic_tlparser nil)
    (results type-eq-decl nil semantic_tlparser nil)
    (astTypeOf type-eq-decl nil semantic_tlparser nil)
    (sem_result type-eq-decl nil semantic_tlparser nil))
   nil
   (semtlpp subtype
    "(number_fields.-)(semantic_tlparser.bound, semantic_tlparser.z`7)"
    "nat")))
 (semtlpp_TCC4 0
  (semtlpp_TCC5-1 nil 3804395188 ("" (subtype-tcc) nil nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (semtlpp subtype
    "(number_fields.-)(semantic_tlparser.bound, semantic_tlparser.z`6)"
    "nat")))
 (semtlpp_TCC5 0
  (semtlpp_TCC6-1 nil 3804395188 ("" (subtype-tcc) nil nil)
   ((int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (semtlpp subtype
    "(number_fields.-)(semantic_tlparser.bound, semantic_tlparser.s_T)"
    "nat")))
 (semtlpp_TCC6 0
  (semtlpp_TCC7-1 nil 3804395188 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype
    "(number_fields.-)(semantic_tlparser.bound, semantic_tlparser.s)"
    "nat")))
 (semtlpp_TCC7 0
  (semtlpp_TCC15-1 nil 3804395188
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (assert)
        (("" (expand "parsing")
          (("" (expand "astType?") (("" (propax) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (astType? def-decl "astType" ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success"
    "semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC8 0
  (semtlpp_TCC18-1 nil 3804395188
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (assert)
        (("" (expand "parsing")
          (("" (expand "s_inp")
            (("" (expand "astType?") (("" (propax) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (astType? def-decl "astType" ast nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].ε(semantic_tlparser.s, semantic_tlparser.s)"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC9 0
  (semtlpp_TCC20-1 nil 3804395188
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (assert)
        (("" (expand "parsing")
          (("" (expand "astType?")
            (("" (expand "min") (("" (propax) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (astType? def-decl "astType" ast nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure"
    "semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC10 0
  (semtlpp_TCC23-1 nil 3804395188
   ("" (skeep)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (expand "s_inp")
          (("" (expand "astType?")
            (("" (expand "min") (("" (assert) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, semantic_tlparser.s)"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC11 0
  (semtlpp_TCC26-1 nil 3804395188
   ("" (skeep)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (expand "astType?")
          (("" (expand "min") (("" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success"
    "semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC12 0
  (semtlpp_TCC8-1 nil 3804395188
   ("" (skeep) (("" (assert) nil nil)) nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (semtlpp subtype "(number_fields.+)(semantic_tlparser.s, 1)"
    "below[V_T, <=, V_N_b, bound, V_S]")))
 (semtlpp_TCC13 0
  (semtlpp_TCC28-1 nil 3804395188
   ("" (skeep)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (expand "s_inp")
          (("" (expand "astType?")
            (("" (expand "min") (("" (assert) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].any(semantic_tlparser.s, (number_fields.+)(semantic_tlparser.s, 1), semantic_tlparser.inp(semantic_tlparser.s))"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC14 0
  (semtlpp_TCC30-1 nil 3804395188
   ("" (skeep)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (expand "astType?")
          (("" (expand "min") (("" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success"
    "semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC15 0
  (semtlpp_TCC32-1 nil 3804395188
   ("" (skeep)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (expand "s_inp")
          (("" (expand "astType?")
            (("" (expand "min") (("" (assert) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].terminal(semantic_tlparser.s, (number_fields.+)(semantic_tlparser.s, 1), semantic_tlparser.a, semantic_tlparser.a)"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC16 0
  (semtlpp_TCC36-1 nil 3804395188
   ("" (skeep)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (expand "astType?")
          (("" (expand "min")
            (("" (assert)
              (("" (lift-if)
                (("" (assert)
                  (("" (split)
                    (("1" (assert) nil nil) ("2" (assert) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure"
    "semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC17 0
  (semtlpp_TCC40-1 nil 3804395188
   ("" (skeep)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (expand "s_inp")
          (("" (expand "astType?")
            (("" (expand "min")
              (("" (assert)
                (("" (lift-if)
                  (("" (assert)
                    (("" (lift-if)
                      (("" (assert)
                        (("" (split 1)
                          (("1" (assert) nil nil)
                           ("2" (assert) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, real_defs.min((number_fields.+)(semantic_tlparser.s, 1), semantic_tlparser.bound))"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC18 0
  (semtlpp_TCC41-1 nil 3804395188
   ("" (skeep)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (expand "astType?")
          (("" (expand "min") (("" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success"
    "semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC19 0
  (semtlpp_TCC43-1 nil 3804395188
   ("" (skeep)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (expand "s_inp")
          (("" (expand "astType?")
            (("" (expand "min") (("" (assert) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].range(semantic_tlparser.s, (number_fields.+)(semantic_tlparser.s, 1), semantic_tlparser.a, semantic_tlparser.b, semantic_tlparser.inp(semantic_tlparser.s))"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC20 0
  (semtlpp_TCC45-1 nil 3804395188
   ("" (skeep)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (expand "astType?")
          (("" (expand "min")
            (("" (assert)
              (("" (lift-if)
                (("" (assert)
                  (("" (lift-if)
                    (("" (assert)
                      (("" (split 1)
                        (("1" (assert) nil nil) ("2" (assert) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure"
    "semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC21 0
  (semtlpp_TCC49-1 nil 3804395188
   ("" (skeep)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (expand "s_inp")
          (("" (expand "astType?")
            (("" (expand "min")
              (("" (assert) (("" (grind) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (in_range const-decl "bool" ast nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, real_defs.min((number_fields.+)(semantic_tlparser.s, 1), semantic_tlparser.bound))"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC22 0
  (semtlpp_TCC54-1 nil 3804395188
   ("" (skeep)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        ((""
          (name-replace "T_ref"
           "parsing(P_exp, B, P_exp(B), inp, s, s)")
          (("" (typepred "res")
            (("" (inst -1 "B" "s")
              (("" (replace -3 * LR)
                (("" (assert)
                  (("" (flatten)
                    (("" (replace -5 * RL)
                      (("" (lemma "Wellformed_theorem")
                        (("" (inst -1 "T_ref")
                          (("" (assert)
                            (("" (flatten)
                              ((""
                                (expand "astType?" 1 2)
                                ((""
                                  (expand "T_ref")
                                  ((""
                                    (split -2)
                                    (("1"
                                      (assert)
                                      (("1"
                                        (replace -3 * LR)
                                        (("1"
                                          (expand "astType?" 1 1)
                                          (("1" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (assert)
                                      (("2"
                                        (replace -4 * LR)
                                        (("2"
                                          (expand "astType?" 2 1)
                                          (("2" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (peg type-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (<= const-decl "bool" reals nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (T_ref skolem-const-decl
     "output[V_T, <=, V_N_b, bound, V_S](P_exp, B, P_exp(B), inp, s, s_T)"
     semantic_tlparser nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (saved_result type-decl nil semantic_tlparser nil)
    (known? adt-recognizer-decl "[saved_result -> boolean]"
     semantic_tlparser nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (valuedTree? const-decl "bool" semantic_interp nil)
    (T adt-accessor-decl "[(known?) -> (valuedTree?)]"
     semantic_tlparser nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail adt-constructor-decl "[[below, below] -> (fail?)]" pre_ast
     nil)
    (semantic? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (semantic adt-constructor-decl
     "[[below, below, V_N[V_N_b], V_S] -> (semantic?)]" pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (status adt-accessor-decl
            "[(known?) -> astType[V_T, <=, V_N_b, bound, V_S]]"
            semantic_tlparser nil)
    (results type-eq-decl nil semantic_tlparser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype "semantic_tlparser.status"
    "semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC23 0
  (semtlpp_TCC12-1 nil 3804395188
   ("" (skeep)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (expand "s_inp")
          (("" (typepred "res")
            (("" (inst -1 B s)
              (("" (assert)
                (("" (flatten)
                  (("" (assert)
                    (("" (lift-if)
                      (("" (expand "astType?" 1 1)
                        ((""
                          (lemma "Wellformed_theorem"
                           (T
                            "parsing(P_exp, B, P_exp(B), inp, s, s)"))
                          (("1" (assert)
                            (("1" (flatten)
                              (("1"
                                (assert)
                                (("1"
                                  (split -2)
                                  (("1"
                                    (assert)
                                    (("1"
                                      (replace -9 * LR)
                                      (("1" (assert) nil nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (assert)
                                    (("2"
                                      (replace -8 * LR)
                                      (("2" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (assert)
                            (("2" (typepred "P_exp")
                              (("2"
                                (expand "strong_WF")
                                (("2" (inst -1 "B") nil nil))
                                nil))
                              nil))
                            nil)
                           ("3" (expand "subterm")
                            (("3" (propax) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (<= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (saved_result type-decl nil semantic_tlparser nil)
    (known? adt-recognizer-decl "[saved_result -> boolean]"
     semantic_tlparser nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (astType type-decl nil ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (astType? def-decl "astType" ast nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (peg type-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (input type-eq-decl nil ast_props nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil) (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (valuedTree? const-decl "bool" semantic_interp nil)
    (T adt-accessor-decl "[(known?) -> (valuedTree?)]"
     semantic_tlparser nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail adt-constructor-decl "[[below, below] -> (fail?)]" pre_ast
     nil)
    (semantic? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (semantic adt-constructor-decl
     "[[below, below, V_N[V_N_b], V_S] -> (semantic?)]" pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (status adt-accessor-decl
            "[(known?) -> astType[V_T, <=, V_N_b, bound, V_S]]"
            semantic_tlparser nil)
    (results type-eq-decl nil semantic_tlparser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype "semantic_tlparser.T_B"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC24 0
  (semtlpp_TCC10-1 nil 3804395188
   ("" (assert) (("" (expand "subterm") (("" (propax) nil nil)) nil))
    nil)
   ((subterm adt-def-decl "boolean" peg nil)) nil
   (semtlpp subtype "semantic_tlparser.P_exp(semantic_tlparser.B)"
    "{e: wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].Δ | peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].subterm(e, semantic_tlparser.P_exp(semantic_tlparser.B))}")))
 (semtlpp_TCC25 0
  (semtlpp_TCC11-1 nil 3804395188
   ("" (skeep)
    (("" (typepred "P_exp")
      (("" (expand "strong_WF")
        (("" (inst -1 "B") (("" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil) (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (below type-eq-decl nil naturalnumbers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (semtlpp subtype "semantic_tlparser.s"
    "{k: naturalnumbers.upto(semantic_tlparser.s) | booleans.⇒((k = semantic_tlparser.s), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].g_wf(semantic_tlparser.P_exp(semantic_tlparser.B), semantic_tlparser.B, wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].P_0c?(semantic_tlparser.P_exp), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].strong))}")))
 (semtlpp_TCC26 0
  (semtlpp_TCC56-1 nil 3804395188
   ("" (skeep)
    (("" (typepred "T_B")
      (("" (replace -1 * LR) (("" (assert) nil nil)) nil)) nil))
    nil)
   ((sem_result type-eq-decl nil semantic_tlparser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (ast type-eq-decl nil ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.T_B"
    "semanticTree[V_T, <=, V_N_b, bound, V_S]")))
 (semtlpp_TCC27 0
  (semtlpp_TCC58-1 nil 3804395188
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (simplify)
        (("" (expand "parsing")
          (("" (expand "astType?")
            (("" (typepred "T_B")
              ((""
                (lemma "semantic_interp_props"
                 ("T" "parsing(P_exp, B, P_exp(B), inp, s, s)" "P_inp"
                  "P_inp"))
                (("" (flatten) (("" (assert) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (sem_result type-eq-decl nil semantic_tlparser nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (ast type-eq-decl nil ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semantic_interp_props formula-decl nil semantic_interp nil)
    (astType? def-decl "astType" ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success"
    "semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC28 0
  (semtlpp_TCC13-1 nil 3804395188
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (expand "s_inp")
          (("" (typepred "status!1")
            (("" (expand "astType?" 1 1) (("" (assert) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (astType type-decl nil ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (astType? def-decl "astType" ast nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (peg type-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (<= const-decl "bool" reals nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (astTypeOf type-eq-decl nil semantic_tlparser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.sem_T"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC29 0
  (semtlpp_TCC61-1 nil 3804395188 ("" (subtype-tcc) nil nil)
   ((V_S formal-type-decl nil semantic_tlparser nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (valuedTree? const-decl "bool" semantic_interp nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (semtlpp subtype "semantic_tlparser.sem_T"
    "(semantic_interp[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].valuedTree?)")))
 (semtlpp_TCC30 0
  (semtlpp_TCC14-1 nil 3804395188
   ("" (skeep*)
    (("" (lift-if -5)
      (("" (split -5)
        (("1" (flatten)
          (("1" (decompose-equality -1)
            (("1" (replace -1 * LR)
              (("1" (replace -2 * LR)
                (("1" (assert)
                  (("1" (typepred "status!1")
                    (("1" (assert)
                      (("1" (assert)
                        (("1" (replace -8 * LR)
                          (("1" (typepred "T_B")
                            (("1"
                              (lemma "semantic_interp_props"
                               (T
                                "parsing(P_exp, B, P_exp(B), inp, s, s)"
                                P_inp
                                "P_inp"))
                              (("1"
                                (replace -2 * RL)
                                (("1"
                                  (flatten)
                                  (("1"
                                    (expand "astType?" 1 1)
                                    (("1"
                                      (assert)
                                      (("1"
                                        (lift-if)
                                        (("1"
                                          (assert)
                                          (("1"
                                            (split 1)
                                            (("1" (propax) nil nil)
                                             ("2"
                                              (lemma
                                               "Wellformed_theorem"
                                               (T "T_B"))
                                              (("2" (assert) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (flatten)
          (("2" (typepred "res1")
            (("2" (inst -1 A!1 s_1)
              (("2" (assert)
                (("2" (ground)
                  (("1" (assert) nil nil) ("2" (assert) nil nil)
                   ("3" (assert) nil nil) ("4" (assert) nil nil)
                   ("5" (assert) nil nil) ("6" (assert) nil nil)
                   ("7" (assert) nil nil) ("8" (assert) nil nil)
                   ("9" (assert) nil nil) ("10" (assert) nil nil)
                   ("11" (assert) nil nil) ("12" (assert) nil nil)
                   ("13" (assert) nil nil) ("14" (assert) nil nil)
                   ("15" (assert) nil nil) ("16" (assert) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((saved_result type-decl nil semantic_tlparser nil)
    (known? adt-recognizer-decl "[saved_result -> boolean]"
     semantic_tlparser nil)
    (valuedTree? const-decl "bool" semantic_interp nil)
    (T adt-accessor-decl "[(known?) -> (valuedTree?)]"
     semantic_tlparser nil)
    (fail adt-constructor-decl "[[below, below] -> (fail?)]" pre_ast
     nil)
    (semantic? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (semantic adt-constructor-decl
     "[[below, below, V_N[V_N_b], V_S] -> (semantic?)]" pre_ast nil)
    (status adt-accessor-decl
            "[(known?) -> astType[V_T, <=, V_N_b, bound, V_S]]"
            semantic_tlparser nil)
    (results type-eq-decl nil semantic_tlparser nil)
    (semantic_interp_props formula-decl nil semantic_interp nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (sem_result type-eq-decl nil semantic_tlparser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (astType type-decl nil ast nil) (pre_ast type-decl nil pre_ast nil)
    (astType? def-decl "astType" ast nil)
    (WF_nT type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil) (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (astTypeOf type-eq-decl nil semantic_tlparser nil)
    (below type-eq-decl nil naturalnumbers nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (<= const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil) (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "semantic_tlparser.res WITH [(semantic_tlparser.B, semantic_tlparser.s) := semantic_tlparser.known(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, semantic_tlparser.sem_T)]"
    "semantic_tlparser.results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)")))
 (semtlpp_TCC31 0
  (semtlpp_TCC66-1 nil 3804395188
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (expand "astType?")
          (("" (typepred "T_B")
            (("" (typepred "status!1")
              (("" (replace -1 * RL)
                ((""
                  (lemma "Wellformed_theorem"
                   (T "(parsing(P_exp, B, P_exp(B), inp, s, s))"))
                  (("" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (astTypeOf type-eq-decl nil semantic_tlparser nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (astType type-decl nil ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (peg type-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (ast type-eq-decl nil ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (sem_result type-eq-decl nil semantic_tlparser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure"
    "semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC32 0
  (semtlpp_TCC16-1 nil 3804395188
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (typepred "T_B")
          (("" (typepred "status!1")
            ((""
              (lemma "Wellformed_theorem"
               (T "(parsing(P_exp, B, P_exp(B), inp, s, s))"))
              (("" (assert)
                (("" (flatten)
                  (("" (expand "s_inp")
                    (("" (assert)
                      (("" (expand "astType?" 2 1)
                        (("" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((sem_result type-eq-decl nil semantic_tlparser nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (ast type-eq-decl nil ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (astTypeOf type-eq-decl nil semantic_tlparser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.fail_T"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC33 0
  (semtlpp_TCC68-1 nil 3804395188 ("" (subtype-tcc) nil nil)
   ((V_S formal-type-decl nil semantic_tlparser nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (valuedTree? const-decl "bool" semantic_interp nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (semtlpp subtype "semantic_tlparser.fail_T"
    "(semantic_interp[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].valuedTree?)")))
 (semtlpp_TCC34 0
  (semtlpp_TCC17-1 nil 3804395188
   ("" (skeep*)
    (("" (lift-if -4)
      (("" (split -4)
        (("1" (flatten)
          (("1" (decompose-equality -1)
            (("1" (replace -1 * LR)
              (("1" (replace -2 * LR)
                (("1" (assert)
                  (("1" (typepred "T_B")
                    (("1"
                      (lemma "Wellformed_theorem"
                       (T "(parsing(P_exp, B, P_exp(B), inp, s, s))"))
                      (("1" (assert)
                        (("1" (flatten)
                          (("1" (assert)
                            (("1" (expand "astType?")
                              (("1" (propax) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (flatten)
          (("2" (assert)
            (("2" (lift-if 3)
              (("2" (assert)
                (("2" (typepred "res1")
                  (("2" (inst -1 "A!1" "s_1")
                    (("2" (assert)
                      (("2" (split)
                        (("1" (assert) nil nil) ("2" (assert) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((results type-eq-decl nil semantic_tlparser nil)
    (status adt-accessor-decl
            "[(known?) -> astType[V_T, <=, V_N_b, bound, V_S]]"
            semantic_tlparser nil)
    (semantic adt-constructor-decl
     "[[below, below, V_N[V_N_b], V_S] -> (semantic?)]" pre_ast nil)
    (semantic? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail adt-constructor-decl "[[below, below] -> (fail?)]" pre_ast
     nil)
    (T adt-accessor-decl "[(known?) -> (valuedTree?)]"
     semantic_tlparser nil)
    (valuedTree? const-decl "bool" semantic_interp nil)
    (known? adt-recognizer-decl "[saved_result -> boolean]"
     semantic_tlparser nil)
    (saved_result type-decl nil semantic_tlparser nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (pre_ast type-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (WF_nT type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (ast type-eq-decl nil ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (sem_result type-eq-decl nil semantic_tlparser nil)
    (below type-eq-decl nil naturalnumbers nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (<= const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil) (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "semantic_tlparser.res WITH [(semantic_tlparser.B, semantic_tlparser.s) := semantic_tlparser.known(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure, semantic_tlparser.fail_T)]"
    "semantic_tlparser.results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)")))
 (semtlpp_TCC35 0
  (semtlpp_TCC19-1 nil 3804395188
   ("" (assert)
    (("" (skeep*)
      (("" (replace -1 * LR)
        (("" (assert)
          (("" (typepred "s_T") (("" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((TRUE const-decl "bool" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (< def-decl "bool" ordinals nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (lex4 const-decl "ordinal" lex4 nil)
    (lex3 const-decl "ordinal" lex3 nil)
    (lex2 const-decl "ordinal" lex2 nil)
    (pegMeasure const-decl "nat" peg nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (peg type-decl nil peg nil) (g_wf def-decl "bool" wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil))
   nil
   (semtlpp termination
    "semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.B, semantic_tlparser.P_exp(semantic_tlparser.B), semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s, semantic_tlparser.res, (LAMBDA (status: semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.B, semantic_tlparser.P_exp(semantic_tlparser.B), semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s))), (T_B: semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.B, semantic_tlparser.P_exp(semantic_tlparser.B), semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s)), (res: semantic_tlparser.results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): IF (status = ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success) THEN LET sem_T = pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].semantic(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T_B), semantic_tlparser.B, semantic_tlparser.P_inp(semantic_tlparser.B, T_B)) IN semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, semantic_tlparser.sem_T, res WITH [(semantic_tlparser.B, semantic_tlparser.s) := semantic_tlparser.known(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, semantic_tlparser.sem_T)]) ELSE LET fail_T = pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T_B)) IN semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure, semantic_tlparser.fail_T, res WITH [(semantic_tlparser.B, semantic_tlparser.s) := semantic_tlparser.known(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure, semantic_tlparser.fail_T)]) ENDIF))"
    "nil")))
 (semtlpp_TCC36 0
  (semtlpp_TCC21-1 nil 3804395188 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype "semantic_tlparser.e1"
    "{e: wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].Δ | peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].subterm(e, semantic_tlparser.P_exp(semantic_tlparser.A))}")))
 (semtlpp_TCC37 0
  (semtlpp_TCC22-1 nil 3804395188 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype "semantic_tlparser.s_T"
    "{k: naturalnumbers.upto(semantic_tlparser.s) | booleans.⇒((k = semantic_tlparser.s), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].g_wf(semantic_tlparser.e1, semantic_tlparser.A, wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].P_0c?(semantic_tlparser.P_exp), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].strong))}")))
 (semtlpp_TCC38 0
  (semtlpp_TCC75-1 nil 3804395188 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure"
    "semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC39 0
  (semtlpp_TCC77-1 nil 3804395188 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T1))"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC40 0
  (semtlpp_TCC24-1 nil 3804395188 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype "semantic_tlparser.e2"
    "{e: wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].Δ | peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].subterm(e, semantic_tlparser.P_exp(semantic_tlparser.A))}")))
 (semtlpp_TCC41 0
  (semtlpp_TCC25-1 nil 3804395188 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype "semantic_tlparser.s_T"
    "{k: naturalnumbers.upto(pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T1)) | booleans.⇒((k = pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T1)), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].g_wf(semantic_tlparser.e2, semantic_tlparser.A, wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].P_0c?(semantic_tlparser.P_exp), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].strong))}")))
 (semtlpp_TCC42 0
  (semtlpp_TCC81-1 nil 3804395188 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure"
    "semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC43 0
  (semtlpp_TCC82-1 nil 3804395188 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T2))"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC44 0
  (semtlpp_TCC84-1 nil 3804395188 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success"
    "semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC45 0
  (semtlpp_TCC27-1 nil 3804395188 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype "semantic_tlparser.T1"
    "{T: pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast | (booleans.¬)(pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].skip?(T))}")))
 (semtlpp_TCC46 0
  (semtlpp_TCC88-1 nil 3804395188 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].seq(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T2), semantic_tlparser.T1, semantic_tlparser.T2)"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC47 0
  (semtlpp_TCC70-1 nil 3804395188 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype "semantic_tlparser.P_exp(semantic_tlparser.A)"
    "{e: wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].Δ | peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].subterm(e, semantic_tlparser.P_exp(semantic_tlparser.A))}")))
 (semtlpp_TCC48 0
  (semtlpp_TCC73-1 nil 3804395188 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype "semantic_tlparser.s"
    "{k: naturalnumbers.upto(semantic_tlparser.s) | booleans.⇒((k = semantic_tlparser.s), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].g_wf(semantic_tlparser.P_exp(semantic_tlparser.A), semantic_tlparser.A, wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].P_0c?(semantic_tlparser.P_exp), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].strong))}")))
 (semtlpp_TCC49 0
  (semtlpp_TCC29-1 nil 3804395188 ("" (termination-tcc) nil nil) nil
   nil
   (semtlpp termination
    "semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, semantic_tlparser.e2, semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T1), semantic_tlparser.s_T, semantic_tlparser.res, (restrict[[ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astType, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast, semantic_tlparser.results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)], [semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e2, semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T1), semantic_tlparser.s_T)), semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e2, semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T1), semantic_tlparser.s_T), semantic_tlparser.results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)], [ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astType, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast]].restrict((LAMBDA (status2, T2, res: semantic_tlparser.results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): IF (semantic_tlparser.status2 = ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure) THEN semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T2)), res) ELSE semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].seq(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T2), semantic_tlparser.T1, semantic_tlparser.T2), res) ENDIF))))"
    "nil")))
 (semtlpp_TCC50 0
  (semtlpp_TCC89-1 nil 3804395188 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype "semantic_tlparser.P_exp(semantic_tlparser.A)"
    "{e: wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].Δ | peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].subterm(e, semantic_tlparser.P_exp(semantic_tlparser.A))}")))
 (semtlpp_TCC51 0
  (semtlpp_TCC91-1 nil 3804395188 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype "semantic_tlparser.s"
    "{k: naturalnumbers.upto(semantic_tlparser.s) | booleans.⇒((k = semantic_tlparser.s), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].g_wf(semantic_tlparser.P_exp(semantic_tlparser.A), semantic_tlparser.A, wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].P_0c?(semantic_tlparser.P_exp), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].strong))}")))
 (semtlpp_TCC52 0
  (semtlpp_TCC31-1 nil 3804395188 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (peg type-decl nil peg nil) (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (subterm adt-def-decl "boolean" peg nil)
    (<= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (saved_result type-decl nil semantic_tlparser nil)
    (known? adt-recognizer-decl "[saved_result -> boolean]"
     semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (astType type-decl nil ast nil) (pre_ast type-decl nil pre_ast nil)
    (astType? def-decl "astType" ast nil)
    (input type-eq-decl nil ast_props nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil) (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (valuedTree? const-decl "bool" semantic_interp nil)
    (T adt-accessor-decl "[(known?) -> (valuedTree?)]"
     semantic_tlparser nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail adt-constructor-decl "[[below, below] -> (fail?)]" pre_ast
     nil)
    (semantic? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (semantic adt-constructor-decl
     "[[below, below, V_N[V_N_b], V_S] -> (semantic?)]" pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (status adt-accessor-decl
            "[(known?) -> astType[V_T, <=, V_N_b, bound, V_S]]"
            semantic_tlparser nil)
    (results type-eq-decl nil semantic_tlparser nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (r const-decl "C(P_exp)" wf_peg nil)
    (array_sum const-decl "upto(3 * V_N_b)" array_sum nil)
    (nT_properties const-decl "F(P_exp)" wf_peg nil)
    (sum const-decl "nat" peg nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (< def-decl "bool" ordinals nil)
    (ρ const-decl "C(P_exp)" wf_peg nil)
    (recompute_nonTerminals_properties def-decl "C(P_exp)" wf_peg nil)
    (aux def-decl "result" array_sum nil)
    (odd_plus_even_is_odd application-judgement "odd_int" integers nil)
    (pegMeasure const-decl "nat" peg nil)
    (lex2 const-decl "ordinal" lex2 nil)
    (lex3 const-decl "ordinal" lex3 nil)
    (lex4 const-decl "ordinal" lex4 nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (semtlpp termination
    "semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, semantic_tlparser.e1, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T, semantic_tlparser.res, (restrict[[ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astType, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast, semantic_tlparser.results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)], [semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e1, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)), semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e1, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T), semantic_tlparser.results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)], [ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astType, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast]].restrict((LAMBDA (status1, T1, res: semantic_tlparser.results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): IF (semantic_tlparser.status1 = ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure) THEN semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T1)), res) ELSE semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, semantic_tlparser.e2, semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T1), semantic_tlparser.s_T, res, (restrict[[ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astType, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast, semantic_tlparser.results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)], [semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e2, semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T1), semantic_tlparser.s_T)), semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e2, semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T1), semantic_tlparser.s_T), semantic_tlparser.results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)], [ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astType, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast]].restrict((LAMBDA (status2, T2, res: semantic_tlparser.results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): IF (semantic_tlparser.status2 = ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure) THEN semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T2)), res) ELSE semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].seq(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T2), semantic_tlparser.T1, semantic_tlparser.T2), res) ENDIF)))) ENDIF))))"
    "nil")))
 (semtlpp_TCC53 0
  (semtlpp_TCC33-1 nil 3804395188 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype "semantic_tlparser.e1"
    "{e: wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].Δ | peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].subterm(e, semantic_tlparser.P_exp(semantic_tlparser.A))}")))
 (semtlpp_TCC54 0
  (semtlpp_TCC34-1 nil 3804395188 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype "semantic_tlparser.s_T"
    "{k: naturalnumbers.upto(semantic_tlparser.s) | booleans.⇒((k = semantic_tlparser.s), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].g_wf(semantic_tlparser.e1, semantic_tlparser.A, wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].P_0c?(semantic_tlparser.P_exp), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].strong))}")))
 (semtlpp_TCC55 0
  (semtlpp_TCC58-1 nil 3804399719 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success"
    "semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC56 0
  (semtlpp_TCC35-1 nil 3804395188 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype "semantic_tlparser.T1"
    "{T: pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast | (booleans.¬)(pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].skip?(T))}")))
 (semtlpp_TCC57 0
  (semtlpp_TCC60-1 nil 3804399719 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].prior(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T1), semantic_tlparser.T1, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].skip(semantic_tlparser.s, semantic_tlparser.s, semantic_tlparser.e2))"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC58 0
  (semtlpp_TCC37-1 nil 3804395188 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype "semantic_tlparser.e2"
    "{e: wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].Δ | peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].subterm(e, semantic_tlparser.P_exp(semantic_tlparser.A))}")))
 (semtlpp_TCC59 0
  (semtlpp_TCC38-1 nil 3804395188 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype "semantic_tlparser.s_T"
    "{k: naturalnumbers.upto(semantic_tlparser.s) | booleans.⇒((k = semantic_tlparser.s), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].g_wf(semantic_tlparser.e2, semantic_tlparser.A, wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].P_0c?(semantic_tlparser.P_exp), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].strong))}")))
 (semtlpp_TCC60 0
  (semtlpp_TCC63-1 nil 3804399719 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success"
    "semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC61 0
  (semtlpp_TCC39-1 nil 3804395188 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype "semantic_tlparser.T1"
    "{T: pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast | (booleans.¬)(pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].skip?(T))}")))
 (semtlpp_TCC62 0
  (semtlpp_TCC65-1 nil 3804399719 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].prior(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T2), semantic_tlparser.T1, semantic_tlparser.T2)"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC63 0
  (semtlpp_TCC66-1 nil 3804399719 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure"
    "semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC64 0
  (semtlpp_TCC67-1 nil 3804399719 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T2))"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC65 0
  (semtlpp_TCC53-1 nil 3804399719 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype "semantic_tlparser.P_exp(semantic_tlparser.A)"
    "{e: wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].Δ | peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].subterm(e, semantic_tlparser.P_exp(semantic_tlparser.A))}")))
 (semtlpp_TCC66 0
  (semtlpp_TCC54-1 nil 3804399719 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype "semantic_tlparser.s"
    "{k: naturalnumbers.upto(semantic_tlparser.s) | booleans.⇒((k = semantic_tlparser.s), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].g_wf(semantic_tlparser.P_exp(semantic_tlparser.A), semantic_tlparser.A, wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].P_0c?(semantic_tlparser.P_exp), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].strong))}")))
 (semtlpp_TCC67 0
  (semtlpp_TCC42-1 nil 3804395188 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (peg type-decl nil peg nil) (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (subterm adt-def-decl "boolean" peg nil)
    (<= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (saved_result type-decl nil semantic_tlparser nil)
    (known? adt-recognizer-decl "[saved_result -> boolean]"
     semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (astType type-decl nil ast nil) (pre_ast type-decl nil pre_ast nil)
    (astType? def-decl "astType" ast nil)
    (input type-eq-decl nil ast_props nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil) (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (valuedTree? const-decl "bool" semantic_interp nil)
    (T adt-accessor-decl "[(known?) -> (valuedTree?)]"
     semantic_tlparser nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail adt-constructor-decl "[[below, below] -> (fail?)]" pre_ast
     nil)
    (semantic? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (semantic adt-constructor-decl
     "[[below, below, V_N[V_N_b], V_S] -> (semantic?)]" pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (status adt-accessor-decl
            "[(known?) -> astType[V_T, <=, V_N_b, bound, V_S]]"
            semantic_tlparser nil)
    (results type-eq-decl nil semantic_tlparser nil)
    (< def-decl "bool" ordinals nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (sum const-decl "nat" peg nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (pegMeasure const-decl "nat" peg nil)
    (lex2 const-decl "ordinal" lex2 nil)
    (lex3 const-decl "ordinal" lex3 nil)
    (lex4 const-decl "ordinal" lex4 nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (semtlpp termination
    "semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, semantic_tlparser.e2, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T, semantic_tlparser.res, (restrict[[ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astType, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast, semantic_tlparser.results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)], [semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e2, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)), semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e2, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T), semantic_tlparser.results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)], [ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astType, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast]].restrict((LAMBDA (status2, T2, res: semantic_tlparser.results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): IF (semantic_tlparser.status2 = ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success) THEN semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].prior(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T2), semantic_tlparser.T1, semantic_tlparser.T2), res) ELSE semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T2)), res) ENDIF))))"
    "nil")))
 (semtlpp_TCC68 0
  (semtlpp_TCC68-1 nil 3804399719 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype "semantic_tlparser.P_exp(semantic_tlparser.A)"
    "{e: wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].Δ | peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].subterm(e, semantic_tlparser.P_exp(semantic_tlparser.A))}")))
 (semtlpp_TCC69 0
  (semtlpp_TCC69-1 nil 3804399719 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype "semantic_tlparser.s"
    "{k: naturalnumbers.upto(semantic_tlparser.s) | booleans.⇒((k = semantic_tlparser.s), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].g_wf(semantic_tlparser.P_exp(semantic_tlparser.A), semantic_tlparser.A, wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].P_0c?(semantic_tlparser.P_exp), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].strong))}")))
 (semtlpp_TCC70 0
  (semtlpp_TCC44-1 nil 3804395188 ("" (termination-tcc) nil nil) nil
   nil
   (semtlpp termination
    "semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, semantic_tlparser.e1, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T, semantic_tlparser.res, (restrict[[ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astType, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast, semantic_tlparser.results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)], [semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e1, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)), semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e1, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T), semantic_tlparser.results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)], [ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astType, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast]].restrict((LAMBDA (status1, T1, res: semantic_tlparser.results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): IF (semantic_tlparser.status1 = ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success) THEN semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].prior(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T1), semantic_tlparser.T1, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].skip(semantic_tlparser.s, semantic_tlparser.s, semantic_tlparser.e2)), res) ELSE semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, semantic_tlparser.e2, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T, res, (restrict[[ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astType, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast, semantic_tlparser.results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)], [semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e2, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)), semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e2, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T), semantic_tlparser.results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)], [ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astType, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast]].restrict((LAMBDA (status2, T2, res: semantic_tlparser.results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): IF (semantic_tlparser.status2 = ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success) THEN semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].prior(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T2), semantic_tlparser.T1, semantic_tlparser.T2), res) ELSE semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T2)), res) ENDIF)))) ENDIF))))"
    "nil")))
 (semtlpp_TCC71 0
  (semtlpp_TCC46-1 nil 3804395188 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype "semantic_tlparser.e"
    "{e: wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].Δ | peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].subterm(e, semantic_tlparser.P_exp(semantic_tlparser.A))}")))
 (semtlpp_TCC72 0
  (semtlpp_TCC47-1 nil 3804395188 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype "semantic_tlparser.s_T"
    "{k: naturalnumbers.upto(semantic_tlparser.s) | booleans.⇒((k = semantic_tlparser.s), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].g_wf(semantic_tlparser.e, semantic_tlparser.A, wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].P_0c?(semantic_tlparser.P_exp), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].strong))}")))
 (semtlpp_TCC73 0
  (semtlpp_TCC76-1 nil 3804399719 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success"
    "semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC74 0
  (semtlpp_TCC48-1 nil 3804395188 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype "semantic_tlparser.T0"
    "{T: pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast | (booleans.¬)(pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].skip?(T))}")))
 (semtlpp_TCC75 0
  (semtlpp_TCC78-1 nil 3804399719 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].star(semantic_tlparser.s, semantic_tlparser.s, semantic_tlparser.T0, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].skip(pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T0), pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T0), peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].star(semantic_tlparser.e)))"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC76 0
  (semtlpp_TCC50-1 nil 3804395188 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype
    "peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].star(semantic_tlparser.e)"
    "{e: wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].Δ | peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].subterm(e, semantic_tlparser.P_exp(semantic_tlparser.A))}")))
 (semtlpp_TCC77 0
  (semtlpp_TCC51-1 nil 3804395188 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype "semantic_tlparser.s_T"
    "{k: naturalnumbers.upto(pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T0)) | booleans.⇒((k = pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T0)), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].g_wf(peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].star(semantic_tlparser.e), semantic_tlparser.A, wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].P_0c?(semantic_tlparser.P_exp), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].strong))}")))
 (semtlpp_TCC78 0
  (semtlpp_TCC81-1 nil 3804399719 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success"
    "semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC79 0
  (semtlpp_TCC52-1 nil 3804395188 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype "semantic_tlparser.T0"
    "{T: pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast | (booleans.¬)(pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].skip?(T))}")))
 (semtlpp_TCC80 0
  (semtlpp_TCC53-1 nil 3804395188 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype "semantic_tlparser.Ts"
    "{T: pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast | booleans.OR(pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].skip?(T), pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].star?(T))}")))
 (semtlpp_TCC81 0
  (semtlpp_TCC84-1 nil 3804399719 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].star(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.Ts), semantic_tlparser.T0, semantic_tlparser.Ts)"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC82 0
  (semtlpp_TCC71-1 nil 3804399719 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype "semantic_tlparser.P_exp(semantic_tlparser.A)"
    "{e: wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].Δ | peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].subterm(e, semantic_tlparser.P_exp(semantic_tlparser.A))}")))
 (semtlpp_TCC83 0
  (semtlpp_TCC72-1 nil 3804399719 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype "semantic_tlparser.s"
    "{k: naturalnumbers.upto(semantic_tlparser.s) | booleans.⇒((k = semantic_tlparser.s), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].g_wf(semantic_tlparser.P_exp(semantic_tlparser.A), semantic_tlparser.A, wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].P_0c?(semantic_tlparser.P_exp), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].strong))}")))
 (semtlpp_TCC84 0
  (semtlpp_TCC55-1 nil 3804395188 ("" (termination-tcc) nil nil) nil
   nil
   (semtlpp termination
    "semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].star(semantic_tlparser.e), semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T0), semantic_tlparser.s_T, semantic_tlparser.res, (restrict[[ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astType, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast, semantic_tlparser.results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)], [semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].star(semantic_tlparser.e), semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T0), semantic_tlparser.s_T)), semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].star(semantic_tlparser.e), semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T0), semantic_tlparser.s_T), semantic_tlparser.results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)], [ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astType, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast]].restrict((LAMBDA (status2, Ts, res: semantic_tlparser.results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].star(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.Ts), semantic_tlparser.T0, semantic_tlparser.Ts), res)))))"
    "nil")))
 (semtlpp_TCC85 0
  (semtlpp_TCC85-1 nil 3804399719 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype "semantic_tlparser.P_exp(semantic_tlparser.A)"
    "{e: wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].Δ | peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].subterm(e, semantic_tlparser.P_exp(semantic_tlparser.A))}")))
 (semtlpp_TCC86 0
  (semtlpp_TCC86-1 nil 3804399719 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype "semantic_tlparser.s"
    "{k: naturalnumbers.upto(semantic_tlparser.s) | booleans.⇒((k = semantic_tlparser.s), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].g_wf(semantic_tlparser.P_exp(semantic_tlparser.A), semantic_tlparser.A, wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].P_0c?(semantic_tlparser.P_exp), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].strong))}")))
 (semtlpp_TCC87 0
  (semtlpp_TCC57-1 nil 3804395188 ("" (termination-tcc) nil nil) nil
   nil
   (semtlpp termination
    "semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T, semantic_tlparser.res, (restrict[[ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astType, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast, semantic_tlparser.results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)], [semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)), semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T), semantic_tlparser.results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)], [ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astType, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast]].restrict((LAMBDA (status1, T0, res: semantic_tlparser.results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): IF (semantic_tlparser.status1 = ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure) THEN semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].star(semantic_tlparser.s, semantic_tlparser.s, semantic_tlparser.T0, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].skip(pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T0), pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T0), peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].star(semantic_tlparser.e))), res) ELSE semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].star(semantic_tlparser.e), semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T0), semantic_tlparser.s_T, res, (restrict[[ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astType, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast, semantic_tlparser.results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)], [semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].star(semantic_tlparser.e), semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T0), semantic_tlparser.s_T)), semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].star(semantic_tlparser.e), semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T0), semantic_tlparser.s_T), semantic_tlparser.results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)], [ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astType, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast]].restrict((LAMBDA (status2, Ts, res: semantic_tlparser.results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].star(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.Ts), semantic_tlparser.T0, semantic_tlparser.Ts), res))))) ENDIF))))"
    "nil")))
 (semtlpp_TCC88 0
  (semtlpp_TCC59-1 nil 3804395188 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype "semantic_tlparser.e"
    "{e: wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].Δ | peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].subterm(e, semantic_tlparser.P_exp(semantic_tlparser.A))}")))
 (semtlpp_TCC89 0
  (semtlpp_TCC60-1 nil 3804395188 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype "semantic_tlparser.s_T"
    "{k: naturalnumbers.upto(semantic_tlparser.s) | booleans.⇒((k = semantic_tlparser.s), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].g_wf(semantic_tlparser.e, semantic_tlparser.A, wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].P_0c?(semantic_tlparser.P_exp), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].strong))}")))
 (semtlpp_TCC90 0
  (semtlpp_TCC93-1 nil 3804399719 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure"
    "semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC91 0
  (semtlpp_TCC94-1 nil 3804399719 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, semantic_tlparser.s)"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC92 0
  (semtlpp_TCC62-1 nil 3804395188 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype
    "peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].star(semantic_tlparser.e)"
    "{e: wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].Δ | peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].subterm(e, semantic_tlparser.P_exp(semantic_tlparser.A))}")))
 (semtlpp_TCC93 0
  (semtlpp_TCC63-1 nil 3804395188 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype "semantic_tlparser.s_T"
    "{k: naturalnumbers.upto(pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T0)) | booleans.⇒((k = pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T0)), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].g_wf(peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].star(semantic_tlparser.e), semantic_tlparser.A, wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].P_0c?(semantic_tlparser.P_exp), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].strong))}")))
 (semtlpp_TCC94 0
  (semtlpp_TCC97-1 nil 3804399719 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success"
    "semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC95 0
  (semtlpp_TCC64-1 nil 3804395188 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype "semantic_tlparser.T0"
    "{T: pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast | (booleans.¬)(pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].skip?(T))}")))
 (semtlpp_TCC96 0
  (semtlpp_TCC65-1 nil 3804395188 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype "semantic_tlparser.Ts"
    "{T: pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast | booleans.OR(pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].skip?(T), booleans.OR(pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].plus?(T), pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail?(T)))}")))
 (semtlpp_TCC97 0
  (semtlpp_TCC100-1 nil 3804399719 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].plus(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.Ts), semantic_tlparser.T0, semantic_tlparser.Ts)"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC98 0
  (semtlpp_TCC88-1 nil 3804399719 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype "semantic_tlparser.P_exp(semantic_tlparser.A)"
    "{e: wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].Δ | peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].subterm(e, semantic_tlparser.P_exp(semantic_tlparser.A))}")))
 (semtlpp_TCC99 0
  (semtlpp_TCC89-1 nil 3804399719 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype "semantic_tlparser.s"
    "{k: naturalnumbers.upto(semantic_tlparser.s) | booleans.⇒((k = semantic_tlparser.s), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].g_wf(semantic_tlparser.P_exp(semantic_tlparser.A), semantic_tlparser.A, wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].P_0c?(semantic_tlparser.P_exp), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].strong))}")))
 (semtlpp_TCC100 0
  (semtlpp_TCC67-1 nil 3804395188 ("" (termination-tcc) nil nil) nil
   nil
   (semtlpp termination
    "semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].star(semantic_tlparser.e), semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T0), semantic_tlparser.s_T, semantic_tlparser.res, (restrict[[ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astType, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast, semantic_tlparser.results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)], [semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].star(semantic_tlparser.e), semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T0), semantic_tlparser.s_T)), semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].star(semantic_tlparser.e), semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T0), semantic_tlparser.s_T), semantic_tlparser.results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)], [ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astType, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast]].restrict((LAMBDA (status2, Ts, res: semantic_tlparser.results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].plus(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.Ts), semantic_tlparser.T0, semantic_tlparser.Ts), res)))))"
    "nil")))
 (semtlpp_TCC101 0
  (semtlpp_TCC101-1 nil 3804399719 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype "semantic_tlparser.P_exp(semantic_tlparser.A)"
    "{e: wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].Δ | peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].subterm(e, semantic_tlparser.P_exp(semantic_tlparser.A))}")))
 (semtlpp_TCC102 0
  (semtlpp_TCC102-1 nil 3804399719 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype "semantic_tlparser.s"
    "{k: naturalnumbers.upto(semantic_tlparser.s) | booleans.⇒((k = semantic_tlparser.s), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].g_wf(semantic_tlparser.P_exp(semantic_tlparser.A), semantic_tlparser.A, wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].P_0c?(semantic_tlparser.P_exp), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].strong))}")))
 (semtlpp_TCC103 0
  (semtlpp_TCC69-1 nil 3804395188 ("" (termination-tcc) nil nil) nil
   nil
   (semtlpp termination
    "semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T, semantic_tlparser.res, (restrict[[ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astType, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast, semantic_tlparser.results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)], [semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)), semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T), semantic_tlparser.results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)], [ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astType, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast]].restrict((LAMBDA (status1, T0, res: semantic_tlparser.results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): IF (semantic_tlparser.status1 = ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure) THEN semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, semantic_tlparser.s), res) ELSE semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].star(semantic_tlparser.e), semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T0), semantic_tlparser.s_T, res, (restrict[[ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astType, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast, semantic_tlparser.results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)], [semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].star(semantic_tlparser.e), semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T0), semantic_tlparser.s_T)), semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].star(semantic_tlparser.e), semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T0), semantic_tlparser.s_T), semantic_tlparser.results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)], [ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astType, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast]].restrict((LAMBDA (status2, Ts, res: semantic_tlparser.results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].plus(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.Ts), semantic_tlparser.T0, semantic_tlparser.Ts), res))))) ENDIF))))"
    "nil")))
 (semtlpp_TCC104 0
  (semtlpp_TCC71-1 nil 3804395188 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype "semantic_tlparser.e"
    "{e: wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].Δ | peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].subterm(e, semantic_tlparser.P_exp(semantic_tlparser.A))}")))
 (semtlpp_TCC105 0
  (semtlpp_TCC72-1 nil 3804395188 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype "semantic_tlparser.s_T"
    "{k: naturalnumbers.upto(semantic_tlparser.s) | booleans.⇒((k = semantic_tlparser.s), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].g_wf(semantic_tlparser.e, semantic_tlparser.A, wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].P_0c?(semantic_tlparser.P_exp), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].strong))}")))
 (semtlpp_TCC106 0
  (semtlpp_TCC109-1 nil 3804399719 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure"
    "semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC107 0
  (semtlpp_TCC110-1 nil 3804399719 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, semantic_tlparser.s)"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC108 0
  (semtlpp_TCC111-1 nil 3804399719 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success"
    "semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC109 0
  (semtlpp_TCC74-1 nil 3804395188 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype "semantic_tlparser.T"
    "{T: pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast | (booleans.¬)(pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].skip?(T))}")))
 (semtlpp_TCC110 0
  (semtlpp_TCC113-1 nil 3804399719 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].opt(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T), semantic_tlparser.T)"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC111 0
  (semtlpp_TCC104-1 nil 3804399719 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype "semantic_tlparser.P_exp(semantic_tlparser.A)"
    "{e: wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].Δ | peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].subterm(e, semantic_tlparser.P_exp(semantic_tlparser.A))}")))
 (semtlpp_TCC112 0
  (semtlpp_TCC105-1 nil 3804399719 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype "semantic_tlparser.s"
    "{k: naturalnumbers.upto(semantic_tlparser.s) | booleans.⇒((k = semantic_tlparser.s), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].g_wf(semantic_tlparser.P_exp(semantic_tlparser.A), semantic_tlparser.A, wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].P_0c?(semantic_tlparser.P_exp), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].strong))}")))
 (semtlpp_TCC113 0
  (semtlpp_TCC76-1 nil 3804395188 ("" (termination-tcc) nil nil) nil
   nil
   (semtlpp termination
    "semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T, semantic_tlparser.res, (restrict[[ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astType, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast, semantic_tlparser.results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)], [semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)), semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T), semantic_tlparser.results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)], [ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astType, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast]].restrict((LAMBDA (status, T, res: semantic_tlparser.results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): IF (semantic_tlparser.status = ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure) THEN semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, semantic_tlparser.s), res) ELSE (semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].opt(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T), semantic_tlparser.T), res)) ENDIF))))"
    "nil")))
 (semtlpp_TCC114 0
  (semtlpp_TCC78-1 nil 3804395188 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype "semantic_tlparser.e"
    "{e: wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].Δ | peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].subterm(e, semantic_tlparser.P_exp(semantic_tlparser.A))}")))
 (semtlpp_TCC115 0
  (semtlpp_TCC79-1 nil 3804395188 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype "semantic_tlparser.s_T"
    "{k: naturalnumbers.upto(semantic_tlparser.s) | booleans.⇒((k = semantic_tlparser.s), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].g_wf(semantic_tlparser.e, semantic_tlparser.A, wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].P_0c?(semantic_tlparser.P_exp), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].strong))}")))
 (semtlpp_TCC116 0
  (semtlpp_TCC119-1 nil 3804399719 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success"
    "semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC117 0
  (semtlpp_TCC80-1 nil 3804395188 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype "semantic_tlparser.T"
    "{T: pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast | (booleans.¬)(pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].skip?(T))}")))
 (semtlpp_TCC118 0
  (semtlpp_TCC121-1 nil 3804399719 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].notP(semantic_tlparser.s, semantic_tlparser.s, semantic_tlparser.T)"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC119 0
  (semtlpp_TCC122-1 nil 3804399719 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure"
    "semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC120 0
  (semtlpp_TCC123-1 nil 3804399719 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, semantic_tlparser.s)"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC121 0
  (semtlpp_TCC114-1 nil 3804399719 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype "semantic_tlparser.P_exp(semantic_tlparser.A)"
    "{e: wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].Δ | peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].subterm(e, semantic_tlparser.P_exp(semantic_tlparser.A))}")))
 (semtlpp_TCC122 0
  (semtlpp_TCC115-1 nil 3804399719 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype "semantic_tlparser.s"
    "{k: naturalnumbers.upto(semantic_tlparser.s) | booleans.⇒((k = semantic_tlparser.s), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].g_wf(semantic_tlparser.P_exp(semantic_tlparser.A), semantic_tlparser.A, wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].P_0c?(semantic_tlparser.P_exp), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].strong))}")))
 (semtlpp_TCC123 0
  (semtlpp_TCC83-1 nil 3804395188 ("" (termination-tcc) nil nil) nil
   nil
   (semtlpp termination
    "semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T, semantic_tlparser.res, (restrict[[ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astType, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast, semantic_tlparser.results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)], [semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)), semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T), semantic_tlparser.results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)], [ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astType, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast]].restrict((LAMBDA (status, T, res: semantic_tlparser.results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): IF (semantic_tlparser.status = ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure) THEN semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].notP(semantic_tlparser.s, semantic_tlparser.s, semantic_tlparser.T), res) ELSE semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, semantic_tlparser.s), res) ENDIF))))"
    "nil")))
 (semtlpp_TCC124 0
  (semtlpp_TCC85-1 nil 3804395188 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype "semantic_tlparser.e"
    "{e: wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].Δ | peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].subterm(e, semantic_tlparser.P_exp(semantic_tlparser.A))}")))
 (semtlpp_TCC125 0
  (semtlpp_TCC86-1 nil 3804395188 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype "semantic_tlparser.s_T"
    "{k: naturalnumbers.upto(semantic_tlparser.s) | booleans.⇒((k = semantic_tlparser.s), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].g_wf(semantic_tlparser.e, semantic_tlparser.A, wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].P_0c?(semantic_tlparser.P_exp), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].strong))}")))
 (semtlpp_TCC126 0
  (semtlpp_TCC129-1 nil 3804399719 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success"
    "semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC127 0
  (semtlpp_TCC87-1 nil 3804395188 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype "semantic_tlparser.T"
    "{T: pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast | (booleans.¬)(pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].skip?(T))}")))
 (semtlpp_TCC128 0
  (semtlpp_TCC131-1 nil 3804399719 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].andP(semantic_tlparser.s, semantic_tlparser.s, semantic_tlparser.T)"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC129 0
  (semtlpp_TCC132-1 nil 3804399719 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure"
    "semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC130 0
  (semtlpp_TCC133-1 nil 3804399719 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, semantic_tlparser.s)"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC131 0
  (semtlpp_TCC124-1 nil 3804399719 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype "semantic_tlparser.P_exp(semantic_tlparser.A)"
    "{e: wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].Δ | peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].subterm(e, semantic_tlparser.P_exp(semantic_tlparser.A))}")))
 (semtlpp_TCC132 0
  (semtlpp_TCC125-1 nil 3804399719 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype "semantic_tlparser.s"
    "{k: naturalnumbers.upto(semantic_tlparser.s) | booleans.⇒((k = semantic_tlparser.s), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].g_wf(semantic_tlparser.P_exp(semantic_tlparser.A), semantic_tlparser.A, wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].P_0c?(semantic_tlparser.P_exp), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].strong))}")))
 (semtlpp_TCC133 0
  (semtlpp_TCC90-1 nil 3804395188 ("" (termination-tcc) nil nil) nil
   nil
   (semtlpp termination
    "semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T, semantic_tlparser.res, (restrict[[ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astType, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast, semantic_tlparser.results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)], [semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)), semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T), semantic_tlparser.results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)], [ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astType, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast]].restrict((LAMBDA (status, T, res: semantic_tlparser.results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): IF (semantic_tlparser.status = ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success) THEN semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].andP(semantic_tlparser.s, semantic_tlparser.s, semantic_tlparser.T), res) ELSE semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, semantic_tlparser.s), res) ENDIF))))"
    "nil"))))

