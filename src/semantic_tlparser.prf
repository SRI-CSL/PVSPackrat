(semantic_tlparser
 (sem_result_TCC1 0
  (sem_result_TCC1-1 nil 3848316423 ("" (assert) nil nil)
   ((subterm_of? const-decl "bool" peg nil)) nil
   (sem_result subtype "semantic_tlparser.G"
    "peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].subterm_of(semantic_tlparser.P_exp(semantic_tlparser.A))")))
 (semtlpp_TCC1 0
  (semtlpp_TCC1-1 nil 3848316423 ("" (assert) nil nil)
   ((subterm_of? const-decl "bool" peg nil)) nil
   (semtlpp subtype "semantic_tlparser.G"
    "peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].subterm_of(semantic_tlparser.P_exp(semantic_tlparser.A))")))
 (semtlpp_TCC2 0
  (semtlpp_TCC1-1 nil 3804853796
   ("" (assert) (("" (expand "subterm") (("" (propax) nil nil)) nil))
    nil)
   ((subterm adt-def-decl "boolean" peg nil)
    (subterm_of? const-decl "bool" peg nil))
   nil
   (semtlpp subtype "semantic_tlparser.P_exp(semantic_tlparser.A)"
    "peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].subterm_of(semantic_tlparser.P_exp(semantic_tlparser.A))")))
 (semtlpp_TCC3 0
  (semtlpp_TCC11-1 nil 3804395188
   ("" (skeep*)
    (("" (assert)
      (("" (use "WF_nT_rewrite")
        (("" (assert)
          (("" (flatten)
            (("" (expand "pattern_WF?") (("" (inst -2 A) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (structural_WF? const-decl "bool" wf_peg nil)
    (pattern_WF? const-decl "bool" wf_peg nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil) (peg type-decl nil peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (WF_nT_rewrite formula-decl nil static_analysis nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.s"
    "{k: naturalnumbers.upto(semantic_tlparser.s) | booleans.IMPLIES((k = semantic_tlparser.s), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].pattern_wf?(semantic_tlparser.P_exp(semantic_tlparser.A), semantic_tlparser.A, static_analysis[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].σ(semantic_tlparser.P_exp), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].P_0c(semantic_tlparser.P_exp)))}")))
 (semtlpp_TCC4 0
  (semtlpp_TCC2-1 nil 3804395188 ("" (assert) nil nil) nil nil
   (semtlpp subtype
    "(number_fields.-)(semantic_tlparser.bound, semantic_tlparser.s_T)"
    "nat")))
 (semtlpp_TCC5 0
  (semtlpp_TCC3-1 nil 3804395188
   ("" (skeep*) (("" (assert) nil nil)) nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "(number_fields.-)(semantic_tlparser.bound, semantic_tlparser.s)"
    "nat")))
 (semtlpp_TCC6 0
  (semtlpp_TCC4-1 nil 3804395188
   ("" (skeep)
    (("" (assert) (("" (typepred "z`7") (("" (assert) nil nil)) nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (below type-eq-decl nil naturalnumbers nil)
    (peg type-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (saved_result type-decl nil semantic_parser nil)
    (known? adt-recognizer-decl "[saved_result -> boolean]"
     semantic_parser nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (astType type-decl nil ast nil) (pre_ast type-decl nil pre_ast nil)
    (astType? def-decl "astType" ast nil)
    (subterm_of type-eq-decl nil peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil) (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (status adt-accessor-decl
            "[(known?) -> astType[V_T, <=, V_N_b, bound, V_S]]"
            semantic_parser nil)
    (T adt-accessor-decl
     "[(known?) -> pre_ast[V_T, <=, V_N_b, bound, V_S]]"
     semantic_parser nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail adt-constructor-decl "[[below, below] -> (fail?)]" pre_ast
     nil)
    (semantic? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (semantic adt-constructor-decl
     "[[below, below, V_N[V_N_b], V_S] -> (semantic?)]" pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (results type-eq-decl nil semantic_parser nil)
    (astTypeOf type-eq-decl nil semantic_parser nil)
    (sem_result type-eq-decl nil semantic_tlparser nil))
   nil
   (semtlpp subtype
    "(number_fields.-)(semantic_tlparser.bound, semantic_tlparser.z`7)"
    "nat")))
 (semtlpp_TCC7 0
  (semtlpp_TCC5-1 nil 3804395188
   ("" (assert)
    (("" (skeep*) (("" (typepred "z`6") (("" (assert) nil nil)) nil))
      nil))
    nil)
   ((TRUE const-decl "bool" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (below type-eq-decl nil naturalnumbers nil)
    (peg type-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (saved_result type-decl nil semantic_parser nil)
    (known? adt-recognizer-decl "[saved_result -> boolean]"
     semantic_parser nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (astType type-decl nil ast nil) (pre_ast type-decl nil pre_ast nil)
    (astType? def-decl "astType" ast nil)
    (subterm_of type-eq-decl nil peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil) (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (status adt-accessor-decl
            "[(known?) -> astType[V_T, <=, V_N_b, bound, V_S]]"
            semantic_parser nil)
    (T adt-accessor-decl
     "[(known?) -> pre_ast[V_T, <=, V_N_b, bound, V_S]]"
     semantic_parser nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail adt-constructor-decl "[[below, below] -> (fail?)]" pre_ast
     nil)
    (semantic? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (semantic adt-constructor-decl
     "[[below, below, V_N[V_N_b], V_S] -> (semantic?)]" pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (results type-eq-decl nil semantic_parser nil)
    (astTypeOf type-eq-decl nil semantic_parser nil)
    (sem_result type-eq-decl nil semantic_tlparser nil))
   nil
   (semtlpp subtype
    "(number_fields.-)(semantic_tlparser.bound, semantic_tlparser.z`6)"
    "nat")))
 (semtlpp_TCC8 0
  (semtlpp_TCC6-1 nil 3804395188 ("" (assert) nil nil) nil nil
   (semtlpp subtype
    "(number_fields.-)(semantic_tlparser.bound, semantic_tlparser.s_T)"
    "nat")))
 (semtlpp_TCC9 0
  (semtlpp_TCC7-1 nil 3804395188 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype
    "(number_fields.-)(semantic_tlparser.bound, semantic_tlparser.s)"
    "nat")))
 (semtlpp_TCC10 0
  (semtlpp_TCC15-1 nil 3804395188
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (assert)
        (("" (expand "parsing")
          (("" (expand "astType?") (("" (propax) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (astType? def-decl "astType" ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success"
    "semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC11 0
  (semtlpp_TCC18-1 nil 3804395188
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (assert)
        (("" (expand "parsing")
          (("" (expand "s_inp")
            (("" (expand "astType?") (("" (propax) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (astType? def-decl "astType" ast nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].ε(semantic_tlparser.s, semantic_tlparser.s)"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC12 0
  (semtlpp_TCC11-1 nil 3805033343
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "sempp") (("" (propax) nil nil)) nil)) nil))
    nil)
   ((sempp def-decl "[astTypeOf(parsing(P_exp, A, G, inp, s, s_T)),
 equalTo(s_inp(P_inp, parsing(P_exp, A, G, inp, s, s_T))),
 results(P_exp, P_inp, inp)]" semantic_parser nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].ε(semantic_tlparser.s, semantic_tlparser.s), semantic_tlparser.res)"
    "{x: [ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astType, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast, semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)] | x = semantic_tlparser.cont(semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].sempp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T, semantic_tlparser.res))}")))
 (semtlpp_TCC13 0
  (semtlpp_TCC20-1 nil 3804395188
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (assert)
        (("" (expand "parsing")
          (("" (expand "astType?")
            (("" (expand "min") (("" (propax) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (astType? def-decl "astType" ast nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure"
    "semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC14 0
  (semtlpp_TCC23-1 nil 3804395188
   ("" (skeep)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (expand "s_inp")
          (("" (expand "astType?")
            (("" (expand "min") (("" (assert) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, semantic_tlparser.s)"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC15 0
  (semtlpp_TCC14-1 nil 3805033343
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "sempp") (("" (assert) nil nil)) nil)) nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (sempp def-decl "[astTypeOf(parsing(P_exp, A, G, inp, s, s_T)),
 equalTo(s_inp(P_inp, parsing(P_exp, A, G, inp, s, s_T))),
 results(P_exp, P_inp, inp)]" semantic_parser nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, semantic_tlparser.s), semantic_tlparser.res)"
    "{x: [ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astType, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast, semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)] | x = semantic_tlparser.cont(semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].sempp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T, semantic_tlparser.res))}")))
 (semtlpp_TCC16 0
  (semtlpp_TCC26-1 nil 3804395188
   ("" (skeep)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (expand "astType?")
          (("" (expand "min") (("" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success"
    "semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC17 0
  (semtlpp_TCC8-1 nil 3804395188
   ("" (skeep) (("" (assert) nil nil)) nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (semtlpp subtype "(number_fields.+)(semantic_tlparser.s, 1)"
    "below[V_T, <=, V_N_b, bound, V_S]")))
 (semtlpp_TCC18 0
  (semtlpp_TCC28-1 nil 3804395188
   ("" (skeep)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (expand "s_inp")
          (("" (expand "astType?")
            (("" (expand "min") (("" (assert) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].any(semantic_tlparser.s, (number_fields.+)(semantic_tlparser.s, 1), semantic_tlparser.inp(semantic_tlparser.s))"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC19 0
  (semtlpp_TCC18-1 nil 3805033343
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "sempp") (("" (assert) nil nil)) nil)) nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (sempp def-decl "[astTypeOf(parsing(P_exp, A, G, inp, s, s_T)),
 equalTo(s_inp(P_inp, parsing(P_exp, A, G, inp, s, s_T))),
 results(P_exp, P_inp, inp)]" semantic_parser nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].any(semantic_tlparser.s, (number_fields.+)(semantic_tlparser.s, 1), semantic_tlparser.inp(semantic_tlparser.s)), semantic_tlparser.res)"
    "{x: [ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astType, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast, semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)] | x = semantic_tlparser.cont(semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].sempp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T, semantic_tlparser.res))}")))
 (semtlpp_TCC20 0
  (semtlpp_TCC30-1 nil 3804395188
   ("" (skeep)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (expand "astType?")
          (("" (expand "min") (("" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success"
    "semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC21 0
  (semtlpp_TCC32-1 nil 3804395188
   ("" (skeep)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (expand "s_inp")
          (("" (expand "astType?")
            (("" (expand "min") (("" (assert) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].terminal(semantic_tlparser.s, (number_fields.+)(semantic_tlparser.s, 1), semantic_tlparser.a, semantic_tlparser.a)"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC22 0
  (semtlpp_TCC21-1 nil 3805033343
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "sempp") (("" (assert) nil nil)) nil)) nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (sempp def-decl "[astTypeOf(parsing(P_exp, A, G, inp, s, s_T)),
 equalTo(s_inp(P_inp, parsing(P_exp, A, G, inp, s, s_T))),
 results(P_exp, P_inp, inp)]" semantic_parser nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].terminal(semantic_tlparser.s, (number_fields.+)(semantic_tlparser.s, 1), semantic_tlparser.a, semantic_tlparser.a), semantic_tlparser.res)"
    "{x: [ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astType, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast, semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)] | x = semantic_tlparser.cont(semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].sempp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T, semantic_tlparser.res))}")))
 (semtlpp_TCC23 0
  (semtlpp_TCC36-1 nil 3804395188
   ("" (skeep)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (expand "astType?")
          (("" (expand "min")
            (("" (assert)
              (("" (lift-if)
                (("" (assert)
                  (("" (split)
                    (("1" (assert) nil nil) ("2" (assert) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure"
    "semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC24 0
  (semtlpp_TCC40-1 nil 3804395188
   ("" (skeep)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (expand "s_inp")
          (("" (expand "astType?")
            (("" (expand "min")
              (("" (assert)
                (("" (lift-if)
                  (("" (assert)
                    (("" (lift-if)
                      (("" (assert)
                        (("" (split 1)
                          (("1" (assert) nil nil)
                           ("2" (assert) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, real_defs.min((number_fields.+)(semantic_tlparser.s, 1), semantic_tlparser.bound))"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC25 0
  (semtlpp_TCC24-1 nil 3805033343
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "sempp") (("" (assert) (("" (ground) nil nil)) nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (posint_min application-judgement "{k: posint | k <= i AND k <= j}"
     real_defs nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (sempp def-decl "[astTypeOf(parsing(P_exp, A, G, inp, s, s_T)),
 equalTo(s_inp(P_inp, parsing(P_exp, A, G, inp, s, s_T))),
 results(P_exp, P_inp, inp)]" semantic_parser nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, real_defs.min((number_fields.+)(semantic_tlparser.s, 1), semantic_tlparser.bound)), semantic_tlparser.res)"
    "{x: [ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astType, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast, semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)] | x = semantic_tlparser.cont(semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].sempp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T, semantic_tlparser.res))}")))
 (semtlpp_TCC26 0
  (semtlpp_TCC41-1 nil 3804395188
   ("" (skeep)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (expand "astType?")
          (("" (expand "min") (("" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success"
    "semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC27 0
  (semtlpp_TCC43-1 nil 3804395188
   ("" (skeep)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (expand "s_inp")
          (("" (expand "astType?")
            (("" (expand "min") (("" (assert) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].range(semantic_tlparser.s, (number_fields.+)(semantic_tlparser.s, 1), semantic_tlparser.a, semantic_tlparser.b, semantic_tlparser.inp(semantic_tlparser.s))"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC28 0
  (semtlpp_TCC27-1 nil 3805033343
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "sempp") (("" (assert) nil nil)) nil)) nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (sempp def-decl "[astTypeOf(parsing(P_exp, A, G, inp, s, s_T)),
 equalTo(s_inp(P_inp, parsing(P_exp, A, G, inp, s, s_T))),
 results(P_exp, P_inp, inp)]" semantic_parser nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].range(semantic_tlparser.s, (number_fields.+)(semantic_tlparser.s, 1), semantic_tlparser.a, semantic_tlparser.b, semantic_tlparser.inp(semantic_tlparser.s)), semantic_tlparser.res)"
    "{x: [ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astType, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast, semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)] | x = semantic_tlparser.cont(semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].sempp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T, semantic_tlparser.res))}")))
 (semtlpp_TCC29 0
  (semtlpp_TCC28-1 nil 3847091012
   ("" (skeep*)
    (("" (replaces)
      (("" (expand "parsing")
        (("" (expand "astType?")
          (("" (lift-if) (("" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (in_range const-decl "bool" ast nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (posint_min application-judgement "{k: posint | k <= i AND k <= j}"
     real_defs nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure"
    "semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC30 0
  (semtlpp_TCC29-1 nil 3847091012
   ("" (skeep*)
    (("" (replaces)
      (("" (expand "parsing")
        (("" (expand "s_inp")
          (("" (expand "astType?")
            (("" (lift-if)
              (("" (lift-if)
                (("" (lift-if) (("" (grind) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (posint_min application-judgement "{k: posint | k <= i AND k <= j}"
     real_defs nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (in_range const-decl "bool" ast nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, real_defs.min((number_fields.+)(semantic_tlparser.s, 1), semantic_tlparser.bound))"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC31 0
  (semtlpp_TCC30-1 nil 3805033343
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "sempp") (("" (assert) (("" (ground) nil nil)) nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (posint_min application-judgement "{k: posint | k <= i AND k <= j}"
     real_defs nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (sempp def-decl "[astTypeOf(parsing(P_exp, A, G, inp, s, s_T)),
 equalTo(s_inp(P_inp, parsing(P_exp, A, G, inp, s, s_T))),
 results(P_exp, P_inp, inp)]" semantic_parser nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, real_defs.min((number_fields.+)(semantic_tlparser.s, 1), semantic_tlparser.bound)), semantic_tlparser.res)"
    "{x: [ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astType, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast, semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)] | x = semantic_tlparser.cont(semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].sempp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T, semantic_tlparser.res))}")))
 (semtlpp_TCC32 0
  (semtlpp_TCC31-1 nil 3847091012
   ("" (skeep)
    (("" (replaces)
      (("" (expand "parsing")
        (("" (expand "astType?")
          (("" (typepred "res")
            (("" (inst -1 B s)
              (("" (assert) (("" (grind) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((TRUE const-decl "bool" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (astType? def-decl "astType" ast nil)
    (below type-eq-decl nil naturalnumbers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (<= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (saved_result type-decl nil semantic_parser nil)
    (known? adt-recognizer-decl "[saved_result -> boolean]"
     semantic_parser nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (astType type-decl nil ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (subterm_of type-eq-decl nil peg nil) (peg type-decl nil peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (input type-eq-decl nil ast_props nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil) (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (status adt-accessor-decl
            "[(known?) -> astType[V_T, <=, V_N_b, bound, V_S]]"
            semantic_parser nil)
    (T adt-accessor-decl
     "[(known?) -> pre_ast[V_T, <=, V_N_b, bound, V_S]]"
     semantic_parser nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail adt-constructor-decl "[[below, below] -> (fail?)]" pre_ast
     nil)
    (semantic? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (semantic adt-constructor-decl
     "[[below, below, V_N[V_N_b], V_S] -> (semantic?)]" pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (results type-eq-decl nil semantic_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype "semantic_tlparser.status"
    "semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC33 0
  (semtlpp_TCC56-1 nil 3804395188
   ("" (skeep)
    (("" (replaces)
      (("" (expand "parsing")
        (("" (expand "s_inp")
          (("" (expand "astType?")
            (("" (typepred "res")
              (("" (inst -1 B s)
                (("" (replaces)
                  (("" (assert) (("" (ground) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((TRUE const-decl "bool" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (results type-eq-decl nil semantic_parser nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semantic adt-constructor-decl
     "[[below, below, V_N[V_N_b], V_S] -> (semantic?)]" pre_ast nil)
    (semantic? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail adt-constructor-decl "[[below, below] -> (fail?)]" pre_ast
     nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (T adt-accessor-decl
     "[(known?) -> pre_ast[V_T, <=, V_N_b, bound, V_S]]"
     semantic_parser nil)
    (status adt-accessor-decl
            "[(known?) -> astType[V_T, <=, V_N_b, bound, V_S]]"
            semantic_parser nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil) (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (input type-eq-decl nil ast_props nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (subterm_of type-eq-decl nil peg nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (astType type-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (known? adt-recognizer-decl "[saved_result -> boolean]"
     semantic_parser nil)
    (saved_result type-decl nil semantic_parser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (<= const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil) (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (below type-eq-decl nil naturalnumbers nil)
    (astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype "semantic_tlparser.T_B"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC34 0
  (semtlpp_TCC33-1 nil 3805033343
   ("" (ground)
    (("" (skeep*)
      (("" (replace -1 * LR)
        (("" (expand "sempp")
          (("" (assert)
            (("" (replace -2 * LR) (("" (assert) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((TRUE const-decl "bool" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (sempp def-decl "[astTypeOf(parsing(P_exp, A, G, inp, s, s_T)),
 equalTo(s_inp(P_inp, parsing(P_exp, A, G, inp, s, s_T))),
 results(P_exp, P_inp, inp)]" semantic_parser nil))
   nil
   (semtlpp subtype
    "semantic_tlparser.cont(semantic_tlparser.status, semantic_tlparser.T_B, semantic_tlparser.res)"
    "{x: [ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astType, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast, semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)] | x = semantic_tlparser.cont(semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].sempp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T, semantic_tlparser.res))}")))
 (semtlpp_TCC35 0
  (semtlpp_TCC10-1 nil 3804395188
   ("" (assert) (("" (expand "subterm") (("" (propax) nil nil)) nil))
    nil)
   ((subterm adt-def-decl "boolean" peg nil)) nil
   (semtlpp subtype "semantic_tlparser.P_exp(semantic_tlparser.B)"
    "{e: wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].Δ | peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].subterm(e, semantic_tlparser.P_exp(semantic_tlparser.B))}")))
 (semtlpp_TCC36 0
  (semtlpp_TCC27-1 nil 3804853796
   ("" (assert)
    (("" (skeep*)
      (("" (use "WF_nT_rewrite")
        (("" (expand "pattern_WF?")
          (("" (assert) (("" (flatten) (("" (inst -2 B) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((TRUE const-decl "bool" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (pattern_WF? const-decl "bool" wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (structural_WF? const-decl "bool" wf_peg nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil) (peg type-decl nil peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (WF_nT_rewrite formula-decl nil static_analysis nil))
   nil
   (semtlpp subtype "semantic_tlparser.s"
    "{k: naturalnumbers.upto(semantic_tlparser.s) | booleans.⇒((k = semantic_tlparser.s), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].pattern_wf?(semantic_tlparser.P_exp(semantic_tlparser.B), semantic_tlparser.B, static_analysis[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].σ(semantic_tlparser.P_exp), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].P_0c(semantic_tlparser.P_exp)))}")))
 (semtlpp_TCC37 0
  (semtlpp_TCC36-1 nil 3847091012
   ("" (skeep)
    (("" (typepred "T_B")
      ((""
        (typepred
         "s_inp(P_inp, parsing(P_exp, B, P_exp(B), inp, s, s))")
        (("" (assert) nil nil)) nil))
      nil))
    nil)
   ((sem_result type-eq-decl nil semantic_tlparser nil)
    (below type-eq-decl nil naturalnumbers nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (ast type-eq-decl nil ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (subterm_of type-eq-decl nil peg nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.T_B"
    "semanticTree[V_T, <=, V_N_b, bound, V_S]")))
 (semtlpp_TCC38 0
  (semtlpp_TCC37-1 nil 3847091012
   ("" (skeep*)
    (("" (replaces)
      (("" (expand "parsing")
        (("" (expand "astType?")
          (("" (typepred "status") (("" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (astType type-decl nil ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (subterm_of type-eq-decl nil peg nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (<= const-decl "bool" reals nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (below type-eq-decl nil naturalnumbers nil)
    (astTypeOf type-eq-decl nil semantic_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success"
    "semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC39 0
  (semtlpp_TCC38-1 nil 3847091012
   ("" (skeep*)
    (("" (replaces)
      (("" (expand "parsing")
        (("" (typepred "status")
          (("" (expand "s_inp")
            (("" (assert)
              (("" (expand "astType?" +) (("" (assert) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astTypeOf type-eq-decl nil semantic_parser nil)
    (below type-eq-decl nil naturalnumbers nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (<= const-decl "bool" reals nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (< const-decl "bool" reals nil)
    (subterm_of type-eq-decl nil peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (astType? def-decl "astType" ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (astType type-decl nil ast nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.sem_T"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC40 0
  (semtlpp_TCC61-1 nil 3804395188
   ("" (skeep*)
    (("" (lift-if -5)
      (("" (split -)
        (("1" (assert)
          (("1" (flatten)
            (("1" (assert)
              (("1" (replaces) (("1" (assert) nil nil)) nil)) nil))
            nil))
          nil)
         ("2" (flatten)
          (("2" (assert)
            (("2" (typepred "res1")
              (("2" (inst - "A!1" "s_1")
                (("2" (assert)
                  (("2" (assert)
                    (("2" (split -1)
                      (("1" (hide 3)
                        (("1" (flatten) (("1" (assert) nil nil)) nil))
                        nil)
                       ("2" (hide 2)
                        (("2" (flatten)
                          (("2" (assert)
                            (("2" (split 2)
                              (("1"
                                (assert)
                                (("1"
                                  (lift-if)
                                  (("1" (assert) nil nil))
                                  nil))
                                nil)
                               ("2"
                                (lift-if)
                                (("2" (assert) nil nil))
                                nil)
                               ("3"
                                (lift-if)
                                (("3" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((results type-eq-decl nil semantic_parser nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semantic adt-constructor-decl
     "[[below, below, V_N[V_N_b], V_S] -> (semantic?)]" pre_ast nil)
    (semantic? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail adt-constructor-decl "[[below, below] -> (fail?)]" pre_ast
     nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (T adt-accessor-decl
     "[(known?) -> pre_ast[V_T, <=, V_N_b, bound, V_S]]"
     semantic_parser nil)
    (status adt-accessor-decl
            "[(known?) -> astType[V_T, <=, V_N_b, bound, V_S]]"
            semantic_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil) (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (input type-eq-decl nil ast_props nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (subterm_of type-eq-decl nil peg nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (astType? def-decl "astType" ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (astType type-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (known? adt-recognizer-decl "[saved_result -> boolean]"
     semantic_parser nil)
    (saved_result type-decl nil semantic_parser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (<= const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil) (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "semantic_tlparser.res WITH [(semantic_tlparser.B, semantic_tlparser.s) := semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].known(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, semantic_tlparser.sem_T)]"
    "semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)")))
 (semtlpp_TCC41 0
  (semtlpp_TCC40-1 nil 3847091012
   ("" (skeep*)
    (("" (replaces)
      (("" (expand "parsing")
        (("" (expand "astType?")
          (("" (typepred "status")
            (("" (assert)
              (("" (typepred "parsing(P_exp, B, P_exp(B), inp, s, s)")
                (("" (use "Wellformed_theorem") (("" (assert) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (astType type-decl nil ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (subterm_of type-eq-decl nil peg nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (<= const-decl "bool" reals nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (below type-eq-decl nil naturalnumbers nil)
    (astTypeOf type-eq-decl nil semantic_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure"
    "semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC42 0
  (semtlpp_TCC41-1 nil 3847091012
   ("" (skeep*)
    (("" (replaces)
      (("" (expand "parsing")
        (("" (typepred "status")
          (("" (expand "s_inp")
            (("" (expand "astType?" +)
              (("" (assert)
                (("" (lift-if)
                  (("" (assert)
                    (("" (typepred "T_B")
                      (("" (assert)
                        (("" (replaces)
                          ((""
                            (use "Wellformed_theorem"
                                 (T
                                  "parsing(P_exp, B, P_exp(B), inp, s, s)"))
                            (("" (assert)
                              ((""
                                (flatten)
                                (("" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astTypeOf type-eq-decl nil semantic_parser nil)
    (below type-eq-decl nil naturalnumbers nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (<= const-decl "bool" reals nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (< const-decl "bool" reals nil)
    (subterm_of type-eq-decl nil peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (astType? def-decl "astType" ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (astType type-decl nil ast nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (sem_result type-eq-decl nil semantic_tlparser nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.fail_T"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC43 0
  (semtlpp_TCC14-1 nil 3804395188
   ("" (skeep*)
    (("" (lift-if -)
      (("" (assert)
        (("" (split -)
          (("1" (flatten)
            (("1" (decompose-equality -)
              (("1" (replace -2 * LR)
                (("1" (assert)
                  (("1" (typepred "T_B")
                    (("1" (assert)
                      (("1" (typepred "status")
                        (("1"
                          (lemma "Wellformed_theorem"
                           (T
                            "(parsing(P_exp, B, P_exp(B), inp, s, s))"))
                          (("1" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (flatten)
            (("2" (typepred "res1")
              (("2" (inst -1 A!1 s_1)
                (("2" (assert)
                  (("2" (lift-if)
                    (("2" (assert) (("2" (ground) nil nil)) nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((AND const-decl "[bool, bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (peg type-decl nil peg nil)
    (nonTerminal? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (below type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (A adt-accessor-decl "[(nonTerminal?) -> below(V_N_b)]" peg nil)
    (nonTerminal adt-constructor-decl
     "[below(V_N_b) -> (nonTerminal?)]" peg nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (astTypeOf type-eq-decl nil semantic_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (pre_ast type-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (subterm_of type-eq-decl nil peg nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (ast type-eq-decl nil ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (sem_result type-eq-decl nil semantic_tlparser nil)
    (results type-eq-decl nil semantic_parser nil)
    (semantic adt-constructor-decl
     "[[below, below, V_N[V_N_b], V_S] -> (semantic?)]" pre_ast nil)
    (semantic? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail adt-constructor-decl "[[below, below] -> (fail?)]" pre_ast
     nil)
    (T adt-accessor-decl
     "[(known?) -> pre_ast[V_T, <=, V_N_b, bound, V_S]]"
     semantic_parser nil)
    (status adt-accessor-decl
            "[(known?) -> astType[V_T, <=, V_N_b, bound, V_S]]"
            semantic_parser nil)
    (known? adt-recognizer-decl "[saved_result -> boolean]"
     semantic_parser nil)
    (saved_result type-decl nil semantic_parser nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "semantic_tlparser.res WITH [(semantic_tlparser.B, semantic_tlparser.s) := semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].known(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure, semantic_tlparser.fail_T)]"
    "semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)")))
 (semtlpp_TCC44 0
  (semtlpp_TCC19-1 nil 3804395188
   ("" (assert)
    (("" (skeep*)
      (("" (replace -1 * LR)
        (("" (assert)
          (("" (typepred "s_T") (("" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((TRUE const-decl "bool" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lex2_lt formula-decl nil lex2 nil)
    (lex3_lt formula-decl nil lex3 nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (pegMeasure const-decl "nat" peg nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (peg type-decl nil peg nil) (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (below type-eq-decl nil naturalnumbers nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (lex4_lt formula-decl nil lex4 nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (semtlpp termination
    "semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.B, semantic_tlparser.P_exp(semantic_tlparser.B), semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s, semantic_tlparser.res, (LAMBDA (status: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.B, semantic_tlparser.P_exp(semantic_tlparser.B), semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s))), (T_B: semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.B, semantic_tlparser.P_exp(semantic_tlparser.B), semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s)), (res: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): IF (status = ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success) THEN LET sem_T = pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].semantic(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T_B), semantic_tlparser.B, semantic_tlparser.P_inp(semantic_tlparser.B, T_B)) IN semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, semantic_tlparser.sem_T, res WITH [(semantic_tlparser.B, semantic_tlparser.s) := semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].known(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, semantic_tlparser.sem_T)]) ELSE LET fail_T = pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T_B)) IN semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure, semantic_tlparser.fail_T, res WITH [(semantic_tlparser.B, semantic_tlparser.s) := semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].known(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure, semantic_tlparser.fail_T)]) ENDIF))"
    "nil")))
 (semtlpp_TCC45 0
  (semtlpp_TCC44-1 nil 3805033343
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "sempp")
        (("" (lift-if)
          (("" (split)
            (("1" (flatten)
              (("1" (replace -3 * LR) (("1" (assert) nil nil)) nil))
              nil)
             ("2" (flatten)
              (("2"
                (name "SemRes"
                      "sempp(P_exp, P_inp, B, P_exp(B), inp, s, s, res)")
                (("2" (replace -1 * LR)
                  (("2" (assert)
                    (("2"
                      (typepred
                       "v(P_exp, P_inp, B, P_exp(B), inp, s, s, res,
                LAMBDA (status: astTypeOf(parsing(P_exp, B, P_exp(B), inp, s, s))),
                       (T_B: sem_result(P_inp, P_exp, B, P_exp(B), inp, s, s)), (res: results(P_exp, P_inp, inp)):
                  IF (status = success)
                    THEN cont(success, semantic(s, e(T_B), B, P_inp(B, T_B)),
                              res WITH [(B, s) := known(success, semantic(s, e(T_B), B, P_inp(B, T_B)))])
                  ELSE cont(failure, fail(s, e(T_B)),
                            res WITH [(B, s) := known(failure, fail(s, e(T_B)))])
                  ENDIF)")
                      (("1" (replace -1 * LR)
                        (("1" (hide -1)
                          (("1" (replace -1 * LR)
                            (("1" (propax) nil nil)) nil))
                          nil))
                        nil)
                       ("2" (assert)
                        (("2" (hide 3)
                          (("2" (skeep)
                            (("2" (skolem 2 ("C" "s_1"))
                              (("2"
                                (assert)
                                (("2"
                                  (hide 3)
                                  (("2"
                                    (typepred "status")
                                    (("2"
                                      (name-replace
                                       "T_ref_B"
                                       "parsing(P_exp, B, P_exp(B), inp, s, s)")
                                      (("2"
                                        (assert)
                                        (("2"
                                          (name-replace
                                           "T_ref_C"
                                           "parsing(P_exp, C, P_exp(C), inp, s_1, s_1)")
                                          (("1"
                                            (use
                                             "Wellformed_theorem"
                                             (T "T_ref_C"))
                                            (("1"
                                              (assert)
                                              (("1"
                                                (flatten)
                                                (("1"
                                                  (hide +)
                                                  (("1"
                                                    (hide -1)
                                                    (("1"
                                                      (lift-if)
                                                      (("1"
                                                        (assert)
                                                        (("1"
                                                          (split -3)
                                                          (("1"
                                                            (flatten)
                                                            (("1"
                                                              (assert)
                                                              (("1"
                                                                (reveal
                                                                 +)
                                                                (("1"
                                                                  (replace
                                                                   -1
                                                                   *
                                                                   LR)
                                                                  (("1"
                                                                    (replace
                                                                     -2
                                                                     *
                                                                     LR)
                                                                    (("1"
                                                                      (assert)
                                                                      (("1"
                                                                        (hide
                                                                         3
                                                                         5)
                                                                        (("1"
                                                                          (lemma
                                                                           "Wellformed_theorem"
                                                                           (T
                                                                            "T_ref_B"))
                                                                          (("1"
                                                                            (assert)
                                                                            (("1"
                                                                              (flatten)
                                                                              (("1"
                                                                                (assert)
                                                                                (("1"
                                                                                  (typepred
                                                                                   "T_B")
                                                                                  (("1"
                                                                                    (assert)
                                                                                    (("1"
                                                                                      (reveal
                                                                                       -)
                                                                                      (("1"
                                                                                        (assert)
                                                                                        nil
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (flatten)
                                                            (("2"
                                                              (reveal
                                                               +)
                                                              (("2"
                                                                (hide
                                                                 5)
                                                                (("2"
                                                                  (assert)
                                                                  (("2"
                                                                    (lift-if)
                                                                    (("2"
                                                                      (assert)
                                                                      (("2"
                                                                        (split
                                                                         5)
                                                                        (("1"
                                                                          (assert)
                                                                          (("1"
                                                                            (split
                                                                             -2)
                                                                            (("1"
                                                                              (assert)
                                                                              (("1"
                                                                                (hide
                                                                                 5)
                                                                                (("1"
                                                                                  (typepred
                                                                                   "res!1")
                                                                                  (("1"
                                                                                    (inst
                                                                                     -1
                                                                                     "C"
                                                                                     "s_1")
                                                                                    (("1"
                                                                                      (assert)
                                                                                      (("1"
                                                                                        (assert)
                                                                                        (("1"
                                                                                          (reveal
                                                                                           -4)
                                                                                          (("1"
                                                                                            (reveal
                                                                                             -3)
                                                                                            (("1"
                                                                                              (replace
                                                                                               -1
                                                                                               *
                                                                                               LR)
                                                                                              (("1"
                                                                                                (split
                                                                                                 -3)
                                                                                                (("1"
                                                                                                  (propax)
                                                                                                  nil
                                                                                                  nil)
                                                                                                 ("2"
                                                                                                  (propax)
                                                                                                  nil
                                                                                                  nil))
                                                                                                nil))
                                                                                              nil))
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil)
                                                                             ("2"
                                                                              (assert)
                                                                              (("2"
                                                                                (typepred
                                                                                 "res!1")
                                                                                (("2"
                                                                                  (inst
                                                                                   -1
                                                                                   "C"
                                                                                   "s_1")
                                                                                  (("2"
                                                                                    (assert)
                                                                                    (("2"
                                                                                      (split
                                                                                       -1)
                                                                                      (("1"
                                                                                        (flatten)
                                                                                        (("1"
                                                                                          (assert)
                                                                                          (("1"
                                                                                            (reveal
                                                                                             -4)
                                                                                            (("1"
                                                                                              (reveal
                                                                                               -3)
                                                                                              (("1"
                                                                                                (assert)
                                                                                                nil
                                                                                                nil))
                                                                                              nil))
                                                                                            nil))
                                                                                          nil))
                                                                                        nil)
                                                                                       ("2"
                                                                                        (hide
                                                                                         2
                                                                                         3
                                                                                         4
                                                                                         5)
                                                                                        (("2"
                                                                                          (reveal
                                                                                           -)
                                                                                          (("2"
                                                                                            (reveal
                                                                                             +)
                                                                                            (("2"
                                                                                              (hide
                                                                                               5)
                                                                                              (("2"
                                                                                                (assert)
                                                                                                (("2"
                                                                                                  (hide
                                                                                                   6)
                                                                                                  (("2"
                                                                                                    (flatten)
                                                                                                    (("2"
                                                                                                      (assert)
                                                                                                      nil
                                                                                                      nil))
                                                                                                    nil))
                                                                                                  nil))
                                                                                                nil))
                                                                                              nil))
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil)
                                                                         ("2"
                                                                          (assert)
                                                                          (("2"
                                                                            (reveal
                                                                             -)
                                                                            (("2"
                                                                              (assert)
                                                                              (("2"
                                                                                (typepred
                                                                                 "res!1")
                                                                                (("2"
                                                                                  (inst
                                                                                   -1
                                                                                   "C"
                                                                                   "s_1")
                                                                                  (("2"
                                                                                    (assert)
                                                                                    (("2"
                                                                                      (split
                                                                                       -1)
                                                                                      (("1"
                                                                                        (flatten)
                                                                                        (("1"
                                                                                          (assert)
                                                                                          nil
                                                                                          nil))
                                                                                        nil)
                                                                                       ("2"
                                                                                        (flatten)
                                                                                        (("2"
                                                                                          (assert)
                                                                                          nil
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (hide 2 3)
                                            (("2"
                                              (hide -)
                                              (("2"
                                                (typepred "P_exp")
                                                (("2"
                                                  (use "WF_nT_rewrite")
                                                  (("2"
                                                    (flatten)
                                                    (("2"
                                                      (assert)
                                                      (("2"
                                                        (expand
                                                         "pattern_WF?")
                                                        (("2"
                                                          (inst -2 "C")
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("3"
                                            (assert)
                                            (("3"
                                              (expand "subterm")
                                              (("3" (propax) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("3" (hide 2 3)
                        (("3" (skeep*)
                          (("3" (typepred "status")
                            (("3" (replace -3 * LR)
                              (("3"
                                (expand "parsing" 2)
                                (("3"
                                  (expand "s_inp")
                                  (("3"
                                    (assert)
                                    (("3"
                                      (lift-if)
                                      (("3"
                                        (assert)
                                        (("3"
                                          (typepred "T_B")
                                          (("3"
                                            (assert)
                                            (("3"
                                              (wf-ast
                                               "parsing(P_exp, B, P_exp(B), inp, s, s)")
                                              (("3"
                                                (assert)
                                                (("3"
                                                  (flatten)
                                                  (("3"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("4" (hide 2 3)
                        (("4" (assert)
                          (("4" (skeep)
                            (("4" (typepred "status")
                              (("4"
                                (replace -3 * LR)
                                (("4"
                                  (expand "parsing" 2)
                                  (("4"
                                    (assert)
                                    (("4"
                                      (wf-ast
                                       "parsing(P_exp, B, P_exp(B), inp, s, s)")
                                      (("4" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("5" (hide 2 3)
                        (("5" (skeep)
                          (("5" (assert)
                            (("5" (skolem 1 ("C" "s_1"))
                              (("5"
                                (assert)
                                (("5"
                                  (flatten)
                                  (("5"
                                    (assert)
                                    (("5"
                                      (lift-if)
                                      (("5"
                                        (assert)
                                        (("5"
                                          (split -2)
                                          (("1"
                                            (flatten)
                                            (("1" (assert) nil nil))
                                            nil)
                                           ("2"
                                            (flatten)
                                            (("2"
                                              (assert)
                                              (("2"
                                                (split 2)
                                                (("1" (propax) nil nil)
                                                 ("2"
                                                  (flatten)
                                                  (("2"
                                                    (hide 3)
                                                    (("2"
                                                      (split 3)
                                                      (("1"
                                                        (flatten)
                                                        (("1"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil)
                                                       ("2"
                                                        (flatten)
                                                        (("2"
                                                          (hide 3)
                                                          (("2"
                                                            (case-replace
                                                             "res!1 WITH [(B, s) := known(success, semantic(s, e(T_B), B, P_inp(B, T_B)))] (C, s_1) = res!1(C, s_1)")
                                                            (("1"
                                                              (assert)
                                                              (("1"
                                                                (typepred
                                                                 "res!1")
                                                                (("1"
                                                                  (inst
                                                                   -
                                                                   "C"
                                                                   "s_1")
                                                                  (("1"
                                                                    (assert)
                                                                    (("1"
                                                                      (split
                                                                       -1)
                                                                      (("1"
                                                                        (propax)
                                                                        nil
                                                                        nil)
                                                                       ("2"
                                                                        (propax)
                                                                        nil
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil)
                                                             ("2"
                                                              (lift-if)
                                                              (("2"
                                                                (assert)
                                                                (("2"
                                                                  (split
                                                                   1)
                                                                  (("1"
                                                                    (flatten)
                                                                    (("1"
                                                                      (assert)
                                                                      nil
                                                                      nil))
                                                                    nil)
                                                                   ("2"
                                                                    (propax)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil)
                                                             ("3"
                                                              (typepred
                                                               "T_B")
                                                              (("3"
                                                                (assert)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("6" (hide 2 3)
                        (("6" (skeep)
                          (("6" (expand "parsing")
                            (("6" (replace -3 * LR)
                              (("6"
                                (assert)
                                (("6"
                                  (expand "s_inp")
                                  (("6" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("7" (assert)
                        (("7" (lift-if)
                          (("7" (assert)
                            (("7" (ground)
                              (("7"
                                (skeep*)
                                (("7"
                                  (typepred "T_B")
                                  (("7" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("8" (hide 2 3)
                        (("8" (skeep)
                          (("8" (replace -3 * LR)
                            (("8" (expand "parsing")
                              (("8"
                                (expand "astType?")
                                (("8" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("9" (expand "subterm") (("9" (propax) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((known adt-constructor-decl "[[astType[V_T, <=, V_N_b, bound, V_S],
  pre_ast[V_T, <=, V_N_b, bound, V_S]] ->
   (known?)]" semantic_parser nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (pegMeasure const-decl "nat" peg nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (lex4 const-decl "ordinal" lex4 nil)
    (ordinal nonempty-type-eq-decl nil ordinals nil)
    (ordinal? def-decl "bool" ordinals nil)
    (< def-decl "bool" ordinals nil)
    (ordstruct type-decl nil ordstruct_adt nil)
    (sem_result type-eq-decl nil semantic_tlparser nil)
    (subterm adt-def-decl "boolean" peg nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (WF_nT_rewrite formula-decl nil static_analysis nil)
    (structural_WF? const-decl "bool" wf_peg nil)
    (pattern_WF? const-decl "bool" wf_peg nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (astType type-decl nil ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (astType? def-decl "astType" ast nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (subterm_of type-eq-decl nil peg nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (<= const-decl "bool" reals nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (below type-eq-decl nil naturalnumbers nil)
    (astTypeOf type-eq-decl nil semantic_parser nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (equalTo type-eq-decl nil semantic_parser nil)
    (saved_result type-decl nil semantic_parser nil)
    (known? adt-recognizer-decl "[saved_result -> boolean]"
     semantic_parser nil)
    (status adt-accessor-decl
            "[(known?) -> astType[V_T, <=, V_N_b, bound, V_S]]"
            semantic_parser nil)
    (T adt-accessor-decl
     "[(known?) -> pre_ast[V_T, <=, V_N_b, bound, V_S]]"
     semantic_parser nil)
    (fail adt-constructor-decl "[[below, below] -> (fail?)]" pre_ast
     nil)
    (semantic? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (semantic adt-constructor-decl
     "[[below, below, V_N[V_N_b], V_S] -> (semantic?)]" pre_ast nil)
    (results type-eq-decl nil semantic_parser nil)
    (sempp def-decl "[astTypeOf(parsing(P_exp, A, G, inp, s, s_T)),
 equalTo(s_inp(P_inp, parsing(P_exp, A, G, inp, s, s_T))),
 results(P_exp, P_inp, inp)]" semantic_parser nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.B, semantic_tlparser.P_exp(semantic_tlparser.B), semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s, semantic_tlparser.res, (LAMBDA (status: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.B, semantic_tlparser.P_exp(semantic_tlparser.B), semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s))), (T_B: semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.B, semantic_tlparser.P_exp(semantic_tlparser.B), semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s)), (res: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): IF (status = ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success) THEN LET sem_T = pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].semantic(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T_B), semantic_tlparser.B, semantic_tlparser.P_inp(semantic_tlparser.B, T_B)) IN semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, semantic_tlparser.sem_T, res WITH [(semantic_tlparser.B, semantic_tlparser.s) := semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].known(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, semantic_tlparser.sem_T)]) ELSE LET fail_T = pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T_B)) IN semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure, semantic_tlparser.fail_T, res WITH [(semantic_tlparser.B, semantic_tlparser.s) := semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].known(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure, semantic_tlparser.fail_T)]) ENDIF))"
    "{x: [ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astType, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast, semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)] | x = semantic_tlparser.cont(semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].sempp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T, semantic_tlparser.res))}")))
 (semtlpp_TCC46 0
  (semtlpp_TCC21-1 nil 3804395188
   ("" (skeep*)
    (("" (ground)
      (("" (typepred "G")
        (("" (lemma "peg[V_T, <=, V_N_b].subterm_transitivity")
          (("" (assert)
            (("" (inst -1 e1 G "P_exp(A)")
              (("" (ground)
                (("" (replace -2 * LR)
                  (("" (expand "subterm")
                    (("" (expand "subterm") (("" (propax) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((subterm_transitivity formula-decl nil peg nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (peg type-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (below type-eq-decl nil naturalnumbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.e1"
    "{e: wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].Δ | peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].subterm(e, semantic_tlparser.P_exp(semantic_tlparser.A))}")))
 (semtlpp_TCC47 0
  (semtlpp_TCC22-1 nil 3804395188
   ("" (skeep*)
    (("" (typepred "s_T")
      (("" (assert)
        (("" (expand "g_wf" -)
          (("" (replace -3 * LR)
            (("" (flatten) (("" (assert) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.s_T"
    "{k: naturalnumbers.upto(semantic_tlparser.s) | booleans.⇒((k = semantic_tlparser.s), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].pattern_wf?(semantic_tlparser.e1, semantic_tlparser.A, static_analysis[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].σ(semantic_tlparser.P_exp), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].P_0c(semantic_tlparser.P_exp)))}")))
 (semtlpp_TCC48 0
  (semtlpp_TCC47-1 nil 3847091012
   ("" (skeep*)
    (("" (assert)
      (("" (replaces)
        (("" (expand "parsing")
          (("" (expand "astType?") (("" (propax) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (astType? def-decl "astType" ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure"
    "semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC49 0
  (semtlpp_TCC48-1 nil 3847091012
   ("" (skeep*)
    (("" (replaces)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "s_inp")
            (("" (lift-if)
              (("" (assert)
                (("" (expand "astType?")
                  (("" (assert)
                    (("" (typepred "T1")
                      (("" (replaces)
                        (("" (use "semantic_interp_props")
                          (("" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((sem_result type-eq-decl nil semantic_tlparser nil)
    (subterm adt-def-decl "boolean" peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (ast type-eq-decl nil ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (subterm_of type-eq-decl nil peg nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semantic_interp_props formula-decl nil semantic_interp nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (astType? def-decl "astType" ast nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T1))"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC50 0
  (semtlpp_TCC24-1 nil 3804395188
   ("" (skeep*)
    (("" (lemma "peg[V_T, <=, V_N_b].subterm_transitivity")
      (("" (inst-cp -1 "e1" "G" "P_exp(A)")
        (("" (inst -1 "e2" "G" "P_exp(A)")
          (("" (replace -3 * LR)
            (("" (assert)
              (("" (expand "subterm" 1)
                (("" (expand "subterm" 1) (("" (propax) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (subterm_transitivity formula-decl nil peg nil)
    (sub_seq formula-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.e2"
    "{e: wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].Δ | peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].subterm(e, semantic_tlparser.P_exp(semantic_tlparser.A))}")))
 (semtlpp_TCC51 0
  (semtlpp_TCC25-1 nil 3804395188
   ("" (skeep*)
    (("" (assert)
      (("" (typepred "s_T")
        (("" (wf-ast T1)
          (("" (assert)
            (("" (flatten)
              (("" (assert)
                (("" (flatten)
                  (("" (assert)
                    (("" (replace -6 * LR)
                      (("" (assert)
                        (("" (flatten)
                          ((""
                            (typepred
                             "parsing(P_exp, A, e1, inp, s, s_T)")
                            (("" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (pre_ast type-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (subterm_of type-eq-decl nil peg nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (subterm_of? const-decl "bool" peg nil)
    (ast type-eq-decl nil ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (sem_result type-eq-decl nil semantic_tlparser nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (peg type-decl nil peg nil) (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (below type-eq-decl nil naturalnumbers nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.s_T"
    "{k: naturalnumbers.upto(pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T1)) | booleans.⇒((k = pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T1)), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].pattern_wf?(semantic_tlparser.e2, semantic_tlparser.A, static_analysis[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].σ(semantic_tlparser.P_exp), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].P_0c(semantic_tlparser.P_exp)))}")))
 (semtlpp_TCC52 0
  (semtlpp_TCC51-1 nil 3847091012
   ("" (skeep*)
    (("" (replaces)
      (("" (expand "parsing")
        (("" (assert)
          (("" (lift-if)
            (("" (assert)
              (("" (wf-ast "parsing(P_exp, A, e1, inp, s, s_T)")
                (("1" (assert)
                  (("1" (flatten)
                    (("1" (assert)
                      (("1" (typepred "status1")
                        (("1" (replace -3 * LR)
                          (("1"
                            (name-replace "T_ref_e1"
                             "parsing(P_exp, A, e1, inp, s, s_T)")
                            (("1" (split 2)
                              (("1"
                                (typepred "status2")
                                (("1"
                                  (assert)
                                  (("1"
                                    (use "semantic_interp_props")
                                    (("1"
                                      (assert)
                                      (("1"
                                        (flatten)
                                        (("1"
                                          (typepred "T1")
                                          (("1"
                                            (assert)
                                            (("1"
                                              (reveal -3)
                                              (("1"
                                                (replace -1 * LR)
                                                (("1"
                                                  (assert)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (flatten)
                                (("2"
                                  (assert)
                                  (("2"
                                    (split 2)
                                    (("1" (propax) nil nil)
                                     ("2"
                                      (assert)
                                      (("2"
                                        (wf-ast
                                         "parsing(P_exp, A, e2, inp, e(T_ref_e1), s_T)")
                                        (("2" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (hide 2 3)
                  (("2" (assert)
                    (("2" (flatten)
                      (("2" (typepred "s_T")
                        (("2" (assert)
                          (("2" (reveal -)
                            (("2" (replace -1 * LR)
                              (("2" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("3" (typepred "G")
                  (("3" (lemma "subterm_seq" (G "P_exp(A)"))
                    (("3" (inst - e1 e2)
                      (("3" (assert)
                        (("3" (reveal -) (("3" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (subterm_seq formula-decl nil peg nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (semantic_interp_props formula-decl nil semantic_interp nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (sem_result type-eq-decl nil semantic_tlparser nil)
    (astTypeOf type-eq-decl nil semantic_parser nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (subterm adt-def-decl "boolean" peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType type-decl nil ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ast type-eq-decl nil ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (<= const-decl "bool" reals nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (< const-decl "bool" reals nil)
    (subterm_of type-eq-decl nil peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (astWellformed? def-decl "bool" ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (subterm_of? const-decl "bool" peg nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure"
    "semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC53 0
  (semtlpp_TCC52-1 nil 3847091012
   ("" (skeep*)
    (("" (replaces)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "s_inp")
            (("" (expand "astType?")
              (("" (lift-if)
                (("" (assert)
                  (("" (case "status1 = success")
                    (("1" (assert)
                      (("1" (typepred "status2")
                        (("1" (typepred "T1")
                          (("1" (use "semantic_interp_props")
                            (("1" (flatten)
                              (("1"
                                (replaces)
                                (("1"
                                  (assert)
                                  (("1"
                                    (decompose-equality 2)
                                    (("1"
                                      (typepred "T2")
                                      (("1"
                                        (use
                                         "semantic_interp_props"
                                         (T T2))
                                        (("1" (assert) nil nil)
                                         ("2" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (typepred "status1")
                      (("2" (use "Wellformed_theorem")
                        (("2" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (pre_ast_fail_extensionality formula-decl nil pre_ast nil)
    (fail adt-constructor-decl "[[below, below] -> (fail?)]" pre_ast
     nil)
    (semantic_interp_props formula-decl nil semantic_interp nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (sem_result type-eq-decl nil semantic_tlparser nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (astType type-decl nil ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (subterm_of type-eq-decl nil peg nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (<= const-decl "bool" reals nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (below type-eq-decl nil naturalnumbers nil)
    (subterm adt-def-decl "boolean" peg nil)
    (astTypeOf type-eq-decl nil semantic_parser nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T2))"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC54 0
  (semtlpp_TCC53-1 nil 3847091012
   ("" (skeep*)
    (("" (replaces)
      (("" (assert)
        (("" (expand "parsing")
          (("" (assert)
            (("" (lift-if)
              (("" (assert)
                (("" (typepred "status1")
                  (("" (typepred "status2")
                    (("" (wf-ast "parsing(P_exp, A, e1, inp, s, s_T)")
                      ((""
                        (wf-ast
                         "parsing(P_exp, A, e2, inp, e(T1), s_T)")
                        (("" (assert)
                          (("" (flatten)
                            (("" (assert)
                              ((""
                                (typepred "T1")
                                ((""
                                  (use "semantic_interp_props")
                                  (("" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (astTypeOf type-eq-decl nil semantic_parser nil)
    (subterm adt-def-decl "boolean" peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (<= const-decl "bool" reals nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (< const-decl "bool" reals nil)
    (subterm_of type-eq-decl nil peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (astType type-decl nil ast nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (semantic_interp_props formula-decl nil semantic_interp nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (sem_result type-eq-decl nil semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (astType? def-decl "astType" ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success"
    "semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC55 0
  (semtlpp_TCC27-1 nil 3804395188
   ("" (skeep*)
    (("" (typepred "T1")
      ((""
        (lemma "semantic_interp_props"
         (T "parsing(P_exp, A, e1, inp, s, s_T)" P_inp P_inp))
        (("" (flatten)
          (("" (replace -5 * RL)
            (("" (expand "astWellformed?") (("" (assert) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((sem_result type-eq-decl nil semantic_tlparser nil)
    (subterm adt-def-decl "boolean" peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (ast type-eq-decl nil ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (subterm_of type-eq-decl nil peg nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semantic_interp_props formula-decl nil semantic_interp nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.T1"
    "{T: pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast | (booleans.¬)(pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].skip?(T))}")))
 (semtlpp_TCC56 0
  (semtlpp_TCC55-1 nil 3847091012
   ("" (skeep*)
    (("" (replaces)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "s_inp")
            (("" (expand "astType?")
              (("" (lift-if)
                (("" (assert)
                  (("" (ground)
                    (("" (typepred "status2")
                      (("" (use "semantic_interp_props")
                        (("" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (astTypeOf type-eq-decl nil semantic_parser nil)
    (sem_result type-eq-decl nil semantic_tlparser nil)
    (subterm adt-def-decl "boolean" peg nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (below type-eq-decl nil naturalnumbers nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (<= const-decl "bool" reals nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (< const-decl "bool" reals nil)
    (subterm_of type-eq-decl nil peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (astType type-decl nil ast nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semantic_interp_props formula-decl nil semantic_interp nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].seq(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T2), semantic_tlparser.T1, semantic_tlparser.T2)"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC57 0
  (semtlpp_TCC29-1 nil 3804395188
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (rewrite "lex4_lt")
        (("" (rewrite "lex3_lt")
          (("" (rewrite "lex2_lt")
            (("" (typepred "T1")
              (("" (lemma "Wellformed_theorem" (T T1))
                (("" (assert)
                  (("" (flatten)
                    (("" (assert) (("" (grind) nil nil)) nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (lex3_lt formula-decl nil lex3 nil)
    (lex2_lt formula-decl nil lex2 nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (pegMeasure_seq formula-decl nil peg nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (seq adt-constructor-decl "[[peg, peg] -> (seq?)]" peg nil)
    (seq? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (pegMeasure const-decl "nat" peg nil)
    (sem_result type-eq-decl nil semantic_tlparser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (ast type-eq-decl nil ast nil)
    (subterm_of? const-decl "bool" peg nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (subterm_of type-eq-decl nil peg nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (lex4_lt formula-decl nil lex4 nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp termination
    "semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, semantic_tlparser.e2, semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T1), semantic_tlparser.s_T, semantic_tlparser.res, (LAMBDA (status2: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e2, semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T1), semantic_tlparser.s_T))), (T2: semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e2, semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T1), semantic_tlparser.s_T)), (res: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): IF (status2 = ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure) THEN semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T2)), res) ELSE semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].seq(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T2), semantic_tlparser.T1, T2), res) ENDIF))"
    "nil")))
 (semtlpp_TCC58 0
  (semtlpp_TCC31-1 nil 3804395188
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (rewrite "lex4_lt")
        (("" (rewrite "lex3_lt")
          (("" (rewrite "lex2_lt")
            (("" (assert) (("" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((lex3_lt formula-decl nil lex3 nil)
    (lex2_lt formula-decl nil lex2 nil)
    (pegMeasure_seq formula-decl nil peg nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (seq adt-constructor-decl "[[peg, peg] -> (seq?)]" peg nil)
    (seq? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (pegMeasure const-decl "nat" peg nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (lex4_lt formula-decl nil lex4 nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp termination
    "semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, semantic_tlparser.e1, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T, semantic_tlparser.res, (LAMBDA (status1: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e1, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))), (T1: semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e1, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)), (res: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): IF (status1 = ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure) THEN semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T1)), res) ELSE semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, semantic_tlparser.e2, semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T1), semantic_tlparser.s_T, res, LAMBDA (status2: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e2, semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T1), semantic_tlparser.s_T))), (T2: semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e2, semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T1), semantic_tlparser.s_T)), (res: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): IF (status2 = ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure) THEN semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T2)), res) ELSE semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].seq(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T2), T1, T2), res) ENDIF) ENDIF))"
    "nil")))
 (semtlpp_TCC59 0
  (semtlpp_TCC58-1 nil 3805033343
   ("" (skeep*)
    (("" (label "eq_G" -1)
      (("" (auto-rewrite! -1)
        (("" (auto-rewrite "parsing")
          ((""
            (typepred "v(P_exp, P_inp, A, e1, inp, s, s_T, res,
               LAMBDA (status1: astTypeOf(parsing(P_exp, A, e1, inp, s, s_T))), (T1: sem_result(P_inp, P_exp, A, e1, inp, s, s_T)), (res: results(P_exp, P_inp, inp)):
                 IF (status1 = failure) THEN
     						   cont(failure, fail(s, e(T1)), res)
                 ELSE
     						   v(P_exp, P_inp, A, e2, inp, e(T1), s_T, res, LAMBDA (status2: astTypeOf(parsing (P_exp, A, e2, inp, e(T1), s_T))), (T2: sem_result(P_inp, P_exp, A, e2, inp, e(T1), s_T)), (res: results(P_exp, P_inp, inp)):
                          IF (status2 = failure) THEN cont(failure, fail(s, e(T2)), res)
                          ELSE cont(success, seq(s, e(T2), T1, T2), res) ENDIF)
                 ENDIF)")
            (("1" (replace -1 * LR)
              (("1" (hide -1)
                (("1" (assert)
                  (("1" (lift-if)
                    (("1" (split +)
                      (("1" (flatten)
                        (("1" (expand "sempp" + 3)
                          (("1" (assert) nil nil)) nil))
                        nil)
                       ("2" (flatten)
                        (("2" (assert)
                          (("2"
                            (typepred
                             "sempp(P_exp, P_inp, A, e1, inp, s, s_T, res)`1")
                            (("2"
                              (lemma "Wellformed_theorem"
                               (T
                                "parsing(P_exp, A, e1, inp, s, s_T)"))
                              (("2"
                                (assert)
                                (("2"
                                  (flatten)
                                  (("2"
                                    (typepred
                                     "v(P_exp, P_inp, A, e2, inp, e(sempp(P_exp, P_inp, A, e1, inp, s, s_T, res)`2), s_T,
       			   sempp(P_exp, P_inp, A, e1, inp, s, s_T, res)`3,
       				 LAMBDA (status2: astTypeOf(parsing(P_exp, A, e2, inp, e (sempp(P_exp, P_inp, A, e1, inp, s, s_T, res)`2), s_T))),
       				        (T2:sem_result(P_inp, P_exp, A, e2, inp, e (sempp(P_exp,P_inp,A,e1,inp,s,s_T,res)`2), s_T)),
       								(res_1:results(P_exp, P_inp, inp)):
       						IF (status2 = failure) THEN
       						    cont(failure,fail(s, e(T2)),res_1)
       						ELSE
       						    cont(success,seq(s, e(T2), sempp(P_exp, P_inp, A, e1, inp, s, s_T, res)`2, T2),res_1)
       					  ENDIF)")
                                    (("1"
                                      (replace -1 * LR)
                                      (("1"
                                        (hide -1)
                                        (("1"
                                          (assert)
                                          (("1"
                                            (name-rewrite
                                             "SemRes1"
                                             "sempp(P_exp, P_inp, A, e1, inp, s, s_T, res)")
                                            (("1"
                                              (typepred "SemRes1`1")
                                              (("1"
                                                (typepred "SemRes1`2")
                                                (("1"
                                                  (assert)
                                                  (("1"
                                                    (expand
                                                     "sempp"
                                                     +
                                                     7)
                                                    (("1"
                                                      (assert)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (hide 3)
                                      (("2"
                                        (skeep*)
                                        (("2"
                                          (expand "s_inp")
                                          (("2"
                                            (lift-if)
                                            (("2"
                                              (flassert)
                                              (("2"
                                                (typepred "status2")
                                                (("2"
                                                  (typepred
                                                   "sempp(P_exp, P_inp, A, e1, inp, s, s_T, res)`2")
                                                  (("2"
                                                    (typepred "T2")
                                                    (("2"
                                                      (typepred
                                                       "parsing(P_exp, A, e1, inp, s, s_T)")
                                                      (("2"
                                                        (flassert)
                                                        (("2"
                                                          (lift-if)
                                                          (("2"
                                                            (assert)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("3"
                                      (hide 3)
                                      (("3"
                                        (skeep*)
                                        (("3"
                                          (typepred
                                           "sempp (P_exp, P_inp, A, e1, inp, s, s_T, res)`2")
                                          (("3"
                                            (assert)
                                            (("3"
                                              (lemma
                                               "Skip_is_badly_formed")
                                              (("3"
                                                (inst
                                                 -
                                                 "s_inp (P_inp, parsing (P_exp, A, e1, inp, s, s_T))")
                                                (("3"
                                                  (assert)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("4"
                                      (hide 3)
                                      (("4"
                                        (skeep*)
                                        (("4"
                                          (assert)
                                          (("4"
                                            (lift-if)
                                            (("4"
                                              (assert)
                                              (("4"
                                                (typepred "status2")
                                                (("4"
                                                  (wf-ast
                                                   "parsing(P_exp, A, e2, inp, e(sempp(P_exp, P_inp, A, e1, inp, s, s_T, res)`2), s_T)")
                                                  (("4"
                                                    (typepred
                                                     "sempp(P_exp, P_inp, A, e1, inp, s, s_T, res)`2")
                                                    (("4"
                                                      (flassert)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("5"
                                      (hide 3)
                                      (("5"
                                        (skeep*)
                                        (("5"
                                          (assert)
                                          (("5"
                                            (expand "s_inp")
                                            (("5"
                                              (assert)
                                              (("5"
                                                (lift-if)
                                                (("5"
                                                  (assert)
                                                  (("5"
                                                    (typepred
                                                     "status2")
                                                    (("5"
                                                      (typepred
                                                       "sempp(P_exp, P_inp, A, e1, inp, s, s_T, res)`2")
                                                      (("5"
                                                        (typepred
                                                         "parsing(P_exp, A, e2, inp, e(sempp(P_exp, P_inp, A, e1, inp, s, s_T, res)`2), s_T)")
                                                        (("5"
                                                          (assert)
                                                          (("5"
                                                            (typepred
                                                             "T2")
                                                            (("5"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("6"
                                      (hide 3)
                                      (("6"
                                        (skeep*)
                                        (("6"
                                          (lift-if)
                                          (("6"
                                            (assert)
                                            (("6"
                                              (typepred "status2")
                                              (("6"
                                                (typepred
                                                 "sempp(P_exp, P_inp, A, e1, inp, s, s_T, res)`2")
                                                (("6"
                                                  (assert)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("7"
                                      (hide 3)
                                      (("7"
                                        (typepred
                                         "sempp[V_T, <=, V_N_b, bound, V_S](P_exp, P_inp, A, e1, inp, s, s_T, res)`2")
                                        (("7"
                                          (wf-ast
                                           "parsing[V_T, <=, V_N_b, bound, V_S](P_exp, A, e1, inp, s, s_T)")
                                          (("7"
                                            (typepred "s_T")
                                            (("7" (flassert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("8"
                                      (hide 3)
                                      (("8"
                                        (use
                                         "subterm_seq"
                                         (G "P_exp(A)"))
                                        (("8"
                                          (typepred "G")
                                          (("8" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (hide 2)
              (("2" (skeep*)
                (("2" (flassert)
                  (("2" (wf-ast T1) (("2" (assert) nil nil)) nil))
                  nil))
                nil))
              nil)
             ("3" (hide 2)
              (("3" (skeep*)
                (("3" (lift-if)
                  (("3" (assert)
                    (("3" (expand "s_inp")
                      (("3" (lift-if)
                        (("3" (assert)
                          (("3" (lift-if)
                            (("3" (assert)
                              (("3"
                                (typepred "status1")
                                (("3"
                                  (typepred "status2")
                                  (("3"
                                    (wf-ast
                                     "parsing(P_exp, A, e2, inp, e(T1), s_T)")
                                    (("3"
                                      (wf-ast
                                       "parsing(P_exp, A, e1, inp, s, s_T)")
                                      (("3"
                                        (typepred "T1")
                                        (("3" (flassert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("4" (hide 2)
              (("4" (skeep*)
                (("4" (typepred "T1")
                  (("4" (wf-ast T1) (("4" (assert) nil nil)) nil))
                  nil))
                nil))
              nil)
             ("5" (hide 2)
              (("5" (skeep*)
                (("5" (lift-if)
                  (("5" (assert)
                    (("5" (typepred "status1")
                      (("5" (typepred "status2")
                        (("5"
                          (wf-ast
                           "parsing(P_exp, A, e2, inp, e(T1), s_T)")
                          (("5"
                            (wf-ast
                             "parsing(P_exp, A, e1, inp, s, s_T)")
                            (("5" (typepred "T1")
                              (("5" (flassert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("6" (hide 2)
              (("6" (skeep*)
                (("6" (assert)
                  (("6" (expand "s_inp")
                    (("6" (lift-if)
                      (("6" (assert)
                        (("6" (lift-if)
                          (("6" (assert)
                            (("6" (typepred "status1")
                              (("6"
                                (wf-ast
                                 "parsing(P_exp, A, e1, inp, s, s_T)")
                                (("6"
                                  (typepred "status2")
                                  (("6"
                                    (wf-ast
                                     "parsing(P_exp, A, e2, inp, e(T1), s_T)")
                                    (("6"
                                      (typepred "T1")
                                      (("6"
                                        (typepred "T2")
                                        (("6" (flassert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("7" (hide 2)
              (("7" (skeep*)
                (("7" (typepred "status2")
                  (("7" (typepred "status1")
                    (("7" (wf-ast "parsing(P_exp, A, e1, inp, s, s_T)")
                      (("7"
                        (wf-ast
                         "parsing(P_exp, A, e2, inp, e(T1), s_T)")
                        (("7" (typepred "T1")
                          (("7" (flassert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("8" (hide 2)
              (("8" (skeep*)
                (("8" (wf-ast T1)
                  (("8" (typepred "s_T")
                    (("8" (typepred "T1")
                      (("8"
                        (typepred "parsing(P_exp, A, e1, inp, s, s_T)")
                        (("8" (flassert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("9" (skeep*)
              (("9" (use "subterm_seq" (G "P_exp(A)"))
                (("9" (typepred "G") (("9" (assert) nil nil)) nil))
                nil))
              nil)
             ("10" (hide 2)
              (("10" (skeep*)
                (("10" (lift-if)
                  (("10" (assert)
                    (("10" (typepred "T1")
                      (("10" (assert)
                        (("10" (expand "s_inp")
                          (("10" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("11" (hide 2)
              (("11" (skeep*)
                (("11" (lift-if) (("11" (assert) nil nil)) nil)) nil))
              nil)
             ("12" (hide 2)
              (("12" (typepred "s_T") (("12" (flassert) nil nil)) nil))
              nil)
             ("13" (hide 2)
              (("13" (use "subterm_seq" (G "P_exp(A)"))
                (("13" (typepred "G") (("13" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (lex4_lt formula-decl nil lex4 nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lex3_lt formula-decl nil lex3 nil)
    (lex2_lt formula-decl nil lex2 nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (subterm_seq formula-decl nil peg nil)
    (Skip_is_badly_formed formula-decl nil ast nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (skip adt-constructor-decl
          "[[below, below, peg[V_T, <=, V_N_b]] -> (skip?)]" pre_ast
          nil)
    (undefined? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (undefined adt-constructor-decl "(undefined?)" ast nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (astType type-decl nil ast nil) (pre_ast type-decl nil pre_ast nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (<= const-decl "bool" reals nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (saved_result type-decl nil semantic_parser nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (known? adt-recognizer-decl "[saved_result -> boolean]"
     semantic_parser nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (astType? def-decl "astType" ast nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (subterm_of type-eq-decl nil peg nil) (peg type-decl nil peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (input type-eq-decl nil ast_props nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil) (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (status adt-accessor-decl
            "[(known?) -> astType[V_T, <=, V_N_b, bound, V_S]]"
            semantic_parser nil)
    (T adt-accessor-decl
     "[(known?) -> pre_ast[V_T, <=, V_N_b, bound, V_S]]"
     semantic_parser nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail adt-constructor-decl "[[below, below] -> (fail?)]" pre_ast
     nil)
    (semantic? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (semantic adt-constructor-decl
     "[[below, below, V_N[V_N_b], V_S] -> (semantic?)]" pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (results type-eq-decl nil semantic_parser nil)
    (below type-eq-decl nil naturalnumbers nil)
    (subterm adt-def-decl "boolean" peg nil)
    (astTypeOf type-eq-decl nil semantic_parser nil)
    (sem_result type-eq-decl nil semantic_tlparser nil)
    (ordstruct type-decl nil ordstruct_adt nil)
    (< def-decl "bool" ordinals nil)
    (ordinal? def-decl "bool" ordinals nil)
    (ordinal nonempty-type-eq-decl nil ordinals nil)
    (lex4 const-decl "ordinal" lex4 nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (pegMeasure const-decl "nat" peg nil)
    (equalTo type-eq-decl nil semantic_parser nil)
    (sempp def-decl "[astTypeOf(parsing(P_exp, A, G, inp, s, s_T)),
 equalTo(s_inp(P_inp, parsing(P_exp, A, G, inp, s, s_T))),
 results(P_exp, P_inp, inp)]" semantic_parser nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (¬ const-decl "[bool -> bool]" booleans nil)
    (seq? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (seq adt-constructor-decl
     "[[below, below, {T: pre_ast | ¬skip?(T)}, pre_ast] -> (seq?)]"
     pre_ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, semantic_tlparser.e1, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T, semantic_tlparser.res, (LAMBDA (status1: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e1, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))), (T1: semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e1, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)), (res: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): IF (status1 = ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure) THEN semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T1)), res) ELSE semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, semantic_tlparser.e2, semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T1), semantic_tlparser.s_T, res, LAMBDA (status2: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e2, semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T1), semantic_tlparser.s_T))), (T2: semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e2, semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T1), semantic_tlparser.s_T)), (res: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): IF (status2 = ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure) THEN semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T2)), res) ELSE semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].seq(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T2), T1, T2), res) ENDIF) ENDIF))"
    "{x: [ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astType, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast, semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)] | x = semantic_tlparser.cont(semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].sempp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T, semantic_tlparser.res))}")))
 (semtlpp_TCC60 0
  (semtlpp_TCC33-1 nil 3804395188
   ("" (skeep*)
    (("" (lemma "peg[V_T, <=, V_N_b].subterm_transitivity")
      (("" (inst-cp -1 "e1" "G" "P_exp(A)")
        (("" (inst -1 "e2" "G" "P_exp(A)")
          (("" (replace -3 * LR)
            (("" (assert)
              (("" (expand "subterm" 1)
                (("" (expand "subterm" 1) (("" (propax) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (subterm_transitivity formula-decl nil peg nil)
    (sub_prior formula-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.e1"
    "{e: wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].Δ | peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].subterm(e, semantic_tlparser.P_exp(semantic_tlparser.A))}")))
 (semtlpp_TCC61 0
  (semtlpp_TCC34-1 nil 3804395188
   ("" (skeep*)
    (("" (typepred "s_T")
      (("" (assert)
        (("" (expand "g_wf" -)
          (("" (replace -3 * LR)
            (("" (flatten) (("" (assert) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.s_T"
    "{k: naturalnumbers.upto(semantic_tlparser.s) | booleans.⇒((k = semantic_tlparser.s), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].pattern_wf?(semantic_tlparser.e1, semantic_tlparser.A, static_analysis[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].σ(semantic_tlparser.P_exp), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].P_0c(semantic_tlparser.P_exp)))}")))
 (semtlpp_TCC62 0
  (semtlpp_TCC61-1 nil 3847091012
   ("" (skeep*)
    (("" (replaces)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "astType?") (("" (propax) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success"
    "semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC63 0
  (semtlpp_TCC35-1 nil 3804395188
   ("" (skeep*)
    (("" (typepred "T1")
      (("" (case "astWellformed?(T1)")
        (("1" (assert)
          (("1" (expand "astWellformed?" -) (("1" (propax) nil nil))
            nil))
          nil)
         ("2" (assert) nil nil))
        nil))
      nil))
    nil)
   ((sem_result type-eq-decl nil semantic_tlparser nil)
    (subterm adt-def-decl "boolean" peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (ast type-eq-decl nil ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (subterm_of type-eq-decl nil peg nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.T1"
    "{T: pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast | (booleans.¬)(pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].skip?(T))}")))
 (semtlpp_TCC64 0
  (semtlpp_TCC63-1 nil 3847091012
   ("" (skeep*)
    (("" (replaces)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "s_inp")
            (("" (expand "astType?")
              (("" (assert)
                (("" (typepred "T1")
                  (("" (decompose-equality 1)
                    (("" (expand "s_inp")
                      (("" (expand "astType?") (("" (propax) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (sem_result type-eq-decl nil semantic_tlparser nil)
    (subterm adt-def-decl "boolean" peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (ast type-eq-decl nil ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (subterm_of type-eq-decl nil peg nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (prior? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (pre_ast_prior_extensionality formula-decl nil pre_ast nil)
    (skip adt-constructor-decl
          "[[below, below, peg[V_T, <=, V_N_b]] -> (skip?)]" pre_ast
          nil)
    (prior adt-constructor-decl
     "[[below, below, {T: pre_ast | ¬skip?(T)}, pre_ast] -> (prior?)]"
     pre_ast nil)
    (¬ const-decl "[bool -> bool]" booleans nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].prior(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T1), semantic_tlparser.T1, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].skip(semantic_tlparser.s, semantic_tlparser.s, semantic_tlparser.e2))"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC65 0
  (semtlpp_TCC37-1 nil 3804395188
   ("" (skeep*)
    (("" (lemma "peg[V_T, <=, V_N_b].subterm_transitivity")
      (("" (inst-cp -1 "e1" "G" "P_exp(A)")
        (("" (inst -1 "e2" "G" "P_exp(A)")
          (("" (replace -3 * LR)
            (("" (assert)
              (("" (expand "subterm" 1)
                (("" (expand "subterm" 1) (("" (propax) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (subterm_transitivity formula-decl nil peg nil)
    (sub_prior formula-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.e2"
    "{e: wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].Δ | peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].subterm(e, semantic_tlparser.P_exp(semantic_tlparser.A))}")))
 (semtlpp_TCC66 0
  (semtlpp_TCC38-1 nil 3804395188
   ("" (skeep*)
    (("" (typepred "s_T")
      (("" (assert)
        (("" (expand "g_wf" -)
          (("" (replace -3 * LR)
            (("" (flatten) (("" (assert) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.s_T"
    "{k: naturalnumbers.upto(semantic_tlparser.s) | booleans.⇒((k = semantic_tlparser.s), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].pattern_wf?(semantic_tlparser.e2, semantic_tlparser.A, static_analysis[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].σ(semantic_tlparser.P_exp), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].P_0c(semantic_tlparser.P_exp)))}")))
 (semtlpp_TCC67 0
  (semtlpp_TCC66-1 nil 3847091012
   ("" (skeep*)
    (("" (replaces)
      (("" (expand "parsing")
        (("" (assert)
          (("" (lift-if)
            (("" (assert)
              (("" (typepred "status1")
                (("" (wf-ast "parsing(P_exp, A, e1, inp, s, s_T)")
                  (("" (assert)
                    (("" (flatten) (("" (assert) nil nil)) nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (astType type-decl nil ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (subterm_of type-eq-decl nil peg nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (<= const-decl "bool" reals nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (below type-eq-decl nil naturalnumbers nil)
    (subterm adt-def-decl "boolean" peg nil)
    (astTypeOf type-eq-decl nil semantic_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success"
    "semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC68 0
  (semtlpp_TCC39-1 nil 3804395188
   ("" (skeep*)
    (("" (typepred "T1")
      (("" (case "astWellformed?(T1)")
        (("1" (assert)
          (("1" (expand "astWellformed?" -) (("1" (propax) nil nil))
            nil))
          nil)
         ("2" (assert) nil nil))
        nil))
      nil))
    nil)
   ((sem_result type-eq-decl nil semantic_tlparser nil)
    (subterm adt-def-decl "boolean" peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (ast type-eq-decl nil ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (subterm_of type-eq-decl nil peg nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.T1"
    "{T: pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast | (booleans.¬)(pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].skip?(T))}")))
 (semtlpp_TCC69 0
  (semtlpp_TCC68-1 nil 3847091012
   ("" (skeep*)
    (("" (replaces)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "s_inp")
            (("" (expand "astType?")
              (("" (typepred "status1")
                (("" (lift-if)
                  (("" (assert)
                    (("" (typepred "T1")
                      (("" (use "semantic_interp_props")
                        (("" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (sem_result type-eq-decl nil semantic_tlparser nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semantic_interp_props formula-decl nil semantic_interp nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (astType type-decl nil ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (subterm_of type-eq-decl nil peg nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (<= const-decl "bool" reals nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (below type-eq-decl nil naturalnumbers nil)
    (subterm adt-def-decl "boolean" peg nil)
    (astTypeOf type-eq-decl nil semantic_parser nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].prior(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T2), semantic_tlparser.T1, semantic_tlparser.T2)"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC70 0
  (semtlpp_TCC69-1 nil 3847091012
   ("" (skeep*)
    (("" (replaces)
      (("" (expand "parsing")
        (("" (assert)
          (("" (typepred "status1")
            (("" (lift-if)
              (("" (assert)
                (("" (use "Wellformed_theorem")
                  (("" (assert)
                    (("" (flatten)
                      (("" (assert)
                        (("" (ground)
                          ((""
                            (use "Wellformed_theorem"
                                 (T
                                  "parsing(P_exp, A, e2, inp, s, s_T)"))
                            (("" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (astType type-decl nil ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (subterm_of type-eq-decl nil peg nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (<= const-decl "bool" reals nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (below type-eq-decl nil naturalnumbers nil)
    (subterm adt-def-decl "boolean" peg nil)
    (astTypeOf type-eq-decl nil semantic_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure"
    "semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC71 0
  (semtlpp_TCC70-1 nil 3847091012
   ("" (skeep*)
    (("" (replaces)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "s_inp")
            (("" (expand "astType?")
              (("" (typepred "status1")
                (("" (lift-if)
                  (("" (lift-if)
                    (("" (assert)
                      (("" (ground)
                        (("1" (typepred "T2") (("1" (assert) nil nil))
                          nil)
                         ("2" (use "Wellformed_theorem")
                          (("2" (assert) nil nil)) nil)
                         ("3" (use "Wellformed_theorem")
                          (("3" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (sem_result type-eq-decl nil semantic_tlparser nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (astType type-decl nil ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (subterm_of type-eq-decl nil peg nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (<= const-decl "bool" reals nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (below type-eq-decl nil naturalnumbers nil)
    (subterm adt-def-decl "boolean" peg nil)
    (astTypeOf type-eq-decl nil semantic_parser nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T2))"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC72 0
  (semtlpp_TCC42-1 nil 3804395188
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (rewrite "lex4_lt")
        (("" (rewrite "lex3_lt")
          (("" (rewrite "lex2_lt")
            (("" (typepred "T1")
              (("" (lemma "Wellformed_theorem" (T T1))
                (("" (assert)
                  (("" (flatten)
                    (("" (assert) (("" (grind) nil nil)) nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((sem_result type-eq-decl nil semantic_tlparser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (ast type-eq-decl nil ast nil)
    (subterm_of? const-decl "bool" peg nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (subterm_of type-eq-decl nil peg nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (lex3_lt formula-decl nil lex3 nil)
    (lex2_lt formula-decl nil lex2 nil)
    (pegMeasure_prior formula-decl nil peg nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (prior adt-constructor-decl "[[peg, peg] -> (prior?)]" peg nil)
    (prior? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (pegMeasure const-decl "nat" peg nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (lex4_lt formula-decl nil lex4 nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp termination
    "semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, semantic_tlparser.e2, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T, semantic_tlparser.res, (LAMBDA (status2: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e2, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))), (T2: semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e2, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)), (res: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): IF (status2 = ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success) THEN semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].prior(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T2), semantic_tlparser.T1, T2), res) ELSE semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T2)), res) ENDIF))"
    "nil")))
 (semtlpp_TCC73 0
  (semtlpp_TCC44-1 nil 3804395188
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (rewrite "lex4_lt")
        (("" (rewrite "lex3_lt")
          (("" (rewrite "lex2_lt")
            (("" (assert) (("" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((lex3_lt formula-decl nil lex3 nil)
    (lex2_lt formula-decl nil lex2 nil)
    (pegMeasure_prior formula-decl nil peg nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (prior adt-constructor-decl "[[peg, peg] -> (prior?)]" peg nil)
    (prior? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (pegMeasure const-decl "nat" peg nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (lex4_lt formula-decl nil lex4 nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp termination
    "semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, semantic_tlparser.e1, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T, semantic_tlparser.res, (LAMBDA (status1: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e1, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))), (T1: semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e1, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)), (res: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): IF (status1 = ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success) THEN semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].prior(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T1), T1, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].skip(semantic_tlparser.s, semantic_tlparser.s, semantic_tlparser.e2)), res) ELSE semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, semantic_tlparser.e2, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T, res, LAMBDA (status2: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e2, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))), (T2: semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e2, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)), (res: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): IF (status2 = ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success) THEN semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].prior(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T2), T1, T2), res) ELSE semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T2)), res) ENDIF) ENDIF))"
    "nil")))
 (semtlpp_TCC74 0
  (semtlpp_TCC74-1 "Cleaner one" 3848398428
   ("" (skeep*)
    (("" (auto-rewrite -1)
      (("" (auto-rewrite "parsing")
        (("" (auto-rewrite "sempp")
          (("" (assert)
            ((""
              (typepred "v(P_exp, P_inp, A, e1, inp, s, s_T, res,
          LAMBDA (status1: astTypeOf(parsing(P_exp, A, e1, inp, s, s_T))),
                 (T1: sem_result(P_inp, P_exp, A, e1, inp, s, s_T)), (res: results(P_exp, P_inp, inp)):
            IF (status1 = success)
              THEN cont(success,
                        prior(s, e(T1), T1, skip(s, s, e2)),
                        res)
            ELSE v(P_exp, P_inp, A, e2, inp, s, s_T, res,
                   LAMBDA (status2: astTypeOf(parsing(P_exp, A, e2, inp, s, s_T))),
                          (T2: sem_result(P_inp, P_exp, A, e2, inp, s, s_T)), (res: results(P_exp, P_inp, inp)):
                     IF (status2 = success)
                       THEN cont(success,
                                 prior(s, e(T2), T1, T2), res)
                     ELSE cont(failure, fail(s, e(T2)), res)
                     ENDIF)
            ENDIF)")
              (("1" (replace -1 * LR)
                (("1" (hide -1)
                  (("1"
                    (name-rewrite "SemRes"
                     "sempp(P_exp, P_inp, A, e1, inp, s, s_T, res)")
                    (("1" (typepred "SemRes`2")
                      (("1" (typepred "SemRes`1")
                        (("1" (assert)
                          (("1" (lift-if)
                            (("1" (ground)
                              (("1"
                                (typepred
                                 "v(P_exp, P_inp, A, e2, inp, s, s_T, SemRes`3,
              LAMBDA (status2: astTypeOf(parsing(P_exp, A, e2, inp, s, s_T))),
                     (T2: sem_result(P_inp, P_exp, A, e2, inp, s, s_T)), (res_1: results(P_exp, P_inp, inp)):
                IF (status2 = success) THEN cont(success, prior(s, e(T2), SemRes`2, T2), res_1) ELSE cont(failure, fail(s, e(T2)), res_1) ENDIF)")
                                (("1" (propax) nil nil)
                                 ("2"
                                  (hide 3)
                                  (("2"
                                    (skeep*)
                                    (("2"
                                      (expand "s_inp" +)
                                      (("2"
                                        (liftassert+)
                                        (("2"
                                          (typepred "status2")
                                          (("2"
                                            (wf-ast
                                             "parsing(P_exp, A, e2, inp, s, s_T)")
                                            (("2"
                                              (assert)
                                              (("2"
                                                (flatten)
                                                (("2"
                                                  (assert)
                                                  (("2"
                                                    (typepred "T2")
                                                    (("2"
                                                      (flassert)
                                                      (("2"
                                                        (wf-ast
                                                         "parsing[V_T, <=, V_N_b, bound, V_S](P_exp, A, e1, inp, s, s_T)")
                                                        (("2"
                                                          (assert)
                                                          (("2"
                                                            (flatten)
                                                            (("2"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("3"
                                  (hide 3)
                                  (("3"
                                    (skeep*)
                                    (("3"
                                      (liftassert+)
                                      (("3"
                                        (typepred "status2")
                                        (("3"
                                          (wf-ast
                                           "parsing[V_T, <=, V_N_b, bound, V_S](P_exp, A, e1, inp, s, s_T)")
                                          (("3"
                                            (wf-ast
                                             "parsing(P_exp, A, e2, inp, s, s_T)")
                                            (("3"
                                              (typepred "T2")
                                              (("3"
                                                (flassert)
                                                nil
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("4"
                                  (hide 3)
                                  (("4"
                                    (skeep*)
                                    (("4"
                                      (expand "s_inp" +)
                                      (("4" (liftassert+) nil nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("5"
                                  (hide 3)
                                  (("5"
                                    (skeep*)
                                    (("5"
                                      (wf-ast "SemRes`2")
                                      (("5" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("6"
                                  (hide 3)
                                  (("6"
                                    (skeep*)
                                    (("6"
                                      (liftassert+)
                                      (("6"
                                        (wf-ast
                                         "parsing[V_T, <=, V_N_b, bound, V_S](P_exp, A, e1, inp, s, s_T)")
                                        (("6" (flassert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("7"
                                  (hide 3)
                                  (("7"
                                    (typepred "s_T")
                                    (("7" (flassert) nil nil))
                                    nil))
                                  nil)
                                 ("8"
                                  (hide 3)
                                  (("8"
                                    (use
                                     "subterm_prior"
                                     (G
                                      "P_exp(A)"
                                      "e1"
                                      "e1"
                                      "e2"
                                      "e2"))
                                    (("8"
                                      (typepred "G")
                                      (("8" (flassert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (hide 2)
                      (("2"
                        (use "subterm_prior"
                             (G "P_exp(A)" "e1" "e1" "e2" "e2"))
                        (("2" (typepred "G") (("2" (flassert) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (hide 2)
                (("2" (skeep*) (("2" (flassert) nil nil)) nil)) nil)
               ("3" (hide 2)
                (("3" (skeep*)
                  (("3" (liftassert+)
                    (("3" (expand "s_inp" +)
                      (("3" (liftassert+)
                        (("3" (typepred "status1")
                          (("3" (typepred "status2")
                            (("3"
                              (wf-ast
                               "parsing(P_exp, A, e1, inp, s, s_T)")
                              (("3"
                                (flassert)
                                (("3"
                                  (wf-ast
                                   "parsing(P_exp, A, e2, inp, s, s_T)")
                                  (("3"
                                    (flassert)
                                    (("3"
                                      (typepred "T2")
                                      (("3" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("4" (hide 2)
                (("4" (skeep*)
                  (("4" (liftassert+)
                    (("4" (typepred "status1")
                      (("4" (typepred "status2")
                        (("4"
                          (wf-ast "parsing(P_exp, A, e1, inp, s, s_T)")
                          (("4"
                            (wf-ast
                             "parsing(P_exp, A, e2, inp, s, s_T)")
                            (("4" (typepred "T2")
                              (("4" (flassert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("5" (hide 2)
                (("5" (skeep*)
                  (("5" (liftassert+)
                    (("5" (expand "s_inp" +)
                      (("5" (liftassert+) nil nil)) nil))
                    nil))
                  nil))
                nil)
               ("6" (hide 2)
                (("6" (skeep*)
                  (("6" (wf-ast T1) (("6" (assert) nil nil)) nil))
                  nil))
                nil)
               ("7" (hide 2)
                (("7" (skeep*)
                  (("7" (liftassert+)
                    (("7" (typepred "status1")
                      (("7"
                        (wf-ast "parsing(P_exp, A, e1, inp, s, s_T)")
                        (("7" (flassert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("8" (hide 2)
                (("8" (skeep*)
                  (("8" (typepred "s_T") (("8" (flassert) nil nil))
                    nil))
                  nil))
                nil)
               ("9" (hide 2)
                (("9" (skeep*)
                  (("9"
                    (use "subterm_prior"
                         (G "P_exp(A)" "e1" "e1" "e2" "e2"))
                    (("9" (typepred "G") (("9" (flassert) nil nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("10" (hide 2)
                (("10" (skeep*)
                  (("10" (assert)
                    (("10" (expand "s_inp" +)
                      (("10" (liftassert+)
                        (("10"
                          (wf-ast "parsing(P_exp, A, e1, inp, s, s_T)")
                          (("10" (flassert)
                            (("10" (typepred "T1")
                              (("10"
                                (expand "s_inp" 1 2)
                                (("10" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("11" (hide 2)
                (("11" (skeep*)
                  (("11" (wf-ast T1) (("11" (flassert) nil nil)) nil))
                  nil))
                nil)
               ("12" (hide 2)
                (("12" (skeep*) (("12" (liftassert+) nil nil)) nil))
                nil)
               ("13" (hide 2)
                (("13" (typepred "s_T") (("13" (flassert) nil nil))
                  nil))
                nil)
               ("14" (hide 2)
                (("14"
                  (use "subterm_prior"
                       (G "P_exp(A)" "e1" "e1" "e2" "e2"))
                  (("14" (typepred "G") (("14" (flassert) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((skip adt-constructor-decl
          "[[below, below, peg[V_T, <=, V_N_b]] -> (skip?)]" pre_ast
          nil)
    (prior adt-constructor-decl
     "[[below, below, {T: pre_ast | ¬skip?(T)}, pre_ast] -> (prior?)]"
     pre_ast nil)
    (prior? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (¬ const-decl "[bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (equalTo type-eq-decl nil semantic_parser nil)
    (pegMeasure const-decl "nat" peg nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (lex4 const-decl "ordinal" lex4 nil)
    (ordinal nonempty-type-eq-decl nil ordinals nil)
    (ordinal? def-decl "bool" ordinals nil)
    (< def-decl "bool" ordinals nil)
    (ordstruct type-decl nil ordstruct_adt nil)
    (sem_result type-eq-decl nil semantic_tlparser nil)
    (astTypeOf type-eq-decl nil semantic_parser nil)
    (subterm adt-def-decl "boolean" peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (results type-eq-decl nil semantic_parser nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semantic adt-constructor-decl
     "[[below, below, V_N[V_N_b], V_S] -> (semantic?)]" pre_ast nil)
    (semantic? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail adt-constructor-decl "[[below, below] -> (fail?)]" pre_ast
     nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (T adt-accessor-decl
     "[(known?) -> pre_ast[V_T, <=, V_N_b, bound, V_S]]"
     semantic_parser nil)
    (status adt-accessor-decl
            "[(known?) -> astType[V_T, <=, V_N_b, bound, V_S]]"
            semantic_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil) (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (input type-eq-decl nil ast_props nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (subterm_of type-eq-decl nil peg nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (astType? def-decl "astType" ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (known? adt-recognizer-decl "[saved_result -> boolean]"
     semantic_parser nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (saved_result type-decl nil semantic_parser nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (<= const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (pre_ast type-decl nil pre_ast nil)
    (astType type-decl nil ast nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (undefined adt-constructor-decl "(undefined?)" ast nil)
    (undefined? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (lex3 const-decl "ordinal" lex3 nil)
    (subterm_prior formula-decl nil peg nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lex3_lt formula-decl nil lex3 nil)
    (lex2_lt formula-decl nil lex2 nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (sempp def-decl "[astTypeOf(parsing(P_exp, A, G, inp, s, s_T)),
 equalTo(s_inp(P_inp, parsing(P_exp, A, G, inp, s, s_T))),
 results(P_exp, P_inp, inp)]" semantic_parser nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak
   (semtlpp subtype
    "semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, semantic_tlparser.e1, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T, semantic_tlparser.res, (LAMBDA (status1: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e1, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))), (T1: semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e1, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)), (res: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): IF (status1 = ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success) THEN semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].prior(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T1), T1, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].skip(semantic_tlparser.s, semantic_tlparser.s, semantic_tlparser.e2)), res) ELSE semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, semantic_tlparser.e2, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T, res, LAMBDA (status2: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e2, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))), (T2: semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e2, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)), (res: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): IF (status2 = ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success) THEN semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].prior(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T2), T1, T2), res) ELSE semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T2)), res) ENDIF) ENDIF))"
    "{x: [ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astType, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast, semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)] | x = semantic_tlparser.cont(semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].sempp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T, semantic_tlparser.res))}"))
  (semtlpp_TCC73-1 nil 3805033343
   ("" (skeep*)
    (("" (replace -1 * LR)
      ((""
        (typepred "v(P_exp, P_inp, A, e1, inp, s, s_T, res,
        LAMBDA (status1:
                  astTypeOf
                      [V_T, <=, V_N_b, bound,
                       V_S](parsing[V_T, <=, V_N_b, bound, V_S]
                                (P_exp, A, e1, inp, s, s_T))),
               (T1: sem_result(P_inp, P_exp, A, e1, inp, s, s_T)),
               (res:
                  results[V_T, <=, V_N_b, bound, V_S](P_exp, P_inp, inp)):
          IF (status1 = success[V_T, <=, V_N_b, bound, V_S])
            THEN cont(success[V_T, <=, V_N_b, bound, V_S],
                      prior[V_T, <=, V_N_b, bound, V_S]
                          (s, e[V_T, <=, V_N_b, bound, V_S](T1), T1,
                           skip[V_T, <=, V_N_b, bound, V_S](s, s, e2)),
                      res)
          ELSE v(P_exp, P_inp, A, e2, inp, s, s_T, res,
                 LAMBDA (status2:
                           astTypeOf
                               [V_T, <=, V_N_b, bound,
                                V_S](parsing[V_T, <=, V_N_b, bound, V_S]
                                     (P_exp, A, e2, inp, s, s_T))),
                        (T2: sem_result(P_inp, P_exp, A, e2, inp, s, s_T)),
                        (res:
                           results[V_T, <=, V_N_b, bound, V_S](P_exp,
                                                               P_inp,
                                                               inp)):
                   IF (status2 = success[V_T, <=, V_N_b, bound, V_S])
                     THEN cont(success[V_T, <=, V_N_b, bound, V_S],
                               prior[V_T, <=, V_N_b, bound, V_S]
                                   (s,
                                    e[V_T, <=, V_N_b, bound, V_S](T2),
                                    T1,
                                    T2),
                               res)
                   ELSE cont(failure[V_T, <=, V_N_b, bound, V_S],
                             fail[V_T, <=, V_N_b, bound, V_S]
                                 (s, e[V_T, <=, V_N_b, bound, V_S](T2)),
                             res)
                   ENDIF)
          ENDIF)")
        (("1" (replace -1 * LR)
          (("1" (hide -1)
            (("1"
              (typepred
               "sempp(P_exp, P_inp, A, e1, inp, s, s_T, res)`1")
              (("1"
                (name "SemRes"
                      "sempp(P_exp, P_inp, A, e1, inp, s, s_T, res)")
                (("1" (replace -1 * LR)
                  (("1" (typepred "SemRes`2")
                    (("1" (lift-if 1)
                      (("1" (assert)
                        (("1" (split 1)
                          (("1" (flatten)
                            (("1" (assert)
                              (("1"
                                (expand "sempp" 1)
                                (("1" (assert) nil nil))
                                nil))
                              nil))
                            nil)
                           ("2" (flatten)
                            (("2"
                              (typepred
                               " v(P_exp, P_inp, A, e2, inp, s, s_T, SemRes`3,
        LAMBDA (status2:
                  astTypeOf
                      [V_T, <=, V_N_b, bound,
                       V_S](parsing[V_T, <=, V_N_b, bound, V_S]
                                (P_exp, A, e2, inp, s, s_T))),
               (T2: sem_result(P_inp, P_exp, A, e2, inp, s, s_T)),
               (res_1:
                  results[V_T, <=, V_N_b, bound, V_S](P_exp, P_inp, inp)):
          IF (status2 = success[V_T, <=, V_N_b, bound, V_S])
            THEN cont(success[V_T, <=, V_N_b, bound, V_S],
                      prior[V_T, <=, V_N_b, bound, V_S]
                          (s, e[V_T, <=, V_N_b, bound, V_S](T2), SemRes`2,
                           T2),
                      res_1)
          ELSE cont(failure[V_T, <=, V_N_b, bound, V_S],
                    fail[V_T, <=, V_N_b, bound, V_S]
                        (s, e[V_T, <=, V_N_b, bound, V_S](T2)),
                    res_1)
          ENDIF)")
                              (("1"
                                (replaces)
                                (("1"
                                  (reveal -1 -2)
                                  (("1"
                                    (lift-if 2)
                                    (("1"
                                      (split 2)
                                      (("1"
                                        (flatten)
                                        (("1"
                                          (expand "sempp" 1 4)
                                          (("1" (assert) nil nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (flatten)
                                        (("2"
                                          (expand "sempp" 2 3)
                                          (("2" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (hide 3)
                                (("2"
                                  (skeep*)
                                  (("2"
                                    (replaces)
                                    (("2"
                                      (expand "parsing" 2)
                                      (("2"
                                        (assert)
                                        (("2"
                                          (expand "s_inp" 2)
                                          (("2"
                                            (expand "astType?" 2)
                                            (("2"
                                              (lift-if)
                                              (("2"
                                                (assert)
                                                (("2"
                                                  (split 2)
                                                  (("1"
                                                    (flatten)
                                                    (("1"
                                                      (assert)
                                                      (("1"
                                                        (typepred "T2")
                                                        (("1"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (typepred
                                                     "status2")
                                                    (("2"
                                                      (lemma
                                                       "Wellformed_theorem"
                                                       (T
                                                        "parsing[V_T, <=, V_N_b, bound, V_S](P_exp, A, e1, inp, s, s_T)"))
                                                      (("2"
                                                        (assert)
                                                        (("2"
                                                          (flatten)
                                                          (("2"
                                                            (assert)
                                                            (("2"
                                                              (assert)
                                                              (("2"
                                                                (lemma
                                                                 "Wellformed_theorem"
                                                                 (T
                                                                  "parsing[V_T, <=, V_N_b, bound, V_S](P_exp, A, e2, inp, s, s_T)"))
                                                                (("2"
                                                                  (assert)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("3"
                                (hide 3)
                                (("3"
                                  (skeep*)
                                  (("3"
                                    (replaces)
                                    (("3"
                                      (expand "parsing" 2)
                                      (("3"
                                        (assert)
                                        (("3"
                                          (expand "astType?" 2)
                                          (("3"
                                            (lift-if)
                                            (("3"
                                              (assert)
                                              (("3"
                                                (split)
                                                (("1" (propax) nil nil)
                                                 ("2"
                                                  (lemma
                                                   "Wellformed_theorem"
                                                   (T
                                                    "parsing[V_T, <=, V_N_b, bound, V_S](P_exp, A, e1, inp, s, s_T)"))
                                                  (("2"
                                                    (lemma
                                                     "Wellformed_theorem"
                                                     (T
                                                      "parsing[V_T, <=, V_N_b, bound, V_S](P_exp, A, e1, inp, s, s_T)"))
                                                    (("2"
                                                      (assert)
                                                      (("2"
                                                        (flatten)
                                                        (("2"
                                                          (assert)
                                                          (("2"
                                                            (typepred
                                                             "T2")
                                                            (("2"
                                                              (lemma
                                                               "Wellformed_theorem"
                                                               (T
                                                                "parsing[V_T, <=, V_N_b, bound, V_S](P_exp, A, e2, inp, s, s_T)"))
                                                              (("2"
                                                                (assert)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("4"
                                (hide 3)
                                (("4"
                                  (skeep*)
                                  (("4"
                                    (replaces)
                                    (("4"
                                      (expand "parsing" 1 2)
                                      (("4"
                                        (assert)
                                        (("4"
                                          (expand "s_inp" + 2)
                                          (("4"
                                            (lift-if)
                                            (("4"
                                              (assert)
                                              (("4"
                                                (expand "astType?" 1 1)
                                                (("4"
                                                  (lift-if)
                                                  (("4"
                                                    (assert)
                                                    (("4"
                                                      (typepred "T2")
                                                      (("4"
                                                        (assert)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("5"
                                (hide 3)
                                (("5"
                                  (skeep*)
                                  (("5"
                                    (replaces)
                                    (("5"
                                      (lemma
                                       "Skip_is_badly_formed"
                                       (T
                                        "(s_inp[V_T, <=, V_N_b, bound, V_S]
               (P_inp,
                parsing[V_T, <=, V_N_b, bound, V_S]
                    (P_exp, A, e1, inp, s, s_T)))"))
                                      (("5" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("6"
                                (hide 3)
                                (("6"
                                  (skeep*)
                                  (("6"
                                    (replaces)
                                    (("6"
                                      (expand "parsing" 1)
                                      (("6"
                                        (assert)
                                        (("6"
                                          (expand "astType?" 1)
                                          (("6"
                                            (lift-if)
                                            (("6"
                                              (assert)
                                              (("6"
                                                (split)
                                                (("1" (propax) nil nil)
                                                 ("2"
                                                  (lemma
                                                   "Wellformed_theorem"
                                                   (T
                                                    "parsing(P_exp, A, e1, inp, s, s_T)"))
                                                  (("2"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("7"
                                (hide 3)
                                (("7"
                                  (replaces)
                                  (("7"
                                    (typepred "s_T")
                                    (("7"
                                      (flatten)
                                      (("7"
                                        (assert)
                                        (("7"
                                          (replaces)
                                          (("7"
                                            (expand "g_wf" -)
                                            (("7" (propax) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("8"
                                (hide 3)
                                (("8"
                                  (replaces)
                                  (("8"
                                    (lemma
                                     "peg[V_T, <=, V_N_b].subterm_transitivity")
                                    (("8"
                                      (inst
                                       -
                                       "e2"
                                       "prior(e1,e2)"
                                       "P_exp(A)")
                                      (("8"
                                        (assert)
                                        (("8"
                                          (expand "subterm" 1)
                                          (("8"
                                            (expand "subterm" 1)
                                            (("8" (propax) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (hide 2)
          (("2" (skeep*)
            (("2" (rewrites ("lex4_lt" "lex3_lt"))
              (("2" (rewrites ("lex4_lt" "lex3_lt" "lex2_lt"))
                (("2" (replace -1 * LR) (("2" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil)
         ("3" (hide 2)
          (("3" (skeep*)
            (("3" (replace -1 * LR)
              (("3" (expand "parsing")
                (("3" (assert)
                  (("3" (expand "s_inp")
                    (("3" (expand "astType?")
                      (("3" (lift-if)
                        (("3" (assert)
                          (("3" (split)
                            (("1" (flatten)
                              (("1"
                                (typepred "T2")
                                (("1" (assert) nil nil))
                                nil))
                              nil)
                             ("2" (typepred "status1")
                              (("2"
                                (lemma
                                 "Wellformed_theorem"
                                 (T
                                  "parsing[V_T, <=, V_N_b, bound, V_S](P_exp, A, e1, inp, s, s_T)"))
                                (("2"
                                  (assert)
                                  (("2"
                                    (flatten)
                                    (("2"
                                      (assert)
                                      (("2"
                                        (lemma
                                         "Wellformed_theorem"
                                         (T
                                          "parsing[V_T, <=, V_N_b, bound, V_S](P_exp, A, e2, inp, s, s_T)"))
                                        (("2" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("4" (hide 2)
          (("4" (skeep*)
            (("4" (replace -1 * LR)
              (("4" (expand "parsing")
                (("4" (assert)
                  (("4" (expand "astType?")
                    (("4"
                      (lemma "Wellformed_theorem"
                       (T
                        "parsing[V_T, <=, V_N_b, bound, V_S](P_exp, A, e1, inp, s, s_T)"))
                      (("1"
                        (lemma "Wellformed_theorem"
                         (T
                          "parsing[V_T, <=, V_N_b, bound, V_S](P_exp, A, e2, inp, s, s_T)"))
                        (("1" (assert)
                          (("1" (flatten) (("1" (assert) nil nil))
                            nil))
                          nil)
                         ("2" (typepred "s_T")
                          (("2" (assert)
                            (("2" (flatten)
                              (("2"
                                (assert)
                                (("2"
                                  (replace -6 * LR)
                                  (("2"
                                    (expand "g_wf" -)
                                    (("2" (propax) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("3"
                          (lemma
                           "peg[V_T, <=, V_N_b].subterm_transitivity")
                          (("3"
                            (lemma
                             "peg[V_T, <=, V_N_b].subterm_transitivity")
                            (("3"
                              (inst - "e2" "prior(e1,e2)" "P_exp(A)")
                              (("3"
                                (assert)
                                (("3"
                                  (expand "subterm" 1)
                                  (("3"
                                    (expand "subterm" 1)
                                    (("3" (propax) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (typepred "s_T")
                        (("2" (assert)
                          (("2" (flatten)
                            (("2" (assert)
                              (("2"
                                (replace -4 * LR)
                                (("2"
                                  (expand "g_wf" -)
                                  (("2" (propax) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("3"
                        (lemma
                         "peg[V_T, <=, V_N_b].subterm_transitivity")
                        (("3" (inst - "e1" "prior(e1,e2)" "P_exp(A)")
                          (("3" (assert)
                            (("3" (expand "subterm" 1)
                              (("3"
                                (expand "subterm" 1)
                                (("3" (propax) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("5" (hide 2)
          (("5" (skeep*)
            (("5" (replaces)
              (("5" (expand "parsing")
                (("5" (assert)
                  (("5" (expand "s_inp")
                    (("5" (expand "astType?")
                      (("5" (lift-if)
                        (("5" (assert)
                          (("5" (typepred "T2")
                            (("5" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("6" (hide 2)
          (("6" (skeep*)
            (("6" (typepred "T1")
              (("6" (lemma "Skip_is_badly_formed" (T T1))
                (("6" (assert) nil nil)) nil))
              nil))
            nil))
          nil)
         ("7" (hide 2)
          (("7" (skeep*)
            (("7" (replaces)
              (("7" (expand "parsing")
                (("7" (assert)
                  (("7" (expand "astType?")
                    (("7" (lift-if)
                      (("7" (assert)
                        (("7" (split)
                          (("1" (propax) nil nil)
                           ("2" (typepred "status1")
                            (("2"
                              (lemma "Wellformed_theorem"
                               (T
                                "parsing(P_exp, A, e1, inp, s, s_T)"))
                              (("2" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("8" (hide 2)
          (("8" (skeep*)
            (("8" (typepred "s_T")
              (("8" (assert)
                (("8" (replaces)
                  (("8" (expand "g_wf" -) (("8" (propax) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("9" (hide 2)
          (("9" (skeep*)
            (("9" (lemma "peg[V_T, <=, V_N_b].subterm_transitivity")
              (("9" (inst - "e2" "prior(e1,e2)" "P_exp(A)")
                (("9" (assert)
                  (("9" (expand "subterm" 1)
                    (("9" (expand "subterm" 1) (("9" (propax) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("10" (hide 2)
          (("10" (skeep*)
            (("10" (replaces)
              (("10" (expand "parsing")
                (("10" (assert)
                  (("10" (expand "s_inp")
                    (("10" (lift-if)
                      (("10" (assert)
                        (("10" (expand "astType?")
                          (("10" (assert)
                            (("10" (typepred "T1")
                              (("10"
                                (replace -1 * RL)
                                (("10"
                                  (expand "s_inp" +)
                                  (("10"
                                    (expand "astType?")
                                    (("10" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("11" (hide 2)
          (("11" (skeep*)
            (("11" (lemma "Skip_is_badly_formed" (T T1))
              (("11" (assert)
                (("11" (typepred "T1") (("11" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil)
         ("12" (hide 2)
          (("12" (skeep*)
            (("12" (replaces)
              (("12" (expand "parsing")
                (("12" (assert)
                  (("12" (expand "astType?") (("12" (propax) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("13" (hide 2)
          (("13" (typepred "s_T")
            (("13" (flatten)
              (("13" (assert)
                (("13" (replaces)
                  (("13" (expand "g_wf" -) (("13" (propax) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("14" (hide 2)
          (("14" (lemma "peg[V_T, <=, V_N_b].subterm_transitivity")
            (("14" (inst - "e1" "prior(e1,e2)" "P_exp(A)")
              (("14" (assert)
                (("14" (expand "subterm" 1)
                  (("14" (expand "subterm" 1) (("14" (propax) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (lex4_lt formula-decl nil lex4 nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (lex3_lt formula-decl nil lex3 nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (lex2_lt formula-decl nil lex2 nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (Skip_is_badly_formed formula-decl nil ast nil)
    (prior adt-constructor-decl "[[peg, peg] -> (prior?)]" peg nil)
    (prior? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (subterm_transitivity formula-decl nil peg nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (astType type-decl nil ast nil) (pre_ast type-decl nil pre_ast nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (<= const-decl "bool" reals nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (saved_result type-decl nil semantic_parser nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (known? adt-recognizer-decl "[saved_result -> boolean]"
     semantic_parser nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (astType? def-decl "astType" ast nil)
    (below type-eq-decl nil naturalnumbers nil)
    (peg type-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (input type-eq-decl nil ast_props nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil) (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (status adt-accessor-decl
            "[(known?) -> astType[V_T, <=, V_N_b, bound, V_S]]"
            semantic_parser nil)
    (T adt-accessor-decl
     "[(known?) -> pre_ast[V_T, <=, V_N_b, bound, V_S]]"
     semantic_parser nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail adt-constructor-decl "[[below, below] -> (fail?)]" pre_ast
     nil)
    (semantic? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (semantic adt-constructor-decl
     "[[below, below, V_N[V_N_b], V_S] -> (semantic?)]" pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (results type-eq-decl nil semantic_parser nil)
    (astTypeOf type-eq-decl nil semantic_parser nil)
    (sem_result type-eq-decl nil semantic_tlparser nil)
    (ordstruct type-decl nil ordstruct_adt nil)
    (< def-decl "bool" ordinals nil)
    (ordinal? def-decl "bool" ordinals nil)
    (ordinal nonempty-type-eq-decl nil ordinals nil)
    (lex4 const-decl "ordinal" lex4 nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (pegMeasure const-decl "nat" peg nil)
    (equalTo type-eq-decl nil semantic_parser nil)
    (sempp def-decl "[astTypeOf(parsing(P_exp, A, G, inp, s, s_T)),
 equalTo(s_inp(P_inp, parsing(P_exp, A, G, inp, s, s_T))),
 results(P_exp, P_inp, inp)]" semantic_parser nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (¬ const-decl "[bool -> bool]" booleans nil)
    (prior? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (prior adt-constructor-decl
     "[[below, below, {T: pre_ast | ¬skip?(T)}, pre_ast] -> (prior?)]"
     pre_ast nil)
    (skip adt-constructor-decl
          "[[below, below, peg[V_T, <=, V_N_b]] -> (skip?)]" pre_ast
          nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, semantic_tlparser.e1, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T, semantic_tlparser.res, (LAMBDA (status1: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e1, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))), (T1: semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e1, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)), (res: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): IF (status1 = ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success) THEN semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].prior(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T1), T1, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].skip(semantic_tlparser.s, semantic_tlparser.s, semantic_tlparser.e2)), res) ELSE semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, semantic_tlparser.e2, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T, res, LAMBDA (status2: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e2, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))), (T2: semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e2, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)), (res: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): IF (status2 = ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success) THEN semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].prior(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T2), T1, T2), res) ELSE semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T2)), res) ENDIF) ENDIF))"
    "{x: [ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astType, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast, semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)] | x = semantic_tlparser.cont(semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].sempp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T, semantic_tlparser.res))}")))
 (semtlpp_TCC75 0
  (semtlpp_TCC46-1 nil 3804395188
   ("" (skeep*)
    (("" (lemma "peg[V_T, <=, V_N_b].subterm_transitivity")
      (("" (inst -1 "e" "G" "P_exp(A)")
        (("" (replace -2 * LR)
          (("" (assert)
            (("" (expand "subterm" 1)
              (("" (expand "subterm" 1) (("" (propax) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (subterm_transitivity formula-decl nil peg nil)
    (sub_star formula-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.e"
    "{e: wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].Δ | peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].subterm(e, semantic_tlparser.P_exp(semantic_tlparser.A))}")))
 (semtlpp_TCC76 0
  (semtlpp_TCC47-1 nil 3804395188
   ("" (skeep*)
    (("" (typepred "s_T")
      (("" (assert)
        (("" (expand "g_wf" -)
          (("" (replace -3 * LR)
            (("" (flatten) (("" (assert) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.s_T"
    "{k: naturalnumbers.upto(semantic_tlparser.s) | booleans.⇒((k = semantic_tlparser.s), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].pattern_wf?(semantic_tlparser.e, semantic_tlparser.A, static_analysis[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].σ(semantic_tlparser.P_exp), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].P_0c(semantic_tlparser.P_exp)))}")))
 (semtlpp_TCC77 0
  (semtlpp_TCC76-1 nil 3847091012
   ("" (skeep*)
    (("" (replaces)
      (("" (use "Star_cannot_fail")
        (("" (assert)
          (("" (use "Wellformed_theorem")
            (("" (assert)
              (("" (flatten)
                (("" (assert)
                  (("" (expand "parsing") (("" (propax) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (subterm_of type-eq-decl nil peg nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (<= const-decl "bool" reals nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (below type-eq-decl nil naturalnumbers nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star adt-constructor-decl "[peg -> (star?)]" peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (Star_cannot_fail formula-decl nil ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success"
    "semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC78 0
  (semtlpp_TCC48-1 nil 3804395188
   ("" (skeep*)
    (("" (typepred "T0")
      (("" (case "astWellformed?(T0)")
        (("1" (assert)
          (("1" (expand "astWellformed?" -) (("1" (propax) nil nil))
            nil))
          nil)
         ("2" (assert) nil nil))
        nil))
      nil))
    nil)
   ((sem_result type-eq-decl nil semantic_tlparser nil)
    (subterm adt-def-decl "boolean" peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (ast type-eq-decl nil ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (subterm_of type-eq-decl nil peg nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.T0"
    "{T: pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast | (booleans.¬)(pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].skip?(T))}")))
 (semtlpp_TCC79 0
  (semtlpp_TCC78-1 nil 3847091012 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (peg type-decl nil peg nil) (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (below type-eq-decl nil naturalnumbers nil)
    (subterm adt-def-decl "boolean" peg nil)
    (<= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (saved_result type-decl nil semantic_parser nil)
    (known? adt-recognizer-decl "[saved_result -> boolean]"
     semantic_parser nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (astType type-decl nil ast nil) (pre_ast type-decl nil pre_ast nil)
    (astType? def-decl "astType" ast nil)
    (subterm_of type-eq-decl nil peg nil)
    (input type-eq-decl nil ast_props nil)
    (subterm_of? const-decl "bool" peg nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil) (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (status adt-accessor-decl
            "[(known?) -> astType[V_T, <=, V_N_b, bound, V_S]]"
            semantic_parser nil)
    (T adt-accessor-decl
     "[(known?) -> pre_ast[V_T, <=, V_N_b, bound, V_S]]"
     semantic_parser nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail adt-constructor-decl "[[below, below] -> (fail?)]" pre_ast
     nil)
    (semantic? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (semantic adt-constructor-decl
     "[[below, below, V_N[V_N_b], V_S] -> (semantic?)]" pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (results type-eq-decl nil semantic_parser nil)
    (astTypeOf type-eq-decl nil semantic_parser nil)
    (sem_result type-eq-decl nil semantic_tlparser nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (topological_sort const-decl
     "{res: [loop(G) + (topological_ordering?(G))] | IN?_2(res) ⇔ is_dag(G)}"
     c_topological_sort digraphs)
    (topological_sort_aux def-decl
     "{res: [loop(G) + [non_temporary_marking, list[Vert(G)]]] |
   CASES res
     OF IN_1(loop): TRUE,
        IN_2(res):
          LET (mp, lp) = res IN
            topperm_list(G, mp)(lp) ∧
             greater_marking(mp, m) ∧
              suffix?(l, lp) ∧ FORALL (i: upto(n)): member(node(G)(i), lp)
     ENDCASES}" c_topological_sort digraphs)
    (gen_seq1 const-decl "Seq(G)" walks_ digraphs)
    (empty_marking const-decl "marking" c_topological_sort digraphs)
    (node const-decl "{v: T | member(v, data(cd))}" c_digraphs_def
     digraphs)
    (size const-decl "nat" c_digraphs_def digraphs)
    (dependency_graph const-decl "c_digraph[nat]" static_analysis nil)
    (nodes const-decl "node_ls" static_analysis nil)
    (interval_list const-decl "list[nat]" interval_list nil)
    (structural_WF? const-decl "bool" wf_peg nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].star(semantic_tlparser.s, semantic_tlparser.s, semantic_tlparser.T0, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].skip(pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T0), pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T0), peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].star(semantic_tlparser.e)))"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC80 0
  (semtlpp_TCC50-1 nil 3804395188
   ("" (skeep*)
    (("" (use "subterm_star" (G "P_exp(A)")) (("" (assert) nil nil))
      nil))
    nil)
   ((subterm_star formula-decl nil peg nil) (peg type-decl nil peg nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (below type-eq-decl nil naturalnumbers nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star adt-constructor-decl "[peg -> (star?)]" peg nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].star(semantic_tlparser.e)"
    "{e: wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].Δ | peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].subterm(e, semantic_tlparser.P_exp(semantic_tlparser.A))}")))
 (semtlpp_TCC81 0
  (semtlpp_TCC51-1 nil 3804395188
   ("" (skeep*)
    (("" (typepred "s_T")
      (("" (replace -3 * LR)
        (("" (assert)
          (("" (typepred "T0")
            (("" (assert)
              (("" (lemma "Wellformed_theorem" (T T0))
                (("" (assert)
                  (("" (flatten)
                    (("" (assert)
                      (("" (flatten) (("" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (pre_ast type-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (subterm_of type-eq-decl nil peg nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (subterm_of? const-decl "bool" peg nil)
    (ast type-eq-decl nil ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (sem_result type-eq-decl nil semantic_tlparser nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.s_T"
    "{k: naturalnumbers.upto(pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T0)) | booleans.⇒((k = pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T0)), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].pattern_wf?(peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].star(semantic_tlparser.e), semantic_tlparser.A, static_analysis[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].σ(semantic_tlparser.P_exp), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].P_0c(semantic_tlparser.P_exp)))}")))
 (semtlpp_TCC82 0
  (semtlpp_TCC81-1 nil 3847091012
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (use "Star_cannot_fail")
        (("" (assert)
          ((""
            (wf-ast "parsing[V_T, <=, V_N_b, bound, V_S]
                  (P_exp, A, star(e), inp, s, s_T)")
            (("" (assert)
              (("" (flatten)
                (("" (assert)
                  (("" (expand "P_fc")
                    (("" (expand "g_props") (("" (propax) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (g_props def-decl "[bool, bool, bool]" wf_peg nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (pre_ast type-decl nil pre_ast nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (subterm_of type-eq-decl nil peg nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (<= const-decl "bool" reals nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (below type-eq-decl nil naturalnumbers nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star adt-constructor-decl "[peg -> (star?)]" peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (Star_cannot_fail formula-decl nil ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success"
    "semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC83 0
  (semtlpp_TCC52-1 nil 3804395188
   ("" (skeep*)
    (("" (typepred "T0")
      (("" (case "astWellformed?(T0)")
        (("1" (assert)
          (("1" (expand "astWellformed?" -) (("1" (propax) nil nil))
            nil))
          nil)
         ("2" (assert) nil nil))
        nil))
      nil))
    nil)
   ((sem_result type-eq-decl nil semantic_tlparser nil)
    (subterm adt-def-decl "boolean" peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (ast type-eq-decl nil ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (subterm_of type-eq-decl nil peg nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.T0"
    "{T: pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast | (booleans.¬)(pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].skip?(T))}")))
 (semtlpp_TCC84 0
  (semtlpp_TCC53-1 nil 3804395188
   ("" (skeep*)
    (("" (typepred "Ts")
      (("" (expand "parsing")
        (("" (expand "s_inp")
          (("" (lift-if)
            (("" (assert) (("" (lift-if) (("" (assert) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((sem_result type-eq-decl nil semantic_tlparser nil)
    (subterm adt-def-decl "boolean" peg nil)
    (star adt-constructor-decl "[peg -> (star?)]" peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (ast type-eq-decl nil ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (subterm_of type-eq-decl nil peg nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.Ts"
    "{T: pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast | booleans.OR(pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].skip?(T), pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].star?(T))}")))
 (semtlpp_TCC85 0
  (semtlpp_TCC84-1 nil 3847091012
   ("" (skeep*)
    (("" (auto-rewrite -1)
      (("" (assert)
        (("" (expand "parsing")
          (("" (expand "s_inp")
            (("" (lift-if)
              (("" (assert)
                (("" (lift-if)
                  (("" (assert)
                    (("" (typepred "T0")
                      (("" (typepred "Ts") (("" (assert) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (sem_result type-eq-decl nil semantic_tlparser nil)
    (subterm adt-def-decl "boolean" peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (ast type-eq-decl nil ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (subterm_of type-eq-decl nil peg nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star adt-constructor-decl "[peg -> (star?)]" peg nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (astType? def-decl "astType" ast nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].star(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.Ts), semantic_tlparser.T0, semantic_tlparser.Ts)"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC86 0
  (semtlpp_TCC55-1 nil 3804395188
   ("" (skeep*)
    (("" (auto-rewrite -1)
      (("" (assert)
        (("" (assert)
          (("" (assert)
            (("" (typepred "T0")
              (("" (typepred "parsing(P_exp, A, e, inp, s, s_T)")
                (("" (typepred "status0")
                  (("" (assert)
                    (("" (wf-ast "T0")
                      (("" (assert)
                        (("" (flatten)
                          (("" (assert)
                            (("" (use "star_cannot_be_P_0")
                              ((""
                                (assert)
                                ((""
                                  (typepred "G")
                                  (("" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lex4_lt formula-decl nil lex4 nil)
    (sem_result type-eq-decl nil semantic_tlparser nil)
    (subterm adt-def-decl "boolean" peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (ast type-eq-decl nil ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (subterm_of type-eq-decl nil peg nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (astTypeOf type-eq-decl nil semantic_parser nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (star_cannot_be_P_0 formula-decl nil wf_peg nil)
    (wf_nT? const-decl "bool" wf_peg nil)
    (wf_nT type-eq-decl nil wf_peg nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lex3_lt formula-decl nil lex3 nil)
    (lex2_lt formula-decl nil lex2 nil)
    (pegMeasure_star formula-decl nil peg nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp termination
    "semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].star(semantic_tlparser.e), semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T0), semantic_tlparser.s_T, semantic_tlparser.res, (LAMBDA (status2: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].star(semantic_tlparser.e), semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T0), semantic_tlparser.s_T))), (Ts: semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].star(semantic_tlparser.e), semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T0), semantic_tlparser.s_T)), (res: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].star(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(Ts), semantic_tlparser.T0, Ts), res)))"
    "nil")))
 (semtlpp_TCC87 0
  (semtlpp_TCC57-1 nil 3804395188
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (rewrite "lex4_lt")
        (("" (rewrite "lex3_lt")
          (("" (rewrite "lex2_lt")
            (("" (assert) (("" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((star adt-constructor-decl "[peg -> (star?)]" peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (pegMeasure const-decl "nat" peg nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (lex4_lt formula-decl nil lex4 nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (pegMeasure_star formula-decl nil peg nil)
    (lex2_lt formula-decl nil lex2 nil)
    (lex3_lt formula-decl nil lex3 nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp termination
    "semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T, semantic_tlparser.res, (LAMBDA (status0: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))), (T0: semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)), (res: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): IF (status0 = ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure) THEN semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].star(semantic_tlparser.s, semantic_tlparser.s, T0, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].skip(pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T0), pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T0), peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].star(semantic_tlparser.e))), res) ELSE semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].star(semantic_tlparser.e), semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T0), semantic_tlparser.s_T, res, LAMBDA (status2: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].star(semantic_tlparser.e), semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T0), semantic_tlparser.s_T))), (Ts: semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].star(semantic_tlparser.e), semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T0), semantic_tlparser.s_T)), (res: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].star(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(Ts), T0, Ts), res)) ENDIF))"
    "nil")))
 (semtlpp_TCC88 0
  (semtlpp_TCC87-1 nil 3805033343
   ("" (skeep*)
    (("" (auto-rewrite -1)
      ((""
        (typepred "v(P_exp, P_inp, A, e, inp, s, s_T, res,
        LAMBDA (status0: astTypeOf(parsing(P_exp, A, e, inp, s, s_T))),
               (T0: sem_result(P_inp, P_exp, A, e, inp, s, s_T)), (res: results(P_exp, P_inp, inp)):
          IF (status0 = failure)
            THEN cont(success, star (s, s, T0, skip (e(T0), e(T0), star[V_T, <=, V_N_b](e))),
                      res)
          ELSE v(P_exp, P_inp, A, star[V_T, <=, V_N_b](e), inp, e(T0), s_T, res,
                 LAMBDA (status2: astTypeOf(parsing(P_exp, A, star[V_T, <=, V_N_b](e), inp, e(T0), s_T))),
                        (Ts: sem_result(P_inp, P_exp, A, star[V_T, <=, V_N_b](e), inp, e(T0), s_T)),
                        (res: results(P_exp, P_inp, inp)):
                   cont(success, star(s, e(Ts), T0, Ts), res))
          ENDIF)")
        (("1" (replace -1 * LR)
          (("1" (hide -1)
            (("1" (assert)
              (("1" (expand "sempp" 1 9)
                (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil))
              nil))
            nil))
          nil)
         ("2" (hide 2)
          (("2" (skeep*)
            (("2" (assert)
              (("2" (assert)
                (("2" (assert)
                  (("2" (typepred "T0")
                    (("2" (wf-ast "parsing(P_exp, A, e, inp, s, s_T)")
                      (("2" (assert)
                        (("2" (flatten)
                          (("2" (assert)
                            (("2" (use "star_cannot_be_P_0")
                              (("2"
                                (typepred "G")
                                (("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("3" (hide 2)
          (("3" (skeep*)
            (("3" (expand "parsing")
              (("3" (lift-if)
                (("3" (ground)
                  (("3" (expand "s_inp")
                    (("3" (lift-if)
                      (("3" (assert)
                        (("3" (lift-if)
                          (("3" (assert)
                            (("3" (typepred "Ts")
                              (("3" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("4" (hide 2)
          (("4" (skeep*)
            (("4" (typepred "Ts")
              (("4" (expand "parsing")
                (("4" (lift-if)
                  (("4" (assert)
                    (("4" (expand "s_inp")
                      (("4" (lift-if)
                        (("4" (assert)
                          (("4" (lift-if) (("4" (assert) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("5" (hide 2)
          (("5" (skeep*)
            (("5" (wf-ast T0) (("5" (assert) nil nil)) nil)) nil))
          nil)
         ("6" (hide 2)
          (("6" (skeep*)
            (("6" (typepred "status0")
              (("6" (wf-ast "parsing(P_exp, A, star(e), inp, s, s_T)")
                (("6" (assert)
                  (("6" (flatten)
                    (("6" (assert)
                      (("6" (expand "P_fc")
                        (("6" (expand "g_props")
                          (("6" (propax) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("7" (hide 2)
          (("7" (skeep*)
            (("7" (typepred "s_T")
              (("7" (typepred "T0")
                (("7" (assert)
                  (("7" (wf-ast T0)
                    (("7" (assert)
                      (("7" (flatten)
                        (("7" (assert)
                          (("7" (flatten) (("7" (assert) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("8" (hide 2)
          (("8" (skeep*)
            (("8" (typepred "G") (("8" (assert) nil nil)) nil)) nil))
          nil)
         ("9" (hide 2)
          (("9" (skeep*)
            (("9" (expand "parsing")
              (("9" (assert)
                (("9" (expand "s_inp")
                  (("9" (lift-if)
                    (("9" (assert)
                      (("9" (typepred "T0")
                        (("9" (expand "s_inp" 1 2)
                          (("9" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("10" (hide 2)
          (("10" (skeep*)
            (("10" (wf-ast T0) (("10" (assert) nil nil)) nil)) nil))
          nil)
         ("11" (hide 2)
          (("11" (skeep*)
            (("11"
              (wf-ast
               "parsing[V_T, <=, V_N_b, bound, V_S](P_exp, A, star(e), inp, s, s_T)")
              (("11" (assert)
                (("11" (flatten)
                  (("11" (assert)
                    (("11" (typepred "T0")
                      (("11" (assert)
                        (("11" (expand "P_fc")
                          (("11" (expand "g_props")
                            (("11" (propax) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("12" (hide 2)
          (("12" (typepred "s_T") (("12" (flassert) nil nil)) nil))
          nil)
         ("13" (hide 2)
          (("13" (use "subterm_star" (G "P_exp(A)"))
            (("13" (typepred "G") (("13" (flassert) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((subterm_star formula-decl nil peg nil)
    (g_props def-decl "[bool, bool, bool]" wf_peg nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (lex2_lt formula-decl nil lex2 nil)
    (lex3_lt formula-decl nil lex3 nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (star_cannot_be_P_0 formula-decl nil wf_peg nil)
    (wf_nT? const-decl "bool" wf_peg nil)
    (wf_nT type-eq-decl nil wf_peg nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lex4_lt formula-decl nil lex4 nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (astType type-decl nil ast nil) (pre_ast type-decl nil pre_ast nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (<= const-decl "bool" reals nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (saved_result type-decl nil semantic_parser nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (known? adt-recognizer-decl "[saved_result -> boolean]"
     semantic_parser nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (astType? def-decl "astType" ast nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (subterm_of type-eq-decl nil peg nil) (peg type-decl nil peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (input type-eq-decl nil ast_props nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil) (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (status adt-accessor-decl
            "[(known?) -> astType[V_T, <=, V_N_b, bound, V_S]]"
            semantic_parser nil)
    (T adt-accessor-decl
     "[(known?) -> pre_ast[V_T, <=, V_N_b, bound, V_S]]"
     semantic_parser nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail adt-constructor-decl "[[below, below] -> (fail?)]" pre_ast
     nil)
    (semantic? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (semantic adt-constructor-decl
     "[[below, below, V_N[V_N_b], V_S] -> (semantic?)]" pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (results type-eq-decl nil semantic_parser nil)
    (below type-eq-decl nil naturalnumbers nil)
    (subterm adt-def-decl "boolean" peg nil)
    (astTypeOf type-eq-decl nil semantic_parser nil)
    (sem_result type-eq-decl nil semantic_tlparser nil)
    (ordstruct type-decl nil ordstruct_adt nil)
    (< def-decl "bool" ordinals nil)
    (ordinal? def-decl "bool" ordinals nil)
    (ordinal nonempty-type-eq-decl nil ordinals nil)
    (lex4 const-decl "ordinal" lex4 nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (pegMeasure const-decl "nat" peg nil)
    (equalTo type-eq-decl nil semantic_parser nil)
    (sempp def-decl "[astTypeOf(parsing(P_exp, A, G, inp, s, s_T)),
 equalTo(s_inp(P_inp, parsing(P_exp, A, G, inp, s, s_T))),
 results(P_exp, P_inp, inp)]" semantic_parser nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (¬ const-decl "[bool -> bool]" booleans nil)
    (star adt-constructor-decl
     "[[below, below, {T: pre_ast | ¬skip?(T)},
  {T: pre_ast | skip?(T) OR star?(T)}] ->
   (star?)]" pre_ast nil)
    (skip adt-constructor-decl
          "[[below, below, peg[V_T, <=, V_N_b]] -> (skip?)]" pre_ast
          nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star adt-constructor-decl "[peg -> (star?)]" peg nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T, semantic_tlparser.res, (LAMBDA (status0: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))), (T0: semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)), (res: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): IF (status0 = ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure) THEN semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].star(semantic_tlparser.s, semantic_tlparser.s, T0, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].skip(pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T0), pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T0), peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].star(semantic_tlparser.e))), res) ELSE semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].star(semantic_tlparser.e), semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T0), semantic_tlparser.s_T, res, LAMBDA (status2: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].star(semantic_tlparser.e), semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T0), semantic_tlparser.s_T))), (Ts: semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].star(semantic_tlparser.e), semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T0), semantic_tlparser.s_T)), (res: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].star(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(Ts), T0, Ts), res)) ENDIF))"
    "{x: [ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astType, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast, semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)] | x = semantic_tlparser.cont(semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].sempp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T, semantic_tlparser.res))}")))
 (semtlpp_TCC89 0
  (semtlpp_TCC59-1 nil 3804395188
   ("" (skeep*)
    (("" (lemma "peg[V_T, <=, V_N_b].subterm_transitivity")
      (("" (inst -1 "e" "G" "P_exp(A)")
        (("" (replace -2 * LR)
          (("" (assert)
            (("" (expand "subterm" 1)
              (("" (expand "subterm" 1) (("" (propax) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (subterm_transitivity formula-decl nil peg nil)
    (sub_plus formula-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.e"
    "{e: wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].Δ | peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].subterm(e, semantic_tlparser.P_exp(semantic_tlparser.A))}")))
 (semtlpp_TCC90 0
  (semtlpp_TCC60-1 nil 3804395188
   ("" (skeep*)
    (("" (typepred "s_T")
      (("" (assert)
        (("" (expand "g_wf" -)
          (("" (replace -3 * LR)
            (("" (flatten) (("" (assert) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.s_T"
    "{k: naturalnumbers.upto(semantic_tlparser.s) | booleans.⇒((k = semantic_tlparser.s), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].pattern_wf?(semantic_tlparser.e, semantic_tlparser.A, static_analysis[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].σ(semantic_tlparser.P_exp), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].P_0c(semantic_tlparser.P_exp)))}")))
 (semtlpp_TCC91 0
  (semtlpp_TCC90-1 nil 3847091012
   ("" (skeep*)
    (("" (replaces)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "astType?") (("" (propax) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure"
    "semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC92 0
  (semtlpp_TCC91-1 nil 3847091012
   ("" (skeep*)
    (("" (replaces)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "s_inp")
            (("" (expand "astType?") (("" (propax) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, semantic_tlparser.s)"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC93 0
  (semtlpp_TCC70-1 nil 3804395188
   ("" (skeep*)
    (("" (use "subterm_plus" (G "P_exp(A)")) (("" (flassert) nil nil))
      nil))
    nil)
   ((subterm_plus formula-decl nil peg nil) (peg type-decl nil peg nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (below type-eq-decl nil naturalnumbers nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus adt-constructor-decl "[peg -> (plus?)]" peg nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].plus(semantic_tlparser.e)"
    "{e: wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].Δ | peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].subterm(e, semantic_tlparser.P_exp(semantic_tlparser.A))}")))
 (semtlpp_TCC94 0
  (semtlpp_TCC63-1 nil 3804395188
   ("" (skeep*)
    (("" (typepred "s_T")
      (("" (replace -3 * LR)
        (("" (assert)
          (("" (typepred "T0")
            (("" (lemma "Wellformed_theorem" (T T0))
              (("" (assert)
                (("" (flatten)
                  (("" (assert)
                    (("" (flatten) (("" (assert) nil nil)) nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (pre_ast type-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (subterm_of type-eq-decl nil peg nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (subterm_of? const-decl "bool" peg nil)
    (ast type-eq-decl nil ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (sem_result type-eq-decl nil semantic_tlparser nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.s_T"
    "{k: naturalnumbers.upto(pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T0)) | booleans.⇒((k = pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T0)), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].pattern_wf?(peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].plus(semantic_tlparser.e), semantic_tlparser.A, static_analysis[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].σ(semantic_tlparser.P_exp), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].P_0c(semantic_tlparser.P_exp)))}")))
 (semtlpp_TCC95 0
  (semtlpp_TCC94-1 nil 3847091012
   ("" (skeep*)
    (("" (auto-rewrite -1)
      (("" (assert)
        (("" (expand "parsing")
          (("" (liftassert+)
            (("" (typepred "status0")
              (("" (wf-ast "parsing(P_exp, A, e, inp, s, s_T)")
                (("" (assert)
                  (("" (ground+)
                    (("" (flassert)
                      (("" (split 2)
                        (("1" (propax) nil nil)
                         ("2"
                          (wf-ast
                           "parsing(P_exp, A, plus(e), inp, e(parsing(P_exp, A, e, inp, s, s_T)), s_T)")
                          (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (astTypeOf type-eq-decl nil semantic_parser nil)
    (subterm adt-def-decl "boolean" peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (<= const-decl "bool" reals nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (< const-decl "bool" reals nil)
    (subterm_of type-eq-decl nil peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (astType type-decl nil ast nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus adt-constructor-decl "[peg -> (plus?)]" peg nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success"
    "semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC96 0
  (semtlpp_TCC64-1 nil 3804395188
   ("" (skeep*)
    (("" (typepred "T0")
      (("" (case "astWellformed?(T0)")
        (("1" (assert)
          (("1" (expand "astWellformed?" -) (("1" (propax) nil nil))
            nil))
          nil)
         ("2" (assert) nil nil))
        nil))
      nil))
    nil)
   ((sem_result type-eq-decl nil semantic_tlparser nil)
    (subterm adt-def-decl "boolean" peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (ast type-eq-decl nil ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (subterm_of type-eq-decl nil peg nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.T0"
    "{T: pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast | (booleans.¬)(pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].skip?(T))}")))
 (semtlpp_TCC97 0
  (semtlpp_TCC65-1 nil 3804395188
   ("" (skeep*)
    (("" (typepred "Ts")
      (("" (expand "parsing")
        (("" (typepred "status0")
          (("" (assert)
            (("" (lift-if)
              (("" (split)
                (("1" (flatten)
                  (("1" (expand "s_inp")
                    (("1" (ground)
                      (("1" (lift-if)
                        (("1" (split)
                          (("1" (flatten) (("1" (assert) nil nil)) nil)
                           ("2" (flatten) (("2" (assert) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (assert)
                    (("2" (expand "s_inp")
                      (("2" (lift-if)
                        (("2" (split)
                          (("1" (flatten) (("1" (assert) nil nil)) nil)
                           ("2" (flatten) (("2" (assert) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((sem_result type-eq-decl nil semantic_tlparser nil)
    (subterm adt-def-decl "boolean" peg nil)
    (plus adt-constructor-decl "[peg -> (plus?)]" peg nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (ast type-eq-decl nil ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (subterm_of type-eq-decl nil peg nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (astTypeOf type-eq-decl nil semantic_parser nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.Ts"
    "{T: pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast | booleans.OR(pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].skip?(T), booleans.OR(pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].plus?(T), pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail?(T)))}")))
 (semtlpp_TCC98 0
  (semtlpp_TCC97-1 nil 3847091012
   ("" (skeep*)
    (("" (replaces)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "s_inp")
            (("" (expand "astType?")
              (("" (lift-if)
                (("" (assert)
                  (("" (typepred "Ts")
                    (("" (typepred "T0")
                      (("" (decompose-equality 2) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (plus adt-constructor-decl
     "[[below, below, {T: pre_ast | ¬skip?(T)},
  {T: pre_ast | skip?(T) OR plus?(T) OR fail?(T)}] ->
   (plus?)]" pre_ast nil)
    (¬ const-decl "[bool -> bool]" booleans nil)
    (pre_ast_plus_extensionality formula-decl nil pre_ast nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (astType type-decl nil ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (subterm_of type-eq-decl nil peg nil) (peg type-decl nil peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (ast type-eq-decl nil ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (below type-eq-decl nil naturalnumbers nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus adt-constructor-decl "[peg -> (plus?)]" peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (sem_result type-eq-decl nil semantic_tlparser nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].plus(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.Ts), semantic_tlparser.T0, semantic_tlparser.Ts)"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC99 0
  (semtlpp_TCC67-1 nil 3804395188
   ("" (skeep*)
    (("" (auto-rewrite -1)
      (("" (assert)
        (("" (assert)
          (("" (assert)
            (("" (typepred "T0")
              (("" (wf-ast "parsing(P_exp, A, e, inp, s, s_T)")
                (("" (assert)
                  (("" (flatten)
                    (("" (assert)
                      (("" (use "plus_cannot_be_P_0")
                        (("" (typepred "G") (("" (assert) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lex4_lt formula-decl nil lex4 nil)
    (sem_result type-eq-decl nil semantic_tlparser nil)
    (subterm adt-def-decl "boolean" peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (ast type-eq-decl nil ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (subterm_of type-eq-decl nil peg nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (wf_nT? const-decl "bool" wf_peg nil)
    (wf_nT type-eq-decl nil wf_peg nil)
    (plus_cannot_be_P_0 formula-decl nil wf_peg nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (lex3_lt formula-decl nil lex3 nil)
    (lex2_lt formula-decl nil lex2 nil)
    (pegMeasure_plus formula-decl nil peg nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp termination
    "semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].plus(semantic_tlparser.e), semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T0), semantic_tlparser.s_T, semantic_tlparser.res, (LAMBDA (status2: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].plus(semantic_tlparser.e), semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T0), semantic_tlparser.s_T))), (Ts: semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].plus(semantic_tlparser.e), semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T0), semantic_tlparser.s_T)), (res: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].plus(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(Ts), semantic_tlparser.T0, Ts), res)))"
    "nil")))
 (semtlpp_TCC100 0
  (semtlpp_TCC69-1 nil 3804395188
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (rewrite "lex4_lt")
        (("" (rewrite "lex3_lt")
          (("" (rewrite "lex2_lt")
            (("" (assert)
              (("" (expand "pegMeasure")
                (("" (expand "reduce_nat" 1 2)
                  (("" (assert) (("" (grind) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((plus adt-constructor-decl "[peg -> (plus?)]" peg nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (pegMeasure const-decl "nat" peg nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (lex4_lt formula-decl nil lex4 nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (pegMeasure_plus formula-decl nil peg nil)
    (lex2_lt formula-decl nil lex2 nil)
    (lex3_lt formula-decl nil lex3 nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp termination
    "semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T, semantic_tlparser.res, (LAMBDA (status0: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))), (T0: semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)), (res: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): IF (status0 = ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure) THEN semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, semantic_tlparser.s), res) ELSE semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].plus(semantic_tlparser.e), semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T0), semantic_tlparser.s_T, res, LAMBDA (status2: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].plus(semantic_tlparser.e), semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T0), semantic_tlparser.s_T))), (Ts: semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].plus(semantic_tlparser.e), semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T0), semantic_tlparser.s_T)), (res: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].plus(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(Ts), T0, Ts), res)) ENDIF))"
    "nil")))
 (semtlpp_TCC101 0
  (semtlpp_TCC100-1 nil 3805033343
   ("" (skeep*)
    (("" (auto-rewrite -1)
      ((""
        (typepred "v(P_exp, P_inp, A, e, inp, s, s_T, res,
        LAMBDA (status0: astTypeOf(parsing(P_exp, A, e, inp, s, s_T))),
               (T0: sem_result(P_inp, P_exp, A, e, inp, s, s_T)), (res: results(P_exp, P_inp, inp)):
          IF (status0 = failure)
            THEN cont(failure, fail(s, s), res)
          ELSE v(P_exp, P_inp, A, plus[V_T, <=, V_N_b](e), inp, e(T0), s_T, res,
                 LAMBDA (status2: astTypeOf (parsing (P_exp, A, plus[V_T, <=, V_N_b](e), inp, e(T0), s_T))),
                        (Ts: sem_result(P_inp, P_exp, A, plus[V_T, <=, V_N_b](e), inp, e(T0), s_T)),
                        (res: results(P_exp, P_inp, inp)):
                   cont(success, plus(s, e(Ts), T0, Ts), res))
          ENDIF)")
        (("1" (replace -1 * LR)
          (("1" (hide -1)
            (("1" (assert)
              (("1" (expand "sempp" 1 6)
                (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil))
              nil))
            nil))
          nil)
         ("2" (hide 2)
          (("2" (skeep*)
            (("2" (hide 2)
              (("2" (typepred "status0")
                (("2" (reveal +)
                  (("2" (hide 2)
                    (("2" (assert)
                      (("2" (assert)
                        (("2" (assert)
                          (("2" (typepred "T0")
                            (("2"
                              (wf-ast
                               "parsing(P_exp, A, e, inp, s, s_T)")
                              (("2"
                                (assert)
                                (("2"
                                  (assert)
                                  (("2"
                                    (flatten)
                                    (("2"
                                      (assert)
                                      (("2"
                                        (use "plus_cannot_be_P_0")
                                        (("2"
                                          (typepred "G")
                                          (("2" (flassert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("3" (hide 2)
          (("3" (skeep*)
            (("3" (expand "parsing")
              (("3" (assert)
                (("3" (expand "s_inp")
                  (("3" (assert)
                    (("3" (lift-if)
                      (("3" (assert)
                        (("3" (typepred "T0")
                          (("3" (typepred "Ts")
                            (("3" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("4" (hide 2)
          (("4" (skeep*)
            (("4" (typepred "Ts")
              (("4" (expand "parsing")
                (("4" (expand "s_inp")
                  (("4" (lift-if)
                    (("4" (assert)
                      (("4" (ground)
                        (("4" (lift-if) (("4" (ground) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("5" (hide 2)
          (("5" (skeep*)
            (("5" (wf-ast T0) (("5" (assert) nil nil)) nil)) nil))
          nil)
         ("6" (hide 2)
          (("6" (skeep*)
            (("6" (expand "parsing")
              (("6" (assert)
                (("6" (lift-if)
                  (("6" (assert)
                    (("6" (split 2)
                      (("1" (propax) nil nil)
                       ("2" (flatten)
                        (("2" (split 2)
                          (("1" (propax) nil nil)
                           ("2" (wf-ast T0)
                            (("2" (assert)
                              (("2"
                                (flatten)
                                (("2"
                                  (wf-ast Ts)
                                  (("2"
                                    (assert)
                                    (("2"
                                      (flatten)
                                      (("2"
                                        (typepred "T0")
                                        (("2"
                                          (typepred "Ts")
                                          (("2" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("7" (hide 2)
          (("7" (skeep*)
            (("7" (typepred "T0")
              (("7" (assert)
                (("7" (wf-ast T0)
                  (("7" (assert)
                    (("7" (flatten)
                      (("7" (assert)
                        (("7" (flatten)
                          (("7" (typepred "s_T")
                            (("7" (flassert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("8" (hide 2)
          (("8" (skeep*)
            (("8" (typepred "G") (("8" (assert) nil nil)) nil)) nil))
          nil)
         ("9" (hide 2)
          (("9" (skeep*)
            (("9" (expand "parsing")
              (("9" (assert)
                (("9" (expand "s_inp") (("9" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil)
         ("10" (hide 2)
          (("10" (skeep*)
            (("10" (expand "parsing") (("10" (assert) nil nil)) nil))
            nil))
          nil)
         ("11" (hide 2)
          (("11" (typepred "s_T") (("11" (flassert) nil nil)) nil))
          nil)
         ("12" (hide 2)
          (("12" (use "subterm_plus" (G "P_exp(A)"))
            (("12" (typepred "G") (("12" (assert) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((subterm_plus formula-decl nil peg nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (lex2_lt formula-decl nil lex2 nil)
    (lex3_lt formula-decl nil lex3 nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (wf_nT type-eq-decl nil wf_peg nil)
    (wf_nT? const-decl "bool" wf_peg nil)
    (plus_cannot_be_P_0 formula-decl nil wf_peg nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lex4_lt formula-decl nil lex4 nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (astType type-decl nil ast nil) (pre_ast type-decl nil pre_ast nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (<= const-decl "bool" reals nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (saved_result type-decl nil semantic_parser nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (known? adt-recognizer-decl "[saved_result -> boolean]"
     semantic_parser nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (astType? def-decl "astType" ast nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (subterm_of type-eq-decl nil peg nil) (peg type-decl nil peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (input type-eq-decl nil ast_props nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil) (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (status adt-accessor-decl
            "[(known?) -> astType[V_T, <=, V_N_b, bound, V_S]]"
            semantic_parser nil)
    (T adt-accessor-decl
     "[(known?) -> pre_ast[V_T, <=, V_N_b, bound, V_S]]"
     semantic_parser nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail adt-constructor-decl "[[below, below] -> (fail?)]" pre_ast
     nil)
    (semantic? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (semantic adt-constructor-decl
     "[[below, below, V_N[V_N_b], V_S] -> (semantic?)]" pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (results type-eq-decl nil semantic_parser nil)
    (below type-eq-decl nil naturalnumbers nil)
    (subterm adt-def-decl "boolean" peg nil)
    (astTypeOf type-eq-decl nil semantic_parser nil)
    (sem_result type-eq-decl nil semantic_tlparser nil)
    (ordstruct type-decl nil ordstruct_adt nil)
    (< def-decl "bool" ordinals nil)
    (ordinal? def-decl "bool" ordinals nil)
    (ordinal nonempty-type-eq-decl nil ordinals nil)
    (lex4 const-decl "ordinal" lex4 nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (pegMeasure const-decl "nat" peg nil)
    (equalTo type-eq-decl nil semantic_parser nil)
    (sempp def-decl "[astTypeOf(parsing(P_exp, A, G, inp, s, s_T)),
 equalTo(s_inp(P_inp, parsing(P_exp, A, G, inp, s, s_T))),
 results(P_exp, P_inp, inp)]" semantic_parser nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus adt-constructor-decl "[peg -> (plus?)]" peg nil)
    (¬ const-decl "[bool -> bool]" booleans nil)
    (plus adt-constructor-decl
     "[[below, below, {T: pre_ast | ¬skip?(T)},
  {T: pre_ast | skip?(T) OR plus?(T) OR fail?(T)}] ->
   (plus?)]" pre_ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T, semantic_tlparser.res, (LAMBDA (status0: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))), (T0: semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)), (res: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): IF (status0 = ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure) THEN semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, semantic_tlparser.s), res) ELSE semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].plus(semantic_tlparser.e), semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T0), semantic_tlparser.s_T, res, LAMBDA (status2: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].plus(semantic_tlparser.e), semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T0), semantic_tlparser.s_T))), (Ts: semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].plus(semantic_tlparser.e), semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T0), semantic_tlparser.s_T)), (res: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].plus(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(Ts), T0, Ts), res)) ENDIF))"
    "{x: [ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astType, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast, semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)] | x = semantic_tlparser.cont(semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].sempp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T, semantic_tlparser.res))}")))
 (semtlpp_TCC102 0
  (semtlpp_TCC71-1 nil 3804395188
   ("" (skeep*)
    (("" (lemma "peg[V_T, <=, V_N_b].subterm_transitivity")
      (("" (inst -1 "e" "G" "P_exp(A)")
        (("" (replace -2 * LR)
          (("" (assert)
            (("" (expand "subterm" 1)
              (("" (expand "subterm" 1) (("" (propax) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (subterm_transitivity formula-decl nil peg nil)
    (sub_opt formula-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.e"
    "{e: wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].Δ | peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].subterm(e, semantic_tlparser.P_exp(semantic_tlparser.A))}")))
 (semtlpp_TCC103 0
  (semtlpp_TCC72-1 nil 3804395188
   ("" (skeep*)
    (("" (typepred "s_T")
      (("" (assert)
        (("" (expand "g_wf" -)
          (("" (replace -3 * LR) (("" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.s_T"
    "{k: naturalnumbers.upto(semantic_tlparser.s) | booleans.⇒((k = semantic_tlparser.s), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].pattern_wf?(semantic_tlparser.e, semantic_tlparser.A, static_analysis[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].σ(semantic_tlparser.P_exp), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].P_0c(semantic_tlparser.P_exp)))}")))
 (semtlpp_TCC104 0
  (semtlpp_TCC103-1 nil 3847091012
   ("" (skeep*)
    (("" (replaces)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "astType?") (("" (propax) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success"
    "semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC105 0
  (semtlpp_TCC74-1 nil 3804395188
   ("" (skeep*)
    (("" (typepred "T")
      (("" (case "astWellformed?(T)")
        (("1" (assert)
          (("1" (expand "astWellformed?" -) (("1" (propax) nil nil))
            nil))
          nil)
         ("2" (assert) nil nil))
        nil))
      nil))
    nil)
   ((sem_result type-eq-decl nil semantic_tlparser nil)
    (subterm adt-def-decl "boolean" peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (ast type-eq-decl nil ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (subterm_of type-eq-decl nil peg nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.T"
    "{T: pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast | (booleans.¬)(pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].skip?(T))}")))
 (semtlpp_TCC106 0
  (semtlpp_TCC105-1 nil 3847091012
   ("" (skeep*)
    (("" (replaces)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "s_inp")
            (("" (expand "astType?")
              (("" (typepred "T") (("" (assert) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (astType type-decl nil ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (subterm_of type-eq-decl nil peg nil) (peg type-decl nil peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (ast type-eq-decl nil ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (below type-eq-decl nil naturalnumbers nil)
    (subterm adt-def-decl "boolean" peg nil)
    (sem_result type-eq-decl nil semantic_tlparser nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].opt(semantic_tlparser.s, semantic_tlparser.s, semantic_tlparser.T)"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC107 0
  (semtlpp_TCC106-1 nil 3847091012
   ("" (skeep*)
    (("" (replaces)
      (("" (expand "parsing")
        (("" (lift-if)
          (("" (assert)
            (("" (lift-if)
              (("" (ground)
                (("" (wf-ast "parsing(P_exp, A, e, inp, s, s_T)")
                  (("" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (pre_ast type-decl nil pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (subterm_of type-eq-decl nil peg nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (<= const-decl "bool" reals nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (astType type-decl nil ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (below type-eq-decl nil naturalnumbers nil)
    (subterm adt-def-decl "boolean" peg nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success"
    "semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC108 0
  (semtlpp_TCC80-1 nil 3804395188
   ("" (skeep*)
    (("" (typepred "T")
      (("" (case "astWellformed?(T)")
        (("1" (assert)
          (("1" (expand "astWellformed?" -) (("1" (propax) nil nil))
            nil))
          nil)
         ("2" (assert) nil nil))
        nil))
      nil))
    nil)
   ((sem_result type-eq-decl nil semantic_tlparser nil)
    (subterm adt-def-decl "boolean" peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (ast type-eq-decl nil ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (subterm_of type-eq-decl nil peg nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.T"
    "{T: pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast | (booleans.¬)(pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].skip?(T))}")))
 (semtlpp_TCC109 0
  (semtlpp_TCC108-1 nil 3847091012
   ("" (skeep*)
    (("" (replaces)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "s_inp")
            (("" (expand "astType?")
              (("" (lift-if)
                (("" (assert)
                  (("" (typepred "T") (("" (assert) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (astType type-decl nil ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (subterm_of type-eq-decl nil peg nil) (peg type-decl nil peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (ast type-eq-decl nil ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (below type-eq-decl nil naturalnumbers nil)
    (subterm adt-def-decl "boolean" peg nil)
    (sem_result type-eq-decl nil semantic_tlparser nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].opt(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T), semantic_tlparser.T)"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC110 0
  (semtlpp_TCC76-1 nil 3804395188
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (rewrite "lex4_lt")
        (("" (rewrite "lex3_lt")
          (("" (rewrite "lex2_lt")
            (("" (assert) (("" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((opt adt-constructor-decl "[peg -> (opt?)]" peg nil)
    (opt? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (pegMeasure const-decl "nat" peg nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (lex4_lt formula-decl nil lex4 nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (pegMeasure_opt formula-decl nil peg nil)
    (lex2_lt formula-decl nil lex2 nil)
    (lex3_lt formula-decl nil lex3 nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp termination
    "semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T, semantic_tlparser.res, (LAMBDA (status: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))), (T: semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)), (res: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): IF (status = ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure) THEN semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].opt(semantic_tlparser.s, semantic_tlparser.s, T), res) ELSE semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].opt(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T), T), res) ENDIF))"
    "nil")))
 (semtlpp_TCC111 0
  (semtlpp_TCC110-1 nil 3805033343
   ("" (skeep*)
    (("" (auto-rewrite -1)
      (("" (auto-rewrite "parsing")
        (("" (auto-rewrite "sempp")
          (("" (assert)
            ((""
              (typepred "v(P_exp, P_inp, A, e, inp, s, s_T, res,
        LAMBDA (status: astTypeOf(parsing(P_exp, A, e, inp, s, s_T))),
               (T: sem_result(P_inp, P_exp, A, e, inp, s, s_T)), (res: results(P_exp, P_inp, inp)):
          IF (status = failure)
            THEN cont(success, opt(s, s, T), res)
          ELSE cont(success, opt(s, e(T), T), res)
          ENDIF)")
              (("1" (propax) nil nil)
               ("2" (hide 2)
                (("2" (skeep*)
                  (("2" (liftassert+)
                    (("2" (expand "s_inp")
                      (("2" (liftassert+) nil nil)) nil))
                    nil))
                  nil))
                nil)
               ("3" (hide 2)
                (("3" (skeep*)
                  (("3" (wf-ast T) (("3" (flassert) nil nil)) nil))
                  nil))
                nil)
               ("4" (hide 2)
                (("4" (skeep*)
                  (("4" (liftassert+)
                    (("4" (wf-ast T) (("4" (flassert) nil nil)) nil))
                    nil))
                  nil))
                nil)
               ("5" (hide 2)
                (("5" (skeep*)
                  (("5" (assert)
                    (("5" (expand "s_inp")
                      (("5" (liftassert+) nil nil)) nil))
                    nil))
                  nil))
                nil)
               ("6" (hide 2)
                (("6" (skeep*)
                  (("6" (wf-ast T) (("6" (flassert) nil nil)) nil))
                  nil))
                nil)
               ("7" (hide 2)
                (("7" (skeep*)
                  (("7" (lift-if) (("7" (assert) nil nil)) nil)) nil))
                nil)
               ("8" (hide 2)
                (("8" (typepred "s_T") (("8" (flassert) nil nil)) nil))
                nil)
               ("9" (hide 2)
                (("9" (use "subterm_opt" (G "P_exp(A)"))
                  (("9" (flassert)
                    (("9" (typepred "G") (("9" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((opt adt-constructor-decl
     "[[below, below, {T: pre_ast | ¬skip?(T)}] -> (opt?)]" pre_ast
     nil)
    (opt? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (¬ const-decl "[bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (equalTo type-eq-decl nil semantic_parser nil)
    (pegMeasure const-decl "nat" peg nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (lex4 const-decl "ordinal" lex4 nil)
    (ordinal nonempty-type-eq-decl nil ordinals nil)
    (ordinal? def-decl "bool" ordinals nil)
    (< def-decl "bool" ordinals nil)
    (ordstruct type-decl nil ordstruct_adt nil)
    (sem_result type-eq-decl nil semantic_tlparser nil)
    (astTypeOf type-eq-decl nil semantic_parser nil)
    (subterm adt-def-decl "boolean" peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (results type-eq-decl nil semantic_parser nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semantic adt-constructor-decl
     "[[below, below, V_N[V_N_b], V_S] -> (semantic?)]" pre_ast nil)
    (semantic? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail adt-constructor-decl "[[below, below] -> (fail?)]" pre_ast
     nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (T adt-accessor-decl
     "[(known?) -> pre_ast[V_T, <=, V_N_b, bound, V_S]]"
     semantic_parser nil)
    (status adt-accessor-decl
            "[(known?) -> astType[V_T, <=, V_N_b, bound, V_S]]"
            semantic_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil) (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (input type-eq-decl nil ast_props nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (subterm_of type-eq-decl nil peg nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (astType? def-decl "astType" ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (known? adt-recognizer-decl "[saved_result -> boolean]"
     semantic_parser nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (saved_result type-decl nil semantic_parser nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (<= const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (pre_ast type-decl nil pre_ast nil)
    (astType type-decl nil ast nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (undefined adt-constructor-decl "(undefined?)" ast nil)
    (undefined? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (/= const-decl "boolean" notequal nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (subterm_opt formula-decl nil peg nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (sempp def-decl "[astTypeOf(parsing(P_exp, A, G, inp, s, s_T)),
 equalTo(s_inp(P_inp, parsing(P_exp, A, G, inp, s, s_T))),
 results(P_exp, P_inp, inp)]" semantic_parser nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T, semantic_tlparser.res, (LAMBDA (status: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))), (T: semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)), (res: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): IF (status = ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure) THEN semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].opt(semantic_tlparser.s, semantic_tlparser.s, T), res) ELSE semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].opt(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T), T), res) ENDIF))"
    "{x: [ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astType, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast, semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)] | x = semantic_tlparser.cont(semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].sempp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T, semantic_tlparser.res))}")))
 (semtlpp_TCC112 0
  (semtlpp_TCC78-1 nil 3804395188
   ("" (skeep*)
    (("" (lemma "peg[V_T, <=, V_N_b].subterm_transitivity")
      (("" (inst -1 "e" "G" "P_exp(A)")
        (("" (replace -2 * LR)
          (("" (assert)
            (("" (expand "subterm" 1)
              (("" (expand "subterm" 1) (("" (propax) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (subterm_transitivity formula-decl nil peg nil)
    (sub_notP formula-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.e"
    "{e: wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].Δ | peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].subterm(e, semantic_tlparser.P_exp(semantic_tlparser.A))}")))
 (semtlpp_TCC113 0
  (semtlpp_TCC79-1 nil 3804395188
   ("" (skeep*)
    (("" (typepred "s_T")
      (("" (assert)
        (("" (expand "g_wf" -)
          (("" (replace -3 * LR) (("" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.s_T"
    "{k: naturalnumbers.upto(semantic_tlparser.s) | booleans.⇒((k = semantic_tlparser.s), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].pattern_wf?(semantic_tlparser.e, semantic_tlparser.A, static_analysis[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].σ(semantic_tlparser.P_exp), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].P_0c(semantic_tlparser.P_exp)))}")))
 (semtlpp_TCC114 0
  (semtlpp_TCC113-1 nil 3847091012
   ("" (skeep*)
    (("" (replaces)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "astType?") (("" (propax) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success"
    "semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC115 0
  (semtlpp_TCC87-1 nil 3804395188
   ("" (skeep*)
    (("" (typepred "T")
      (("" (case "astWellformed?(T)")
        (("1" (assert)
          (("1" (expand "astWellformed?" -) (("1" (propax) nil nil))
            nil))
          nil)
         ("2" (assert) nil nil))
        nil))
      nil))
    nil)
   ((sem_result type-eq-decl nil semantic_tlparser nil)
    (subterm adt-def-decl "boolean" peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (ast type-eq-decl nil ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (subterm_of type-eq-decl nil peg nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.T"
    "{T: pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast | (booleans.¬)(pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].skip?(T))}")))
 (semtlpp_TCC116 0
  (semtlpp_TCC115-1 nil 3847091012
   ("" (skeep*)
    (("" (replaces)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "s_inp")
            (("" (expand "astType?")
              (("" (typepred "T") (("" (assert) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (astType type-decl nil ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (subterm_of type-eq-decl nil peg nil) (peg type-decl nil peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (ast type-eq-decl nil ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (below type-eq-decl nil naturalnumbers nil)
    (subterm adt-def-decl "boolean" peg nil)
    (sem_result type-eq-decl nil semantic_tlparser nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].notP(semantic_tlparser.s, semantic_tlparser.s, semantic_tlparser.T)"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC117 0
  (semtlpp_TCC116-1 nil 3847091012
   ("" (skeep*)
    (("" (auto-rewrite -1)
      (("" (assert)
        (("" (expand "parsing")
          (("" (wf-ast T) (("" (flassert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (sem_result type-eq-decl nil semantic_tlparser nil)
    (subterm adt-def-decl "boolean" peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (ast type-eq-decl nil ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (subterm_of type-eq-decl nil peg nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure"
    "semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC118 0
  (semtlpp_TCC117-1 nil 3847091012
   ("" (skeep*)
    (("" (replaces)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "s_inp")
            (("" (expand "astType?")
              (("" (lift-if)
                (("" (assert)
                  (("" (typepred "status")
                    (("" (use "Wellformed_theorem")
                      (("" (assert)
                        (("" (assert)
                          (("" (flatten) (("" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (astType type-decl nil ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (subterm_of type-eq-decl nil peg nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (<= const-decl "bool" reals nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (below type-eq-decl nil naturalnumbers nil)
    (subterm adt-def-decl "boolean" peg nil)
    (astTypeOf type-eq-decl nil semantic_parser nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, semantic_tlparser.s)"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC119 0
  (semtlpp_TCC83-1 nil 3804395188
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (rewrite "lex4_lt")
        (("" (rewrite "lex3_lt")
          (("" (rewrite "lex2_lt")
            (("" (assert) (("" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((notP adt-constructor-decl "[peg -> (notP?)]" peg nil)
    (notP? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (pegMeasure const-decl "nat" peg nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (lex4_lt formula-decl nil lex4 nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (pegMeasure_notP formula-decl nil peg nil)
    (lex2_lt formula-decl nil lex2 nil)
    (lex3_lt formula-decl nil lex3 nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp termination
    "semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T, semantic_tlparser.res, (LAMBDA (status: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))), (T: semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)), (res: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): IF (status = ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure) THEN semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].notP(semantic_tlparser.s, semantic_tlparser.s, T), res) ELSE semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, semantic_tlparser.s), res) ENDIF))"
    "nil")))
 (semtlpp_TCC120 0
  (semtlpp_TCC119-1 nil 3805033343
   ("" (skeep*)
    (("" (auto-rewrite -1)
      (("" (auto-rewrite "parsing")
        (("" (auto-rewrite "sempp")
          (("" (assert)
            ((""
              (typepred "v(P_exp, P_inp, A, e, inp, s, s_T, res,
        LAMBDA (status: astTypeOf(parsing(P_exp, A, e, inp, s, s_T))),
               (T: sem_result(P_inp, P_exp, A, e, inp, s, s_T)), (res: results(P_exp, P_inp, inp)):
          IF (status = failure)
            THEN cont(success, notP(s, s, T), res)
          ELSE cont(failure, fail(s, s), res)
          ENDIF)")
              (("1" (propax) nil nil)
               ("2" (hide 2)
                (("2" (skeep*)
                  (("2" (assert)
                    (("2" (expand "s_inp")
                      (("2" (wf-ast T) (("2" (flassert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("3" (hide 2)
                (("3" (skeep*)
                  (("3" (wf-ast T) (("3" (flassert) nil nil)) nil))
                  nil))
                nil)
               ("4" (hide 2)
                (("4" (skeep*)
                  (("4" (expand "s_inp")
                    (("4" (wf-ast T) (("4" (flassert) nil nil)) nil))
                    nil))
                  nil))
                nil)
               ("5" (hide 2)
                (("5" (skeep*)
                  (("5" (wf-ast T) (("5" (flassert) nil nil)) nil))
                  nil))
                nil)
               ("6" (hide 2)
                (("6" (skeep*)
                  (("6" (wf-ast T) (("6" (flassert) nil nil)) nil))
                  nil))
                nil)
               ("7" (hide 2)
                (("7" (typepred "s_T") (("7" (flassert) nil nil)) nil))
                nil)
               ("8" (hide 2)
                (("8" (use "subterm_notP" (G "P_exp(A)"))
                  (("8" (flassert)
                    (("8" (typepred "G") (("8" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((notP adt-constructor-decl
     "[[below, below, {T: pre_ast | ¬skip?(T)}] -> (notP?)]" pre_ast
     nil)
    (notP? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (¬ const-decl "[bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (equalTo type-eq-decl nil semantic_parser nil)
    (pegMeasure const-decl "nat" peg nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (lex4 const-decl "ordinal" lex4 nil)
    (ordinal nonempty-type-eq-decl nil ordinals nil)
    (ordinal? def-decl "bool" ordinals nil)
    (< def-decl "bool" ordinals nil)
    (ordstruct type-decl nil ordstruct_adt nil)
    (sem_result type-eq-decl nil semantic_tlparser nil)
    (astTypeOf type-eq-decl nil semantic_parser nil)
    (subterm adt-def-decl "boolean" peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (results type-eq-decl nil semantic_parser nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semantic adt-constructor-decl
     "[[below, below, V_N[V_N_b], V_S] -> (semantic?)]" pre_ast nil)
    (semantic? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail adt-constructor-decl "[[below, below] -> (fail?)]" pre_ast
     nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (T adt-accessor-decl
     "[(known?) -> pre_ast[V_T, <=, V_N_b, bound, V_S]]"
     semantic_parser nil)
    (status adt-accessor-decl
            "[(known?) -> astType[V_T, <=, V_N_b, bound, V_S]]"
            semantic_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil) (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (input type-eq-decl nil ast_props nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (subterm_of type-eq-decl nil peg nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (astType? def-decl "astType" ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (known? adt-recognizer-decl "[saved_result -> boolean]"
     semantic_parser nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (saved_result type-decl nil semantic_parser nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (<= const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (pre_ast type-decl nil pre_ast nil)
    (astType type-decl nil ast nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (undefined adt-constructor-decl "(undefined?)" ast nil)
    (undefined? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (subterm_notP formula-decl nil peg nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (sempp def-decl "[astTypeOf(parsing(P_exp, A, G, inp, s, s_T)),
 equalTo(s_inp(P_inp, parsing(P_exp, A, G, inp, s, s_T))),
 results(P_exp, P_inp, inp)]" semantic_parser nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T, semantic_tlparser.res, (LAMBDA (status: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))), (T: semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)), (res: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): IF (status = ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure) THEN semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].notP(semantic_tlparser.s, semantic_tlparser.s, T), res) ELSE semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, semantic_tlparser.s), res) ENDIF))"
    "{x: [ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astType, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast, semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)] | x = semantic_tlparser.cont(semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].sempp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T, semantic_tlparser.res))}")))
 (semtlpp_TCC121 0
  (semtlpp_TCC85-1 nil 3804395188
   ("" (skeep*)
    (("" (lemma "peg[V_T, <=, V_N_b].subterm_transitivity")
      (("" (inst -1 "e" "G" "P_exp(A)")
        (("" (replace -2 * LR)
          (("" (assert)
            (("" (expand "subterm" 1)
              (("" (expand "subterm" 1) (("" (propax) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (subterm_transitivity formula-decl nil peg nil)
    (sub_andP formula-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.e"
    "{e: wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].Δ | peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].subterm(e, semantic_tlparser.P_exp(semantic_tlparser.A))}")))
 (semtlpp_TCC122 0
  (semtlpp_TCC86-1 nil 3804395188
   ("" (skeep*)
    (("" (typepred "s_T")
      (("" (assert)
        (("" (expand "g_wf" -)
          (("" (replace -3 * LR) (("" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.s_T"
    "{k: naturalnumbers.upto(semantic_tlparser.s) | booleans.⇒((k = semantic_tlparser.s), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].pattern_wf?(semantic_tlparser.e, semantic_tlparser.A, static_analysis[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].σ(semantic_tlparser.P_exp), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].P_0c(semantic_tlparser.P_exp)))}")))
 (semtlpp_TCC123 0
  (semtlpp_TCC122-1 nil 3847091012
   ("" (skeep*)
    (("" (replaces)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "astType?")
            (("" (typepred "status") (("" (assert) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success"
    "semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC124 0
  (semtlpp_TCC108-1 nil 3804487992
   ("" (skeep*) (("" (wf-ast T) (("" (flassert) nil nil)) nil)) nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (subterm_of type-eq-decl nil peg nil) (peg type-decl nil peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (ast type-eq-decl nil ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (below type-eq-decl nil naturalnumbers nil)
    (subterm adt-def-decl "boolean" peg nil)
    (sem_result type-eq-decl nil semantic_tlparser nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.T"
    "{T: pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast | (booleans.¬)(pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].skip?(T))}")))
 (semtlpp_TCC125 0
  (semtlpp_TCC124-1 nil 3847091012
   ("" (skeep*)
    (("" (replaces)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "s_inp")
            (("" (expand "astType?")
              (("" (typepred "status") (("" (assert) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (astType type-decl nil ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (subterm_of type-eq-decl nil peg nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (<= const-decl "bool" reals nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (below type-eq-decl nil naturalnumbers nil)
    (subterm adt-def-decl "boolean" peg nil)
    (astTypeOf type-eq-decl nil semantic_parser nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].andP(semantic_tlparser.s, semantic_tlparser.s, semantic_tlparser.T)"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC126 0
  (semtlpp_TCC125-1 nil 3847091012
   ("" (skeep*)
    (("" (replaces)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "astType?")
            (("" (typepred "status")
              (("" (assert)
                (("" (use "Wellformed_theorem") (("" (assert) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (astTypeOf type-eq-decl nil semantic_parser nil)
    (subterm adt-def-decl "boolean" peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (<= const-decl "bool" reals nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (< const-decl "bool" reals nil)
    (subterm_of type-eq-decl nil peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (astType type-decl nil ast nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure"
    "semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC127 0
  (semtlpp_TCC126-1 nil 3847091012
   ("" (skeep*)
    (("" (replaces)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "s_inp")
            (("" (expand "astType?")
              (("" (typepred "status")
                (("" (lift-if)
                  (("" (assert)
                    (("" (use "Wellformed_theorem")
                      (("" (assert)
                        (("" (flatten) (("" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (astType type-decl nil ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (subterm_of type-eq-decl nil peg nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (<= const-decl "bool" reals nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (below type-eq-decl nil naturalnumbers nil)
    (subterm adt-def-decl "boolean" peg nil)
    (astTypeOf type-eq-decl nil semantic_parser nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, semantic_tlparser.s)"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC128 0
  (semtlpp_TCC90-1 nil 3804395188
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (rewrite "lex4_lt")
        (("" (rewrite "lex3_lt")
          (("" (rewrite "lex2_lt")
            (("" (assert) (("" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((andP adt-constructor-decl "[peg -> (andP?)]" peg nil)
    (andP? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (pegMeasure const-decl "nat" peg nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (lex4_lt formula-decl nil lex4 nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (pegMeasure_andP formula-decl nil peg nil)
    (lex2_lt formula-decl nil lex2 nil)
    (lex3_lt formula-decl nil lex3 nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp termination
    "semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T, semantic_tlparser.res, (LAMBDA (status: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))), (T: semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)), (res: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): IF (status = ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success) THEN semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].andP(semantic_tlparser.s, semantic_tlparser.s, T), res) ELSE semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, semantic_tlparser.s), res) ENDIF))"
    "nil")))
 (semtlpp_TCC129 0
  (semtlpp_TCC128-1 nil 3805033343
   ("" (skeep*)
    (("" (auto-rewrite -1)
      (("" (auto-rewrite "parsing")
        (("" (auto-rewrite "sempp")
          (("" (assert)
            ((""
              (typepred "v(P_exp, P_inp, A, e, inp, s, s_T, res,
        LAMBDA (status: astTypeOf(parsing(P_exp, A, e, inp, s, s_T))),
               (T: sem_result(P_inp, P_exp, A, e, inp, s, s_T)), (res: results(P_exp, P_inp, inp)):
          IF (status = success)
            THEN cont(success, andP(s, s, T), res)
          ELSE cont(failure, fail(s, s), res)
          ENDIF)")
              (("1" (propax) nil nil)
               ("2" (hide 2)
                (("2" (skeep*)
                  (("2" (expand "s_inp")
                    (("2" (wf-ast T) (("2" (flassert) nil nil)) nil))
                    nil))
                  nil))
                nil)
               ("3" (hide 2)
                (("3" (skeep*)
                  (("3" (wf-ast T) (("3" (flassert) nil nil)) nil))
                  nil))
                nil)
               ("4" (hide 2)
                (("4" (skeep*)
                  (("4" (expand "s_inp")
                    (("4" (wf-ast T) (("4" (flassert) nil nil)) nil))
                    nil))
                  nil))
                nil)
               ("5" (hide 2)
                (("5" (skeep*)
                  (("5" (wf-ast T) (("5" (flassert) nil nil)) nil))
                  nil))
                nil)
               ("6" (hide 2)
                (("6" (skeep*)
                  (("6" (wf-ast T) (("6" (flassert) nil nil)) nil))
                  nil))
                nil)
               ("7" (hide 2)
                (("7" (typepred "s_T") (("7" (flassert) nil nil)) nil))
                nil)
               ("8" (hide 2)
                (("8" (use "subterm_andP" (G "P_exp(A)"))
                  (("8" (flassert)
                    (("8" (typepred "G") (("8" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((andP adt-constructor-decl
     "[[below, below, {T: pre_ast | ¬skip?(T)}] -> (andP?)]" pre_ast
     nil)
    (andP? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (¬ const-decl "[bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (equalTo type-eq-decl nil semantic_parser nil)
    (pegMeasure const-decl "nat" peg nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (lex4 const-decl "ordinal" lex4 nil)
    (ordinal nonempty-type-eq-decl nil ordinals nil)
    (ordinal? def-decl "bool" ordinals nil)
    (< def-decl "bool" ordinals nil)
    (ordstruct type-decl nil ordstruct_adt nil)
    (sem_result type-eq-decl nil semantic_tlparser nil)
    (astTypeOf type-eq-decl nil semantic_parser nil)
    (subterm adt-def-decl "boolean" peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (results type-eq-decl nil semantic_parser nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semantic adt-constructor-decl
     "[[below, below, V_N[V_N_b], V_S] -> (semantic?)]" pre_ast nil)
    (semantic? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail adt-constructor-decl "[[below, below] -> (fail?)]" pre_ast
     nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (T adt-accessor-decl
     "[(known?) -> pre_ast[V_T, <=, V_N_b, bound, V_S]]"
     semantic_parser nil)
    (status adt-accessor-decl
            "[(known?) -> astType[V_T, <=, V_N_b, bound, V_S]]"
            semantic_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil) (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (input type-eq-decl nil ast_props nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (subterm_of type-eq-decl nil peg nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (astType? def-decl "astType" ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (known? adt-recognizer-decl "[saved_result -> boolean]"
     semantic_parser nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (saved_result type-decl nil semantic_parser nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (<= const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (pre_ast type-decl nil pre_ast nil)
    (astType type-decl nil ast nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (subterm_andP formula-decl nil peg nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (sempp def-decl "[astTypeOf(parsing(P_exp, A, G, inp, s, s_T)),
 equalTo(s_inp(P_inp, parsing(P_exp, A, G, inp, s, s_T))),
 results(P_exp, P_inp, inp)]" semantic_parser nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T, semantic_tlparser.res, (LAMBDA (status: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))), (T: semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)), (res: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): IF (status = ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success) THEN semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].andP(semantic_tlparser.s, semantic_tlparser.s, T), res) ELSE semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, semantic_tlparser.s), res) ENDIF))"
    "{x: [ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astType, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast, semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)] | x = semantic_tlparser.cont(semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].sempp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T, semantic_tlparser.res))}")))
 (semantic_tlparser_correct 0
  (semantic_tlparser_correct-1 nil 3804495937
   ("" (skeep*)
    ((""
      (typepred "semtlpp(P_exp, P_inp, A, G, inp, s, s_T, res,
              LAMBDA (x:
                        [astTypeOf(parsing(P_exp, A, G, inp, s, s_T)),
                         sem_result(P_inp, P_exp, A, G, inp, s, s_T),
                         results(P_exp, P_inp, inp)]):
                (x`1, x`2, x`3))")
      (("" (replaces) (("" (assert) nil nil)) nil)) nil))
    nil)
   ((semtlpp def-decl
     "{x: [astType, pre_ast, results(P_exp, P_inp, inp)] |
   x = cont(sempp(P_exp, P_inp, A, G, inp, s, s_T, res))}"
     semantic_tlparser nil)
    (sempp def-decl "[astTypeOf(parsing(P_exp, A, G, inp, s, s_T)),
 equalTo(s_inp(P_inp, parsing(P_exp, A, G, inp, s, s_T))),
 results(P_exp, P_inp, inp)]" semantic_parser nil)
    (equalTo type-eq-decl nil semantic_parser nil)
    (sem_result type-eq-decl nil semantic_tlparser nil)
    (astTypeOf type-eq-decl nil semantic_parser nil)
    (subterm adt-def-decl "boolean" peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (results type-eq-decl nil semantic_parser nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semantic adt-constructor-decl
     "[[below, below, V_N[V_N_b], V_S] -> (semantic?)]" pre_ast nil)
    (semantic? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail adt-constructor-decl "[[below, below] -> (fail?)]" pre_ast
     nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (T adt-accessor-decl
     "[(known?) -> pre_ast[V_T, <=, V_N_b, bound, V_S]]"
     semantic_parser nil)
    (status adt-accessor-decl
            "[(known?) -> astType[V_T, <=, V_N_b, bound, V_S]]"
            semantic_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil) (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (input type-eq-decl nil ast_props nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (subterm_of type-eq-decl nil peg nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (astType? def-decl "astType" ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (known? adt-recognizer-decl "[saved_result -> boolean]"
     semantic_parser nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (saved_result type-decl nil semantic_parser nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (<= const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (pre_ast type-decl nil pre_ast nil)
    (astType type-decl nil ast nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak)))

