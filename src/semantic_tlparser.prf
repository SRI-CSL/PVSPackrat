(semantic_tlparser
 (sem_result_TCC1 0
  (sem_result_TCC1-1 nil 3804417092 ("" (subtype-tcc) nil nil) nil nil
   (sem_result subtype "semantic_tlparser.A"
    "naturalnumbers.upto(semantic_tlparser.V_N_b)")))
 (semtlpp_TCC1 0
  (semtlpp_TCC1-1 nil 3804853796
   ("" (expand "subterm") (("" (propax) nil nil)) nil)
   ((subterm adt-def-decl "boolean" peg nil)) nil
   (semtlpp subtype "semantic_tlparser.P_exp(semantic_tlparser.A)"
    "{e: wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].Δ | peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].subterm(e, semantic_tlparser.P_exp(semantic_tlparser.A))}")))
 (semtlpp_TCC2 0
  (semtlpp_TCC11-1 nil 3804395188
   ("" (skeep*)
    (("" (typepred "P_exp")
      (("" (expand "strong_WF")
        (("" (assert) (("" (inst? -) nil nil)) nil)) nil))
      nil))
    nil)
   ((WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (V_N type-eq-decl nil nTpred_order nil))
   nil
   (semtlpp subtype "semantic_tlparser.s"
    "{k: naturalnumbers.upto(semantic_tlparser.s) | booleans.⇒((k = semantic_tlparser.s), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].g_wf(semantic_tlparser.P_exp(semantic_tlparser.A), semantic_tlparser.A, wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].P_0c?(semantic_tlparser.P_exp), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].strong))}")))
 (semtlpp_TCC3 0
  (semtlpp_TCC2-1 nil 3804395188 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype
    "(number_fields.-)(semantic_tlparser.bound, semantic_tlparser.s_T)"
    "nat")))
 (semtlpp_TCC4 0
  (semtlpp_TCC3-1 nil 3804395188 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype
    "(number_fields.-)(semantic_tlparser.bound, semantic_tlparser.s)"
    "nat")))
 (semtlpp_TCC5 0
  (semtlpp_TCC4-1 nil 3804395188
   ("" (skeep)
    (("" (assert)
      (("" (typepred "z`6")
        (("" (typepred "z`7") (("" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((WF_nT type-eq-decl nil wf_peg nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (peg type-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (input type-eq-decl nil ast_props nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (saved_result type-decl nil semantic_parser nil)
    (known? adt-recognizer-decl "[saved_result -> boolean]"
     semantic_parser nil)
    (astType type-decl nil ast nil) (pre_ast type-decl nil pre_ast nil)
    (astType? def-decl "astType" ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil) (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (status adt-accessor-decl
            "[(known?) -> astType[V_T, <=, V_N_b, bound, V_S]]"
            semantic_parser nil)
    (T adt-accessor-decl
     "[(known?) -> pre_ast[V_T, <=, V_N_b, bound, V_S]]"
     semantic_parser nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail adt-constructor-decl "[[below, below] -> (fail?)]" pre_ast
     nil)
    (semantic? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (semantic adt-constructor-decl
     "[[below, below, V_N[V_N_b], V_S] -> (semantic?)]" pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (results type-eq-decl nil semantic_parser nil)
    (astTypeOf type-eq-decl nil semantic_parser nil))
   nil
   (semtlpp subtype
    "(number_fields.-)(semantic_tlparser.bound, semantic_tlparser.z`7)"
    "nat")))
 (semtlpp_TCC6 0
  (semtlpp_TCC5-1 nil 3804395188 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype
    "(number_fields.-)(semantic_tlparser.bound, semantic_tlparser.z`6)"
    "nat")))
 (semtlpp_TCC7 0
  (semtlpp_TCC6-1 nil 3804395188 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype
    "(number_fields.-)(semantic_tlparser.bound, semantic_tlparser.s_T)"
    "nat")))
 (semtlpp_TCC8 0
  (semtlpp_TCC7-1 nil 3804395188 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype
    "(number_fields.-)(semantic_tlparser.bound, semantic_tlparser.s)"
    "nat")))
 (semtlpp_TCC9 0
  (semtlpp_TCC15-1 nil 3804395188
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (assert)
        (("" (expand "parsing")
          (("" (expand "astType?") (("" (propax) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (astType? def-decl "astType" ast nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success"
    "semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC10 0
  (semtlpp_TCC18-1 nil 3804395188
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (assert)
        (("" (expand "parsing")
          (("" (expand "s_inp")
            (("" (expand "astType?") (("" (propax) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (astType? def-decl "astType" ast nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].ε(semantic_tlparser.s, semantic_tlparser.s)"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC11 0
  (semtlpp_TCC20-1 nil 3804395188
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (assert)
        (("" (expand "parsing")
          (("" (expand "astType?")
            (("" (expand "min") (("" (propax) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (astType? def-decl "astType" ast nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure"
    "semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC12 0
  (semtlpp_TCC23-1 nil 3804395188
   ("" (skeep)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (expand "s_inp")
          (("" (expand "astType?")
            (("" (expand "min") (("" (assert) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, semantic_tlparser.s)"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC13 0
  (semtlpp_TCC26-1 nil 3804395188
   ("" (skeep)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (expand "astType?")
          (("" (expand "min") (("" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success"
    "semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC14 0
  (semtlpp_TCC8-1 nil 3804395188
   ("" (skeep) (("" (assert) nil nil)) nil) nil nil
   (semtlpp subtype "(number_fields.+)(semantic_tlparser.s, 1)"
    "below[V_T, <=, V_N_b, bound, V_S]")))
 (semtlpp_TCC15 0
  (semtlpp_TCC28-1 nil 3804395188
   ("" (skeep)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (expand "s_inp")
          (("" (expand "astType?")
            (("" (expand "min") (("" (assert) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].any(semantic_tlparser.s, (number_fields.+)(semantic_tlparser.s, 1), semantic_tlparser.inp(semantic_tlparser.s))"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC16 0
  (semtlpp_TCC30-1 nil 3804395188
   ("" (skeep)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (expand "astType?")
          (("" (expand "min") (("" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success"
    "semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC17 0
  (semtlpp_TCC32-1 nil 3804395188
   ("" (skeep)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (expand "s_inp")
          (("" (expand "astType?")
            (("" (expand "min") (("" (assert) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].terminal(semantic_tlparser.s, (number_fields.+)(semantic_tlparser.s, 1), semantic_tlparser.a, semantic_tlparser.a)"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC18 0
  (semtlpp_TCC36-1 nil 3804395188
   ("" (skeep)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (expand "astType?")
          (("" (expand "min")
            (("" (assert)
              (("" (lift-if)
                (("" (assert)
                  (("" (split)
                    (("1" (assert) nil nil) ("2" (assert) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure"
    "semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC19 0
  (semtlpp_TCC40-1 nil 3804395188
   ("" (skeep)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (expand "s_inp")
          (("" (expand "astType?")
            (("" (expand "min")
              (("" (assert)
                (("" (lift-if)
                  (("" (assert)
                    (("" (lift-if)
                      (("" (assert)
                        (("" (split 1)
                          (("1" (assert) nil nil)
                           ("2" (assert) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, real_defs.min((number_fields.+)(semantic_tlparser.s, 1), semantic_tlparser.bound))"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC20 0
  (semtlpp_TCC41-1 nil 3804395188
   ("" (skeep)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (expand "astType?")
          (("" (expand "min") (("" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success"
    "semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC21 0
  (semtlpp_TCC43-1 nil 3804395188
   ("" (skeep)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (expand "s_inp")
          (("" (expand "astType?")
            (("" (expand "min") (("" (assert) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].range(semantic_tlparser.s, (number_fields.+)(semantic_tlparser.s, 1), semantic_tlparser.a, semantic_tlparser.b, semantic_tlparser.inp(semantic_tlparser.s))"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC22 0
  (semtlpp_TCC45-1 nil 3804395188
   ("" (skeep)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (expand "astType?")
          (("" (expand "min")
            (("" (assert)
              (("" (lift-if)
                (("" (assert)
                  (("" (lift-if)
                    (("" (assert)
                      (("" (split 1)
                        (("1" (assert) nil nil) ("2" (assert) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure"
    "semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC23 0
  (semtlpp_TCC49-1 nil 3804395188
   ("" (skeep)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (expand "s_inp")
          (("" (expand "astType?")
            (("" (expand "min")
              (("" (assert) (("" (grind) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (in_range const-decl "bool" ast nil)
    (astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, real_defs.min((number_fields.+)(semantic_tlparser.s, 1), semantic_tlparser.bound))"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC24 0
  (semtlpp_TCC54-1 nil 3804395188
   ("" (skeep)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (expand "astType?")
          (("" (typepred "res")
            (("" (inst -1 "B" "s")
              (("" (replace -3 * LR)
                (("" (assert) (("" (ground) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (<= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (saved_result type-decl nil semantic_parser nil)
    (known? adt-recognizer-decl "[saved_result -> boolean]"
     semantic_parser nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (astType type-decl nil ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (peg type-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (input type-eq-decl nil ast_props nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil) (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (status adt-accessor-decl
            "[(known?) -> astType[V_T, <=, V_N_b, bound, V_S]]"
            semantic_parser nil)
    (T adt-accessor-decl
     "[(known?) -> pre_ast[V_T, <=, V_N_b, bound, V_S]]"
     semantic_parser nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail adt-constructor-decl "[[below, below] -> (fail?)]" pre_ast
     nil)
    (semantic? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (semantic adt-constructor-decl
     "[[below, below, V_N[V_N_b], V_S] -> (semantic?)]" pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (results type-eq-decl nil semantic_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype "semantic_tlparser.status"
    "semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC25 0
  (semtlpp_TCC12-1 nil 3804395188
   ("" (skeep)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (expand "s_inp")
          (("" (typepred "res")
            (("" (inst -1 B s)
              (("" (assert)
                (("" (expand "astType?" 1 1)
                  (("" (assert)
                    ((""
                      (lemma "Wellformed_theorem"
                       (T "parsing(P_exp, B, P_exp(B), inp, s, s)"))
                      (("1" (lift-if)
                        (("1" (ground)
                          (("1" (replace -8 * LR)
                            (("1" (assert) nil nil)) nil)
                           ("2" (replace -7 * LR)
                            (("2" (assert) nil nil)) nil))
                          nil))
                        nil)
                       ("2" (typepred "P_exp")
                        (("2" (expand "strong_WF")
                          (("2" (inst -1 "B") nil nil)) nil))
                        nil)
                       ("3" (expand "subterm") (("3" (propax) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (<= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (saved_result type-decl nil semantic_parser nil)
    (known? adt-recognizer-decl "[saved_result -> boolean]"
     semantic_parser nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (astType type-decl nil ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (astType? def-decl "astType" ast nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (peg type-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (input type-eq-decl nil ast_props nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil) (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (status adt-accessor-decl
            "[(known?) -> astType[V_T, <=, V_N_b, bound, V_S]]"
            semantic_parser nil)
    (T adt-accessor-decl
     "[(known?) -> pre_ast[V_T, <=, V_N_b, bound, V_S]]"
     semantic_parser nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail adt-constructor-decl "[[below, below] -> (fail?)]" pre_ast
     nil)
    (semantic? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (semantic adt-constructor-decl
     "[[below, below, V_N[V_N_b], V_S] -> (semantic?)]" pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (results type-eq-decl nil semantic_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype "semantic_tlparser.T_B"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC26 0
  (semtlpp_TCC10-1 nil 3804395188
   ("" (assert) (("" (expand "subterm") (("" (propax) nil nil)) nil))
    nil)
   ((subterm adt-def-decl "boolean" peg nil)) nil
   (semtlpp subtype "semantic_tlparser.P_exp(semantic_tlparser.B)"
    "{e: wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].Δ | peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].subterm(e, semantic_tlparser.P_exp(semantic_tlparser.B))}")))
 (semtlpp_TCC27 0
  (semtlpp_TCC27-1 nil 3804853796 ("" (subtype-tcc) nil nil)
   ((V_N type-eq-decl nil nTpred_order nil) (peg type-decl nil peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (saved_result type-decl nil semantic_parser nil)
    (known? adt-recognizer-decl "[saved_result -> boolean]"
     semantic_parser nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (astType type-decl nil ast nil) (pre_ast type-decl nil pre_ast nil)
    (astType? def-decl "astType" ast nil)
    (input type-eq-decl nil ast_props nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil) (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (status adt-accessor-decl
            "[(known?) -> astType[V_T, <=, V_N_b, bound, V_S]]"
            semantic_parser nil)
    (T adt-accessor-decl
     "[(known?) -> pre_ast[V_T, <=, V_N_b, bound, V_S]]"
     semantic_parser nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail adt-constructor-decl "[[below, below] -> (fail?)]" pre_ast
     nil)
    (semantic? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (semantic adt-constructor-decl
     "[[below, below, V_N[V_N_b], V_S] -> (semantic?)]" pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (results type-eq-decl nil semantic_parser nil)
    (strong const-decl "bool" wf_peg nil))
   nil
   (semtlpp subtype "semantic_tlparser.s"
    "{k: naturalnumbers.upto(semantic_tlparser.s) | booleans.⇒((k = semantic_tlparser.s), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].g_wf(semantic_tlparser.P_exp(semantic_tlparser.B), semantic_tlparser.B, wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].P_0c?(semantic_tlparser.P_exp), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].strong))}")))
 (semtlpp_TCC28 0
  (semtlpp_TCC56-1 nil 3804395188
   ("" (skeep)
    (("" (typepred "T_B")
      (("" (replace -1 * LR) (("" (assert) nil nil)) nil)) nil))
    nil)
   ((parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (ast type-eq-decl nil ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil) (WF_nT type-eq-decl nil wf_peg nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (pre_ast type-decl nil pre_ast nil))
   nil
   (semtlpp subtype "semantic_tlparser.T_B"
    "semanticTree[V_T, <=, V_N_b, bound, V_S]")))
 (semtlpp_TCC29 0
  (semtlpp_TCC58-1 nil 3804395188
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (simplify)
        (("" (expand "parsing")
          (("" (expand "astType?")
            (("" (typepred "T_B")
              ((""
                (lemma "semantic_interp_props"
                 ("T" "parsing(P_exp, B, P_exp(B), inp, s, s)" "P_inp"
                  "P_inp"))
                (("" (flatten) (("" (assert) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (ast type-eq-decl nil ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil) (WF_nT type-eq-decl nil wf_peg nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (pre_ast type-decl nil pre_ast nil)
    (semantic_interp_props formula-decl nil semantic_interp nil)
    (astType? def-decl "astType" ast nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success"
    "semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC30 0
  (semtlpp_TCC13-1 nil 3804395188
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (expand "s_inp")
          (("" (typepred "status")
            (("" (expand "astType?" 1 1) (("" (assert) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (astType type-decl nil ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (astType? def-decl "astType" ast nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (peg type-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (<= const-decl "bool" reals nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (astTypeOf type-eq-decl nil semantic_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.sem_T"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC31 0
  (semtlpp_TCC61-1 nil 3804395188
   ("" (skeep*)
    (("" (lift-if -5)
      (("" (split -)
        (("1" (flatten)
          (("1" (decompose-equality -)
            (("1" (replace -1 * LR)
              (("1" (replace -2 * LR)
                (("1" (assert) (("1" (assert) nil nil)) nil)) nil))
              nil))
            nil))
          nil)
         ("2" (flatten)
          (("2" (assert)
            (("2" (typepred "res1")
              (("2" (inst - "A!1" "s_1")
                (("2" (assert)
                  (("2" (split -1)
                    (("1" (hide 3)
                      (("1" (flatten) (("1" (assert) nil nil)) nil))
                      nil)
                     ("2" (hide 2)
                      (("2" (flatten)
                        (("2" (assert)
                          (("2" (assert)
                            (("2" (split 2)
                              (("1"
                                (assert)
                                (("1"
                                  (lift-if)
                                  (("1" (assert) nil nil))
                                  nil))
                                nil)
                               ("2"
                                (lift-if)
                                (("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((results type-eq-decl nil semantic_parser nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semantic adt-constructor-decl
     "[[below, below, V_N[V_N_b], V_S] -> (semantic?)]" pre_ast nil)
    (semantic? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail adt-constructor-decl "[[below, below] -> (fail?)]" pre_ast
     nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (T adt-accessor-decl
     "[(known?) -> pre_ast[V_T, <=, V_N_b, bound, V_S]]"
     semantic_parser nil)
    (status adt-accessor-decl
            "[(known?) -> astType[V_T, <=, V_N_b, bound, V_S]]"
            semantic_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil) (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (input type-eq-decl nil ast_props nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil) (WF_nT type-eq-decl nil wf_peg nil)
    (astType? def-decl "astType" ast nil)
    (pre_ast type-decl nil pre_ast nil) (astType type-decl nil ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (known? adt-recognizer-decl "[saved_result -> boolean]"
     semantic_parser nil)
    (saved_result type-decl nil semantic_parser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (below type-eq-decl nil naturalnumbers nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (<= const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil) (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "semantic_tlparser.res WITH [(semantic_tlparser.B, semantic_tlparser.s) := semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].known(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, semantic_tlparser.sem_T)]"
    "semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)")))
 (semtlpp_TCC32 0
  (semtlpp_TCC66-1 nil 3804395188
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (expand "astType?")
          (("" (assert)
            (("" (typepred "status")
              ((""
                (lemma "Wellformed_theorem"
                 (T "parsing(P_exp, B, P_exp(B), inp, s, s)"))
                (("" (assert) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (astTypeOf type-eq-decl nil semantic_parser nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (<= const-decl "bool" reals nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (astType type-decl nil ast nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure"
    "semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC33 0
  (semtlpp_TCC16-1 nil 3804395188
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (typepred "T_B")
          ((""
            (lemma "Wellformed_theorem"
             (T "(parsing(P_exp, B, P_exp(B), inp, s, s))"))
            (("" (assert)
              (("" (flatten)
                (("" (expand "s_inp" +)
                  (("" (assert)
                    (("" (lift-if)
                      (("" (ground)
                        (("" (expand "astType?" +)
                          (("" (propax) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((sem_result type-eq-decl nil semantic_tlparser nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (ast type-eq-decl nil ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.fail_T"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC34 0
  (semtlpp_TCC14-1 nil 3804395188
   ("" (skeep*)
    (("" (lift-if -)
      (("" (split -)
        (("1" (flatten)
          (("1" (decompose-equality -)
            (("1" (replace -1 * LR)
              (("1" (replace -2 * LR)
                (("1" (assert)
                  (("1" (typepred "T_B")
                    (("1" (assert)
                      (("1" (typepred "status")
                        (("1"
                          (lemma "Wellformed_theorem"
                           (T
                            "(parsing(P_exp, B, P_exp(B), inp, s, s))"))
                          (("1" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (flatten)
          (("2" (typepred "res1")
            (("2" (inst -1 A!1 s_1)
              (("2" (assert)
                (("2" (ground)
                  (("1" (assert) nil nil) ("2" (assert) nil nil)
                   ("3" (assert) nil nil) ("4" (assert) nil nil)
                   ("5" (assert) nil nil) ("6" (assert) nil nil)
                   ("7" (assert) nil nil) ("8" (assert) nil nil)
                   ("9" (assert) nil nil) ("10" (assert) nil nil)
                   ("11" (assert) nil nil) ("12" (assert) nil nil)
                   ("13" (assert) nil nil) ("14" (assert) nil nil)
                   ("15" (assert) nil nil) ("16" (assert) nil nil)
                   ("17" (assert) nil nil) ("18" (assert) nil nil)
                   ("19" (assert) nil nil) ("20" (assert) nil nil)
                   ("21" (assert) nil nil) ("22" (assert) nil nil)
                   ("23" (assert) nil nil) ("24" (assert) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((saved_result type-decl nil semantic_parser nil)
    (known? adt-recognizer-decl "[saved_result -> boolean]"
     semantic_parser nil)
    (status adt-accessor-decl
            "[(known?) -> astType[V_T, <=, V_N_b, bound, V_S]]"
            semantic_parser nil)
    (T adt-accessor-decl
     "[(known?) -> pre_ast[V_T, <=, V_N_b, bound, V_S]]"
     semantic_parser nil)
    (fail adt-constructor-decl "[[below, below] -> (fail?)]" pre_ast
     nil)
    (semantic? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (semantic adt-constructor-decl
     "[[below, below, V_N[V_N_b], V_S] -> (semantic?)]" pre_ast nil)
    (results type-eq-decl nil semantic_parser nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (astTypeOf type-eq-decl nil semantic_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (pre_ast type-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (WF_nT type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (ast type-eq-decl nil ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (sem_result type-eq-decl nil semantic_tlparser nil)
    (below type-eq-decl nil naturalnumbers nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (<= const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil) (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "semantic_tlparser.res WITH [(semantic_tlparser.B, semantic_tlparser.s) := semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].known(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure, semantic_tlparser.fail_T)]"
    "semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)")))
 (semtlpp_TCC35 0
  (semtlpp_TCC19-1 nil 3804395188
   ("" (assert)
    (("" (skeep*)
      (("" (replace -1 * LR)
        (("" (assert)
          (("" (typepred "s_T") (("" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (pegMeasure const-decl "nat" peg nil) (peg type-decl nil peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil))
   nil
   (semtlpp termination
    "semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.B, semantic_tlparser.P_exp(semantic_tlparser.B), semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s, semantic_tlparser.res, (LAMBDA (status: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.B, semantic_tlparser.P_exp(semantic_tlparser.B), semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s))), (T_B: semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.B, semantic_tlparser.P_exp(semantic_tlparser.B), semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s)), (res: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): IF (status = ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success) THEN LET sem_T = pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].semantic(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T_B), semantic_tlparser.B, semantic_tlparser.P_inp(semantic_tlparser.B, T_B)) IN semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, semantic_tlparser.sem_T, res WITH [(semantic_tlparser.B, semantic_tlparser.s) := semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].known(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, semantic_tlparser.sem_T)]) ELSE LET fail_T = pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T_B)) IN semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure, semantic_tlparser.fail_T, res WITH [(semantic_tlparser.B, semantic_tlparser.s) := semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].known(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure, semantic_tlparser.fail_T)]) ENDIF))"
    "nil")))
 (semtlpp_TCC36 0
  (semtlpp_TCC21-1 nil 3804395188
   ("" (skeep*)
    (("" (ground)
      (("" (typepred "G")
        (("" (lemma "peg[V_T, <=, V_N_b].subterm_transitivity")
          (("" (assert)
            (("" (inst -1 e1 G "P_exp(A)")
              (("" (ground)
                (("" (replace -2 * LR)
                  (("" (expand "subterm")
                    (("" (expand "subterm") (("" (propax) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((subterm_transitivity formula-decl nil peg nil)
    (peg type-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (WF_nT type-eq-decl nil wf_peg nil))
   nil
   (semtlpp subtype "semantic_tlparser.e1"
    "{e: wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].Δ | peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].subterm(e, semantic_tlparser.P_exp(semantic_tlparser.A))}")))
 (semtlpp_TCC37 0
  (semtlpp_TCC22-1 nil 3804395188
   ("" (skeep*)
    (("" (typepred "s_T")
      (("" (assert)
        (("" (expand "g_wf" -)
          (("" (replace -3 * LR)
            (("" (flatten) (("" (assert) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (subterm adt-def-decl "boolean" peg nil)
    (g_wf def-decl "bool" wf_peg nil) (peg type-decl nil peg nil))
   nil
   (semtlpp subtype "semantic_tlparser.s_T"
    "{k: naturalnumbers.upto(semantic_tlparser.s) | booleans.⇒((k = semantic_tlparser.s), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].g_wf(semantic_tlparser.e1, semantic_tlparser.A, wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].P_0c?(semantic_tlparser.P_exp), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].strong))}")))
 (semtlpp_TCC38 0
  (semtlpp_TCC75-1 nil 3804395188
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (expand "astType?" 1 2)
          (("" (expand "astType?" 1 2) (("" (assert) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure"
    "semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC39 0
  (semtlpp_TCC77-1 nil 3804395188
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (typepred "status1")
          (("" (assert)
            (("" (expand "s_inp")
              (("" (expand "astType?" 1 1)
                ((""
                  (lemma "semantic_interp_props"
                   (T "parsing(P_exp, A, e1, inp, s, s_T)" P_inp
                    P_inp))
                  (("" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astTypeOf type-eq-decl nil semantic_parser nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil) (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil) (WF_nT type-eq-decl nil wf_peg nil)
    (astType? def-decl "astType" ast nil)
    (pre_ast type-decl nil pre_ast nil) (astType type-decl nil ast nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semantic_interp_props formula-decl nil semantic_interp nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T1))"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC40 0
  (semtlpp_TCC24-1 nil 3804395188
   ("" (skeep*)
    (("" (lemma "peg[V_T, <=, V_N_b].subterm_transitivity")
      (("" (inst-cp -1 "e1" "G" "P_exp(A)")
        (("" (inst -1 "e2" "G" "P_exp(A)")
          (("" (replace -3 * LR)
            (("" (assert)
              (("" (expand "subterm" 1)
                (("" (expand "subterm" 1) (("" (propax) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((subterm_transitivity formula-decl nil peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil))
   nil
   (semtlpp subtype "semantic_tlparser.e2"
    "{e: wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].Δ | peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].subterm(e, semantic_tlparser.P_exp(semantic_tlparser.A))}")))
 (semtlpp_TCC41 0
  (semtlpp_TCC25-1 nil 3804395188
   ("" (skeep*)
    (("" (typepred "s_T")
      (("" (assert)
        (("" (replace -3 * LR)
          (("" (expand "g_wf" -)
            (("" (typepred "T1")
              ((""
                (lemma "semantic_interp_props"
                 ("T" "parsing(P_exp, A, e1, inp, s, s_T)" P_inp
                  P_inp))
                (("" (flatten)
                  (("" (assert)
                    (("" (replace -5 * RL)
                      (("" (lemma "Wellformed_theorem" (T T1))
                        (("" (assert)
                          (("" (flatten)
                            (("" (assert)
                              ((""
                                (flatten)
                                ((""
                                  (assert)
                                  ((""
                                    (flatten)
                                    ((""
                                      (assert)
                                      ((""
                                        (expand "strong")
                                        ((""
                                          (case "P_0c?(P_exp)(e1)")
                                          (("1" (assert) nil nil)
                                           ("2"
                                            (hide 2 3)
                                            (("2"
                                              (typepred
                                               " parsing(P_exp, A, e1, inp, s, s_T)")
                                              (("2" (assert) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (subterm adt-def-decl "boolean" peg nil)
    (g_wf def-decl "bool" wf_peg nil) (peg type-decl nil peg nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (ast type-eq-decl nil ast nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (semantic_interp_props formula-decl nil semantic_interp nil))
   nil
   (semtlpp subtype "semantic_tlparser.s_T"
    "{k: naturalnumbers.upto(pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T1)) | booleans.⇒((k = pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T1)), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].g_wf(semantic_tlparser.e2, semantic_tlparser.A, wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].P_0c?(semantic_tlparser.P_exp), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].strong))}")))
 (semtlpp_TCC42 0
  (semtlpp_TCC81-1 nil 3804395188
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "astType?")
            (("" (typepred "status1")
              (("" (typepred "status2")
                (("" (assert)
                  (("" (typepred "T1")
                    ((""
                      (lemma "semantic_interp_props"
                       ("T" "parsing(P_exp, A, e1, inp, s, s_T)" P_inp
                        P_inp))
                      (("" (flatten)
                        (("" (replace -5 * RL)
                          (("" (lemma "Wellformed_theorem" (T T1))
                            (("" (assert)
                              ((""
                                (flatten)
                                (("" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astTypeOf type-eq-decl nil semantic_parser nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil) (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil) (WF_nT type-eq-decl nil wf_peg nil)
    (pre_ast type-decl nil pre_ast nil) (astType type-decl nil ast nil)
    (semantic_interp_props formula-decl nil semantic_interp nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure"
    "semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC43 0
  (semtlpp_TCC82-1 nil 3804395188
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "s_inp")
            (("" (expand "astType?")
              (("" (typepred "status1")
                (("" (typepred "status2")
                  (("" (typepred "T1")
                    ((""
                      (lemma "semantic_interp_props"
                       ("T" "parsing(P_exp, A, e1, inp, s, s_T)" P_inp
                        P_inp))
                      (("" (flatten)
                        (("" (assert)
                          (("" (lemma "Wellformed_theorem" (T T1))
                            (("" (assert)
                              ((""
                                (assert)
                                ((""
                                  (flatten)
                                  ((""
                                    (assert)
                                    ((""
                                      (replace -7 * RL)
                                      ((""
                                        (replace -4 * LR)
                                        ((""
                                          (typepred "T2")
                                          ((""
                                            (lemma
                                             "semantic_interp_props"
                                             (T
                                              "parsing(P_exp, A, e2, inp, e(T1), s_T)"
                                              P_inp
                                              P_inp))
                                            (("" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semantic_interp_props formula-decl nil semantic_interp nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (astType type-decl nil ast nil) (pre_ast type-decl nil pre_ast nil)
    (WF_nT type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil) (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (astTypeOf type-eq-decl nil semantic_parser nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T2))"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC44 0
  (semtlpp_TCC84-1 nil 3804395188
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "astType?")
            (("" (typepred "status1")
              (("" (typepred "status2")
                (("" (typepred "T1")
                  ((""
                    (lemma "semantic_interp_props"
                     ("T" "parsing(P_exp, A, e1, inp, s, s_T)" P_inp
                      P_inp))
                    (("" (flatten)
                      (("" (assert)
                        (("" (lemma "Wellformed_theorem" (T T1))
                          (("" (assert)
                            (("" (typepred "T2")
                              ((""
                                (lemma
                                 "semantic_interp_props"
                                 (T
                                  "parsing(P_exp, A, e2, inp, e(T1), s_T)"
                                  P_inp
                                  P_inp))
                                ((""
                                  (assert)
                                  ((""
                                    (ground)
                                    ((""
                                      (lift-if)
                                      ((""
                                        (assert)
                                        ((""
                                          (split)
                                          (("1" (propax) nil nil)
                                           ("2"
                                            (replace -8 * RL)
                                            (("2"
                                              (replace -5 * LR)
                                              (("2"
                                                (lemma
                                                 "Wellformed_theorem"
                                                 (T T1))
                                                (("2"
                                                  (lemma
                                                   "Wellformed_theorem"
                                                   (T T2))
                                                  (("2"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astTypeOf type-eq-decl nil semantic_parser nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil) (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil) (WF_nT type-eq-decl nil wf_peg nil)
    (pre_ast type-decl nil pre_ast nil) (astType type-decl nil ast nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (semantic_interp_props formula-decl nil semantic_interp nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success"
    "semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC45 0
  (semtlpp_TCC27-1 nil 3804395188
   ("" (skeep*)
    (("" (typepred "T1")
      ((""
        (lemma "semantic_interp_props"
         (T "parsing(P_exp, A, e1, inp, s, s_T)" P_inp P_inp))
        (("" (flatten)
          (("" (replace -5 * RL)
            (("" (expand "astWellformed?") (("" (assert) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (ast type-eq-decl nil ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil) (WF_nT type-eq-decl nil wf_peg nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (pre_ast type-decl nil pre_ast nil)
    (semantic_interp_props formula-decl nil semantic_interp nil))
   nil
   (semtlpp subtype "semantic_tlparser.T1"
    "{T: pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast | (booleans.¬)(pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].skip?(T))}")))
 (semtlpp_TCC46 0
  (semtlpp_TCC88-1 nil 3804395188
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "s_inp")
            (("" (expand "astType?")
              (("" (typepred "T1")
                (("" (typepred "T2")
                  (("" (lemma "Wellformed_theorem" (T T1))
                    (("" (lemma "Wellformed_theorem" (T T2))
                      (("" (assert)
                        (("" (flatten) (("" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (astType type-decl nil ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (WF_nT type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (ast type-eq-decl nil ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].seq(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T2), semantic_tlparser.T1, semantic_tlparser.T2)"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC47 0
  (semtlpp_TCC29-1 nil 3804395188
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (rewrite "lex4_lt")
        (("" (rewrite "lex3_lt")
          (("" (rewrite "lex2_lt")
            (("" (typepred "T1")
              (("" (lemma "Wellformed_theorem" (T T1))
                (("" (assert)
                  (("" (flatten)
                    (("" (assert) (("" (grind) nil nil)) nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((sum const-decl "nat" peg nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (seq adt-constructor-decl "[[peg, peg] -> (seq?)]" peg nil)
    (seq? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (pegMeasure const-decl "nat" peg nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (ast type-eq-decl nil ast nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (subterm adt-def-decl "boolean" peg nil)
    (g_wf def-decl "bool" wf_peg nil) (peg type-decl nil peg nil))
   nil
   (semtlpp termination
    "semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, semantic_tlparser.e2, semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T1), semantic_tlparser.s_T, semantic_tlparser.res, (LAMBDA (status2: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e2, semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T1), semantic_tlparser.s_T))), (T2: semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e2, semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T1), semantic_tlparser.s_T)), (res: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): IF (status2 = ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure) THEN semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T2)), res) ELSE semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].seq(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T2), semantic_tlparser.T1, T2), res) ENDIF))"
    "nil")))
 (semtlpp_TCC48 0
  (semtlpp_TCC31-1 nil 3804395188
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (rewrite "lex4_lt")
        (("" (rewrite "lex3_lt")
          (("" (rewrite "lex2_lt")
            (("" (assert) (("" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (sum const-decl "nat" peg nil)
    (seq adt-constructor-decl "[[peg, peg] -> (seq?)]" peg nil)
    (seq? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (pegMeasure const-decl "nat" peg nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (subterm adt-def-decl "boolean" peg nil)
    (g_wf def-decl "bool" wf_peg nil) (peg type-decl nil peg nil))
   nil
   (semtlpp termination
    "semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, semantic_tlparser.e1, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T, semantic_tlparser.res, (LAMBDA (status1: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e1, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))), (T1: semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e1, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)), (res: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): IF (status1 = ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure) THEN semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T1)), res) ELSE semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, semantic_tlparser.e2, semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T1), semantic_tlparser.s_T, res, LAMBDA (status2: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e2, semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T1), semantic_tlparser.s_T))), (T2: semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e2, semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T1), semantic_tlparser.s_T)), (res: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): IF (status2 = ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure) THEN semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T2)), res) ELSE semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].seq(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T2), T1, T2), res) ENDIF) ENDIF))"
    "nil")))
 (semtlpp_TCC49 0
  (semtlpp_TCC33-1 nil 3804395188
   ("" (skeep*)
    (("" (lemma "peg[V_T, <=, V_N_b].subterm_transitivity")
      (("" (inst-cp -1 "e1" "G" "P_exp(A)")
        (("" (inst -1 "e2" "G" "P_exp(A)")
          (("" (replace -3 * LR)
            (("" (assert)
              (("" (expand "subterm" 1)
                (("" (expand "subterm" 1) (("" (propax) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((subterm_transitivity formula-decl nil peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil))
   nil
   (semtlpp subtype "semantic_tlparser.e1"
    "{e: wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].Δ | peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].subterm(e, semantic_tlparser.P_exp(semantic_tlparser.A))}")))
 (semtlpp_TCC50 0
  (semtlpp_TCC34-1 nil 3804395188
   ("" (skeep*)
    (("" (typepred "s_T")
      (("" (assert)
        (("" (expand "g_wf" -)
          (("" (replace -3 * LR)
            (("" (flatten) (("" (assert) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (subterm adt-def-decl "boolean" peg nil)
    (g_wf def-decl "bool" wf_peg nil) (peg type-decl nil peg nil))
   nil
   (semtlpp subtype "semantic_tlparser.s_T"
    "{k: naturalnumbers.upto(semantic_tlparser.s) | booleans.⇒((k = semantic_tlparser.s), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].g_wf(semantic_tlparser.e1, semantic_tlparser.A, wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].P_0c?(semantic_tlparser.P_exp), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].strong))}")))
 (semtlpp_TCC51 0
  (semtlpp_TCC58-1 nil 3804399719
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "astType?") (("" (propax) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success"
    "semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC52 0
  (semtlpp_TCC35-1 nil 3804395188
   ("" (skeep*)
    (("" (typepred "T1")
      (("" (case "astWellformed?(T1)")
        (("1" (assert)
          (("1" (expand "astWellformed?" -) (("1" (propax) nil nil))
            nil))
          nil)
         ("2" (assert) nil nil))
        nil))
      nil))
    nil)
   ((parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (ast type-eq-decl nil ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil) (WF_nT type-eq-decl nil wf_peg nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (pre_ast type-decl nil pre_ast nil))
   nil
   (semtlpp subtype "semantic_tlparser.T1"
    "{T: pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast | (booleans.¬)(pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].skip?(T))}")))
 (semtlpp_TCC53 0
  (semtlpp_TCC60-1 nil 3804399719
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (assert)
          (("" (assert)
            (("" (expand "s_inp")
              (("" (expand "astType?")
                (("" (assert)
                  (("" (expand "s_inp" 1 2)
                    (("" (expand "astType?") (("" (assert) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].prior(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T1), semantic_tlparser.T1, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].skip(semantic_tlparser.s, semantic_tlparser.s, semantic_tlparser.e2))"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC54 0
  (semtlpp_TCC37-1 nil 3804395188
   ("" (skeep*)
    (("" (lemma "peg[V_T, <=, V_N_b].subterm_transitivity")
      (("" (inst-cp -1 "e1" "G" "P_exp(A)")
        (("" (inst -1 "e2" "G" "P_exp(A)")
          (("" (replace -3 * LR)
            (("" (assert)
              (("" (expand "subterm" 1)
                (("" (expand "subterm" 1) (("" (propax) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((subterm_transitivity formula-decl nil peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil))
   nil
   (semtlpp subtype "semantic_tlparser.e2"
    "{e: wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].Δ | peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].subterm(e, semantic_tlparser.P_exp(semantic_tlparser.A))}")))
 (semtlpp_TCC55 0
  (semtlpp_TCC38-1 nil 3804395188
   ("" (skeep*)
    (("" (typepred "s_T")
      (("" (assert)
        (("" (expand "g_wf" -)
          (("" (replace -3 * LR)
            (("" (flatten) (("" (assert) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (subterm adt-def-decl "boolean" peg nil)
    (g_wf def-decl "bool" wf_peg nil) (peg type-decl nil peg nil))
   nil
   (semtlpp subtype "semantic_tlparser.s_T"
    "{k: naturalnumbers.upto(semantic_tlparser.s) | booleans.⇒((k = semantic_tlparser.s), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].g_wf(semantic_tlparser.e2, semantic_tlparser.A, wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].P_0c?(semantic_tlparser.P_exp), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].strong))}")))
 (semtlpp_TCC56 0
  (semtlpp_TCC63-1 nil 3804399719
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "astType?")
            (("" (lift-if)
              (("" (split)
                (("1" (propax) nil nil)
                 ("2" (assert)
                  (("2" (lemma "Wellformed_theorem" (T T1))
                    (("2" (assert)
                      (("2" (typepred "status1")
                        (("2" (typepred "T1") (("2" (assert) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astTypeOf type-eq-decl nil semantic_parser nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (astType type-decl nil ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (WF_nT type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (ast type-eq-decl nil ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success"
    "semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC57 0
  (semtlpp_TCC39-1 nil 3804395188
   ("" (skeep*)
    (("" (typepred "T1")
      (("" (case "astWellformed?(T1)")
        (("1" (assert)
          (("1" (expand "astWellformed?" -) (("1" (propax) nil nil))
            nil))
          nil)
         ("2" (assert) nil nil))
        nil))
      nil))
    nil)
   ((parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (ast type-eq-decl nil ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil) (WF_nT type-eq-decl nil wf_peg nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (pre_ast type-decl nil pre_ast nil))
   nil
   (semtlpp subtype "semantic_tlparser.T1"
    "{T: pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast | (booleans.¬)(pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].skip?(T))}")))
 (semtlpp_TCC58 0
  (semtlpp_TCC65-1 nil 3804399719
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "s_inp")
            (("" (expand "astType?")
              (("" (typepred "T1")
                (("" (typepred "T2")
                  (("" (lemma "Wellformed_theorem" (T T1))
                    (("" (lemma "Wellformed_theorem" (T T2))
                      (("" (assert)
                        (("" (flatten) (("" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (astType type-decl nil ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (WF_nT type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (ast type-eq-decl nil ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].prior(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T2), semantic_tlparser.T1, semantic_tlparser.T2)"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC59 0
  (semtlpp_TCC66-1 nil 3804399719
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "astType?")
            (("" (lift-if)
              (("" (split)
                (("1" (propax) nil nil)
                 ("2" (assert)
                  (("2" (lemma "Wellformed_theorem" (T T1))
                    (("2" (lemma "Wellformed_theorem" (T T2))
                      (("2" (typepred "status1")
                        (("2" (typepred "status2")
                          (("2" (typepred "T1")
                            (("2" (typepred "T2")
                              (("2"
                                (assert)
                                (("2"
                                  (flatten)
                                  (("2"
                                    (replace -3 * RL)
                                    (("2"
                                      (replace -4 * RL)
                                      (("2" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astTypeOf type-eq-decl nil semantic_parser nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (astType type-decl nil ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (WF_nT type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (ast type-eq-decl nil ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure"
    "semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC60 0
  (semtlpp_TCC67-1 nil 3804399719
   ("" (assert)
    (("" (skeep*)
      (("" (replace -1 * LR)
        (("" (expand "parsing")
          (("" (assert)
            (("" (expand "s_inp")
              (("" (expand "astType?")
                (("" (typepred "T1")
                  (("" (replace -1 * RL)
                    (("" (assert)
                      (("" (lemma "Wellformed_theorem" (T T1))
                        (("" (assert)
                          (("" (assert)
                            (("" (flatten)
                              ((""
                                (assert)
                                ((""
                                  (typepred "T2")
                                  ((""
                                    (lift-if)
                                    ((""
                                      (split)
                                      (("1" (assert) nil nil)
                                       ("2"
                                        (flatten)
                                        (("2"
                                          (assert)
                                          (("2"
                                            (assert)
                                            (("2"
                                              (typepred "status2")
                                              (("2"
                                                (replace -1 * RL)
                                                (("2"
                                                  (lemma
                                                   "semantic_interp_props"
                                                   (T
                                                    "parsing(P_exp, A, e2, inp, s, s_T)"
                                                    P_inp
                                                    P_inp))
                                                  (("2"
                                                    (replace -3 * RL)
                                                    (("2"
                                                      (flatten)
                                                      (("2"
                                                        (lemma
                                                         "Wellformed_theorem"
                                                         (T T2))
                                                        (("2"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (ast type-eq-decl nil ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil) (WF_nT type-eq-decl nil wf_peg nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (pre_ast type-decl nil pre_ast nil)
    (astTypeOf type-eq-decl nil semantic_parser nil)
    (semantic_interp_props formula-decl nil semantic_interp nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (astType? def-decl "astType" ast nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T2))"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC61 0
  (semtlpp_TCC42-1 nil 3804395188
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (rewrite "lex4_lt")
        (("" (rewrite "lex3_lt")
          (("" (rewrite "lex2_lt")
            (("" (typepred "T1")
              (("" (lemma "Wellformed_theorem" (T T1))
                (("" (assert)
                  (("" (flatten)
                    (("" (assert) (("" (grind) nil nil)) nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (ast type-eq-decl nil ast nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (pre_ast type-decl nil pre_ast nil) (sum const-decl "nat" peg nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (prior adt-constructor-decl "[[peg, peg] -> (prior?)]" peg nil)
    (prior? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (pegMeasure const-decl "nat" peg nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (subterm adt-def-decl "boolean" peg nil)
    (g_wf def-decl "bool" wf_peg nil) (peg type-decl nil peg nil))
   nil
   (semtlpp termination
    "semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, semantic_tlparser.e2, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T, semantic_tlparser.res, (LAMBDA (status2: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e2, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))), (T2: semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e2, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)), (res: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): IF (status2 = ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success) THEN semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].prior(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T2), semantic_tlparser.T1, T2), res) ELSE semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T2)), res) ENDIF))"
    "nil")))
 (semtlpp_TCC62 0
  (semtlpp_TCC44-1 nil 3804395188
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (rewrite "lex4_lt")
        (("" (rewrite "lex3_lt")
          (("" (rewrite "lex2_lt")
            (("" (assert) (("" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (sum const-decl "nat" peg nil)
    (prior adt-constructor-decl "[[peg, peg] -> (prior?)]" peg nil)
    (prior? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (pegMeasure const-decl "nat" peg nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (subterm adt-def-decl "boolean" peg nil)
    (g_wf def-decl "bool" wf_peg nil) (peg type-decl nil peg nil))
   nil
   (semtlpp termination
    "semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, semantic_tlparser.e1, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T, semantic_tlparser.res, (LAMBDA (status1: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e1, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))), (T1: semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e1, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)), (res: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): IF (status1 = ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success) THEN semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].prior(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T1), T1, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].skip(semantic_tlparser.s, semantic_tlparser.s, semantic_tlparser.e2)), res) ELSE semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, semantic_tlparser.e2, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T, res, LAMBDA (status2: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e2, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))), (T2: semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e2, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)), (res: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): IF (status2 = ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success) THEN semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].prior(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T2), T1, T2), res) ELSE semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T2)), res) ENDIF) ENDIF))"
    "nil")))
 (semtlpp_TCC63 0
  (semtlpp_TCC46-1 nil 3804395188
   ("" (skeep*)
    (("" (lemma "peg[V_T, <=, V_N_b].subterm_transitivity")
      (("" (inst -1 "e" "G" "P_exp(A)")
        (("" (replace -2 * LR)
          (("" (assert)
            (("" (expand "subterm" 1)
              (("" (expand "subterm" 1) (("" (propax) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((subterm_transitivity formula-decl nil peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil))
   nil
   (semtlpp subtype "semantic_tlparser.e"
    "{e: wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].Δ | peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].subterm(e, semantic_tlparser.P_exp(semantic_tlparser.A))}")))
 (semtlpp_TCC64 0
  (semtlpp_TCC47-1 nil 3804395188
   ("" (skeep*)
    (("" (typepred "s_T")
      (("" (assert)
        (("" (expand "g_wf" -)
          (("" (replace -3 * LR)
            (("" (flatten) (("" (assert) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (subterm adt-def-decl "boolean" peg nil)
    (g_wf def-decl "bool" wf_peg nil) (peg type-decl nil peg nil))
   nil
   (semtlpp subtype "semantic_tlparser.s_T"
    "{k: naturalnumbers.upto(semantic_tlparser.s) | booleans.⇒((k = semantic_tlparser.s), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].g_wf(semantic_tlparser.e, semantic_tlparser.A, wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].P_0c?(semantic_tlparser.P_exp), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].strong))}")))
 (semtlpp_TCC65 0
  (semtlpp_TCC76-1 nil 3804399719
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "astType?") (("" (propax) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success"
    "semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC66 0
  (semtlpp_TCC48-1 nil 3804395188
   ("" (skeep*)
    (("" (typepred "T0")
      (("" (case "astWellformed?(T0)")
        (("1" (assert)
          (("1" (expand "astWellformed?" -) (("1" (propax) nil nil))
            nil))
          nil)
         ("2" (assert) nil nil))
        nil))
      nil))
    nil)
   ((parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (ast type-eq-decl nil ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil) (WF_nT type-eq-decl nil wf_peg nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (pre_ast type-decl nil pre_ast nil))
   nil
   (semtlpp subtype "semantic_tlparser.T0"
    "{T: pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast | (booleans.¬)(pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].skip?(T))}")))
 (semtlpp_TCC67 0
  (semtlpp_TCC78-1 nil 3804399719
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "s_inp")
            (("" (expand "astType?")
              (("" (typepred "T0")
                (("" (replace -1 * RL)
                  (("" (lemma "Wellformed_theorem" (T T0))
                    (("" (assert)
                      (("" (assert)
                        (("" (expand "s_inp" +)
                          (("" (lift-if)
                            (("" (split)
                              (("1"
                                (flatten)
                                (("1"
                                  (assert)
                                  (("1"
                                    (expand "astType?")
                                    (("1" (propax) nil nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (assert) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (astType type-decl nil ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (WF_nT type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (ast type-eq-decl nil ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].star(semantic_tlparser.s, semantic_tlparser.s, semantic_tlparser.T0, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].skip(pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T0), pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T0), peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].star(semantic_tlparser.e)))"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC68 0
  (semtlpp_TCC50-1 nil 3804395188 ("" (subtype-tcc) nil nil)
   ((V_N type-eq-decl nil nTpred_order nil) (peg type-decl nil peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (saved_result type-decl nil semantic_parser nil)
    (known? adt-recognizer-decl "[saved_result -> boolean]"
     semantic_parser nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (astType type-decl nil ast nil) (pre_ast type-decl nil pre_ast nil)
    (astType? def-decl "astType" ast nil)
    (input type-eq-decl nil ast_props nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil) (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (status adt-accessor-decl
            "[(known?) -> astType[V_T, <=, V_N_b, bound, V_S]]"
            semantic_parser nil)
    (T adt-accessor-decl
     "[(known?) -> pre_ast[V_T, <=, V_N_b, bound, V_S]]"
     semantic_parser nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail adt-constructor-decl "[[below, below] -> (fail?)]" pre_ast
     nil)
    (semantic? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (semantic adt-constructor-decl
     "[[below, below, V_N[V_N_b], V_S] -> (semantic?)]" pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (results type-eq-decl nil semantic_parser nil)
    (astTypeOf type-eq-decl nil semantic_parser nil))
   nil
   (semtlpp subtype
    "peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].star(semantic_tlparser.e)"
    "{e: wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].Δ | peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].subterm(e, semantic_tlparser.P_exp(semantic_tlparser.A))}")))
 (semtlpp_TCC69 0
  (semtlpp_TCC51-1 nil 3804395188
   ("" (skeep*)
    (("" (typepred "s_T")
      (("" (replace -3 * LR)
        (("" (assert)
          (("" (typepred "T0")
            (("" (assert)
              (("" (lemma "Wellformed_theorem" (T T0))
                (("" (assert)
                  (("" (flatten)
                    (("" (assert)
                      (("" (flatten) (("" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (subterm adt-def-decl "boolean" peg nil)
    (g_wf def-decl "bool" wf_peg nil) (peg type-decl nil peg nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (ast type-eq-decl nil ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype "semantic_tlparser.s_T"
    "{k: naturalnumbers.upto(pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T0)) | booleans.⇒((k = pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T0)), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].g_wf(peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].star(semantic_tlparser.e), semantic_tlparser.A, wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].P_0c?(semantic_tlparser.P_exp), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].strong))}")))
 (semtlpp_TCC70 0
  (semtlpp_TCC81-1 nil 3804399719
   ("" (skeep*)
    (("" (replace -1 * LR)
      ((""
        (typepred "parsing[V_T, <=, V_N_b, bound, V_S]
                (P_exp, A, star(e), inp, s, s_T)")
        (("" (assert)
          (("" (expand "trueToGrammar")
            (("" (flatten)
              ((""
                (lemma "Star_cannot_fail"
                 (T "parsing[V_T, <=, V_N_b, bound, V_S]
                (P_exp, A, star(e), inp, s, s_T)"))
                (("" (assert)
                  (("" (flatten)
                    ((""
                      (lemma "Wellformed_theorem"
                       (T "parsing[V_T, <=, V_N_b, bound, V_S]
                (P_exp, A, star(e), inp, s, s_T)"))
                      (("" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((Wellformed_theorem formula-decl nil ast nil)
    (Star_cannot_fail formula-decl nil ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (WF_nT type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (ast type-eq-decl nil ast nil) (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (star adt-constructor-decl "[peg -> (star?)]" peg nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success"
    "semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC71 0
  (semtlpp_TCC52-1 nil 3804395188
   ("" (skeep*)
    (("" (typepred "T0")
      (("" (case "astWellformed?(T0)")
        (("1" (assert)
          (("1" (expand "astWellformed?" -) (("1" (propax) nil nil))
            nil))
          nil)
         ("2" (assert) nil nil))
        nil))
      nil))
    nil)
   ((parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (ast type-eq-decl nil ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil) (WF_nT type-eq-decl nil wf_peg nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (pre_ast type-decl nil pre_ast nil))
   nil
   (semtlpp subtype "semantic_tlparser.T0"
    "{T: pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast | (booleans.¬)(pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].skip?(T))}")))
 (semtlpp_TCC72 0
  (semtlpp_TCC53-1 nil 3804395188
   ("" (skeep*)
    (("" (typepred "Ts")
      (("" (typepred " parsing(P_exp, A, star(e), inp, e(T0), s_T)")
        (("" (expand "trueToGrammar")
          (("" (hide -4 -5 -6 -7 -8)
            (("" (expand "s_inp")
              (("" (assert)
                (("" (lift-if)
                  (("" (typepred "status0")
                    (("" (split -)
                      (("1" (assert)
                        (("1" (flatten)
                          (("1" (assert)
                            (("1" (use "Star_cannot_fail")
                              (("1" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil)
                       ("2" (flatten) (("2" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((star adt-constructor-decl "[peg -> (star?)]" peg nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (ast type-eq-decl nil ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil) (WF_nT type-eq-decl nil wf_peg nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (pre_ast type-decl nil pre_ast nil)
    (Star_cannot_fail formula-decl nil ast nil)
    (astTypeOf type-eq-decl nil semantic_parser nil))
   nil
   (semtlpp subtype "semantic_tlparser.Ts"
    "{T: pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast | booleans.OR(pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].skip?(T), pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].star?(T))}")))
 (semtlpp_TCC73 0
  (semtlpp_TCC84-1 nil 3804399719
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "s_inp")
            (("" (expand "astType?")
              (("" (typepred "T0")
                (("" (replace -1 * RL)
                  (("" (assert)
                    (("" (lemma "Wellformed_theorem" (T T0))
                      (("" (assert)
                        (("" (flatten)
                          (("" (assert)
                            (("" (lift-if)
                              ((""
                                (split)
                                (("1"
                                  (assert)
                                  (("1"
                                    (flatten)
                                    (("1" (assert) nil nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (assert)
                                  (("2"
                                    (flatten)
                                    (("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (astType type-decl nil ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (WF_nT type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (ast type-eq-decl nil ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].star(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.Ts), semantic_tlparser.T0, semantic_tlparser.Ts)"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC74 0
  (semtlpp_TCC55-1 nil 3804395188
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (rewrite "lex4_lt")
        (("" (rewrite "lex3_lt")
          (("" (rewrite "lex2_lt")
            (("" (typepred "T0")
              (("" (lemma "Wellformed_theorem" (T T0))
                (("" (assert)
                  (("" (typepred " parsing(P_exp, A, e, inp, s, s_T)")
                    (("" (flatten)
                      (("" (assert)
                        (("" (typepred "G")
                          (("" (typepred "P_exp")
                            ((""
                              (lemma "complete_WF_theorem"
                               (P_exp P_exp A A G G))
                              ((""
                                (assert)
                                ((""
                                  (replace -16 * LR)
                                  ((""
                                    (expand "g_wf")
                                    (("" (propax) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((complete_WF_theorem formula-decl nil wf_peg nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (star adt-constructor-decl "[peg -> (star?)]" peg nil)
    (pegMeasure const-decl "nat" peg nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (ast type-eq-decl nil ast nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (subterm adt-def-decl "boolean" peg nil)
    (g_wf def-decl "bool" wf_peg nil) (peg type-decl nil peg nil))
   nil
   (semtlpp termination
    "semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].star(semantic_tlparser.e), semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T0), semantic_tlparser.s_T, semantic_tlparser.res, (LAMBDA (status2: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].star(semantic_tlparser.e), semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T0), semantic_tlparser.s_T))), (Ts: semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].star(semantic_tlparser.e), semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T0), semantic_tlparser.s_T)), (res: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].star(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(Ts), semantic_tlparser.T0, Ts), res)))"
    "nil")))
 (semtlpp_TCC75 0
  (semtlpp_TCC57-1 nil 3804395188
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (rewrite "lex4_lt")
        (("" (rewrite "lex3_lt")
          (("" (rewrite "lex2_lt")
            (("" (assert) (("" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (inc const-decl "nat" peg nil)
    (star adt-constructor-decl "[peg -> (star?)]" peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (pegMeasure const-decl "nat" peg nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (subterm adt-def-decl "boolean" peg nil)
    (g_wf def-decl "bool" wf_peg nil) (peg type-decl nil peg nil))
   nil
   (semtlpp termination
    "semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T, semantic_tlparser.res, (LAMBDA (status0: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))), (T0: semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)), (res: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): IF (status0 = ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure) THEN semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].star(semantic_tlparser.s, semantic_tlparser.s, T0, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].skip(pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T0), pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T0), peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].star(semantic_tlparser.e))), res) ELSE semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].star(semantic_tlparser.e), semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T0), semantic_tlparser.s_T, res, LAMBDA (status2: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].star(semantic_tlparser.e), semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T0), semantic_tlparser.s_T))), (Ts: semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].star(semantic_tlparser.e), semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T0), semantic_tlparser.s_T)), (res: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].star(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(Ts), T0, Ts), res)) ENDIF))"
    "nil")))
 (semtlpp_TCC76 0
  (semtlpp_TCC59-1 nil 3804395188
   ("" (skeep*)
    (("" (lemma "peg[V_T, <=, V_N_b].subterm_transitivity")
      (("" (inst -1 "e" "G" "P_exp(A)")
        (("" (replace -2 * LR)
          (("" (assert)
            (("" (expand "subterm" 1)
              (("" (expand "subterm" 1) (("" (propax) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((subterm_transitivity formula-decl nil peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil))
   nil
   (semtlpp subtype "semantic_tlparser.e"
    "{e: wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].Δ | peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].subterm(e, semantic_tlparser.P_exp(semantic_tlparser.A))}")))
 (semtlpp_TCC77 0
  (semtlpp_TCC60-1 nil 3804395188
   ("" (skeep*)
    (("" (typepred "s_T")
      (("" (assert)
        (("" (expand "g_wf" -)
          (("" (replace -3 * LR)
            (("" (flatten) (("" (assert) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (subterm adt-def-decl "boolean" peg nil)
    (g_wf def-decl "bool" wf_peg nil) (peg type-decl nil peg nil))
   nil
   (semtlpp subtype "semantic_tlparser.s_T"
    "{k: naturalnumbers.upto(semantic_tlparser.s) | booleans.⇒((k = semantic_tlparser.s), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].g_wf(semantic_tlparser.e, semantic_tlparser.A, wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].P_0c?(semantic_tlparser.P_exp), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].strong))}")))
 (semtlpp_TCC78 0
  (semtlpp_TCC93-1 nil 3804399719
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "astType?") (("" (propax) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure"
    "semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC79 0
  (semtlpp_TCC94-1 nil 3804399719
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "s_inp")
            (("" (expand "astType?") (("" (propax) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, semantic_tlparser.s)"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC80 0
  (semtlpp_TCC70-1 nil 3804395188 ("" (subtype-tcc) nil nil)
   ((V_N type-eq-decl nil nTpred_order nil) (peg type-decl nil peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (saved_result type-decl nil semantic_parser nil)
    (known? adt-recognizer-decl "[saved_result -> boolean]"
     semantic_parser nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (astType type-decl nil ast nil) (pre_ast type-decl nil pre_ast nil)
    (astType? def-decl "astType" ast nil)
    (input type-eq-decl nil ast_props nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil) (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (status adt-accessor-decl
            "[(known?) -> astType[V_T, <=, V_N_b, bound, V_S]]"
            semantic_parser nil)
    (T adt-accessor-decl
     "[(known?) -> pre_ast[V_T, <=, V_N_b, bound, V_S]]"
     semantic_parser nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail adt-constructor-decl "[[below, below] -> (fail?)]" pre_ast
     nil)
    (semantic? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (semantic adt-constructor-decl
     "[[below, below, V_N[V_N_b], V_S] -> (semantic?)]" pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (results type-eq-decl nil semantic_parser nil)
    (astTypeOf type-eq-decl nil semantic_parser nil))
   nil
   (semtlpp subtype
    "peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].plus(semantic_tlparser.e)"
    "{e: wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].Δ | peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].subterm(e, semantic_tlparser.P_exp(semantic_tlparser.A))}")))
 (semtlpp_TCC81 0
  (semtlpp_TCC63-1 nil 3804395188
   ("" (skeep*)
    (("" (typepred "s_T")
      (("" (replace -3 * LR)
        (("" (assert)
          (("" (typepred "T0")
            (("" (lemma "Wellformed_theorem" (T T0))
              (("" (assert)
                (("" (flatten)
                  (("" (assert)
                    (("" (flatten) (("" (assert) nil nil)) nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (subterm adt-def-decl "boolean" peg nil)
    (g_wf def-decl "bool" wf_peg nil) (peg type-decl nil peg nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (ast type-eq-decl nil ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype "semantic_tlparser.s_T"
    "{k: naturalnumbers.upto(pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T0)) | booleans.⇒((k = pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T0)), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].g_wf(peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].plus(semantic_tlparser.e), semantic_tlparser.A, wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].P_0c?(semantic_tlparser.P_exp), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].strong))}")))
 (semtlpp_TCC82 0
  (semtlpp_TCC97-1 nil 3804399719
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "astType?")
            (("" (typepred "status0")
              (("" (lemma "Wellformed_theorem" (T T0))
                (("" (typepred "T0")
                  (("" (assert)
                    (("" (flatten)
                      (("" (assert)
                        ((""
                          (lemma "semantic_interp_props"
                           (T " parsing(P_exp, A, e, inp, s, s_T)"
                            P_inp P_inp))
                          (("" (replace -2 * RL)
                            (("" (flatten)
                              ((""
                                (lift-if 2)
                                ((""
                                  (split)
                                  (("1" (propax) nil nil)
                                   ("2"
                                    (assert)
                                    (("2"
                                      (flatten)
                                      (("2"
                                        (assert)
                                        (("2"
                                          (split)
                                          (("1" (propax) nil nil)
                                           ("2"
                                            (assert)
                                            (("2"
                                              (lemma
                                               "Wellformed_theorem"
                                               (T
                                                "parsing(P_exp, A, plus(e), inp,
                       e(parsing(P_exp, A, e, inp, s, s_T)), s_T)"))
                                              (("2" (assert) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astTypeOf type-eq-decl nil semantic_parser nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil) (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil) (WF_nT type-eq-decl nil wf_peg nil)
    (pre_ast type-decl nil pre_ast nil) (astType type-decl nil ast nil)
    (semantic_interp_props formula-decl nil semantic_interp nil)
    (plus adt-constructor-decl "[peg -> (plus?)]" peg nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success"
    "semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC83 0
  (semtlpp_TCC64-1 nil 3804395188
   ("" (skeep*)
    (("" (typepred "T0")
      (("" (case "astWellformed?(T0)")
        (("1" (assert)
          (("1" (expand "astWellformed?" -) (("1" (propax) nil nil))
            nil))
          nil)
         ("2" (assert) nil nil))
        nil))
      nil))
    nil)
   ((parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (ast type-eq-decl nil ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil) (WF_nT type-eq-decl nil wf_peg nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (pre_ast type-decl nil pre_ast nil))
   nil
   (semtlpp subtype "semantic_tlparser.T0"
    "{T: pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast | (booleans.¬)(pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].skip?(T))}")))
 (semtlpp_TCC84 0
  (semtlpp_TCC65-1 nil 3804395188
   ("" (skeep*)
    (("" (typepred "Ts")
      (("" (expand "parsing")
        (("" (typepred "status0")
          (("" (assert)
            (("" (lift-if)
              (("" (split)
                (("1" (flatten)
                  (("1" (expand "s_inp")
                    (("1" (ground)
                      (("1" (lift-if)
                        (("1" (split)
                          (("1" (flatten) (("1" (assert) nil nil)) nil)
                           ("2" (flatten) (("2" (assert) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (assert)
                    (("2" (expand "s_inp")
                      (("2" (lift-if)
                        (("2" (split)
                          (("1" (flatten) (("1" (assert) nil nil)) nil)
                           ("2" (flatten) (("2" (assert) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((plus adt-constructor-decl "[peg -> (plus?)]" peg nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (ast type-eq-decl nil ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil) (WF_nT type-eq-decl nil wf_peg nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (pre_ast type-decl nil pre_ast nil)
    (astTypeOf type-eq-decl nil semantic_parser nil))
   nil
   (semtlpp subtype "semantic_tlparser.Ts"
    "{T: pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast | booleans.OR(pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].skip?(T), booleans.OR(pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].plus?(T), pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail?(T)))}")))
 (semtlpp_TCC85 0
  (semtlpp_TCC100-1 nil 3804399719
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "s_inp")
            (("" (expand "astType?")
              (("" (typepred "T0")
                (("" (replace -1 * RL)
                  (("" (assert)
                    (("" (lemma "Wellformed_theorem" (T T0))
                      (("" (assert)
                        (("" (flatten)
                          (("" (assert)
                            (("" (lift-if)
                              ((""
                                (split)
                                (("1"
                                  (flatten)
                                  (("1"
                                    (lift-if)
                                    (("1"
                                      (split)
                                      (("1" (assert) nil nil)
                                       ("2"
                                        (assert)
                                        (("2" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (flatten)
                                  (("2"
                                    (assert)
                                    (("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (astType type-decl nil ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (WF_nT type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (ast type-eq-decl nil ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].plus(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.Ts), semantic_tlparser.T0, semantic_tlparser.Ts)"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC86 0
  (semtlpp_TCC67-1 nil 3804395188
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (rewrite "lex4_lt")
        (("" (rewrite "lex3_lt")
          (("" (rewrite "lex2_lt")
            (("" (typepred "T0")
              (("" (lemma "Wellformed_theorem" (T T0))
                (("" (assert)
                  (("" (flatten)
                    (("" (assert)
                      (("" (typepred "G")
                        (("" (typepred "P_exp")
                          ((""
                            (lemma "complete_WF_theorem"
                             (P_exp P_exp A A G G))
                            (("" (assert)
                              ((""
                                (expand "g_wf")
                                ((""
                                  (replace -7 * LR)
                                  ((""
                                    (assert)
                                    ((""
                                      (flatten)
                                      ((""
                                        (typepred
                                         "parsing(P_exp, A, e, inp, s, s_T)")
                                        (("" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((complete_WF_theorem formula-decl nil wf_peg nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (plus adt-constructor-decl "[peg -> (plus?)]" peg nil)
    (pegMeasure const-decl "nat" peg nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (ast type-eq-decl nil ast nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (subterm adt-def-decl "boolean" peg nil)
    (g_wf def-decl "bool" wf_peg nil) (peg type-decl nil peg nil))
   nil
   (semtlpp termination
    "semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].plus(semantic_tlparser.e), semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T0), semantic_tlparser.s_T, semantic_tlparser.res, (LAMBDA (status2: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].plus(semantic_tlparser.e), semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T0), semantic_tlparser.s_T))), (Ts: semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].plus(semantic_tlparser.e), semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T0), semantic_tlparser.s_T)), (res: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].plus(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(Ts), semantic_tlparser.T0, Ts), res)))"
    "nil")))
 (semtlpp_TCC87 0
  (semtlpp_TCC69-1 nil 3804395188
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (rewrite "lex4_lt")
        (("" (rewrite "lex3_lt")
          (("" (rewrite "lex2_lt")
            (("" (assert)
              (("" (expand "pegMeasure")
                (("" (expand "reduce_nat" 1 2)
                  (("" (assert) (("" (grind) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (inc const-decl "nat" peg nil)
    (plus adt-constructor-decl "[peg -> (plus?)]" peg nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (pegMeasure const-decl "nat" peg nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (subterm adt-def-decl "boolean" peg nil)
    (g_wf def-decl "bool" wf_peg nil) (peg type-decl nil peg nil))
   nil
   (semtlpp termination
    "semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T, semantic_tlparser.res, (LAMBDA (status0: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))), (T0: semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)), (res: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): IF (status0 = ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure) THEN semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, semantic_tlparser.s), res) ELSE semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].plus(semantic_tlparser.e), semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T0), semantic_tlparser.s_T, res, LAMBDA (status2: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].plus(semantic_tlparser.e), semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T0), semantic_tlparser.s_T))), (Ts: semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].plus(semantic_tlparser.e), semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T0), semantic_tlparser.s_T)), (res: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].plus(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(Ts), T0, Ts), res)) ENDIF))"
    "nil")))
 (semtlpp_TCC88 0
  (semtlpp_TCC71-1 nil 3804395188
   ("" (skeep*)
    (("" (lemma "peg[V_T, <=, V_N_b].subterm_transitivity")
      (("" (inst -1 "e" "G" "P_exp(A)")
        (("" (replace -2 * LR)
          (("" (assert)
            (("" (expand "subterm" 1)
              (("" (expand "subterm" 1) (("" (propax) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((subterm_transitivity formula-decl nil peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil))
   nil
   (semtlpp subtype "semantic_tlparser.e"
    "{e: wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].Δ | peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].subterm(e, semantic_tlparser.P_exp(semantic_tlparser.A))}")))
 (semtlpp_TCC89 0
  (semtlpp_TCC72-1 nil 3804395188
   ("" (skeep*)
    (("" (typepred "s_T")
      (("" (assert)
        (("" (expand "g_wf" -)
          (("" (replace -3 * LR) (("" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (subterm adt-def-decl "boolean" peg nil)
    (g_wf def-decl "bool" wf_peg nil) (peg type-decl nil peg nil))
   nil
   (semtlpp subtype "semantic_tlparser.s_T"
    "{k: naturalnumbers.upto(semantic_tlparser.s) | booleans.⇒((k = semantic_tlparser.s), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].g_wf(semantic_tlparser.e, semantic_tlparser.A, wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].P_0c?(semantic_tlparser.P_exp), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].strong))}")))
 (semtlpp_TCC90 0
  (semtlpp_TCC111-1 nil 3804399719
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "astType?") (("" (propax) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success"
    "semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC91 0
  (semtlpp_TCC74-1 nil 3804395188
   ("" (skeep*)
    (("" (typepred "T")
      (("" (case "astWellformed?(T)")
        (("1" (assert)
          (("1" (expand "astWellformed?" -) (("1" (propax) nil nil))
            nil))
          nil)
         ("2" (assert) nil nil))
        nil))
      nil))
    nil)
   ((sem_result type-eq-decl nil semantic_tlparser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (ast type-eq-decl nil ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.T"
    "{T: pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast | (booleans.¬)(pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].skip?(T))}")))
 (semtlpp_TCC92 0
  (semtlpp_TCC132-1 nil 3804399719
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "s_inp")
            (("" (expand "astType?") (("" (assert) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].opt(semantic_tlparser.s, semantic_tlparser.s, semantic_tlparser.T)"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC93 0
  (semtlpp_TCC119-1 nil 3804399719
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "astType?")
            (("" (lift-if)
              (("" (split)
                (("1" (propax) nil nil)
                 ("2" (flatten)
                  (("2"
                    (lemma "Wellformed_theorem"
                     (T "parsing(P_exp, A, e, inp, s, s_T)"))
                    (("2" (assert) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((Wellformed_theorem formula-decl nil ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (WF_nT type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil) (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (astType type-decl nil ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success"
    "semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC94 0
  (semtlpp_TCC80-1 nil 3804395188
   ("" (skeep*)
    (("" (typepred "T")
      (("" (case "astWellformed?(T)")
        (("1" (assert)
          (("1" (expand "astWellformed?" -) (("1" (propax) nil nil))
            nil))
          nil)
         ("2" (assert) nil nil))
        nil))
      nil))
    nil)
   ((sem_result type-eq-decl nil semantic_tlparser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (ast type-eq-decl nil ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.T"
    "{T: pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast | (booleans.¬)(pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].skip?(T))}")))
 (semtlpp_TCC95 0
  (semtlpp_TCC113-1 nil 3804399719
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "s_inp")
            (("" (expand "astType?")
              ((""
                (lemma "Wellformed_theorem"
                 (T "parsing(P_exp, A, e, inp, s, s_T)"))
                (("1" (assert)
                  (("1" (flatten) (("1" (assert) nil nil)) nil)) nil)
                 ("2" (ground)
                  (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)
                 ("3" (ground)
                  (("3" (lift-if) (("3" (ground) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (peg type-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (<= const-decl "bool" reals nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (astType type-decl nil ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].opt(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T), semantic_tlparser.T)"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC96 0
  (semtlpp_TCC76-1 nil 3804395188
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (rewrite "lex4_lt")
        (("" (rewrite "lex3_lt")
          (("" (rewrite "lex2_lt")
            (("" (assert) (("" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (inc const-decl "nat" peg nil)
    (opt adt-constructor-decl "[peg -> (opt?)]" peg nil)
    (opt? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (pegMeasure const-decl "nat" peg nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (subterm adt-def-decl "boolean" peg nil)
    (g_wf def-decl "bool" wf_peg nil) (peg type-decl nil peg nil))
   nil
   (semtlpp termination
    "semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T, semantic_tlparser.res, (LAMBDA (status: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))), (T: semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)), (res: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): IF (status = ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure) THEN semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].opt(semantic_tlparser.s, semantic_tlparser.s, T), res) ELSE semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].opt(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T), T), res) ENDIF))"
    "nil")))
 (semtlpp_TCC97 0
  (semtlpp_TCC78-1 nil 3804395188
   ("" (skeep*)
    (("" (lemma "peg[V_T, <=, V_N_b].subterm_transitivity")
      (("" (inst -1 "e" "G" "P_exp(A)")
        (("" (replace -2 * LR)
          (("" (assert)
            (("" (expand "subterm" 1)
              (("" (expand "subterm" 1) (("" (propax) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((subterm_transitivity formula-decl nil peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil))
   nil
   (semtlpp subtype "semantic_tlparser.e"
    "{e: wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].Δ | peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].subterm(e, semantic_tlparser.P_exp(semantic_tlparser.A))}")))
 (semtlpp_TCC98 0
  (semtlpp_TCC79-1 nil 3804395188
   ("" (skeep*)
    (("" (typepred "s_T")
      (("" (assert)
        (("" (expand "g_wf" -)
          (("" (replace -3 * LR) (("" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (subterm adt-def-decl "boolean" peg nil)
    (g_wf def-decl "bool" wf_peg nil) (peg type-decl nil peg nil))
   nil
   (semtlpp subtype "semantic_tlparser.s_T"
    "{k: naturalnumbers.upto(semantic_tlparser.s) | booleans.⇒((k = semantic_tlparser.s), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].g_wf(semantic_tlparser.e, semantic_tlparser.A, wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].P_0c?(semantic_tlparser.P_exp), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].strong))}")))
 (semtlpp_TCC99 0
  (semtlpp_TCC129-1 nil 3804399719
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "astType?") (("" (propax) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success"
    "semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC100 0
  (semtlpp_TCC87-1 nil 3804395188
   ("" (skeep*)
    (("" (typepred "T")
      (("" (case "astWellformed?(T)")
        (("1" (assert)
          (("1" (expand "astWellformed?" -) (("1" (propax) nil nil))
            nil))
          nil)
         ("2" (assert) nil nil))
        nil))
      nil))
    nil)
   ((sem_result type-eq-decl nil semantic_tlparser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (ast type-eq-decl nil ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.T"
    "{T: pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast | (booleans.¬)(pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].skip?(T))}")))
 (semtlpp_TCC101 0
  (semtlpp_TCC121-1 nil 3804399719
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "s_inp")
            (("" (expand "astType?") (("" (assert) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].notP(semantic_tlparser.s, semantic_tlparser.s, semantic_tlparser.T)"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC102 0
  (semtlpp_TCC109-1 nil 3804399719
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "astType?")
            (("" (typepred "status")
              ((""
                (lemma "Wellformed_theorem"
                 (T "parsing(P_exp, A, e, inp, s, s_T)"))
                (("" (assert)
                  (("" (flatten) (("" (assert) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astTypeOf type-eq-decl nil semantic_parser nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (<= const-decl "bool" reals nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (astType type-decl nil ast nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure"
    "semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC103 0
  (semtlpp_TCC110-1 nil 3804399719
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "s_inp")
            (("" (expand "astType?")
              (("" (typepred "status")
                ((""
                  (lemma "Wellformed_theorem"
                   (T "parsing(P_exp, A, e, inp, s, s_T)"))
                  (("" (assert)
                    (("" (flatten) (("" (assert) nil nil)) nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (astType type-decl nil ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (peg type-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (<= const-decl "bool" reals nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (astTypeOf type-eq-decl nil semantic_parser nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, semantic_tlparser.s)"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC104 0
  (semtlpp_TCC83-1 nil 3804395188
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (rewrite "lex4_lt")
        (("" (rewrite "lex3_lt")
          (("" (rewrite "lex2_lt")
            (("" (assert) (("" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (inc const-decl "nat" peg nil)
    (notP adt-constructor-decl "[peg -> (notP?)]" peg nil)
    (notP? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (pegMeasure const-decl "nat" peg nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (subterm adt-def-decl "boolean" peg nil)
    (g_wf def-decl "bool" wf_peg nil) (peg type-decl nil peg nil))
   nil
   (semtlpp termination
    "semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T, semantic_tlparser.res, (LAMBDA (status: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))), (T: semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)), (res: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): IF (status = ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure) THEN semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].notP(semantic_tlparser.s, semantic_tlparser.s, T), res) ELSE semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, semantic_tlparser.s), res) ENDIF))"
    "nil")))
 (semtlpp_TCC105 0
  (semtlpp_TCC85-1 nil 3804395188
   ("" (skeep*)
    (("" (lemma "peg[V_T, <=, V_N_b].subterm_transitivity")
      (("" (inst -1 "e" "G" "P_exp(A)")
        (("" (replace -2 * LR)
          (("" (assert)
            (("" (expand "subterm" 1)
              (("" (expand "subterm" 1) (("" (propax) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((subterm_transitivity formula-decl nil peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil))
   nil
   (semtlpp subtype "semantic_tlparser.e"
    "{e: wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].Δ | peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].subterm(e, semantic_tlparser.P_exp(semantic_tlparser.A))}")))
 (semtlpp_TCC106 0
  (semtlpp_TCC86-1 nil 3804395188
   ("" (skeep*)
    (("" (typepred "s_T")
      (("" (assert)
        (("" (expand "g_wf" -)
          (("" (replace -3 * LR) (("" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (subterm adt-def-decl "boolean" peg nil)
    (g_wf def-decl "bool" wf_peg nil) (peg type-decl nil peg nil))
   nil
   (semtlpp subtype "semantic_tlparser.s_T"
    "{k: naturalnumbers.upto(semantic_tlparser.s) | booleans.⇒((k = semantic_tlparser.s), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].g_wf(semantic_tlparser.e, semantic_tlparser.A, wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].P_0c?(semantic_tlparser.P_exp), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].strong))}")))
 (semtlpp_TCC107 0
  (semtlpp_TCC133-1 nil 3804399719
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "astType?") (("" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success"
    "semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC108 0
  (semtlpp_TCC108-1 nil 3804487992
   ("" (skeep*)
    (("" (assert)
      (("" (typepred "T")
        (("" (assert)
          (("" (expand "s_inp")
            (("" (lift-if) (("" (ground) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (peg type-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (ast type-eq-decl nil ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (sem_result type-eq-decl nil semantic_tlparser nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.T"
    "{T: pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast | (booleans.¬)(pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].skip?(T))}")))
 (semtlpp_TCC109 0
  (semtlpp_TCC131-1 nil 3804399719
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "s_inp")
            (("" (expand "astType?") (("" (assert) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].andP(semantic_tlparser.s, semantic_tlparser.s, semantic_tlparser.T)"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC110 0
  (semtlpp_TCC122-1 nil 3804399719
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "astType?")
            (("" (assert)
              ((""
                (lemma "Wellformed_theorem"
                 (T "parsing(P_exp, A, e, inp, s, s_T)"))
                (("" (assert) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((Wellformed_theorem formula-decl nil ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (peg type-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (<= const-decl "bool" reals nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (astType type-decl nil ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure"
    "semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC111 0
  (semtlpp_TCC123-1 nil 3804399719
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "s_inp")
            (("" (expand "astType?")
              (("" (typepred "status")
                ((""
                  (lemma "Wellformed_theorem"
                   (T "parsing(P_exp, A, e, inp, s, s_T)"))
                  (("" (assert)
                    (("" (flatten) (("" (assert) nil nil)) nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (astType type-decl nil ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (peg type-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (<= const-decl "bool" reals nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (astTypeOf type-eq-decl nil semantic_parser nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, semantic_tlparser.s)"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC112 0
  (semtlpp_TCC90-1 nil 3804395188
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (rewrite "lex4_lt")
        (("" (rewrite "lex3_lt")
          (("" (rewrite "lex2_lt")
            (("" (assert) (("" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (inc const-decl "nat" peg nil)
    (andP adt-constructor-decl "[peg -> (andP?)]" peg nil)
    (andP? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (pegMeasure const-decl "nat" peg nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (subterm adt-def-decl "boolean" peg nil)
    (g_wf def-decl "bool" wf_peg nil) (peg type-decl nil peg nil))
   nil
   (semtlpp termination
    "semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T, semantic_tlparser.res, (LAMBDA (status: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))), (T: semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)), (res: semantic_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): IF (status = ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success) THEN semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].andP(semantic_tlparser.s, semantic_tlparser.s, T), res) ELSE semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, semantic_tlparser.s), res) ENDIF))"
    "nil")))
 (semantic_tlparser_correct 0
  (semantic_tlparser_correct-1 nil 3804495937
   ("" (skolem 1 ("P_exp" "P_inp" "_" "_" "inp" "_" "_" "_"))
    ((""
      (case "FORALL (A:below(V_N_b)), (G: Δ), (s: upto(bound)), (s_T: upto(bound)):
        subterm(G, P_exp(A)) ⇒
	((s_T <= s) AND ((s_T = s) ⇒ g_wf(G, A, P_0c?(P_exp), strong))) ⇒
	(forall (res: results(P_exp, P_inp, inp)), (cont  : [
               	             [astTypeOf(parsing(P_exp, A, G, inp, s, s_T)),
                                     sem_result(P_inp, P_exp, A, G, inp, s, s_T),
               		      results(P_exp, P_inp, inp)]
               		     ->
               		     [astType, pre_ast,results(P_exp,P_inp,inp)]
               		    ]):
                       semtlpp(P_exp, P_inp, A, G, inp, s, s_T, res, cont)
                        = cont(astType?(parsing(P_exp, A, G, inp, s, s_T)), s_inp(P_inp, parsing(P_exp, A, G, inp, s, s_T)), res))")
      (("1" (skeep)
        (("1" (inst -1 "A" "G" "s" "s_T")
          (("1" (assert)
            (("1" (typepred "s_T")
              (("1" (assert)
                (("1" (split -3)
                  (("1"
                    (inst -1 "res" "LAMBDA (x:
                                [astTypeOf(parsing(P_exp, A, G, inp, s, s_T)),
                                 sem_result(P_inp, P_exp, A, G, inp, s, s_T),
                                 results(P_exp, P_inp, inp)]):
                        (x`1, x`2, x`3)")
                    (("1" (replace -1 * LR) (("1" (assert) nil nil))
                      nil))
                    nil)
                   ("2" (propax) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (hide 2)
        (("2"
          (measure-induct+
           " lex4(bound - s_T, bound - s,  A, pegMeasure(G))"
           ("A" "G" "s" "s_T"))
          (("1" (name-replace "A" "x!1")
            (("1" (name-replace "G" "x!2")
              (("1" (name-replace "s" "x!3")
                (("1" (name-replace "s_T" "x!4")
                  (("1" (skeep)
                    (("1" (case "nonTerminal?(G)")
                      (("1"
                        (case "Exists (B: V_N): G = nonTerminal(B)")
                        (("1" (skeep -1)
                          (("1" (replace -1 * LR)
                            (("1" (expand "semtlpp" +)
                              (("1"
                                (lift-if)
                                (("1"
                                  (split 1)
                                  (("1"
                                    (flatten)
                                    (("1"
                                      (typepred "res")
                                      (("1"
                                        (inst? -1)
                                        (("1"
                                          (assert)
                                          (("1"
                                            (lemma
                                             "Wellformed_theorem"
                                             (T
                                              "parsing(P_exp, B, P_exp(B), inp, s, s)"))
                                            (("1"
                                              (assert)
                                              (("1"
                                                (flatten)
                                                (("1"
                                                  (assert)
                                                  (("1"
                                                    (expand
                                                     "parsing"
                                                     1)
                                                    (("1"
                                                      (name-replace
                                                       "T_ref"
                                                       "parsing(P_exp, B, P_exp(B), inp, s, s)")
                                                      (("1"
                                                        (expand
                                                         "astType?"
                                                         1)
                                                        (("1"
                                                          (split -2)
                                                          (("1"
                                                            (ground)
                                                            (("1"
                                                              (grind)
                                                              nil
                                                              nil)
                                                             ("2"
                                                              (grind)
                                                              nil
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (ground)
                                                            (("1"
                                                              (replace
                                                               -3
                                                               *
                                                               LR)
                                                              (("1"
                                                                (replace
                                                                 -2
                                                                 *
                                                                 LR)
                                                                (("1"
                                                                  (replace
                                                                   -5
                                                                   *
                                                                   RL)
                                                                  (("1"
                                                                    (expand
                                                                     "astType?"
                                                                     +)
                                                                    (("1"
                                                                      (assert)
                                                                      (("1"
                                                                        (expand
                                                                         "s_inp"
                                                                         3
                                                                         2)
                                                                        (("1"
                                                                          (expand
                                                                           "astType?"
                                                                           +)
                                                                          (("1"
                                                                            (assert)
                                                                            nil
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil)
                                                             ("2"
                                                              (replace
                                                               -2
                                                               *
                                                               LR)
                                                              (("2"
                                                                (replace
                                                                 -1
                                                                 *
                                                                 LR)
                                                                (("2"
                                                                  (replace
                                                                   -4
                                                                   *
                                                                   RL)
                                                                  (("2"
                                                                    (expand
                                                                     "astType?"
                                                                     +)
                                                                    (("2"
                                                                      (expand
                                                                       "s_inp"
                                                                       +
                                                                       2)
                                                                      (("2"
                                                                        (expand
                                                                         "astType?"
                                                                         +)
                                                                        (("2"
                                                                          (assert)
                                                                          nil
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (flatten)
                                    (("2"
                                      (inst -3 "B" "P_exp(B)" "s" "s")
                                      (("2"
                                        (split -3)
                                        (("1"
                                          (name
                                           "T_refB"
                                           "parsing(P_exp, B, P_exp(B), inp, s, s)")
                                          (("1"
                                            (inst
                                             -2
                                             "res WITH [(B,s) := known(astType?(T_refB), s_inp(P_inp, nonTerminal(s(T_refB), e(T_refB), B, T_refB)))]"
                                             "_")
                                            (("1"
                                              (inst
                                               -2
                                               " LAMBDA (status:
                        astTypeOf(parsing(P_exp, B, P_exp(B), inp, s, s))),
                     (T_B:
                        sem_result(P_inp, P_exp, B, P_exp(B), inp, s, s)),
                     (res: results(P_exp, P_inp, inp)):
                IF (status = success)
                  THEN LET sem_T: (semantic?[V_T, <=, V_N_b, bound, V_S]) =
                             semantic(s, e(T_B), B, P_inp(B, T_B))
                         IN
                         cont(success, sem_T,
                              res WITH [(B, s) := known(success, sem_T)])
                ELSE LET fail_T: (fail?[V_T, <=, V_N_b, bound, V_S]) =
                           fail(s, e(T_B))
                       IN
                       cont(failure, fail_T,
                            res WITH [(B, s) := known(failure, fail_T)])
                ENDIF")
                                              (("1" (postpone) nil nil)
                                               ("2"
                                                (assert)
                                                (("2"
                                                  (skeep*)
                                                  (("2"
                                                    (postpone)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil)
                                               ("3"
                                                (expand "valuedTree?")
                                                (("3"
                                                  (propax)
                                                  nil
                                                  nil))
                                                nil)
                                               ("4"
                                                (skolem-typepred)
                                                (("4"
                                                  (flatten)
                                                  (("4"
                                                    (skolem-typepred)
                                                    (("4"
                                                      (assert)
                                                      (("4"
                                                        (flatten)
                                                        (("4"
                                                          (assert)
                                                          (("4"
                                                            (postpone)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("5" (postpone) nil nil)
                                               ("6" (postpone) nil nil)
                                               ("7" (postpone) nil nil)
                                               ("8" (postpone) nil nil)
                                               ("9" (postpone) nil nil)
                                               ("10"
                                                (postpone)
                                                nil
                                                nil))
                                              nil)
                                             ("2"
                                              (hide 2 3)
                                              (("2"
                                                (skolem 1 ("C" "s'"))
                                                (("2"
                                                  (flatten)
                                                  (("2"
                                                    (lift-if -1)
                                                    (("2"
                                                      (split -1)
                                                      (("1"
                                                        (flatten)
                                                        (("1"
                                                          (decompose-equality
                                                           -1)
                                                          (("1"
                                                            (replace
                                                             -1
                                                             *
                                                             LR)
                                                            (("1"
                                                              (replace
                                                               -2
                                                               *
                                                               LR)
                                                              (("1"
                                                                (assert)
                                                                (("1"
                                                                  (replace
                                                                   -4
                                                                   *
                                                                   LR)
                                                                  (("1"
                                                                    (lemma
                                                                     "Wellformed_theorem"
                                                                     (T
                                                                      T_refB))
                                                                    (("1"
                                                                      (assert)
                                                                      (("1"
                                                                        (flatten)
                                                                        (("1"
                                                                          (split
                                                                           -2)
                                                                          (("1"
                                                                            (assert)
                                                                            (("1"
                                                                              (expand
                                                                               "s_inp")
                                                                              (("1"
                                                                                (expand
                                                                                 "astType?"
                                                                                 1
                                                                                 1)
                                                                                (("1"
                                                                                  (expand
                                                                                   "astType?"
                                                                                   1
                                                                                   1)
                                                                                  (("1"
                                                                                    (expand
                                                                                     "astType?"
                                                                                     1
                                                                                     1)
                                                                                    (("1"
                                                                                      (expand
                                                                                       "astType?"
                                                                                       1
                                                                                       1)
                                                                                      (("1"
                                                                                        (assert)
                                                                                        nil
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil)
                                                                           ("2"
                                                                            (assert)
                                                                            (("2"
                                                                              (expand
                                                                               "s_inp"
                                                                               1
                                                                               1)
                                                                              (("2"
                                                                                (expand
                                                                                 "astType?"
                                                                                 1
                                                                                 1)
                                                                                (("2"
                                                                                  (expand
                                                                                   "s_inp"
                                                                                   1
                                                                                   1)
                                                                                  (("2"
                                                                                    (expand
                                                                                     "astType?"
                                                                                     1
                                                                                     1)
                                                                                    (("2"
                                                                                      (expand
                                                                                       "s_inp"
                                                                                       1
                                                                                       1)
                                                                                      (("2"
                                                                                        (expand
                                                                                         "astType?"
                                                                                         1
                                                                                         1)
                                                                                        (("2"
                                                                                          (expand
                                                                                           "astType?"
                                                                                           1
                                                                                           1)
                                                                                          (("2"
                                                                                            (assert)
                                                                                            nil
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil)
                                                       ("2"
                                                        (flatten)
                                                        (("2"
                                                          (ground)
                                                          (("1"
                                                            (lift-if)
                                                            (("1"
                                                              (assert)
                                                              (("1"
                                                                (split)
                                                                (("1"
                                                                  (flatten)
                                                                  (("1"
                                                                    (assert)
                                                                    nil
                                                                    nil))
                                                                  nil)
                                                                 ("2"
                                                                  (flatten)
                                                                  (("2"
                                                                    (assert)
                                                                    (("2"
                                                                      (typepred
                                                                       "res")
                                                                      (("2"
                                                                        (grind)
                                                                        nil
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (lift-if)
                                                            (("2"
                                                              (split)
                                                              (("1"
                                                                (assert)
                                                                (("1"
                                                                  (flatten)
                                                                  (("1"
                                                                    (assert)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil)
                                                               ("2"
                                                                (flatten)
                                                                (("2"
                                                                  (typepred
                                                                   "res")
                                                                  (("2"
                                                                    (grind)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil)
                                                           ("3"
                                                            (assert)
                                                            (("3"
                                                              (lift-if)
                                                              (("3"
                                                                (split)
                                                                (("1"
                                                                  (assert)
                                                                  (("1"
                                                                    (flatten)
                                                                    (("1"
                                                                      (assert)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil)
                                                                 ("2"
                                                                  (flatten)
                                                                  (("2"
                                                                    (assert)
                                                                    (("2"
                                                                      (typepred
                                                                       "res")
                                                                      (("2"
                                                                        (grind)
                                                                        nil
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil)
                                                           ("4"
                                                            (lift-if)
                                                            (("4"
                                                              (assert)
                                                              (("4"
                                                                (split)
                                                                (("1"
                                                                  (flatten)
                                                                  (("1"
                                                                    (assert)
                                                                    nil
                                                                    nil))
                                                                  nil)
                                                                 ("2"
                                                                  (flatten)
                                                                  (("2"
                                                                    (assert)
                                                                    (("2"
                                                                      (typepred
                                                                       "res")
                                                                      (("2"
                                                                        (grind)
                                                                        nil
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil)
                                                           ("5"
                                                            (assert)
                                                            (("5"
                                                              (lift-if)
                                                              (("5"
                                                                (split)
                                                                (("1"
                                                                  (assert)
                                                                  (("1"
                                                                    (flatten)
                                                                    (("1"
                                                                      (assert)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil)
                                                                 ("2"
                                                                  (flatten)
                                                                  (("2"
                                                                    (assert)
                                                                    (("2"
                                                                      (typepred
                                                                       "res")
                                                                      (("2"
                                                                        (inst
                                                                         -1
                                                                         "C"
                                                                         "s'")
                                                                        (("2"
                                                                          (assert)
                                                                          nil
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil)
                                                           ("6"
                                                            (lift-if)
                                                            (("6"
                                                              (split)
                                                              (("1"
                                                                (flatten)
                                                                (("1"
                                                                  (assert)
                                                                  nil
                                                                  nil))
                                                                nil)
                                                               ("2"
                                                                (flatten)
                                                                (("2"
                                                                  (typepred
                                                                   "res")
                                                                  (("2"
                                                                    (inst
                                                                     -1
                                                                     "C"
                                                                     "s'")
                                                                    (("2"
                                                                      (assert)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil)
                                                           ("7"
                                                            (lift-if)
                                                            (("7"
                                                              (split)
                                                              (("1"
                                                                (flatten)
                                                                (("1"
                                                                  (assert)
                                                                  nil
                                                                  nil))
                                                                nil)
                                                               ("2"
                                                                (flatten)
                                                                (("2"
                                                                  (typepred
                                                                   "res")
                                                                  (("2"
                                                                    (inst
                                                                     -1
                                                                     "C"
                                                                     "s'")
                                                                    (("2"
                                                                      (assert)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil)
                                                           ("8"
                                                            (lift-if)
                                                            (("8"
                                                              (split)
                                                              (("1"
                                                                (flatten)
                                                                (("1"
                                                                  (assert)
                                                                  nil
                                                                  nil))
                                                                nil)
                                                               ("2"
                                                                (flatten)
                                                                (("2"
                                                                  (typepred
                                                                   "res")
                                                                  (("2"
                                                                    (inst
                                                                     -1
                                                                     "C"
                                                                     "s'")
                                                                    (("2"
                                                                      (assert)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil)
                                                           ("9"
                                                            (lift-if)
                                                            (("9"
                                                              (split)
                                                              (("1"
                                                                (flatten)
                                                                (("1"
                                                                  (assert)
                                                                  nil
                                                                  nil))
                                                                nil)
                                                               ("2"
                                                                (flatten)
                                                                (("2"
                                                                  (typepred
                                                                   "res")
                                                                  (("2"
                                                                    (inst
                                                                     -1
                                                                     "C"
                                                                     "s'")
                                                                    (("2"
                                                                      (assert)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil)
                                                           ("10"
                                                            (lift-if)
                                                            (("10"
                                                              (split)
                                                              (("1"
                                                                (flatten)
                                                                (("1"
                                                                  (assert)
                                                                  nil
                                                                  nil))
                                                                nil)
                                                               ("2"
                                                                (flatten)
                                                                (("2"
                                                                  (typepred
                                                                   "res")
                                                                  (("2"
                                                                    (inst
                                                                     -1
                                                                     "C"
                                                                     "s'")
                                                                    (("2"
                                                                      (assert)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("3"
                                              (expand "s_inp" 1 1)
                                              (("3"
                                                (split 1)
                                                (("1"
                                                  (expand
                                                   "valuedTree?")
                                                  (("1"
                                                    (propax)
                                                    nil
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (expand
                                                   "valuedTree?")
                                                  (("2"
                                                    (propax)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2" (assert) nil nil)
                                         ("3"
                                          (typepred "P_exp")
                                          (("3"
                                            (expand "strong_WF")
                                            (("3"
                                              (assert)
                                              (("3" (inst? -) nil nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("4"
                                          (expand "subterm")
                                          (("4" (propax) nil nil))
                                          nil)
                                         ("5"
                                          (hide 2 3)
                                          (("5"
                                            (rewrite "lex4_lt")
                                            (("5"
                                              (rewrite "lex3_lt")
                                              (("5"
                                                (assert)
                                                (("5"
                                                  (flatten)
                                                  (("5"
                                                    (rewrite "lex2_lt")
                                                    (("5"
                                                      (assert)
                                                      (("5"
                                                        (flatten)
                                                        (("5"
                                                          (assert)
                                                          (("5"
                                                            (typepred
                                                             "s_T")
                                                            (("5"
                                                              (case
                                                               "s = s_T")
                                                              (("1"
                                                                (replace
                                                                 -1
                                                                 *
                                                                 LR)
                                                                (("1"
                                                                  (replace
                                                                   -1
                                                                   *
                                                                   RL)
                                                                  (("1"
                                                                    (hide
                                                                     1)
                                                                    (("1"
                                                                      (typepred
                                                                       "s_T")
                                                                      (("1"
                                                                        (expand
                                                                         "g_wf")
                                                                        (("1"
                                                                          (expand
                                                                           "strong")
                                                                          (("1"
                                                                            (propax)
                                                                            nil
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil)
                                                               ("2"
                                                                (assert)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (inst 1 "A(G)")
                          (("2" (assert)
                            (("2" (hide 2 -2 -3 -4)
                              (("2"
                                (hide -2)
                                (("2" (decompose-equality) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (postpone) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (hide 2)
            (("2" (skeep)
              (("2" (typepred "P_exp")
                (("2" (expand "strong_WF") (("2" (inst? -) nil nil))
                  nil))
                nil))
              nil))
            nil)
           ("3" (hide 2)
            (("3" (skeep*)
              (("3" (typepred "P_exp")
                (("3" (expand "strong_WF")
                  (("3" (inst? -)
                    (("3" (expand "subterm") (("3" (propax) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("4" (hide 2)
            (("4" (skeep*)
              (("4" (typepred "P_exp")
                (("4" (expand "strong_WF") (("4" (inst? -) nil nil))
                  nil))
                nil))
              nil))
            nil)
           ("5" (hide 2)
            (("5" (skeep*)
              (("5" (typepred "P_exp")
                (("5" (expand "strong_WF")
                  (("5" (inst? -)
                    (("5" (expand "subterm") (("5" (propax) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("6" (hide 2)
            (("6" (skeep*)
              (("6" (typepred "P_exp")
                (("6" (expand "strong_WF") (("6" (inst? -) nil nil))
                  nil))
                nil))
              nil))
            nil)
           ("7" (hide 2)
            (("7" (skeep*)
              (("7" (typepred "P_exp")
                (("7" (expand "strong_WF")
                  (("7" (inst? -)
                    (("7" (expand "subterm") (("7" (propax) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("8" (hide 2)
            (("8" (skeep*)
              (("8" (typepred "P_exp")
                (("8" (expand "strong_WF") (("8" (inst? -) nil nil))
                  nil))
                nil))
              nil))
            nil)
           ("9" (hide 2)
            (("9" (skeep*)
              (("9" (typepred "P_exp")
                (("9" (expand "strong_WF")
                  (("9" (inst? -)
                    (("9" (expand "subterm") (("9" (propax) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("10" (hide 2)
            (("10" (typepred "P_exp")
              (("10" (expand "strong_WF")
                (("10" (typepred "x!1`1") (("10" (assert) nil nil))
                  nil))
                nil))
              nil))
            nil)
           ("11" (hide 2)
            (("11" (skeep*)
              (("11" (typepred "P_exp")
                (("11" (expand "strong_WF") (("11" (inst? -) nil nil))
                  nil))
                nil))
              nil))
            nil)
           ("12" (assert)
            (("12" (hide 2)
              (("12" (skeep*)
                (("12" (typepred "P_exp")
                  (("12" (expand "strong_WF")
                    (("12" (inst? -)
                      (("12" (expand "subterm")
                        (("12" (propax) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("13" (hide 2)
            (("13" (skeep*)
              (("13" (typepred "P_exp")
                (("13" (expand "strong_WF") (("13" (inst? -) nil nil))
                  nil))
                nil))
              nil))
            nil)
           ("14" (hide 2)
            (("14" (skeep*)
              (("14" (typepred "P_exp")
                (("14" (expand "strong_WF")
                  (("14" (inst? -)
                    (("14" (expand "subterm") (("14" (propax) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("15" (hide 2)
            (("15" (typepred "P_exp")
              (("15" (expand "strong_WF")
                (("15" (inst? -) (("15" (assert) nil nil)) nil)) nil))
              nil))
            nil)
           ("16" (typepred "x!1`3") (("16" (assert) nil nil)) nil)
           ("17" (assert) nil nil) ("18" (assert) nil nil)
           ("19" (assert) nil nil)
           ("20" (assert)
            (("20" (hide 2)
              (("20" (skeep*)
                (("20" (typepred "P_exp")
                  (("20" (expand "strong_WF")
                    (("20" (inst? -) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil)
           ("21" (assert)
            (("21" (hide 2)
              (("21" (skeep*)
                (("21" (typepred "P_exp")
                  (("21" (expand "strong_WF")
                    (("21" (inst? -)
                      (("21" (expand "subterm")
                        (("21" (propax) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("22" (hide 2)
            (("22" (skeep*)
              (("22" (typepred "P_exp")
                (("22" (expand "strong_WF") (("22" (inst? -) nil nil))
                  nil))
                nil))
              nil))
            nil)
           ("23" (hide 2)
            (("23" (skeep*)
              (("23" (typepred "P_exp")
                (("23" (expand "strong_WF")
                  (("23" (inst? -)
                    (("23" (expand "subterm") (("23" (propax) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("3" (hide 2)
        (("3" (skeep*)
          (("3" (typepred "P_exp")
            (("3" (expand "strong_WF") (("3" (inst? -) nil nil)) nil))
            nil))
          nil))
        nil)
       ("4" (expand "subterm") (("4" (propax) nil nil)) nil)
       ("5" (hide 2)
        (("5" (skeep*)
          (("5" (typepred "P_exp")
            (("5" (expand "strong_WF") (("5" (inst? -) nil nil)) nil))
            nil))
          nil))
        nil)
       ("6" (expand "subterm") (("6" (propax) nil nil)) nil))
      nil))
    nil)
   nil shostak)))

