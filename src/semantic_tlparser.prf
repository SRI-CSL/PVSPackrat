(semantic_tlparser
 (results_TCC1 0
  (results_TCC1-1 nil 3804395188
   ("" (assert) (("" (expand "subterm") (("" (propax) nil nil)) nil))
    nil)
   ((subterm adt-def-decl "boolean" peg nil)) nil
   (results subtype "semantic_tlparser.P_exp(semantic_tlparser.A)"
    "{e: wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].Δ | peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].subterm(e, semantic_tlparser.P_exp(semantic_tlparser.A))}")))
 (results_TCC2 0
  (results_TCC2-1 nil 3804395188 ("" (subtype-tcc) nil nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil) (peg type-decl nil peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (<= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (strong const-decl "bool" wf_peg nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (results subtype "semantic_tlparser.s"
    "{k: naturalnumbers.upto(semantic_tlparser.s) | booleans.⇒((k = semantic_tlparser.s), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].g_wf(semantic_tlparser.P_exp(semantic_tlparser.A), semantic_tlparser.A, wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].P_0c?(semantic_tlparser.P_exp), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].strong))}")))
 (sem_result_TCC1 0
  (sem_result_TCC1-1 nil 3804417092 ("" (subtype-tcc) nil nil) nil nil
   (sem_result subtype "semantic_tlparser.A"
    "naturalnumbers.upto(semantic_tlparser.V_N_b)")))
 (semtlpp_TCC1 0
  (semtlpp_TCC2-1 nil 3804395188 ("" (subtype-tcc) nil nil)
   ((int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (semtlpp subtype
    "(number_fields.-)(semantic_tlparser.bound, semantic_tlparser.s_T)"
    "nat")))
 (semtlpp_TCC2 0
  (semtlpp_TCC3-1 nil 3804395188 ("" (subtype-tcc) nil nil)
   ((int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (semtlpp subtype
    "(number_fields.-)(semantic_tlparser.bound, semantic_tlparser.s)"
    "nat")))
 (semtlpp_TCC3 0
  (semtlpp_TCC4-1 nil 3804395188
   ("" (skeep)
    (("" (assert)
      (("" (typepred "z`6")
        (("" (typepred "z`7") (("" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (below type-eq-decl nil naturalnumbers nil)
    (peg type-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (saved_result type-decl nil semantic_tlparser nil)
    (known? adt-recognizer-decl "[saved_result -> boolean]"
     semantic_tlparser nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (astType type-decl nil ast nil) (pre_ast type-decl nil pre_ast nil)
    (astType? def-decl "astType" ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil) (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (valuedTree? const-decl "bool" semantic_interp nil)
    (T adt-accessor-decl "[(known?) -> (valuedTree?)]"
     semantic_tlparser nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail adt-constructor-decl "[[below, below] -> (fail?)]" pre_ast
     nil)
    (semantic? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (semantic adt-constructor-decl
     "[[below, below, V_N[V_N_b], V_S] -> (semantic?)]" pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (status adt-accessor-decl
            "[(known?) -> astType[V_T, <=, V_N_b, bound, V_S]]"
            semantic_tlparser nil)
    (results type-eq-decl nil semantic_tlparser nil)
    (astTypeOf type-eq-decl nil semantic_tlparser nil)
    (sem_result type-eq-decl nil semantic_tlparser nil))
   nil
   (semtlpp subtype
    "(number_fields.-)(semantic_tlparser.bound, semantic_tlparser.z`7)"
    "nat")))
 (semtlpp_TCC4 0
  (semtlpp_TCC5-1 nil 3804395188 ("" (subtype-tcc) nil nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (semtlpp subtype
    "(number_fields.-)(semantic_tlparser.bound, semantic_tlparser.z`6)"
    "nat")))
 (semtlpp_TCC5 0
  (semtlpp_TCC6-1 nil 3804395188 ("" (subtype-tcc) nil nil)
   ((int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (semtlpp subtype
    "(number_fields.-)(semantic_tlparser.bound, semantic_tlparser.s_T)"
    "nat")))
 (semtlpp_TCC6 0
  (semtlpp_TCC7-1 nil 3804395188 ("" (subtype-tcc) nil nil) nil nil
   (semtlpp subtype
    "(number_fields.-)(semantic_tlparser.bound, semantic_tlparser.s)"
    "nat")))
 (semtlpp_TCC7 0
  (semtlpp_TCC15-1 nil 3804395188
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (assert)
        (("" (expand "parsing")
          (("" (expand "astType?") (("" (propax) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (astType? def-decl "astType" ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success"
    "semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC8 0
  (semtlpp_TCC18-1 nil 3804395188
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (assert)
        (("" (expand "parsing")
          (("" (expand "s_inp")
            (("" (expand "astType?") (("" (propax) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (astType? def-decl "astType" ast nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].ε(semantic_tlparser.s, semantic_tlparser.s)"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC9 0
  (semtlpp_TCC20-1 nil 3804395188
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (assert)
        (("" (expand "parsing")
          (("" (expand "astType?")
            (("" (expand "min") (("" (propax) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (astType? def-decl "astType" ast nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure"
    "semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC10 0
  (semtlpp_TCC23-1 nil 3804395188
   ("" (skeep)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (expand "s_inp")
          (("" (expand "astType?")
            (("" (expand "min") (("" (assert) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, semantic_tlparser.s)"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC11 0
  (semtlpp_TCC26-1 nil 3804395188
   ("" (skeep)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (expand "astType?")
          (("" (expand "min") (("" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success"
    "semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC12 0
  (semtlpp_TCC8-1 nil 3804395188
   ("" (skeep) (("" (assert) nil nil)) nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (semtlpp subtype "(number_fields.+)(semantic_tlparser.s, 1)"
    "below[V_T, <=, V_N_b, bound, V_S]")))
 (semtlpp_TCC13 0
  (semtlpp_TCC28-1 nil 3804395188
   ("" (skeep)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (expand "s_inp")
          (("" (expand "astType?")
            (("" (expand "min") (("" (assert) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].any(semantic_tlparser.s, (number_fields.+)(semantic_tlparser.s, 1), semantic_tlparser.inp(semantic_tlparser.s))"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC14 0
  (semtlpp_TCC30-1 nil 3804395188
   ("" (skeep)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (expand "astType?")
          (("" (expand "min") (("" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success"
    "semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC15 0
  (semtlpp_TCC32-1 nil 3804395188
   ("" (skeep)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (expand "s_inp")
          (("" (expand "astType?")
            (("" (expand "min") (("" (assert) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].terminal(semantic_tlparser.s, (number_fields.+)(semantic_tlparser.s, 1), semantic_tlparser.a, semantic_tlparser.a)"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC16 0
  (semtlpp_TCC36-1 nil 3804395188
   ("" (skeep)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (expand "astType?")
          (("" (expand "min")
            (("" (assert)
              (("" (lift-if)
                (("" (assert)
                  (("" (split)
                    (("1" (assert) nil nil) ("2" (assert) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure"
    "semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC17 0
  (semtlpp_TCC40-1 nil 3804395188
   ("" (skeep)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (expand "s_inp")
          (("" (expand "astType?")
            (("" (expand "min")
              (("" (assert)
                (("" (lift-if)
                  (("" (assert)
                    (("" (lift-if)
                      (("" (assert)
                        (("" (split 1)
                          (("1" (assert) nil nil)
                           ("2" (assert) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, real_defs.min((number_fields.+)(semantic_tlparser.s, 1), semantic_tlparser.bound))"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC18 0
  (semtlpp_TCC41-1 nil 3804395188
   ("" (skeep)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (expand "astType?")
          (("" (expand "min") (("" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success"
    "semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC19 0
  (semtlpp_TCC43-1 nil 3804395188
   ("" (skeep)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (expand "s_inp")
          (("" (expand "astType?")
            (("" (expand "min") (("" (assert) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].range(semantic_tlparser.s, (number_fields.+)(semantic_tlparser.s, 1), semantic_tlparser.a, semantic_tlparser.b, semantic_tlparser.inp(semantic_tlparser.s))"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC20 0
  (semtlpp_TCC45-1 nil 3804395188
   ("" (skeep)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (expand "astType?")
          (("" (expand "min")
            (("" (assert)
              (("" (lift-if)
                (("" (assert)
                  (("" (lift-if)
                    (("" (assert)
                      (("" (split 1)
                        (("1" (assert) nil nil) ("2" (assert) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure"
    "semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC21 0
  (semtlpp_TCC49-1 nil 3804395188
   ("" (skeep)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (expand "s_inp")
          (("" (expand "astType?")
            (("" (expand "min")
              (("" (assert) (("" (grind) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (in_range const-decl "bool" ast nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, real_defs.min((number_fields.+)(semantic_tlparser.s, 1), semantic_tlparser.bound))"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC22 0
  (semtlpp_TCC54-1 nil 3804395188
   ("" (skeep)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        ((""
          (name-replace "T_ref"
           "parsing(P_exp, B, P_exp(B), inp, s, s)")
          (("" (typepred "res")
            (("" (inst -1 "B" "s")
              (("" (replace -3 * LR)
                (("" (assert)
                  (("" (flatten)
                    (("" (replace -5 * RL)
                      (("" (lemma "Wellformed_theorem")
                        (("" (inst -1 "T_ref")
                          (("" (assert)
                            (("" (flatten)
                              ((""
                                (expand "astType?" 1 2)
                                ((""
                                  (expand "T_ref")
                                  ((""
                                    (split -2)
                                    (("1"
                                      (assert)
                                      (("1"
                                        (replace -3 * LR)
                                        (("1"
                                          (expand "astType?" 1 1)
                                          (("1" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (assert)
                                      (("2"
                                        (replace -4 * LR)
                                        (("2"
                                          (expand "astType?" 2 1)
                                          (("2" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (peg type-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (<= const-decl "bool" reals nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (saved_result type-decl nil semantic_tlparser nil)
    (known? adt-recognizer-decl "[saved_result -> boolean]"
     semantic_tlparser nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (valuedTree? const-decl "bool" semantic_interp nil)
    (T adt-accessor-decl "[(known?) -> (valuedTree?)]"
     semantic_tlparser nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail adt-constructor-decl "[[below, below] -> (fail?)]" pre_ast
     nil)
    (semantic? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (semantic adt-constructor-decl
     "[[below, below, V_N[V_N_b], V_S] -> (semantic?)]" pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (status adt-accessor-decl
            "[(known?) -> astType[V_T, <=, V_N_b, bound, V_S]]"
            semantic_tlparser nil)
    (results type-eq-decl nil semantic_tlparser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype "semantic_tlparser.status"
    "semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC23 0
  (semtlpp_TCC12-1 nil 3804395188
   ("" (skeep)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (expand "s_inp")
          (("" (typepred "res")
            (("" (inst -1 B s)
              (("" (assert)
                (("" (flatten)
                  (("" (assert)
                    (("" (lift-if)
                      (("" (expand "astType?" 1 1)
                        ((""
                          (lemma "Wellformed_theorem"
                           (T
                            "parsing(P_exp, B, P_exp(B), inp, s, s)"))
                          (("1" (assert)
                            (("1" (flatten)
                              (("1"
                                (assert)
                                (("1"
                                  (split -2)
                                  (("1"
                                    (assert)
                                    (("1"
                                      (replace -9 * LR)
                                      (("1" (assert) nil nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (assert)
                                    (("2"
                                      (replace -8 * LR)
                                      (("2" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (assert)
                            (("2" (typepred "P_exp")
                              (("2"
                                (expand "strong_WF")
                                (("2" (inst -1 "B") nil nil))
                                nil))
                              nil))
                            nil)
                           ("3" (expand "subterm")
                            (("3" (propax) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (<= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (saved_result type-decl nil semantic_tlparser nil)
    (known? adt-recognizer-decl "[saved_result -> boolean]"
     semantic_tlparser nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (astType type-decl nil ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (astType? def-decl "astType" ast nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (peg type-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (input type-eq-decl nil ast_props nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil) (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (valuedTree? const-decl "bool" semantic_interp nil)
    (T adt-accessor-decl "[(known?) -> (valuedTree?)]"
     semantic_tlparser nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail adt-constructor-decl "[[below, below] -> (fail?)]" pre_ast
     nil)
    (semantic? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (semantic adt-constructor-decl
     "[[below, below, V_N[V_N_b], V_S] -> (semantic?)]" pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (status adt-accessor-decl
            "[(known?) -> astType[V_T, <=, V_N_b, bound, V_S]]"
            semantic_tlparser nil)
    (results type-eq-decl nil semantic_tlparser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   nil
   (semtlpp subtype "semantic_tlparser.T_B"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC24 0
  (semtlpp_TCC10-1 nil 3804395188
   ("" (assert) (("" (expand "subterm") (("" (propax) nil nil)) nil))
    nil)
   ((subterm adt-def-decl "boolean" peg nil)) nil
   (semtlpp subtype "semantic_tlparser.P_exp(semantic_tlparser.B)"
    "{e: wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].Δ | peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].subterm(e, semantic_tlparser.P_exp(semantic_tlparser.B))}")))
 (semtlpp_TCC25 0
  (semtlpp_TCC11-1 nil 3804395188
   ("" (skeep)
    (("" (typepred "P_exp")
      (("" (expand "strong_WF")
        (("" (inst -1 "B") (("" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil) (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (below type-eq-decl nil naturalnumbers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (semtlpp subtype "semantic_tlparser.s"
    "{k: naturalnumbers.upto(semantic_tlparser.s) | booleans.⇒((k = semantic_tlparser.s), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].g_wf(semantic_tlparser.P_exp(semantic_tlparser.B), semantic_tlparser.B, wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].P_0c?(semantic_tlparser.P_exp), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].strong))}")))
 (semtlpp_TCC26 0
  (semtlpp_TCC56-1 nil 3804395188
   ("" (skeep)
    (("" (typepred "T_B")
      (("" (replace -1 * LR) (("" (assert) nil nil)) nil)) nil))
    nil)
   ((sem_result type-eq-decl nil semantic_tlparser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (ast type-eq-decl nil ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.T_B"
    "semanticTree[V_T, <=, V_N_b, bound, V_S]")))
 (semtlpp_TCC27 0
  (semtlpp_TCC58-1 nil 3804395188
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (simplify)
        (("" (expand "parsing")
          (("" (expand "astType?")
            (("" (typepred "T_B")
              ((""
                (lemma "semantic_interp_props"
                 ("T" "parsing(P_exp, B, P_exp(B), inp, s, s)" "P_inp"
                  "P_inp"))
                (("" (flatten) (("" (assert) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (sem_result type-eq-decl nil semantic_tlparser nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (ast type-eq-decl nil ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semantic_interp_props formula-decl nil semantic_interp nil)
    (astType? def-decl "astType" ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success"
    "semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC28 0
  (semtlpp_TCC13-1 nil 3804395188
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (expand "s_inp")
          (("" (typepred "status!1")
            (("" (expand "astType?" 1 1) (("" (assert) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (astType type-decl nil ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (astType? def-decl "astType" ast nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (peg type-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (<= const-decl "bool" reals nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (astTypeOf type-eq-decl nil semantic_tlparser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.sem_T"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC29 0
  (semtlpp_TCC61-1 nil 3804395188 ("" (subtype-tcc) nil nil)
   ((V_S formal-type-decl nil semantic_tlparser nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (valuedTree? const-decl "bool" semantic_interp nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (semtlpp subtype "semantic_tlparser.sem_T"
    "(semantic_interp[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].valuedTree?)")))
 (semtlpp_TCC30 0
  (semtlpp_TCC14-1 nil 3804395188
   ("" (skeep*)
    (("" (lift-if -5)
      (("" (split -5)
        (("1" (flatten)
          (("1" (decompose-equality -1)
            (("1" (replace -1 * LR)
              (("1" (replace -2 * LR)
                (("1" (assert)
                  (("1" (typepred "status!1")
                    (("1" (assert)
                      (("1" (assert)
                        (("1" (replace -8 * LR)
                          (("1" (typepred "T_B")
                            (("1"
                              (lemma "semantic_interp_props"
                               (T
                                "parsing(P_exp, B, P_exp(B), inp, s, s)"
                                P_inp
                                "P_inp"))
                              (("1"
                                (replace -2 * RL)
                                (("1"
                                  (flatten)
                                  (("1"
                                    (expand "astType?" 1 1)
                                    (("1"
                                      (assert)
                                      (("1"
                                        (lift-if)
                                        (("1"
                                          (assert)
                                          (("1"
                                            (split 1)
                                            (("1" (propax) nil nil)
                                             ("2"
                                              (lemma
                                               "Wellformed_theorem"
                                               (T "T_B"))
                                              (("2" (assert) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (flatten)
          (("2" (typepred "res1")
            (("2" (inst -1 A!1 s_1)
              (("2" (assert)
                (("2" (ground)
                  (("1" (assert) nil nil) ("2" (assert) nil nil)
                   ("3" (assert) nil nil) ("4" (assert) nil nil)
                   ("5" (assert) nil nil) ("6" (assert) nil nil)
                   ("7" (assert) nil nil) ("8" (assert) nil nil)
                   ("9" (assert) nil nil) ("10" (assert) nil nil)
                   ("11" (assert) nil nil) ("12" (assert) nil nil)
                   ("13" (assert) nil nil) ("14" (assert) nil nil)
                   ("15" (assert) nil nil) ("16" (assert) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((saved_result type-decl nil semantic_tlparser nil)
    (known? adt-recognizer-decl "[saved_result -> boolean]"
     semantic_tlparser nil)
    (valuedTree? const-decl "bool" semantic_interp nil)
    (T adt-accessor-decl "[(known?) -> (valuedTree?)]"
     semantic_tlparser nil)
    (fail adt-constructor-decl "[[below, below] -> (fail?)]" pre_ast
     nil)
    (semantic? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (semantic adt-constructor-decl
     "[[below, below, V_N[V_N_b], V_S] -> (semantic?)]" pre_ast nil)
    (status adt-accessor-decl
            "[(known?) -> astType[V_T, <=, V_N_b, bound, V_S]]"
            semantic_tlparser nil)
    (results type-eq-decl nil semantic_tlparser nil)
    (semantic_interp_props formula-decl nil semantic_interp nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (sem_result type-eq-decl nil semantic_tlparser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (astType type-decl nil ast nil) (pre_ast type-decl nil pre_ast nil)
    (astType? def-decl "astType" ast nil)
    (WF_nT type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil) (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (astTypeOf type-eq-decl nil semantic_tlparser nil)
    (below type-eq-decl nil naturalnumbers nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (<= const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil) (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "semantic_tlparser.res WITH [(semantic_tlparser.B, semantic_tlparser.s) := semantic_tlparser.known(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, semantic_tlparser.sem_T)]"
    "semantic_tlparser.results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)")))
 (semtlpp_TCC31 0
  (semtlpp_TCC66-1 nil 3804395188
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (expand "astType?")
          (("" (typepred "T_B")
            (("" (typepred "status!1")
              (("" (replace -1 * RL)
                ((""
                  (lemma "Wellformed_theorem"
                   (T "(parsing(P_exp, B, P_exp(B), inp, s, s))"))
                  (("" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (astTypeOf type-eq-decl nil semantic_tlparser nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (astType type-decl nil ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (peg type-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (ast type-eq-decl nil ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (sem_result type-eq-decl nil semantic_tlparser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure"
    "semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC32 0
  (semtlpp_TCC16-1 nil 3804395188
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (typepred "T_B")
          (("" (typepred "status!1")
            ((""
              (lemma "Wellformed_theorem"
               (T "(parsing(P_exp, B, P_exp(B), inp, s, s))"))
              (("" (assert)
                (("" (flatten)
                  (("" (expand "s_inp")
                    (("" (assert)
                      (("" (expand "astType?" 2 1)
                        (("" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((sem_result type-eq-decl nil semantic_tlparser nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (ast type-eq-decl nil ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (astTypeOf type-eq-decl nil semantic_tlparser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.fail_T"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC33 0
  (semtlpp_TCC68-1 nil 3804395188 ("" (subtype-tcc) nil nil)
   ((V_S formal-type-decl nil semantic_tlparser nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (valuedTree? const-decl "bool" semantic_interp nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (semtlpp subtype "semantic_tlparser.fail_T"
    "(semantic_interp[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].valuedTree?)")))
 (semtlpp_TCC34 0
  (semtlpp_TCC17-1 nil 3804395188
   ("" (skeep*)
    (("" (lift-if -4)
      (("" (split -4)
        (("1" (flatten)
          (("1" (decompose-equality -1)
            (("1" (replace -1 * LR)
              (("1" (replace -2 * LR)
                (("1" (assert)
                  (("1" (typepred "T_B")
                    (("1"
                      (lemma "Wellformed_theorem"
                       (T "(parsing(P_exp, B, P_exp(B), inp, s, s))"))
                      (("1" (assert)
                        (("1" (flatten)
                          (("1" (assert)
                            (("1" (expand "astType?")
                              (("1" (propax) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (flatten)
          (("2" (assert)
            (("2" (lift-if 3)
              (("2" (assert)
                (("2" (typepred "res1")
                  (("2" (inst -1 "A!1" "s_1")
                    (("2" (assert)
                      (("2" (split)
                        (("1" (assert) nil nil) ("2" (assert) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((results type-eq-decl nil semantic_tlparser nil)
    (status adt-accessor-decl
            "[(known?) -> astType[V_T, <=, V_N_b, bound, V_S]]"
            semantic_tlparser nil)
    (semantic adt-constructor-decl
     "[[below, below, V_N[V_N_b], V_S] -> (semantic?)]" pre_ast nil)
    (semantic? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail adt-constructor-decl "[[below, below] -> (fail?)]" pre_ast
     nil)
    (T adt-accessor-decl "[(known?) -> (valuedTree?)]"
     semantic_tlparser nil)
    (valuedTree? const-decl "bool" semantic_interp nil)
    (known? adt-recognizer-decl "[saved_result -> boolean]"
     semantic_tlparser nil)
    (saved_result type-decl nil semantic_tlparser nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (pre_ast type-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (WF_nT type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (ast type-eq-decl nil ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (sem_result type-eq-decl nil semantic_tlparser nil)
    (below type-eq-decl nil naturalnumbers nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (<= const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil) (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "semantic_tlparser.res WITH [(semantic_tlparser.B, semantic_tlparser.s) := semantic_tlparser.known(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure, semantic_tlparser.fail_T)]"
    "semantic_tlparser.results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)")))
 (semtlpp_TCC35 0
  (semtlpp_TCC19-1 nil 3804395188
   ("" (assert)
    (("" (skeep*)
      (("" (replace -1 * LR)
        (("" (assert)
          (("" (typepred "s_T") (("" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((TRUE const-decl "bool" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (< def-decl "bool" ordinals nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (lex4 const-decl "ordinal" lex4 nil)
    (lex3 const-decl "ordinal" lex3 nil)
    (lex2 const-decl "ordinal" lex2 nil)
    (pegMeasure const-decl "nat" peg nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (peg type-decl nil peg nil) (g_wf def-decl "bool" wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil))
   nil
   (semtlpp termination
    "semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.B, semantic_tlparser.P_exp(semantic_tlparser.B), semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s, semantic_tlparser.res, (LAMBDA (status: semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.B, semantic_tlparser.P_exp(semantic_tlparser.B), semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s))), (T_B: semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.B, semantic_tlparser.P_exp(semantic_tlparser.B), semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s)), (res: semantic_tlparser.results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): IF (status = ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success) THEN LET sem_T = pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].semantic(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T_B), semantic_tlparser.B, semantic_tlparser.P_inp(semantic_tlparser.B, T_B)) IN semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, semantic_tlparser.sem_T, res WITH [(semantic_tlparser.B, semantic_tlparser.s) := semantic_tlparser.known(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, semantic_tlparser.sem_T)]) ELSE LET fail_T = pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T_B)) IN semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure, semantic_tlparser.fail_T, res WITH [(semantic_tlparser.B, semantic_tlparser.s) := semantic_tlparser.known(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure, semantic_tlparser.fail_T)]) ENDIF))"
    "nil")))
 (semtlpp_TCC36 0
  (semtlpp_TCC21-1 nil 3804395188
   ("" (skeep*)
    (("" (ground)
      (("" (typepred "G")
        (("" (lemma "peg[V_T, <=, V_N_b].subterm_transitivity")
          (("" (assert)
            (("" (inst -1 e1 G "P_exp(A)")
              (("" (ground)
                (("" (replace -2 * LR)
                  (("" (expand "subterm")
                    (("" (expand "subterm") (("" (propax) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((subterm_transitivity formula-decl nil peg nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (peg type-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.e1"
    "{e: wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].Δ | peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].subterm(e, semantic_tlparser.P_exp(semantic_tlparser.A))}")))
 (semtlpp_TCC37 0
  (semtlpp_TCC22-1 nil 3804395188
   ("" (skeep*)
    (("" (typepred "s_T")
      (("" (assert)
        (("" (expand "g_wf" -)
          (("" (replace -3 * LR)
            (("" (flatten) (("" (assert) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (subterm adt-def-decl "boolean" peg nil)
    (g_wf def-decl "bool" wf_peg nil) (peg type-decl nil peg nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.s_T"
    "{k: naturalnumbers.upto(semantic_tlparser.s) | booleans.⇒((k = semantic_tlparser.s), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].g_wf(semantic_tlparser.e1, semantic_tlparser.A, wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].P_0c?(semantic_tlparser.P_exp), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].strong))}")))
 (semtlpp_TCC38 0
  (semtlpp_TCC75-1 nil 3804395188
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (expand "astType?" 1 2)
          (("" (expand "astType?" 1 2) (("" (assert) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure"
    "semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC39 0
  (semtlpp_TCC77-1 nil 3804395188
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (typepred "status1")
          (("" (assert)
            (("" (expand "s_inp")
              (("" (expand "astType?" 1 1)
                ((""
                  (lemma "semantic_interp_props"
                   (T "parsing(P_exp, A, e1, inp, s, s_T)" P_inp
                    P_inp))
                  (("" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astTypeOf type-eq-decl nil semantic_tlparser nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (<= const-decl "bool" reals nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (astType? def-decl "astType" ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (astType type-decl nil ast nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semantic_interp_props formula-decl nil semantic_interp nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T1))"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC40 0
  (semtlpp_TCC24-1 nil 3804395188
   ("" (skeep*)
    (("" (lemma "peg[V_T, <=, V_N_b].subterm_transitivity")
      (("" (inst-cp -1 "e1" "G" "P_exp(A)")
        (("" (inst -1 "e2" "G" "P_exp(A)")
          (("" (replace -3 * LR)
            (("" (assert)
              (("" (expand "subterm" 1)
                (("" (expand "subterm" 1) (("" (propax) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (subterm_transitivity formula-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.e2"
    "{e: wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].Δ | peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].subterm(e, semantic_tlparser.P_exp(semantic_tlparser.A))}")))
 (semtlpp_TCC41 0
  (semtlpp_TCC25-1 nil 3804395188
   ("" (skeep*)
    (("" (typepred "s_T")
      (("" (assert)
        (("" (replace -3 * LR)
          (("" (expand "g_wf" -)
            (("" (typepred "T1")
              ((""
                (lemma "semantic_interp_props"
                 ("T" "parsing(P_exp, A, e1, inp, s, s_T)" P_inp
                  P_inp))
                (("" (flatten)
                  (("" (assert)
                    (("" (replace -5 * RL)
                      (("" (lemma "Wellformed_theorem" (T T1))
                        (("" (assert)
                          (("" (flatten)
                            (("" (assert)
                              ((""
                                (flatten)
                                ((""
                                  (assert)
                                  ((""
                                    (flatten)
                                    ((""
                                      (assert)
                                      ((""
                                        (expand "strong")
                                        ((""
                                          (case "P_0c?(P_exp)(e1)")
                                          (("1" (assert) nil nil)
                                           ("2"
                                            (hide 2 3)
                                            (("2"
                                              (typepred
                                               " parsing(P_exp, A, e1, inp, s, s_T)")
                                              (("2" (assert) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (subterm adt-def-decl "boolean" peg nil)
    (g_wf def-decl "bool" wf_peg nil) (peg type-decl nil peg nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (sem_result type-eq-decl nil semantic_tlparser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (ast type-eq-decl nil ast nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (semantic_interp_props formula-decl nil semantic_interp nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.s_T"
    "{k: naturalnumbers.upto(pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T1)) | booleans.⇒((k = pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T1)), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].g_wf(semantic_tlparser.e2, semantic_tlparser.A, wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].P_0c?(semantic_tlparser.P_exp), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].strong))}")))
 (semtlpp_TCC42 0
  (semtlpp_TCC81-1 nil 3804395188
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "astType?")
            (("" (typepred "status1")
              (("" (typepred "status2")
                (("" (assert)
                  (("" (typepred "T1")
                    ((""
                      (lemma "semantic_interp_props"
                       ("T" "parsing(P_exp, A, e1, inp, s, s_T)" P_inp
                        P_inp))
                      (("" (flatten)
                        (("" (replace -5 * RL)
                          (("" (lemma "Wellformed_theorem" (T T1))
                            (("" (assert)
                              ((""
                                (flatten)
                                (("" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astTypeOf type-eq-decl nil semantic_tlparser nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (<= const-decl "bool" reals nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (astType type-decl nil ast nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semantic_interp_props formula-decl nil semantic_interp nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (sem_result type-eq-decl nil semantic_tlparser nil)
    (astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure"
    "semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC43 0
  (semtlpp_TCC82-1 nil 3804395188
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "s_inp")
            (("" (expand "astType?")
              (("" (typepred "status1")
                (("" (typepred "status2")
                  (("" (typepred "T1")
                    ((""
                      (lemma "semantic_interp_props"
                       ("T" "parsing(P_exp, A, e1, inp, s, s_T)" P_inp
                        P_inp))
                      (("" (flatten)
                        (("" (assert)
                          (("" (lemma "Wellformed_theorem" (T T1))
                            (("" (assert)
                              ((""
                                (assert)
                                ((""
                                  (flatten)
                                  ((""
                                    (assert)
                                    ((""
                                      (replace -7 * RL)
                                      ((""
                                        (replace -4 * LR)
                                        ((""
                                          (typepred "T2")
                                          ((""
                                            (lemma
                                             "semantic_interp_props"
                                             (T
                                              "parsing(P_exp, A, e2, inp, e(T1), s_T)"
                                              P_inp
                                              P_inp))
                                            (("" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (sem_result type-eq-decl nil semantic_tlparser nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semantic_interp_props formula-decl nil semantic_interp nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (astType type-decl nil ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (peg type-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (<= const-decl "bool" reals nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (astTypeOf type-eq-decl nil semantic_tlparser nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T2))"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC44 0
  (semtlpp_TCC84-1 nil 3804395188
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "astType?")
            (("" (typepred "status1")
              (("" (typepred "status2")
                (("" (typepred "T1")
                  ((""
                    (lemma "semantic_interp_props"
                     ("T" "parsing(P_exp, A, e1, inp, s, s_T)" P_inp
                      P_inp))
                    (("" (flatten)
                      (("" (assert)
                        (("" (lemma "Wellformed_theorem" (T T1))
                          (("" (assert)
                            (("" (typepred "T2")
                              ((""
                                (lemma
                                 "semantic_interp_props"
                                 (T
                                  "parsing(P_exp, A, e2, inp, e(T1), s_T)"
                                  P_inp
                                  P_inp))
                                ((""
                                  (assert)
                                  ((""
                                    (ground)
                                    ((""
                                      (lift-if)
                                      ((""
                                        (assert)
                                        ((""
                                          (split)
                                          (("1" (propax) nil nil)
                                           ("2"
                                            (replace -8 * RL)
                                            (("2"
                                              (replace -5 * LR)
                                              (("2"
                                                (lemma
                                                 "Wellformed_theorem"
                                                 (T T1))
                                                (("2"
                                                  (lemma
                                                   "Wellformed_theorem"
                                                   (T T2))
                                                  (("2"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astTypeOf type-eq-decl nil semantic_tlparser nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (<= const-decl "bool" reals nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (astType type-decl nil ast nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (semantic_interp_props formula-decl nil semantic_interp nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (sem_result type-eq-decl nil semantic_tlparser nil)
    (astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success"
    "semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC45 0
  (semtlpp_TCC27-1 nil 3804395188
   ("" (skeep*)
    (("" (typepred "T1")
      ((""
        (lemma "semantic_interp_props"
         (T "parsing(P_exp, A, e1, inp, s, s_T)" P_inp P_inp))
        (("" (flatten)
          (("" (replace -5 * RL)
            (("" (expand "astWellformed?") (("" (assert) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((sem_result type-eq-decl nil semantic_tlparser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (ast type-eq-decl nil ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semantic_interp_props formula-decl nil semantic_interp nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.T1"
    "{T: pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast | (booleans.¬)(pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].skip?(T))}")))
 (semtlpp_TCC46 0
  (semtlpp_TCC88-1 nil 3804395188
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "s_inp")
            (("" (expand "astType?")
              (("" (typepred "T1")
                (("" (typepred "T2")
                  (("" (lemma "Wellformed_theorem" (T T1))
                    (("" (lemma "Wellformed_theorem" (T T2))
                      (("" (assert)
                        (("" (flatten) (("" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (astType type-decl nil ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (peg type-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (ast type-eq-decl nil ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (sem_result type-eq-decl nil semantic_tlparser nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].seq(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T2), semantic_tlparser.T1, semantic_tlparser.T2)"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC47 0
  (semtlpp_TCC29-1 nil 3804395188
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (rewrite "lex4_lt")
        (("" (rewrite "lex3_lt")
          (("" (rewrite "lex2_lt")
            (("" (typepred "T1")
              (("" (lemma "Wellformed_theorem" (T T1))
                (("" (assert)
                  (("" (flatten)
                    (("" (assert) (("" (grind) nil nil)) nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((lex3_lt formula-decl nil lex3 nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (sum const-decl "nat" peg nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (lex2_lt formula-decl nil lex2 nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (seq adt-constructor-decl "[[peg, peg] -> (seq?)]" peg nil)
    (seq? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (pegMeasure const-decl "nat" peg nil)
    (sem_result type-eq-decl nil semantic_tlparser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (ast type-eq-decl nil ast nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (subterm adt-def-decl "boolean" peg nil)
    (g_wf def-decl "bool" wf_peg nil) (peg type-decl nil peg nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (lex4_lt formula-decl nil lex4 nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp termination
    "semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, semantic_tlparser.e2, semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T1), semantic_tlparser.s_T, semantic_tlparser.res, (LAMBDA (status2: semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e2, semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T1), semantic_tlparser.s_T))), (T2: semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e2, semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T1), semantic_tlparser.s_T)), (res: semantic_tlparser.results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): IF (status2 = ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure) THEN semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T2)), res) ELSE semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].seq(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T2), semantic_tlparser.T1, T2), res) ENDIF))"
    "nil")))
 (semtlpp_TCC48 0
  (semtlpp_TCC31-1 nil 3804395188
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (rewrite "lex4_lt")
        (("" (rewrite "lex3_lt")
          (("" (rewrite "lex2_lt")
            (("" (assert) (("" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((lex3_lt formula-decl nil lex3 nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (sum const-decl "nat" peg nil) (lex2_lt formula-decl nil lex2 nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (seq adt-constructor-decl "[[peg, peg] -> (seq?)]" peg nil)
    (seq? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (pegMeasure const-decl "nat" peg nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (subterm adt-def-decl "boolean" peg nil)
    (g_wf def-decl "bool" wf_peg nil) (peg type-decl nil peg nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (lex4_lt formula-decl nil lex4 nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp termination
    "semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, semantic_tlparser.e1, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T, semantic_tlparser.res, (LAMBDA (status1: semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e1, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))), (T1: semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e1, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)), (res: semantic_tlparser.results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): IF (status1 = ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure) THEN semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T1)), res) ELSE semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, semantic_tlparser.e2, semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T1), semantic_tlparser.s_T, res, LAMBDA (status2: semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e2, semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T1), semantic_tlparser.s_T))), (T2: semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e2, semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T1), semantic_tlparser.s_T)), (res: semantic_tlparser.results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): IF (status2 = ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure) THEN semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T2)), res) ELSE semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].seq(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T2), T1, T2), res) ENDIF) ENDIF))"
    "nil")))
 (semtlpp_TCC49 0
  (semtlpp_TCC33-1 nil 3804395188
   ("" (skeep*)
    (("" (lemma "peg[V_T, <=, V_N_b].subterm_transitivity")
      (("" (inst-cp -1 "e1" "G" "P_exp(A)")
        (("" (inst -1 "e2" "G" "P_exp(A)")
          (("" (replace -3 * LR)
            (("" (assert)
              (("" (expand "subterm" 1)
                (("" (expand "subterm" 1) (("" (propax) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (subterm_transitivity formula-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.e1"
    "{e: wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].Δ | peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].subterm(e, semantic_tlparser.P_exp(semantic_tlparser.A))}")))
 (semtlpp_TCC50 0
  (semtlpp_TCC34-1 nil 3804395188
   ("" (skeep*)
    (("" (typepred "s_T")
      (("" (assert)
        (("" (expand "g_wf" -)
          (("" (replace -3 * LR)
            (("" (flatten) (("" (assert) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (subterm adt-def-decl "boolean" peg nil)
    (g_wf def-decl "bool" wf_peg nil) (peg type-decl nil peg nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.s_T"
    "{k: naturalnumbers.upto(semantic_tlparser.s) | booleans.⇒((k = semantic_tlparser.s), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].g_wf(semantic_tlparser.e1, semantic_tlparser.A, wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].P_0c?(semantic_tlparser.P_exp), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].strong))}")))
 (semtlpp_TCC51 0
  (semtlpp_TCC58-1 nil 3804399719
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "astType?") (("" (propax) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success"
    "semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC52 0
  (semtlpp_TCC35-1 nil 3804395188
   ("" (skeep*)
    (("" (typepred "T1")
      (("" (case "astWellformed?(T1)")
        (("1" (assert)
          (("1" (expand "astWellformed?" -) (("1" (propax) nil nil))
            nil))
          nil)
         ("2" (assert) nil nil))
        nil))
      nil))
    nil)
   ((sem_result type-eq-decl nil semantic_tlparser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (ast type-eq-decl nil ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.T1"
    "{T: pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast | (booleans.¬)(pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].skip?(T))}")))
 (semtlpp_TCC53 0
  (semtlpp_TCC60-1 nil 3804399719
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (assert)
          (("" (assert)
            (("" (expand "s_inp")
              (("" (expand "astType?")
                (("" (assert)
                  (("" (expand "s_inp" 1 2)
                    (("" (expand "astType?") (("" (assert) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].prior(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T1), semantic_tlparser.T1, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].skip(semantic_tlparser.s, semantic_tlparser.s, semantic_tlparser.e2))"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC54 0
  (semtlpp_TCC37-1 nil 3804395188
   ("" (skeep*)
    (("" (lemma "peg[V_T, <=, V_N_b].subterm_transitivity")
      (("" (inst-cp -1 "e1" "G" "P_exp(A)")
        (("" (inst -1 "e2" "G" "P_exp(A)")
          (("" (replace -3 * LR)
            (("" (assert)
              (("" (expand "subterm" 1)
                (("" (expand "subterm" 1) (("" (propax) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (subterm_transitivity formula-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.e2"
    "{e: wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].Δ | peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].subterm(e, semantic_tlparser.P_exp(semantic_tlparser.A))}")))
 (semtlpp_TCC55 0
  (semtlpp_TCC38-1 nil 3804395188
   ("" (skeep*)
    (("" (typepred "s_T")
      (("" (assert)
        (("" (expand "g_wf" -)
          (("" (replace -3 * LR)
            (("" (flatten) (("" (assert) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (subterm adt-def-decl "boolean" peg nil)
    (g_wf def-decl "bool" wf_peg nil) (peg type-decl nil peg nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.s_T"
    "{k: naturalnumbers.upto(semantic_tlparser.s) | booleans.⇒((k = semantic_tlparser.s), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].g_wf(semantic_tlparser.e2, semantic_tlparser.A, wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].P_0c?(semantic_tlparser.P_exp), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].strong))}")))
 (semtlpp_TCC56 0
  (semtlpp_TCC63-1 nil 3804399719
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "astType?")
            (("" (lift-if)
              (("" (split)
                (("1" (propax) nil nil)
                 ("2" (assert)
                  (("2" (lemma "Wellformed_theorem" (T T1))
                    (("2" (assert)
                      (("2" (typepred "status1")
                        (("2" (typepred "T1") (("2" (assert) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astTypeOf type-eq-decl nil semantic_tlparser nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (astType type-decl nil ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (peg type-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (ast type-eq-decl nil ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (sem_result type-eq-decl nil semantic_tlparser nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success"
    "semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC57 0
  (semtlpp_TCC39-1 nil 3804395188
   ("" (skeep*)
    (("" (typepred "T1")
      (("" (case "astWellformed?(T1)")
        (("1" (assert)
          (("1" (expand "astWellformed?" -) (("1" (propax) nil nil))
            nil))
          nil)
         ("2" (assert) nil nil))
        nil))
      nil))
    nil)
   ((sem_result type-eq-decl nil semantic_tlparser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (ast type-eq-decl nil ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.T1"
    "{T: pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast | (booleans.¬)(pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].skip?(T))}")))
 (semtlpp_TCC58 0
  (semtlpp_TCC65-1 nil 3804399719
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "s_inp")
            (("" (expand "astType?")
              (("" (typepred "T1")
                (("" (typepred "T2")
                  (("" (lemma "Wellformed_theorem" (T T1))
                    (("" (lemma "Wellformed_theorem" (T T2))
                      (("" (assert)
                        (("" (flatten) (("" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (astType type-decl nil ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (peg type-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (ast type-eq-decl nil ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (sem_result type-eq-decl nil semantic_tlparser nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].prior(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T2), semantic_tlparser.T1, semantic_tlparser.T2)"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC59 0
  (semtlpp_TCC66-1 nil 3804399719
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "astType?")
            (("" (lift-if)
              (("" (split)
                (("1" (propax) nil nil)
                 ("2" (assert)
                  (("2" (lemma "Wellformed_theorem" (T T1))
                    (("2" (lemma "Wellformed_theorem" (T T2))
                      (("2" (typepred "status1")
                        (("2" (typepred "status2")
                          (("2" (typepred "T1")
                            (("2" (typepred "T2")
                              (("2"
                                (assert)
                                (("2"
                                  (flatten)
                                  (("2"
                                    (replace -3 * RL)
                                    (("2"
                                      (replace -4 * RL)
                                      (("2" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (astTypeOf type-eq-decl nil semantic_tlparser nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (astType type-decl nil ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (peg type-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (ast type-eq-decl nil ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (sem_result type-eq-decl nil semantic_tlparser nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure"
    "semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC60 0
  (semtlpp_TCC67-1 nil 3804399719
   ("" (assert)
    (("" (skeep*)
      (("" (replace -1 * LR)
        (("" (expand "parsing")
          (("" (assert)
            (("" (expand "s_inp")
              (("" (expand "astType?")
                (("" (typepred "T1")
                  (("" (replace -1 * RL)
                    (("" (assert)
                      (("" (lemma "Wellformed_theorem" (T T1))
                        (("" (assert)
                          (("" (assert)
                            (("" (flatten)
                              ((""
                                (assert)
                                ((""
                                  (typepred "T2")
                                  ((""
                                    (lift-if)
                                    ((""
                                      (split)
                                      (("1" (assert) nil nil)
                                       ("2"
                                        (flatten)
                                        (("2"
                                          (assert)
                                          (("2"
                                            (assert)
                                            (("2"
                                              (typepred "status2")
                                              (("2"
                                                (replace -1 * RL)
                                                (("2"
                                                  (lemma
                                                   "semantic_interp_props"
                                                   (T
                                                    "parsing(P_exp, A, e2, inp, s, s_T)"
                                                    P_inp
                                                    P_inp))
                                                  (("2"
                                                    (replace -3 * RL)
                                                    (("2"
                                                      (flatten)
                                                      (("2"
                                                        (lemma
                                                         "Wellformed_theorem"
                                                         (T T2))
                                                        (("2"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((TRUE const-decl "bool" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (sem_result type-eq-decl nil semantic_tlparser nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (ast type-eq-decl nil ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (astTypeOf type-eq-decl nil semantic_tlparser nil)
    (semantic_interp_props formula-decl nil semantic_interp nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (astType? def-decl "astType" ast nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T2))"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC61 0
  (semtlpp_TCC42-1 nil 3804395188
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (rewrite "lex4_lt")
        (("" (rewrite "lex3_lt")
          (("" (rewrite "lex2_lt")
            (("" (typepred "T1")
              (("" (lemma "Wellformed_theorem" (T T1))
                (("" (assert)
                  (("" (flatten)
                    (("" (assert) (("" (grind) nil nil)) nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((lex3_lt formula-decl nil lex3 nil)
    (sem_result type-eq-decl nil semantic_tlparser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (ast type-eq-decl nil ast nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (sum const-decl "nat" peg nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (lex2_lt formula-decl nil lex2 nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (prior adt-constructor-decl "[[peg, peg] -> (prior?)]" peg nil)
    (prior? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (pegMeasure const-decl "nat" peg nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (subterm adt-def-decl "boolean" peg nil)
    (g_wf def-decl "bool" wf_peg nil) (peg type-decl nil peg nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (lex4_lt formula-decl nil lex4 nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp termination
    "semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, semantic_tlparser.e2, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T, semantic_tlparser.res, (LAMBDA (status2: semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e2, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))), (T2: semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e2, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)), (res: semantic_tlparser.results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): IF (status2 = ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success) THEN semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].prior(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T2), semantic_tlparser.T1, T2), res) ELSE semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T2)), res) ENDIF))"
    "nil")))
 (semtlpp_TCC62 0
  (semtlpp_TCC44-1 nil 3804395188
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (rewrite "lex4_lt")
        (("" (rewrite "lex3_lt")
          (("" (rewrite "lex2_lt")
            (("" (assert) (("" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((lex3_lt formula-decl nil lex3 nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (sum const-decl "nat" peg nil) (lex2_lt formula-decl nil lex2 nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (prior adt-constructor-decl "[[peg, peg] -> (prior?)]" peg nil)
    (prior? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (pegMeasure const-decl "nat" peg nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (subterm adt-def-decl "boolean" peg nil)
    (g_wf def-decl "bool" wf_peg nil) (peg type-decl nil peg nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (lex4_lt formula-decl nil lex4 nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp termination
    "semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, semantic_tlparser.e1, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T, semantic_tlparser.res, (LAMBDA (status1: semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e1, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))), (T1: semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e1, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)), (res: semantic_tlparser.results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): IF (status1 = ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success) THEN semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].prior(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T1), T1, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].skip(semantic_tlparser.s, semantic_tlparser.s, semantic_tlparser.e2)), res) ELSE semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, semantic_tlparser.e2, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T, res, LAMBDA (status2: semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e2, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))), (T2: semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e2, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)), (res: semantic_tlparser.results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): IF (status2 = ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success) THEN semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].prior(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T2), T1, T2), res) ELSE semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T2)), res) ENDIF) ENDIF))"
    "nil")))
 (semtlpp_TCC63 0
  (semtlpp_TCC46-1 nil 3804395188
   ("" (skeep*)
    (("" (lemma "peg[V_T, <=, V_N_b].subterm_transitivity")
      (("" (inst -1 "e" "G" "P_exp(A)")
        (("" (replace -2 * LR)
          (("" (assert)
            (("" (expand "subterm" 1)
              (("" (expand "subterm" 1) (("" (propax) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (subterm_transitivity formula-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.e"
    "{e: wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].Δ | peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].subterm(e, semantic_tlparser.P_exp(semantic_tlparser.A))}")))
 (semtlpp_TCC64 0
  (semtlpp_TCC47-1 nil 3804395188
   ("" (skeep*)
    (("" (typepred "s_T")
      (("" (assert)
        (("" (expand "g_wf" -)
          (("" (replace -3 * LR)
            (("" (flatten) (("" (assert) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (subterm adt-def-decl "boolean" peg nil)
    (g_wf def-decl "bool" wf_peg nil) (peg type-decl nil peg nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.s_T"
    "{k: naturalnumbers.upto(semantic_tlparser.s) | booleans.⇒((k = semantic_tlparser.s), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].g_wf(semantic_tlparser.e, semantic_tlparser.A, wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].P_0c?(semantic_tlparser.P_exp), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].strong))}")))
 (semtlpp_TCC65 0
  (semtlpp_TCC76-1 nil 3804399719
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "astType?") (("" (propax) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success"
    "semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC66 0
  (semtlpp_TCC48-1 nil 3804395188
   ("" (skeep*)
    (("" (typepred "T0")
      (("" (case "astWellformed?(T0)")
        (("1" (assert)
          (("1" (expand "astWellformed?" -) (("1" (propax) nil nil))
            nil))
          nil)
         ("2" (assert) nil nil))
        nil))
      nil))
    nil)
   ((sem_result type-eq-decl nil semantic_tlparser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (ast type-eq-decl nil ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.T0"
    "{T: pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast | (booleans.¬)(pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].skip?(T))}")))
 (semtlpp_TCC67 0
  (semtlpp_TCC78-1 nil 3804399719
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "s_inp")
            (("" (expand "astType?")
              (("" (typepred "T0")
                (("" (replace -1 * RL)
                  (("" (lemma "Wellformed_theorem" (T T0))
                    (("" (assert)
                      (("" (assert)
                        (("" (expand "s_inp" +)
                          (("" (lift-if)
                            (("" (split)
                              (("1"
                                (flatten)
                                (("1"
                                  (assert)
                                  (("1"
                                    (expand "astType?")
                                    (("1" (propax) nil nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (assert) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (astType type-decl nil ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (peg type-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (ast type-eq-decl nil ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (sem_result type-eq-decl nil semantic_tlparser nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].star(semantic_tlparser.s, semantic_tlparser.s, semantic_tlparser.T0, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].skip(pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T0), pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T0), peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].star(semantic_tlparser.e)))"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC68 0
  (semtlpp_TCC50-1 nil 3804395188 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (peg type-decl nil peg nil) (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (subterm adt-def-decl "boolean" peg nil)
    (<= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (saved_result type-decl nil semantic_tlparser nil)
    (known? adt-recognizer-decl "[saved_result -> boolean]"
     semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (astType type-decl nil ast nil) (pre_ast type-decl nil pre_ast nil)
    (astType? def-decl "astType" ast nil)
    (input type-eq-decl nil ast_props nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil) (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (valuedTree? const-decl "bool" semantic_interp nil)
    (T adt-accessor-decl "[(known?) -> (valuedTree?)]"
     semantic_tlparser nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail adt-constructor-decl "[[below, below] -> (fail?)]" pre_ast
     nil)
    (semantic? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (semantic adt-constructor-decl
     "[[below, below, V_N[V_N_b], V_S] -> (semantic?)]" pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (status adt-accessor-decl
            "[(known?) -> astType[V_T, <=, V_N_b, bound, V_S]]"
            semantic_tlparser nil)
    (results type-eq-decl nil semantic_tlparser nil)
    (sem_result type-eq-decl nil semantic_tlparser nil)
    (astTypeOf type-eq-decl nil semantic_tlparser nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (semtlpp subtype
    "peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].star(semantic_tlparser.e)"
    "{e: wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].Δ | peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].subterm(e, semantic_tlparser.P_exp(semantic_tlparser.A))}")))
 (semtlpp_TCC69 0
  (semtlpp_TCC51-1 nil 3804395188
   ("" (skeep*)
    (("" (typepred "s_T")
      (("" (replace -3 * LR)
        (("" (assert)
          (("" (typepred "T0")
            (("" (assert)
              (("" (lemma "Wellformed_theorem" (T T0))
                (("" (assert)
                  (("" (flatten)
                    (("" (assert)
                      (("" (flatten) (("" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (subterm adt-def-decl "boolean" peg nil)
    (g_wf def-decl "bool" wf_peg nil) (peg type-decl nil peg nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (pre_ast type-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (ast type-eq-decl nil ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (sem_result type-eq-decl nil semantic_tlparser nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.s_T"
    "{k: naturalnumbers.upto(pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T0)) | booleans.⇒((k = pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T0)), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].g_wf(peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].star(semantic_tlparser.e), semantic_tlparser.A, wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].P_0c?(semantic_tlparser.P_exp), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].strong))}")))
 (semtlpp_TCC70 0
  (semtlpp_TCC81-1 nil 3804399719
   ("" (skeep*)
    (("" (replace -1 * LR)
      ((""
        (typepred "parsing[V_T, <=, V_N_b, bound, V_S]
                (P_exp, A, star(e), inp, s, s_T)")
        (("" (assert)
          (("" (expand "trueToGrammar")
            (("" (flatten)
              ((""
                (lemma "Star_cannot_fail"
                 (T "parsing[V_T, <=, V_N_b, bound, V_S]
                (P_exp, A, star(e), inp, s, s_T)"))
                (("" (assert)
                  (("" (flatten)
                    ((""
                      (lemma "Wellformed_theorem"
                       (T "parsing[V_T, <=, V_N_b, bound, V_S]
                (P_exp, A, star(e), inp, s, s_T)"))
                      (("" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (Star_cannot_fail formula-decl nil ast nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (pre_ast type-decl nil pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (peg type-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (<= const-decl "bool" reals nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (star adt-constructor-decl "[peg -> (star?)]" peg nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success"
    "semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC71 0
  (semtlpp_TCC52-1 nil 3804395188
   ("" (skeep*)
    (("" (typepred "T0")
      (("" (case "astWellformed?(T0)")
        (("1" (assert)
          (("1" (expand "astWellformed?" -) (("1" (propax) nil nil))
            nil))
          nil)
         ("2" (assert) nil nil))
        nil))
      nil))
    nil)
   ((sem_result type-eq-decl nil semantic_tlparser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (ast type-eq-decl nil ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.T0"
    "{T: pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast | (booleans.¬)(pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].skip?(T))}")))
 (semtlpp_TCC72 0
  (semtlpp_TCC53-1 nil 3804395188
   ("" (skeep*)
    (("" (typepred "Ts")
      (("" (typepred " parsing(P_exp, A, star(e), inp, e(T0), s_T)")
        (("" (expand "trueToGrammar")
          (("" (hide -4 -5 -6 -7 -8)
            (("" (expand "s_inp")
              (("" (assert)
                (("" (lift-if)
                  (("" (typepred "status0")
                    (("" (split -)
                      (("1" (assert)
                        (("1" (flatten)
                          (("1" (assert)
                            (("1" (use "Star_cannot_fail")
                              (("1" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil)
                       ("2" (flatten) (("2" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((sem_result type-eq-decl nil semantic_tlparser nil)
    (star adt-constructor-decl "[peg -> (star?)]" peg nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (ast type-eq-decl nil ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Star_cannot_fail formula-decl nil ast nil)
    (astTypeOf type-eq-decl nil semantic_tlparser nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.Ts"
    "{T: pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast | booleans.OR(pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].skip?(T), pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].star?(T))}")))
 (semtlpp_TCC73 0
  (semtlpp_TCC84-1 nil 3804399719
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "s_inp")
            (("" (expand "astType?")
              (("" (typepred "T0")
                (("" (replace -1 * RL)
                  (("" (assert)
                    (("" (lemma "Wellformed_theorem" (T T0))
                      (("" (assert)
                        (("" (flatten)
                          (("" (assert)
                            (("" (lift-if)
                              ((""
                                (split)
                                (("1"
                                  (assert)
                                  (("1"
                                    (flatten)
                                    (("1" (assert) nil nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (assert)
                                  (("2"
                                    (flatten)
                                    (("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (astType type-decl nil ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (peg type-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (ast type-eq-decl nil ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (sem_result type-eq-decl nil semantic_tlparser nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].star(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.Ts), semantic_tlparser.T0, semantic_tlparser.Ts)"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC74 0
  (semtlpp_TCC55-1 nil 3804395188
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (rewrite "lex4_lt")
        (("" (rewrite "lex3_lt")
          (("" (rewrite "lex2_lt")
            (("" (typepred "T0")
              (("" (lemma "Wellformed_theorem" (T T0))
                (("" (assert)
                  (("" (typepred " parsing(P_exp, A, e, inp, s, s_T)")
                    (("" (flatten)
                      (("" (assert)
                        (("" (typepred "G")
                          (("" (typepred "P_exp")
                            ((""
                              (lemma "complete_WF_theorem"
                               (P_exp P_exp A A G G))
                              ((""
                                (assert)
                                ((""
                                  (replace -16 * LR)
                                  ((""
                                    (expand "g_wf")
                                    (("" (propax) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((lex3_lt formula-decl nil lex3 nil)
    (complete_WF_theorem formula-decl nil wf_peg nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (lex2_lt formula-decl nil lex2 nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (star adt-constructor-decl "[peg -> (star?)]" peg nil)
    (pegMeasure const-decl "nat" peg nil)
    (sem_result type-eq-decl nil semantic_tlparser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (ast type-eq-decl nil ast nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (subterm adt-def-decl "boolean" peg nil)
    (g_wf def-decl "bool" wf_peg nil) (peg type-decl nil peg nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (lex4_lt formula-decl nil lex4 nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp termination
    "semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].star(semantic_tlparser.e), semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T0), semantic_tlparser.s_T, semantic_tlparser.res, (LAMBDA (status2: semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].star(semantic_tlparser.e), semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T0), semantic_tlparser.s_T))), (Ts: semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].star(semantic_tlparser.e), semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T0), semantic_tlparser.s_T)), (res: semantic_tlparser.results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].star(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(Ts), semantic_tlparser.T0, Ts), res)))"
    "nil")))
 (semtlpp_TCC75 0
  (semtlpp_TCC57-1 nil 3804395188
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (rewrite "lex4_lt")
        (("" (rewrite "lex3_lt")
          (("" (rewrite "lex2_lt")
            (("" (assert) (("" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((lex3_lt formula-decl nil lex3 nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (inc const-decl "nat" peg nil) (lex2_lt formula-decl nil lex2 nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (star adt-constructor-decl "[peg -> (star?)]" peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (pegMeasure const-decl "nat" peg nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (subterm adt-def-decl "boolean" peg nil)
    (g_wf def-decl "bool" wf_peg nil) (peg type-decl nil peg nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (lex4_lt formula-decl nil lex4 nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp termination
    "semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T, semantic_tlparser.res, (LAMBDA (status0: semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))), (T0: semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)), (res: semantic_tlparser.results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): IF (status0 = ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure) THEN semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].star(semantic_tlparser.s, semantic_tlparser.s, T0, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].skip(pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T0), pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T0), peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].star(semantic_tlparser.e))), res) ELSE semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].star(semantic_tlparser.e), semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T0), semantic_tlparser.s_T, res, LAMBDA (status2: semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].star(semantic_tlparser.e), semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T0), semantic_tlparser.s_T))), (Ts: semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].star(semantic_tlparser.e), semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T0), semantic_tlparser.s_T)), (res: semantic_tlparser.results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].star(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(Ts), T0, Ts), res)) ENDIF))"
    "nil")))
 (semtlpp_TCC76 0
  (semtlpp_TCC59-1 nil 3804395188
   ("" (skeep*)
    (("" (lemma "peg[V_T, <=, V_N_b].subterm_transitivity")
      (("" (inst -1 "e" "G" "P_exp(A)")
        (("" (replace -2 * LR)
          (("" (assert)
            (("" (expand "subterm" 1)
              (("" (expand "subterm" 1) (("" (propax) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (subterm_transitivity formula-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.e"
    "{e: wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].Δ | peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].subterm(e, semantic_tlparser.P_exp(semantic_tlparser.A))}")))
 (semtlpp_TCC77 0
  (semtlpp_TCC60-1 nil 3804395188
   ("" (skeep*)
    (("" (typepred "s_T")
      (("" (assert)
        (("" (expand "g_wf" -)
          (("" (replace -3 * LR)
            (("" (flatten) (("" (assert) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (subterm adt-def-decl "boolean" peg nil)
    (g_wf def-decl "bool" wf_peg nil) (peg type-decl nil peg nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.s_T"
    "{k: naturalnumbers.upto(semantic_tlparser.s) | booleans.⇒((k = semantic_tlparser.s), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].g_wf(semantic_tlparser.e, semantic_tlparser.A, wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].P_0c?(semantic_tlparser.P_exp), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].strong))}")))
 (semtlpp_TCC78 0
  (semtlpp_TCC93-1 nil 3804399719
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "astType?") (("" (propax) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure"
    "semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC79 0
  (semtlpp_TCC94-1 nil 3804399719
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "s_inp")
            (("" (expand "astType?") (("" (propax) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, semantic_tlparser.s)"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC80 0
  (semtlpp_TCC70-1 nil 3804395188 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (peg type-decl nil peg nil) (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (subterm adt-def-decl "boolean" peg nil)
    (<= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (saved_result type-decl nil semantic_tlparser nil)
    (known? adt-recognizer-decl "[saved_result -> boolean]"
     semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (astType type-decl nil ast nil) (pre_ast type-decl nil pre_ast nil)
    (astType? def-decl "astType" ast nil)
    (input type-eq-decl nil ast_props nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil) (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (valuedTree? const-decl "bool" semantic_interp nil)
    (T adt-accessor-decl "[(known?) -> (valuedTree?)]"
     semantic_tlparser nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail adt-constructor-decl "[[below, below] -> (fail?)]" pre_ast
     nil)
    (semantic? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (semantic adt-constructor-decl
     "[[below, below, V_N[V_N_b], V_S] -> (semantic?)]" pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (status adt-accessor-decl
            "[(known?) -> astType[V_T, <=, V_N_b, bound, V_S]]"
            semantic_tlparser nil)
    (results type-eq-decl nil semantic_tlparser nil)
    (sem_result type-eq-decl nil semantic_tlparser nil)
    (astTypeOf type-eq-decl nil semantic_tlparser nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (semtlpp subtype
    "peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].plus(semantic_tlparser.e)"
    "{e: wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].Δ | peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].subterm(e, semantic_tlparser.P_exp(semantic_tlparser.A))}")))
 (semtlpp_TCC81 0
  (semtlpp_TCC63-1 nil 3804395188
   ("" (skeep*)
    (("" (typepred "s_T")
      (("" (replace -3 * LR)
        (("" (assert)
          (("" (typepred "T0")
            (("" (lemma "Wellformed_theorem" (T T0))
              (("" (assert)
                (("" (flatten)
                  (("" (assert)
                    (("" (flatten) (("" (assert) nil nil)) nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (subterm adt-def-decl "boolean" peg nil)
    (g_wf def-decl "bool" wf_peg nil) (peg type-decl nil peg nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (pre_ast type-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (ast type-eq-decl nil ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (sem_result type-eq-decl nil semantic_tlparser nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.s_T"
    "{k: naturalnumbers.upto(pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T0)) | booleans.⇒((k = pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T0)), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].g_wf(peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].plus(semantic_tlparser.e), semantic_tlparser.A, wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].P_0c?(semantic_tlparser.P_exp), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].strong))}")))
 (semtlpp_TCC82 0
  (semtlpp_TCC97-1 nil 3804399719
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "astType?")
            (("" (typepred "status0")
              (("" (lemma "Wellformed_theorem" (T T0))
                (("" (typepred "T0")
                  (("" (assert)
                    (("" (flatten)
                      (("" (assert)
                        ((""
                          (lemma "semantic_interp_props"
                           (T " parsing(P_exp, A, e, inp, s, s_T)"
                            P_inp P_inp))
                          (("" (replace -2 * RL)
                            (("" (flatten)
                              ((""
                                (lift-if 2)
                                ((""
                                  (split)
                                  (("1" (propax) nil nil)
                                   ("2"
                                    (assert)
                                    (("2"
                                      (flatten)
                                      (("2"
                                        (assert)
                                        (("2"
                                          (split)
                                          (("1" (propax) nil nil)
                                           ("2"
                                            (assert)
                                            (("2"
                                              (lemma
                                               "Wellformed_theorem"
                                               (T
                                                "parsing(P_exp, A, plus(e), inp,
                       e(parsing(P_exp, A, e, inp, s, s_T)), s_T)"))
                                              (("2" (assert) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astTypeOf type-eq-decl nil semantic_tlparser nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (<= const-decl "bool" reals nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (astType type-decl nil ast nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semantic_interp_props formula-decl nil semantic_interp nil)
    (plus adt-constructor-decl "[peg -> (plus?)]" peg nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (sem_result type-eq-decl nil semantic_tlparser nil)
    (astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success"
    "semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC83 0
  (semtlpp_TCC64-1 nil 3804395188
   ("" (skeep*)
    (("" (typepred "T0")
      (("" (case "astWellformed?(T0)")
        (("1" (assert)
          (("1" (expand "astWellformed?" -) (("1" (propax) nil nil))
            nil))
          nil)
         ("2" (assert) nil nil))
        nil))
      nil))
    nil)
   ((sem_result type-eq-decl nil semantic_tlparser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (ast type-eq-decl nil ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.T0"
    "{T: pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast | (booleans.¬)(pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].skip?(T))}")))
 (semtlpp_TCC84 0
  (semtlpp_TCC65-1 nil 3804395188
   ("" (skeep*)
    (("" (typepred "Ts")
      (("" (expand "parsing")
        (("" (typepred "status0")
          (("" (assert)
            (("" (lift-if)
              (("" (split)
                (("1" (flatten)
                  (("1" (expand "s_inp")
                    (("1" (ground)
                      (("1" (lift-if)
                        (("1" (split)
                          (("1" (flatten) (("1" (assert) nil nil)) nil)
                           ("2" (flatten) (("2" (assert) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (assert)
                    (("2" (expand "s_inp")
                      (("2" (lift-if)
                        (("2" (split)
                          (("1" (flatten) (("1" (assert) nil nil)) nil)
                           ("2" (flatten) (("2" (assert) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((sem_result type-eq-decl nil semantic_tlparser nil)
    (plus adt-constructor-decl "[peg -> (plus?)]" peg nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (ast type-eq-decl nil ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (astTypeOf type-eq-decl nil semantic_tlparser nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.Ts"
    "{T: pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast | booleans.OR(pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].skip?(T), booleans.OR(pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].plus?(T), pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail?(T)))}")))
 (semtlpp_TCC85 0
  (semtlpp_TCC100-1 nil 3804399719
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "s_inp")
            (("" (expand "astType?")
              (("" (typepred "T0")
                (("" (replace -1 * RL)
                  (("" (assert)
                    (("" (lemma "Wellformed_theorem" (T T0))
                      (("" (assert)
                        (("" (flatten)
                          (("" (assert)
                            (("" (lift-if)
                              ((""
                                (split)
                                (("1"
                                  (flatten)
                                  (("1"
                                    (lift-if)
                                    (("1"
                                      (split)
                                      (("1" (assert) nil nil)
                                       ("2"
                                        (assert)
                                        (("2" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (flatten)
                                  (("2"
                                    (assert)
                                    (("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (astType type-decl nil ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (peg type-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (ast type-eq-decl nil ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (sem_result type-eq-decl nil semantic_tlparser nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].plus(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.Ts), semantic_tlparser.T0, semantic_tlparser.Ts)"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC86 0
  (semtlpp_TCC67-1 nil 3804395188
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (rewrite "lex4_lt")
        (("" (rewrite "lex3_lt")
          (("" (rewrite "lex2_lt")
            (("" (typepred "T0")
              (("" (lemma "Wellformed_theorem" (T T0))
                (("" (assert)
                  (("" (flatten)
                    (("" (assert)
                      (("" (typepred "G")
                        (("" (typepred "P_exp")
                          ((""
                            (lemma "complete_WF_theorem"
                             (P_exp P_exp A A G G))
                            (("" (assert)
                              ((""
                                (expand "g_wf")
                                ((""
                                  (replace -7 * LR)
                                  ((""
                                    (assert)
                                    ((""
                                      (flatten)
                                      ((""
                                        (typepred
                                         "parsing(P_exp, A, e, inp, s, s_T)")
                                        (("" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((lex3_lt formula-decl nil lex3 nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (complete_WF_theorem formula-decl nil wf_peg nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (lex2_lt formula-decl nil lex2 nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (plus adt-constructor-decl "[peg -> (plus?)]" peg nil)
    (pegMeasure const-decl "nat" peg nil)
    (sem_result type-eq-decl nil semantic_tlparser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (ast type-eq-decl nil ast nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (subterm adt-def-decl "boolean" peg nil)
    (g_wf def-decl "bool" wf_peg nil) (peg type-decl nil peg nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (lex4_lt formula-decl nil lex4 nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp termination
    "semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].plus(semantic_tlparser.e), semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T0), semantic_tlparser.s_T, semantic_tlparser.res, (LAMBDA (status2: semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].plus(semantic_tlparser.e), semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T0), semantic_tlparser.s_T))), (Ts: semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].plus(semantic_tlparser.e), semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T0), semantic_tlparser.s_T)), (res: semantic_tlparser.results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].plus(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(Ts), semantic_tlparser.T0, Ts), res)))"
    "nil")))
 (semtlpp_TCC87 0
  (semtlpp_TCC69-1 nil 3804395188
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (rewrite "lex4_lt")
        (("" (rewrite "lex3_lt")
          (("" (rewrite "lex2_lt")
            (("" (assert)
              (("" (expand "pegMeasure")
                (("" (expand "reduce_nat" 1 2)
                  (("" (assert) (("" (grind) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((lex3_lt formula-decl nil lex3 nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (inc const-decl "nat" peg nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (lex2_lt formula-decl nil lex2 nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (plus adt-constructor-decl "[peg -> (plus?)]" peg nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (pegMeasure const-decl "nat" peg nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (subterm adt-def-decl "boolean" peg nil)
    (g_wf def-decl "bool" wf_peg nil) (peg type-decl nil peg nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (lex4_lt formula-decl nil lex4 nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp termination
    "semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T, semantic_tlparser.res, (LAMBDA (status0: semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))), (T0: semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)), (res: semantic_tlparser.results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): IF (status0 = ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure) THEN semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, semantic_tlparser.s), res) ELSE semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].plus(semantic_tlparser.e), semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T0), semantic_tlparser.s_T, res, LAMBDA (status2: semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].plus(semantic_tlparser.e), semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T0), semantic_tlparser.s_T))), (Ts: semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].plus(semantic_tlparser.e), semantic_tlparser.inp, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T0), semantic_tlparser.s_T)), (res: semantic_tlparser.results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].plus(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(Ts), T0, Ts), res)) ENDIF))"
    "nil")))
 (semtlpp_TCC88 0
  (semtlpp_TCC71-1 nil 3804395188
   ("" (skeep*)
    (("" (lemma "peg[V_T, <=, V_N_b].subterm_transitivity")
      (("" (inst -1 "e" "G" "P_exp(A)")
        (("" (replace -2 * LR)
          (("" (assert)
            (("" (expand "subterm" 1)
              (("" (expand "subterm" 1) (("" (propax) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (subterm_transitivity formula-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.e"
    "{e: wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].Δ | peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].subterm(e, semantic_tlparser.P_exp(semantic_tlparser.A))}")))
 (semtlpp_TCC89 0
  (semtlpp_TCC72-1 nil 3804395188
   ("" (skeep*)
    (("" (typepred "s_T")
      (("" (assert)
        (("" (expand "g_wf" -)
          (("" (replace -3 * LR) (("" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (subterm adt-def-decl "boolean" peg nil)
    (g_wf def-decl "bool" wf_peg nil) (peg type-decl nil peg nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.s_T"
    "{k: naturalnumbers.upto(semantic_tlparser.s) | booleans.⇒((k = semantic_tlparser.s), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].g_wf(semantic_tlparser.e, semantic_tlparser.A, wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].P_0c?(semantic_tlparser.P_exp), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].strong))}")))
 (semtlpp_TCC90 0
  (semtlpp_TCC111-1 nil 3804399719
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "astType?") (("" (propax) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success"
    "semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC91 0
  (semtlpp_TCC74-1 nil 3804395188
   ("" (skeep*)
    (("" (typepred "T!1")
      (("" (case "astWellformed?(T!1)")
        (("1" (assert)
          (("1" (expand "astWellformed?" -) (("1" (propax) nil nil))
            nil))
          nil)
         ("2" (assert) nil nil))
        nil))
      nil))
    nil)
   ((sem_result type-eq-decl nil semantic_tlparser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (ast type-eq-decl nil ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.T"
    "{T: pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast | (booleans.¬)(pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].skip?(T))}")))
 (semtlpp_TCC92 0
  (semtlpp_TCC132-1 nil 3804399719
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "s_inp")
            (("" (expand "astType?") (("" (assert) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].opt(semantic_tlparser.s, semantic_tlparser.s, semantic_tlparser.T)"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC93 0
  (semtlpp_TCC119-1 nil 3804399719
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "astType?")
            (("" (lift-if)
              (("" (split)
                (("1" (propax) nil nil)
                 ("2" (flatten)
                  (("2"
                    (lemma "Wellformed_theorem"
                     (T "parsing(P_exp, A, e, inp, s, s_T)"))
                    (("2" (assert) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((Wellformed_theorem formula-decl nil ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (peg type-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (<= const-decl "bool" reals nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (astType type-decl nil ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success"
    "semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC94 0
  (semtlpp_TCC80-1 nil 3804395188
   ("" (skeep*)
    (("" (typepred "T!1")
      (("" (case "astWellformed?(T!1)")
        (("1" (assert)
          (("1" (expand "astWellformed?" -) (("1" (propax) nil nil))
            nil))
          nil)
         ("2" (assert) nil nil))
        nil))
      nil))
    nil)
   ((sem_result type-eq-decl nil semantic_tlparser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (ast type-eq-decl nil ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.T"
    "{T: pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast | (booleans.¬)(pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].skip?(T))}")))
 (semtlpp_TCC95 0
  (semtlpp_TCC113-1 nil 3804399719
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "s_inp")
            (("" (expand "astType?")
              (("" (typepred "T!1")
                ((""
                  (lemma "Wellformed_theorem"
                   (T "parsing(P_exp, A, e, inp, s, s_T)"))
                  (("" (assert)
                    (("" (flatten) (("" (assert) nil nil)) nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (astType type-decl nil ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (peg type-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (ast type-eq-decl nil ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (sem_result type-eq-decl nil semantic_tlparser nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].opt(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(semantic_tlparser.T), semantic_tlparser.T)"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC96 0
  (semtlpp_TCC76-1 nil 3804395188
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (rewrite "lex4_lt")
        (("" (rewrite "lex3_lt")
          (("" (rewrite "lex2_lt")
            (("" (assert) (("" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((lex3_lt formula-decl nil lex3 nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (inc const-decl "nat" peg nil) (lex2_lt formula-decl nil lex2 nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (opt adt-constructor-decl "[peg -> (opt?)]" peg nil)
    (opt? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (pegMeasure const-decl "nat" peg nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (subterm adt-def-decl "boolean" peg nil)
    (g_wf def-decl "bool" wf_peg nil) (peg type-decl nil peg nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (lex4_lt formula-decl nil lex4 nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp termination
    "semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T, semantic_tlparser.res, (LAMBDA (status: semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))), (T: semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)), (res: semantic_tlparser.results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): IF (status = ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure) THEN semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].opt(semantic_tlparser.s, semantic_tlparser.s, T), res) ELSE semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].opt(semantic_tlparser.s, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].e(T), T), res) ENDIF))"
    "nil")))
 (semtlpp_TCC97 0
  (semtlpp_TCC78-1 nil 3804395188
   ("" (skeep*)
    (("" (lemma "peg[V_T, <=, V_N_b].subterm_transitivity")
      (("" (inst -1 "e" "G" "P_exp(A)")
        (("" (replace -2 * LR)
          (("" (assert)
            (("" (expand "subterm" 1)
              (("" (expand "subterm" 1) (("" (propax) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (subterm_transitivity formula-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.e"
    "{e: wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].Δ | peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].subterm(e, semantic_tlparser.P_exp(semantic_tlparser.A))}")))
 (semtlpp_TCC98 0
  (semtlpp_TCC79-1 nil 3804395188
   ("" (skeep*)
    (("" (typepred "s_T")
      (("" (assert)
        (("" (expand "g_wf" -)
          (("" (replace -3 * LR) (("" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (subterm adt-def-decl "boolean" peg nil)
    (g_wf def-decl "bool" wf_peg nil) (peg type-decl nil peg nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.s_T"
    "{k: naturalnumbers.upto(semantic_tlparser.s) | booleans.⇒((k = semantic_tlparser.s), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].g_wf(semantic_tlparser.e, semantic_tlparser.A, wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].P_0c?(semantic_tlparser.P_exp), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].strong))}")))
 (semtlpp_TCC99 0
  (semtlpp_TCC129-1 nil 3804399719
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "astType?") (("" (propax) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success"
    "semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC100 0
  (semtlpp_TCC87-1 nil 3804395188
   ("" (skeep*)
    (("" (typepred "T!1")
      (("" (case "astWellformed?(T!1)")
        (("1" (assert)
          (("1" (expand "astWellformed?" -) (("1" (propax) nil nil))
            nil))
          nil)
         ("2" (assert) nil nil))
        nil))
      nil))
    nil)
   ((sem_result type-eq-decl nil semantic_tlparser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (ast type-eq-decl nil ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.T"
    "{T: pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast | (booleans.¬)(pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].skip?(T))}")))
 (semtlpp_TCC101 0
  (semtlpp_TCC121-1 nil 3804399719
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "s_inp")
            (("" (expand "astType?") (("" (assert) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].notP(semantic_tlparser.s, semantic_tlparser.s, semantic_tlparser.T)"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC102 0
  (semtlpp_TCC109-1 nil 3804399719
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "astType?")
            (("" (typepred "status!1")
              ((""
                (lemma "Wellformed_theorem"
                 (T "parsing(P_exp, A, e, inp, s, s_T)"))
                (("" (assert)
                  (("" (flatten) (("" (assert) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astTypeOf type-eq-decl nil semantic_tlparser nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (<= const-decl "bool" reals nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (astType type-decl nil ast nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure"
    "semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC103 0
  (semtlpp_TCC110-1 nil 3804399719
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "s_inp")
            (("" (expand "astType?")
              (("" (typepred "status!1")
                ((""
                  (lemma "Wellformed_theorem"
                   (T "parsing(P_exp, A, e, inp, s, s_T)"))
                  (("" (assert)
                    (("" (flatten) (("" (assert) nil nil)) nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (astType type-decl nil ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (peg type-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (<= const-decl "bool" reals nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (astTypeOf type-eq-decl nil semantic_tlparser nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, semantic_tlparser.s)"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC104 0
  (semtlpp_TCC83-1 nil 3804395188
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (rewrite "lex4_lt")
        (("" (rewrite "lex3_lt")
          (("" (rewrite "lex2_lt")
            (("" (assert) (("" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((lex3_lt formula-decl nil lex3 nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (inc const-decl "nat" peg nil) (lex2_lt formula-decl nil lex2 nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (notP adt-constructor-decl "[peg -> (notP?)]" peg nil)
    (notP? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (pegMeasure const-decl "nat" peg nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (subterm adt-def-decl "boolean" peg nil)
    (g_wf def-decl "bool" wf_peg nil) (peg type-decl nil peg nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (lex4_lt formula-decl nil lex4 nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp termination
    "semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T, semantic_tlparser.res, (LAMBDA (status: semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))), (T: semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)), (res: semantic_tlparser.results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): IF (status = ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure) THEN semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].notP(semantic_tlparser.s, semantic_tlparser.s, T), res) ELSE semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, semantic_tlparser.s), res) ENDIF))"
    "nil")))
 (semtlpp_TCC105 0
  (semtlpp_TCC85-1 nil 3804395188
   ("" (skeep*)
    (("" (lemma "peg[V_T, <=, V_N_b].subterm_transitivity")
      (("" (inst -1 "e" "G" "P_exp(A)")
        (("" (replace -2 * LR)
          (("" (assert)
            (("" (expand "subterm" 1)
              (("" (expand "subterm" 1) (("" (propax) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (subterm_transitivity formula-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.e"
    "{e: wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].Δ | peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].subterm(e, semantic_tlparser.P_exp(semantic_tlparser.A))}")))
 (semtlpp_TCC106 0
  (semtlpp_TCC86-1 nil 3804395188
   ("" (skeep*)
    (("" (typepred "s_T")
      (("" (assert)
        (("" (expand "g_wf" -)
          (("" (replace -3 * LR) (("" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (subterm adt-def-decl "boolean" peg nil)
    (g_wf def-decl "bool" wf_peg nil) (peg type-decl nil peg nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.s_T"
    "{k: naturalnumbers.upto(semantic_tlparser.s) | booleans.⇒((k = semantic_tlparser.s), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].g_wf(semantic_tlparser.e, semantic_tlparser.A, wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].P_0c?(semantic_tlparser.P_exp), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].strong))}")))
 (semtlpp_TCC107 0
  (semtlpp_TCC133-1 nil 3804399719
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "astType?") (("" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success"
    "semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC108 0
  (semtlpp_TCC108-1 nil 3804487992
   ("" (skeep*)
    (("" (case "astWellformed?(T!1)")
      (("1" (expand "astWellformed?") (("1" (assert) nil nil)) nil)
       ("2" (assert)
        (("2" (typepred "T!1") (("2" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((sem_result type-eq-decl nil semantic_tlparser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (ast type-eq-decl nil ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (astWellformed? def-decl "bool" ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype "semantic_tlparser.T"
    "{T: pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].pre_ast | (booleans.¬)(pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].skip?(T))}")))
 (semtlpp_TCC109 0
  (semtlpp_TCC131-1 nil 3804399719
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "s_inp")
            (("" (expand "astType?") (("" (assert) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].andP(semantic_tlparser.s, semantic_tlparser.s, semantic_tlparser.T)"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC110 0
  (semtlpp_TCC122-1 nil 3804399719
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "astType?")
            (("" (assert)
              (("" (typepred "status!1")
                ((""
                  (lemma "Wellformed_theorem"
                   (T "parsing(P_exp, A, e, inp, s, s_T)"))
                  (("" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((Wellformed_theorem formula-decl nil ast nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (astType type-decl nil ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (peg type-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (<= const-decl "bool" reals nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (astTypeOf type-eq-decl nil semantic_tlparser nil)
    (astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure"
    "semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))")))
 (semtlpp_TCC111 0
  (semtlpp_TCC123-1 nil 3804399719
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "s_inp")
            (("" (expand "astType?")
              (("" (typepred "status!1")
                ((""
                  (lemma "Wellformed_theorem"
                   (T "parsing(P_exp, A, e, inp, s, s_T)"))
                  (("" (assert)
                    (("" (flatten) (("" (assert) nil nil)) nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (V_S formal-type-decl nil semantic_tlparser nil)
    (astType type-decl nil ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (peg type-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (<= const-decl "bool" reals nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (astTypeOf type-eq-decl nil semantic_tlparser nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp subtype
    "pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, semantic_tlparser.s)"
    "semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.G, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)")))
 (semtlpp_TCC112 0
  (semtlpp_TCC90-1 nil 3804395188
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (rewrite "lex4_lt")
        (("" (rewrite "lex3_lt")
          (("" (rewrite "lex2_lt")
            (("" (assert) (("" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((lex3_lt formula-decl nil lex3 nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (inc const-decl "nat" peg nil) (lex2_lt formula-decl nil lex2 nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (andP adt-constructor-decl "[peg -> (andP?)]" peg nil)
    (andP? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (pegMeasure const-decl "nat" peg nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (subterm adt-def-decl "boolean" peg nil)
    (g_wf def-decl "bool" wf_peg nil) (peg type-decl nil peg nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_tlparser nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (bound formal-const-decl "posnat" semantic_tlparser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (lex4_lt formula-decl nil lex4 nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (semtlpp termination
    "semantic_tlparser.semtlpp(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T, semantic_tlparser.res, (LAMBDA (status: semantic_tlparser.astTypeOf(peg_parser[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].parsing(semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T))), (T: semantic_tlparser.sem_result(semantic_tlparser.P_inp, semantic_tlparser.P_exp, semantic_tlparser.A, semantic_tlparser.e, semantic_tlparser.inp, semantic_tlparser.s, semantic_tlparser.s_T)), (res: semantic_tlparser.results(semantic_tlparser.P_exp, semantic_tlparser.P_inp, semantic_tlparser.inp)): IF (status = ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success) THEN semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].success, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].andP(semantic_tlparser.s, semantic_tlparser.s, T), res) ELSE semantic_tlparser.cont(ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].failure, pre_ast[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b, semantic_tlparser.bound, semantic_tlparser.V_S].fail(semantic_tlparser.s, semantic_tlparser.s), res) ENDIF))"
    "nil")))
 (memoïzed_does_not_change 0
  (memoïzed_does_not_change-1 nil 3804503631
   ("" (skolem 1 ("P_exp" "P_inp" "_" "_" "inp" "_" "_" "_" "_" "_"))
    (("" (measure-induct "A" "A")
      (("" (skolem 1 "A")
        (("" (ground)
          (("" (measure-induct+ "pegMeasure(G)" "G")
            (("" (name-replace "G" "x!1")
              (("" (measure-induct+ "bound - s" "s")
                (("1" (name-replace "s" "x!2")
                  (("1" (postpone) nil nil)) nil)
                 ("2" (postpone) nil nil) ("3" (postpone) nil nil)
                 ("4" (postpone) nil nil) ("5" (postpone) nil nil)
                 ("6" (postpone) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak))
 (semantic_tlparser_correct 0
  (semantic_tlparser_correct-1 nil 3804495937
   ("" (skolem 1 ("P_exp" "P_inp" "A" "_" "inp" "_" "_" "_"))
    ((""
      (case "FORALL (G: {e: Δ | subterm(e, P_exp(A))}),
             (s: upto(bound)),
             (s_T:
                {k: upto(s) | (k = s) ⇒ g_wf(G, A, P_0c?(P_exp), strong)}),
             (res: results(P_exp, P_inp, inp)), (cont  : [
	             [astTypeOf(parsing(P_exp, A, G, inp, s, s_T)),
                      sem_result(P_inp, P_exp, A, G, inp, s, s_T),
		      results(P_exp, P_inp, inp)]
		     ->
		     [astType, pre_ast]
		    ]):
        semtlpp(P_exp, P_inp, A, G, inp, s, s_T, res, cont)
         = cont(astType?(parsing(P_exp, A, G, inp, s, s_T)), s_inp(P_inp, parsing(P_exp, A, G, inp, s, s_T)), res)")
      (("1" (skeep)
        (("1" (inst -1 "G" "s" "s_T" "res" "_")
          (("1"
            (inst -1 "LAMBDA (x:
                        [astTypeOf(parsing(P_exp, A, G, inp, s, s_T)),
                         sem_result(P_inp, P_exp, A, G, inp, s, s_T),
                         results(P_exp, P_inp, inp)]):
                (x`1, x`2)")
            (("1" (replace -1 * LR) (("1" (assert) nil nil)) nil))
            nil))
          nil))
        nil)
       ("2" (hide 2)
        (("2" (induct "G")
          (("1" (typepred "G!1") (("1" (propax) nil nil)) nil)
           ("2" (flatten)
            (("2" (skeep*) (("2" (assert) (("2" (grind) nil nil)) nil))
              nil))
            nil)
           ("3" (flatten)
            (("3" (skeep*) (("3" (assert) (("3" (grind) nil nil)) nil))
              nil))
            nil)
           ("4" (skeep*) (("4" (assert) (("4" (grind) nil nil)) nil))
            nil)
           ("5" (skeep*) (("5" (assert) (("5" (grind) nil nil)) nil))
            nil)
           ("6" (skeep*)
            (("6" (name-replace "B" "nonTerminal1_var")
              (("6" (expand "semtlpp")
                (("6" (lift-if)
                  (("6" (split)
                    (("1" (flatten)
                      (("1" (typepred "res")
                        (("1" (inst? -1)
                          (("1" (assert)
                            (("1" (flatten)
                              (("1"
                                (lemma
                                 "Wellformed_theorem"
                                 (T
                                  "parsing(P_exp, B, P_exp(B), inp, s, s)"))
                                (("1"
                                  (assert)
                                  (("1"
                                    (flatten)
                                    (("1"
                                      (split -2)
                                      (("1"
                                        (assert)
                                        (("1"
                                          (replace -7 * LR)
                                          (("1"
                                            (expand "parsing" +)
                                            (("1"
                                              (expand "astType?" +)
                                              (("1"
                                                (expand "s_inp" +)
                                                (("1"
                                                  (assert)
                                                  (("1"
                                                    (replace -1 * LR)
                                                    (("1"
                                                      (expand
                                                       "astType?"
                                                       +)
                                                      (("1"
                                                        (replace
                                                         -3
                                                         *
                                                         LR)
                                                        (("1"
                                                          (assert)
                                                          (("1"
                                                            (expand
                                                             "astType?"
                                                             -4)
                                                            (("1"
                                                              (propax)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (assert)
                                        (("2"
                                          (replace -4 * LR)
                                          (("2"
                                            (expand "parsing" 2 4)
                                            (("2"
                                              (expand "parsing" 2 6)
                                              (("2"
                                                (assert)
                                                (("2"
                                                  (expand "astType?" +)
                                                  (("2"
                                                    (assert)
                                                    (("2"
                                                      (hide 1)
                                                      (("2"
                                                        (expand
                                                         "s_inp"
                                                         1
                                                         2)
                                                        (("2"
                                                          (expand
                                                           "astType?"
                                                           1
                                                           2)
                                                          (("2"
                                                            (replace
                                                             -3
                                                             *
                                                             RL)
                                                            (("2"
                                                              (replace
                                                               -1
                                                               *
                                                               LR)
                                                              (("2"
                                                                (assert)
                                                                (("2"
                                                                  (postpone)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (postpone) nil nil)
                                 ("3" (postpone) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (postpone) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("7" (postpone) nil nil) ("8" (postpone) nil nil)
           ("9" (postpone) nil nil) ("10" (postpone) nil nil)
           ("11" (postpone) nil nil) ("12" (postpone) nil nil)
           ("13" (postpone) nil nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak)))

