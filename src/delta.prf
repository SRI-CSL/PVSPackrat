(peg
 (subterm_lq 0
  (subterm_lq-1 nil 3770493380
   ("" (measure-induct+ "pegMeasure(e2)" "e2")
    (("" (name-replace "G" "x!1")
      (("" (skeep)
        (("" (expand "subterm" -2)
          (("" (split -2)
            (("1" (replace -1 * LR) (("1" (assert) nil nil)) nil)
             ("2" (propax) nil nil)
             ("3" (flatten)
              (("3" (split -1)
                (("1" (propax) nil nil)
                 ("2" (flatten)
                  (("2" (split -1)
                    (("1" (propax) nil nil)
                     ("2" (flatten)
                      (("2" (split -1)
                        (("1" (propax) nil nil)
                         ("2" (flatten)
                          (("2" (split -1)
                            (("1" (propax) nil nil)
                             ("2" (flatten)
                              (("2"
                                (split -1)
                                (("1"
                                  (flatten)
                                  (("1"
                                    (inst-cp -3 "e1(G)")
                                    (("1"
                                      (inst -3 "e2(G)")
                                      (("1"
                                        (inst -4 "e1!1")
                                        (("1"
                                          (inst -3 "e1!1")
                                          (("1" (grind) nil nil))
                                          nil))
                                        nil)
                                       ("2" (flatten) nil nil))
                                      nil)
                                     ("2" (flatten) nil nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (flatten)
                                  (("2"
                                    (split -1)
                                    (("1"
                                      (flatten)
                                      (("1"
                                        (inst-cp -3 "e1(G)")
                                        (("1"
                                          (inst -3 "e2(G)")
                                          (("1"
                                            (inst -4 "e1!1")
                                            (("1"
                                              (inst -3 "e1!1")
                                              (("1" (grind) nil nil))
                                              nil))
                                            nil)
                                           ("2" (flatten) nil nil))
                                          nil)
                                         ("2" (flatten) nil nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (flatten)
                                      (("2"
                                        (split -1)
                                        (("1"
                                          (flatten)
                                          (("1"
                                            (inst -3 "e(G)")
                                            (("1"
                                              (inst -3 "e1!1")
                                              (("1"
                                                (assert)
                                                (("1" (grind) nil nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (flatten)
                                          (("2"
                                            (split -1)
                                            (("1"
                                              (assert)
                                              (("1"
                                                (flatten)
                                                (("1"
                                                  (assert)
                                                  (("1"
                                                    (inst -3 "e(G)")
                                                    (("1"
                                                      (inst -3 "e1!1")
                                                      (("1"
                                                        (grind)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (flatten)
                                              (("2"
                                                (split -1)
                                                (("1"
                                                  (flatten)
                                                  (("1"
                                                    (assert)
                                                    (("1"
                                                      (inst -3 "e(G)")
                                                      (("1"
                                                        (inst
                                                         -3
                                                         "e1!1")
                                                        (("1"
                                                          (grind)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (flatten)
                                                  (("2"
                                                    (split -1)
                                                    (("1"
                                                      (flatten)
                                                      (("1"
                                                        (assert)
                                                        (("1"
                                                          (inst
                                                           -3
                                                           "e(G)")
                                                          (("1"
                                                            (inst
                                                             -3
                                                             "e1!1")
                                                            (("1"
                                                              (grind)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (flatten)
                                                      (("2"
                                                        (inst
                                                         -2
                                                         "e(G)")
                                                        (("2"
                                                          (inst
                                                           -2
                                                           "e1!1")
                                                          (("2"
                                                            (grind)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((= const-decl "[T, T -> boolean]" equalities nil)
    (inc const-decl "nat" peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (opt? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (notP? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (andP? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (e shared-adt-accessor-decl
     "[{x: peg |      star?(x) OR plus?(x) OR opt?(x) OR notP?(x) OR andP?(x)} -> peg]"
     peg nil)
    (e2 shared-adt-accessor-decl
     "[{x: peg | seq?(x) OR prior?(x)} -> peg]" peg nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (sum const-decl "nat" peg nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (e1 shared-adt-accessor-decl
     "[{x: peg | seq?(x) OR prior?(x)} -> peg]" peg nil)
    (prior? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (G skolem-const-decl "peg" peg nil)
    (seq? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (<= const-decl "bool" reals nil)
    (subterm adt-def-decl "boolean" peg nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (wf_nat formula-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (pegMeasure const-decl "nat" peg nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (peg type-decl nil peg nil)
    (measure_induction formula-decl nil measure_induction nil)
    (well_founded? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil))
   shostak))
 (subterm_eq 0
  (subterm_eq-1 nil 3771187460
   ("" (skolem 1 ("G" "_"))
    (("" (induct "e2")
      (("1" (grind) nil nil) ("2" (grind) nil nil)
       ("3" (grind) nil nil) ("4" (grind) nil nil)
       ("5" (grind) nil nil)
       ("6" (skeep)
        (("6" (lemma "subterm_lq")
          (("6" (inst-cp -1 "G" "seq1_var")
            (("6" (inst -1 "G" "seq2_var") (("6" (grind) nil nil))
              nil))
            nil))
          nil))
        nil)
       ("7" (skeep)
        (("7" (lemma "subterm_lq")
          (("7" (lemma "subterm_lq")
            (("7" (inst-cp -1 "G" "prior1_var")
              (("7" (inst -1 "G" "prior2_var") (("7" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("8" (skeep)
        (("8" (lemma "subterm_lq")
          (("8" (inst -1 "G" "star1_var") (("8" (grind) nil nil)) nil))
          nil))
        nil)
       ("9" (skeep)
        (("9" (lemma "subterm_lq")
          (("9" (inst -1 "G" "plus1_var") (("9" (grind) nil nil)) nil))
          nil))
        nil)
       ("10" (skeep)
        (("10" (lemma "subterm_lq")
          (("10" (inst -1 "G" "opt1_var") (("10" (grind) nil nil))
            nil))
          nil))
        nil)
       ("11" (skeep)
        (("11" (lemma "subterm_lq")
          (("11" (inst -1 "G" "notP1_var") (("11" (grind) nil nil))
            nil))
          nil))
        nil)
       ("12" (skeep)
        (("12" (lemma "subterm_lq")
          (("12" (inst -1 "G" "andP1_var") (("12" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((peg type-decl nil peg nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (subterm adt-def-decl "boolean" peg nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pegMeasure const-decl "nat" peg nil)
    (peg_induction formula-decl nil peg nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (V_N_b formal-const-decl "posnat" peg nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (subterm_lq formula-decl nil peg nil)
    (sum const-decl "nat" peg nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (inc const-decl "nat" peg nil))
   shostak))
 (subterm_transitivity 0
  (subterm_transitivity-1 nil 3770494034
   ("" (induct "e2")
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (grind) nil nil) ("5" (grind) nil nil)
     ("6" (skeep)
      (("6" (skeep)
        (("6" (expand "subterm" -4)
          (("6" (inst -1 "e!1" "e1!1")
            (("6" (inst -2 "e!1" "e1!1") (("6" (grind) nil nil)) nil))
            nil))
          nil))
        nil))
      nil)
     ("7" (skeep)
      (("7" (skeep)
        (("7" (expand "subterm" -4)
          (("7" (inst -1 "e!1" "e1!1")
            (("7" (inst -2 "e!1" "e1!1") (("7" (grind) nil nil)) nil))
            nil))
          nil))
        nil))
      nil)
     ("8" (skeep)
      (("8" (skeep)
        (("8" (expand "subterm" -3)
          (("8" (inst -1 "e!1" "e1!1") (("8" (grind) nil nil)) nil))
          nil))
        nil))
      nil)
     ("9" (skeep)
      (("9" (skeep)
        (("9" (expand "subterm" -3)
          (("9" (inst -1 "e!1" "e1!1") (("9" (grind) nil nil)) nil))
          nil))
        nil))
      nil)
     ("10" (skeep)
      (("10" (skeep)
        (("10" (expand "subterm" -3)
          (("10" (inst -1 "e!1" "e1!1") (("10" (grind) nil nil)) nil))
          nil))
        nil))
      nil)
     ("11" (skeep)
      (("11" (skeep)
        (("11" (expand "subterm" -3)
          (("11" (inst -1 "e!1" "e1!1") (("11" (grind) nil nil)) nil))
          nil))
        nil))
      nil)
     ("12" (skeep)
      (("12" (skeep)
        (("12" (expand "subterm" -3)
          (("12" (inst -1 "e!1" "e1!1") (("12" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (V_N_b formal-const-decl "posnat" peg nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (peg_induction formula-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (peg type-decl nil peg nil))
   shostak))
 (subterm_seq 0
  (subterm_seq-1 nil 3847452744
   ("" (skeep)
    (("" (lemma "subterm_transitivity")
      (("" (inst-cp -1 "e1!1" "seq(e1!1, e2!1)" "G")
        (("" (inst -1 "e2!1" "seq(e1!1, e2!1)" "G")
          (("" (assert) (("" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((subterm_transitivity formula-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (seq adt-constructor-decl "[[peg, peg] -> (seq?)]" peg nil)
    (seq? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (boolean nonempty-type-decl nil booleans nil)
    (peg type-decl nil peg nil))
   shostak))
 (subterm_prior 0
  (subterm_prior-1 nil 3847452921
   ("" (skeep)
    (("" (lemma "subterm_transitivity")
      (("" (inst-cp -1 "e1!1" "prior(e1!1, e2!1)" "G")
        (("" (inst -1 "e2!1" "prior(e1!1, e2!1)" "G")
          (("" (assert) (("" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((subterm_transitivity formula-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (prior adt-constructor-decl "[[peg, peg] -> (prior?)]" peg nil)
    (prior? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (boolean nonempty-type-decl nil booleans nil)
    (peg type-decl nil peg nil))
   shostak))
 (subterm_star 0
  (subterm_star-1 nil 3847453043
   ("" (skeep)
    (("" (lemma "subterm_transitivity")
      (("" (inst? - (e e!1)) (("" (assert) (("" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((subterm_transitivity formula-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (star adt-constructor-decl "[peg -> (star?)]" peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (boolean nonempty-type-decl nil booleans nil)
    (peg type-decl nil peg nil))
   shostak))
 (subterm_plus 0
  (subterm_plus-1 nil 3847453097
   ("" (skeep)
    (("" (lemma "subterm_transitivity")
      (("" (inst? - (e e!1)) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((subterm_transitivity formula-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (plus adt-constructor-decl "[peg -> (plus?)]" peg nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (boolean nonempty-type-decl nil booleans nil)
    (peg type-decl nil peg nil))
   shostak))
 (subterm_opt 0
  (subterm_opt-1 nil 3847453109
   ("" (skeep)
    (("" (lemma "subterm_transitivity")
      (("" (inst? - (e e!1)) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((subterm_transitivity formula-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (opt adt-constructor-decl "[peg -> (opt?)]" peg nil)
    (opt? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (boolean nonempty-type-decl nil booleans nil)
    (peg type-decl nil peg nil))
   shostak))
 (subterm_notP 0
  (subterm_notP-1 nil 3847453117
   ("" (skeep)
    (("" (lemma "subterm_transitivity")
      (("" (inst? - (e e!1)) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((subterm_transitivity formula-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (notP adt-constructor-decl "[peg -> (notP?)]" peg nil)
    (notP? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (boolean nonempty-type-decl nil booleans nil)
    (peg type-decl nil peg nil))
   shostak))
 (subterm_andP 0
  (subterm_andP-1 nil 3847453120
   ("" (skeep)
    (("" (lemma "subterm_transitivity")
      (("" (inst? - (e e!1)) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((subterm_transitivity formula-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (andP adt-constructor-decl "[peg -> (andP?)]" peg nil)
    (andP? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (boolean nonempty-type-decl nil booleans nil)
    (peg type-decl nil peg nil))
   shostak)))
(wf_peg
 (g_props_TCC1 0
  (g_props_TCC1-1 nil 3784646054 ("" (termination-tcc) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (sum const-decl "nat" peg nil)
    (pegMeasure const-decl "nat" peg nil))
   nil
   (g_props termination "wf_peg.g_props(wf_peg.e1, wf_peg.P)" "nil")))
 (g_props_TCC2 0
  (g_props_TCC2-1 nil 3784646054 ("" (termination-tcc) nil nil)
   ((sum const-decl "nat" peg nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (pegMeasure const-decl "nat" peg nil))
   nil
   (g_props termination "wf_peg.g_props(wf_peg.e2, wf_peg.P)" "nil")))
 (g_props_TCC3 0
  (g_props_TCC3-1 nil 3784646054 ("" (termination-tcc) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (sum const-decl "nat" peg nil)
    (pegMeasure const-decl "nat" peg nil))
   nil
   (g_props termination "wf_peg.g_props(wf_peg.e1, wf_peg.P)" "nil")))
 (g_props_TCC4 0
  (g_props_TCC4-1 nil 3784646054 ("" (termination-tcc) nil nil)
   ((sum const-decl "nat" peg nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (pegMeasure const-decl "nat" peg nil))
   nil
   (g_props termination "wf_peg.g_props(wf_peg.e2, wf_peg.P)" "nil")))
 (g_props_TCC5 0
  (g_props_TCC5-1 nil 3784646054 ("" (termination-tcc) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (inc const-decl "nat" peg nil)
    (pegMeasure const-decl "nat" peg nil))
   nil
   (g_props termination "wf_peg.g_props(wf_peg.e, wf_peg.P)" "nil")))
 (g_props_TCC6 0
  (g_props_TCC6-1 nil 3784646054 ("" (termination-tcc) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (inc const-decl "nat" peg nil)
    (pegMeasure const-decl "nat" peg nil))
   nil
   (g_props termination "wf_peg.g_props(wf_peg.e, wf_peg.P)" "nil")))
 (g_props_TCC7 0
  (g_props_TCC7-1 nil 3784646054 ("" (termination-tcc) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (inc const-decl "nat" peg nil)
    (pegMeasure const-decl "nat" peg nil))
   nil
   (g_props termination "wf_peg.g_props(wf_peg.e, wf_peg.P)" "nil")))
 (g_props_TCC8 0
  (g_props_TCC8-1 nil 3784646054 ("" (termination-tcc) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (inc const-decl "nat" peg nil)
    (pegMeasure const-decl "nat" peg nil))
   nil
   (g_props termination "wf_peg.g_props(wf_peg.e, wf_peg.P)" "nil")))
 (g_props_TCC9 0
  (g_props_TCC9-1 nil 3784646054 ("" (termination-tcc) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (inc const-decl "nat" peg nil)
    (pegMeasure const-decl "nat" peg nil))
   nil
   (g_props termination "wf_peg.g_props(wf_peg.e, wf_peg.P)" "nil")))
 (g_props_growth 0
  (g_props_growth-1 nil 3784716892
   ("" (skolem 1 ("_" "P" "P1"))
    (("" (induct "G")
      (("1" (grind) nil nil) ("2" (grind) nil nil)
       ("3" (grind) nil nil) ("4" (grind) nil nil)
       ("5" (grind) nil nil) ("6" (grind) nil nil)
       ("7" (grind) nil nil) ("8" (grind) nil nil)
       ("9" (grind) nil nil) ("10" (grind) nil nil)
       ("11" (grind) nil nil) ("12" (grind) nil nil))
      nil))
    nil)
   ((peg type-decl nil peg nil) (Δ type-eq-decl nil wf_peg nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (nTpred type-eq-decl nil nTpred_order nil)
    (nTprop type-eq-decl nil nTpred_order nil)
    (<= const-decl "bool" nTpred_order nil)
    (nTinst type-eq-decl nil nTpred_order nil)
    (<= const-decl "bool" nTpred_order nil)
    (g_props def-decl "[bool, bool, bool]" wf_peg nil)
    (V_N_b formal-const-decl "posnat" wf_peg nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" wf_peg nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (V_T formal-nonempty-type-decl nil wf_peg nil)
    (peg_induction formula-decl nil peg nil)
    (leq const-decl "bool" nTpred_order nil)
    (leq_inst const-decl "bool" nTpred_order nil)
    (below type-eq-decl nil naturalnumbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   shostak))
 (ρ_TCC1 0
  (ρ_TCC1-1 nil 3784653349
   ("" (skeep)
    (("" (typepred "P")
      ((""
        (name "P1"
              "(P`1 WITH [(A) := A_f], P`2 WITH [(A) := A_0], P`3 WITH [(A) := A_s])")
        (("" (replace -1 * LR)
          (("" (expand "coherent_properties")
            (("" (lemma "g_props_growth")
              (("" (inst -1 "_" "P" "P1")
                (("" (skolem 1 "B")
                  (("" (inst -1 "P_exp(B)")
                    (("" (split -1)
                      (("1" (expand "<=")
                        (("1" (expand "leq_inst")
                          (("1" (replace -2 1 RL)
                            (("1" (assert)
                              (("1"
                                (assert)
                                (("1"
                                  (split 1)
                                  (("1"
                                    (assert)
                                    (("1"
                                      (flatten)
                                      (("1"
                                        (lift-if -1)
                                        (("1"
                                          (split -1)
                                          (("1"
                                            (flatten)
                                            (("1"
                                              (assert)
                                              (("1"
                                                (replace -6 * LR)
                                                (("1"
                                                  (propax)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (flatten)
                                            (("2"
                                              (assert)
                                              (("2"
                                                (replace -5 * LR)
                                                (("2"
                                                  (inst -6 "B")
                                                  (("2"
                                                    (flatten)
                                                    (("2"
                                                      (assert)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (flatten)
                                    (("2"
                                      (lift-if -1)
                                      (("2"
                                        (split -1)
                                        (("1"
                                          (flatten)
                                          (("1"
                                            (assert)
                                            (("1"
                                              (replace -6 * LR)
                                              (("1" (propax) nil nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (flatten)
                                          (("2"
                                            (inst -6 "B")
                                            (("2"
                                              (flatten)
                                              (("2"
                                                (assert)
                                                (("2"
                                                  (replace -5 * LR)
                                                  (("2"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("3"
                                    (flatten)
                                    (("3"
                                      (lift-if -1)
                                      (("3"
                                        (split -1)
                                        (("1"
                                          (assert)
                                          (("1"
                                            (flatten)
                                            (("1"
                                              (replace -6 * LR)
                                              (("1" (assert) nil nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (flatten)
                                          (("2"
                                            (inst -6 "B")
                                            (("2"
                                              (flatten)
                                              (("2"
                                                (assert)
                                                (("2"
                                                  (replace -5 * LR)
                                                  (("2"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (hide 2)
                        (("2" (expand "<=")
                          (("2" (expand "leq")
                            (("2" (skeep)
                              (("2"
                                (inst -2 "i")
                                (("2"
                                  (expand "leq_inst")
                                  (("2"
                                    (flatten)
                                    (("2"
                                      (replace -1 * RL)
                                      (("2"
                                        (assert)
                                        (("2"
                                          (split 1)
                                          (("1"
                                            (flatten)
                                            (("1"
                                              (lift-if 1)
                                              (("1"
                                                (split 1)
                                                (("1"
                                                  (flatten)
                                                  (("1"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (flatten)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (assert)
                                            (("2"
                                              (flatten)
                                              (("2"
                                                (lift-if 1)
                                                (("2"
                                                  (split 1)
                                                  (("1"
                                                    (flatten)
                                                    (("1"
                                                      (assert)
                                                      nil
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (flatten)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("3"
                                            (assert)
                                            (("3"
                                              (flatten)
                                              (("3"
                                                (lift-if 1)
                                                (("3"
                                                  (split)
                                                  (("1"
                                                    (flatten)
                                                    (("1"
                                                      (assert)
                                                      nil
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (flatten)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((C type-eq-decl nil wf_peg nil)
    (coherent_properties const-decl "bool" wf_peg nil)
    (nTprop type-eq-decl nil nTpred_order nil)
    (nTpred type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (Δ type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (<= formal-const-decl "(total_order?[V_T])" wf_peg nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (V_N_b formal-const-decl "posnat" wf_peg nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (g_props_growth formula-decl nil wf_peg nil)
    (leq_inst const-decl "bool" nTpred_order nil)
    (<= const-decl "bool" nTpred_order nil)
    (<= const-decl "bool" nTpred_order nil)
    (leq const-decl "bool" nTpred_order nil)
    (= const-decl "[T, T -> boolean]" equalities nil))
   nil
   (ρ subtype
    "(wf_peg.P`1 WITH [(wf_peg.A) := wf_peg.A_f], wf_peg.P`2 WITH [(wf_peg.A) := wf_peg.A_0], wf_peg.P`3 WITH [(wf_peg.A) := wf_peg.A_s])"
    "wf_peg.C(wf_peg.P_exp)")))
 (ρ_growth 0
  (ρ_growth-1 nil 3784707576
   ("" (skeep)
    (("" (expand "ρ")
      (("" (expand "<=")
        (("" (expand "leq")
          (("" (skeep)
            (("" (typepred "P")
              (("" (expand "coherent_properties")
                (("" (inst -1 "A")
                  (("" (expand "<=")
                    (("" (expand "leq_inst")
                      (("" (flatten)
                        (("" (split 1)
                          (("1" (flatten)
                            (("1" (lift-if 1)
                              (("1"
                                (split 1)
                                (("1"
                                  (flatten)
                                  (("1" (assert) nil nil))
                                  nil)
                                 ("2" (flatten) nil nil))
                                nil))
                              nil))
                            nil)
                           ("2" (flatten)
                            (("2" (lift-if 1)
                              (("2"
                                (split)
                                (("1"
                                  (flatten)
                                  (("1" (assert) nil nil))
                                  nil)
                                 ("2" (flatten) nil nil))
                                nil))
                              nil))
                            nil)
                           ("3" (flatten)
                            (("3" (lift-if)
                              (("3"
                                (split)
                                (("1"
                                  (flatten)
                                  (("1" (assert) nil nil))
                                  nil)
                                 ("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((ρ const-decl "C(P_exp)" wf_peg nil)
    (leq const-decl "bool" nTpred_order nil)
    (C type-eq-decl nil wf_peg nil)
    (coherent_properties const-decl "bool" wf_peg nil)
    (nTprop type-eq-decl nil nTpred_order nil)
    (nTpred type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (Δ type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (<= formal-const-decl "(total_order?[V_T])" wf_peg nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (V_N_b formal-const-decl "posnat" wf_peg nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (leq_inst const-decl "bool" nTpred_order nil)
    (<= const-decl "bool" nTpred_order nil)
    (<= const-decl "bool" nTpred_order nil))
   shostak))
 (ρ_growth2 0
  (ρ_growth2-1 nil 3784708391
   ("" (skeep)
    (("" (expand " ρ")
      (("" (lemma "g_props_growth")
        (("" (inst -1 "P_exp(A)" "P" "P1")
          (("" (assert)
            (("" (expand "<=")
              (("" (expand "leq_inst")
                (("" (expand "leq")
                  (("" (skeep)
                    (("" (inst -4 "i")
                      (("" (lift-if 1)
                        (("" (split 1)
                          (("1" (flatten)
                            (("1" (assert)
                              (("1"
                                (replace -1 * LR)
                                (("1"
                                  (split 1)
                                  (("1" (propax) nil nil)
                                   ("2" (propax) nil nil)
                                   ("3" (propax) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (flatten)
                            (("2" (split 2)
                              (("1" (propax) nil nil)
                               ("2" (propax) nil nil)
                               ("3" (propax) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((ρ const-decl "C(P_exp)" wf_peg nil)
    (V_T formal-nonempty-type-decl nil wf_peg nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" wf_peg nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" wf_peg nil)
    (peg type-decl nil peg nil) (Δ type-eq-decl nil wf_peg nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (nTpred type-eq-decl nil nTpred_order nil)
    (nTprop type-eq-decl nil nTpred_order nil)
    (coherent_properties const-decl "bool" wf_peg nil)
    (C type-eq-decl nil wf_peg nil)
    (<= const-decl "bool" nTpred_order nil)
    (<= const-decl "bool" nTpred_order nil)
    (leq const-decl "bool" nTpred_order nil)
    (leq_inst const-decl "bool" nTpred_order nil)
    (g_props_growth formula-decl nil wf_peg nil))
   shostak))
 (recompute_nonTerminals_properties_TCC1 0
  (recompute_nonTerminals_properties_TCC1-1 nil 3770412224
   ("" (subtype-tcc) nil nil) nil nil
   (recompute_nonTerminals_properties subtype
    "((number_fields.-)(wf_peg.V_N_b, wf_peg.A))" "naturalnumber")))
 (recompute_nonTerminals_properties_TCC2 0
  (recompute_nonTerminals_properties_TCC3-1 nil 3770412224
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (V_T formal-nonempty-type-decl nil wf_peg nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" wf_peg nil)
    (peg type-decl nil peg nil) (Δ type-eq-decl nil wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (nTpred type-eq-decl nil nTpred_order nil)
    (nTprop type-eq-decl nil nTpred_order nil)
    (coherent_properties const-decl "bool" wf_peg nil)
    (C type-eq-decl nil wf_peg nil)
    (leq_inst const-decl "bool" nTpred_order nil)
    (<= const-decl "bool" nTpred_order nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (recompute_nonTerminals_properties subtype
    "(number_fields.+)(wf_peg.A, 1)" "V_N[V_N_b]")))
 (recompute_nonTerminals_properties_TCC3 0
  (recompute_nonTerminals_properties_TCC5-1 nil 3770412224
   ("" (termination-tcc) nil nil)
   ((int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (recompute_nonTerminals_properties termination
    "wf_peg.recompute_nonTerminals_properties(wf_peg.P_exp, (number_fields.+)(wf_peg.A, 1), wf_peg.ρ(wf_peg.P_exp, wf_peg.A, wf_peg.P))"
    "nil")))
 (lemma_3_2_1 0
  (lemma_3_2_1-1 nil 3784647385
   ("" (skolem 1 ("P_exp" "_" "_"))
    ((""
      (case "FORALL ((P: C(P_exp)), A): P <= r(P_exp, V_N_b -1 -A, P)")
      (("1" (skeep)
        (("1" (inst -1 "P" "V_N_b-1-A") (("1" (assert) nil nil)) nil))
        nil)
       ("2" (hide 2)
        (("2" (induct "A")
          (("1" (flatten)
            (("1" (skeep)
              (("1" (expand "r")
                (("1" (expand "recompute_nonTerminals_properties")
                  (("1" (use " ρ_growth") (("1" (assert) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (skolem 1 "i")
            (("2" (flatten)
              (("2" (skeep)
                (("2" (expand "r")
                  (("2" (expand "recompute_nonTerminals_properties" 1)
                    (("2" (inst -2 "ρ(P_exp, -2 - i + V_N_b, P)")
                      (("1" (assert)
                        (("1" (use " ρ_growth")
                          (("1" (assert)
                            (("1" (lemma "leq_tr")
                              (("1"
                                (inst
                                 -1
                                 "P"
                                 "ρ(P_exp, -2 - i + V_N_b, P)"
                                 "recompute_nonTerminals_properties(P_exp,
                                         -1 - i + V_N_b,
                                         ρ(P_exp, -2 - i + V_N_b, P))")
                                (("1" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (assert) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (r const-decl "C(P_exp)" wf_peg nil)
    (<= const-decl "bool" nTpred_order nil)
    (C type-eq-decl nil wf_peg nil)
    (coherent_properties const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (Δ type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (<= formal-const-decl "(total_order?[V_T])" wf_peg nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil wf_peg nil)
    (nTprop type-eq-decl nil nTpred_order nil)
    (nTpred type-eq-decl nil nTpred_order nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (V_N_b formal-const-decl "posnat" wf_peg nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (below_induction formula-decl nil bounded_nat_inductions nil)
    (recompute_nonTerminals_properties def-decl "C(P_exp)" wf_peg nil)
    (ρ_growth formula-decl nil wf_peg nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (i skolem-const-decl "below(V_N_b)" wf_peg nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (ρ const-decl "C(P_exp)" wf_peg nil)
    (leq_tr formula-decl nil nTpred_order nil))
   shostak))
 (lemma_3_2_2 0
  (lemma_3_2_2-1 nil 3784707998
   ("" (skolem 1 ("P_exp" "_" "_" "_"))
    ((""
      (case "FORALL ((P, P1: C(P_exp)), A): (P <= P1) ⇒ (r(P_exp, V_N_b-1-A, P) <= r(P_exp, V_N_b-1-A, P1))")
      (("1" (skeep)
        (("1" (inst -1 "P" "P1" "V_N_b-1-A") (("1" (assert) nil nil))
          nil))
        nil)
       ("2" (hide 2)
        (("2" (induct "A")
          (("1" (assert)
            (("1" (flatten)
              (("1" (skeep)
                (("1" (expand "r")
                  (("1" (expand "recompute_nonTerminals_properties")
                    (("1" (expand " ρ")
                      (("1" (lemma "g_props_growth")
                        (("1" (inst -1 "P_exp(V_N_b -1)" "P" "P1")
                          (("1" (assert)
                            (("1" (expand "<=")
                              (("1"
                                (expand "leq")
                                (("1"
                                  (expand "leq_inst")
                                  (("1"
                                    (flatten)
                                    (("1"
                                      (skeep 1)
                                      (("1"
                                        (lift-if 1)
                                        (("1"
                                          (inst -5 "i")
                                          (("1"
                                            (flatten)
                                            (("1"
                                              (split 1)
                                              (("1"
                                                (flatten)
                                                (("1"
                                                  (assert)
                                                  (("1"
                                                    (split 1)
                                                    (("1"
                                                      (propax)
                                                      nil
                                                      nil)
                                                     ("2"
                                                      (propax)
                                                      nil
                                                      nil)
                                                     ("3"
                                                      (propax)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (flatten)
                                                (("2"
                                                  (split 2)
                                                  (("1"
                                                    (propax)
                                                    nil
                                                    nil)
                                                   ("2"
                                                    (propax)
                                                    nil
                                                    nil)
                                                   ("3"
                                                    (propax)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (skolem 1 "j")
            (("2" (flatten)
              (("2" (skeep)
                (("2" (lemma " ρ_growth2")
                  (("2" (inst -1 "P_exp" "_" "P" "P1")
                    (("2" (assert)
                      (("2" (inst -1 "V_N_b -2 -j")
                        (("2"
                          (inst -3 "ρ(P_exp, V_N_b - 2 - j, P)"
                           "ρ(P_exp, V_N_b - 2 - j, P1)")
                          (("2" (expand "r")
                            (("2"
                              (expand "recompute_nonTerminals_properties"
                                      1)
                              (("2" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (r const-decl "C(P_exp)" wf_peg nil)
    (<= const-decl "bool" nTpred_order nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (C type-eq-decl nil wf_peg nil)
    (coherent_properties const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (Δ type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (<= formal-const-decl "(total_order?[V_T])" wf_peg nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil wf_peg nil)
    (nTprop type-eq-decl nil nTpred_order nil)
    (nTpred type-eq-decl nil nTpred_order nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (V_N_b formal-const-decl "posnat" wf_peg nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (below_induction formula-decl nil bounded_nat_inductions nil)
    (ρ const-decl "C(P_exp)" wf_peg nil)
    (<= const-decl "bool" nTpred_order nil)
    (leq_inst const-decl "bool" nTpred_order nil)
    (leq const-decl "bool" nTpred_order nil)
    (g_props_growth formula-decl nil wf_peg nil)
    (recompute_nonTerminals_properties def-decl "C(P_exp)" wf_peg nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (ρ_growth2 formula-decl nil wf_peg nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil))
   shostak))
 (lemma_3_2_3_TCC1 0
  (lemma_3_2_3_TCC1-1 nil 3784647385 ("" (subtype-tcc) nil nil) nil nil
   (lemma_3_2_3 subtype "(number_fields.+)(wf_peg.A, 1)"
    "V_N[V_N_b]")))
 (lemma_3_2_3_TCC2 0
  (lemma_3_2_3_TCC2-1 nil 3784647385 ("" (subtype-tcc) nil nil) nil nil
   (lemma_3_2_3 subtype "wf_peg.A" "V_N[V_N_b]")))
 (lemma_3_2_3 0
  (lemma_3_2_3-1 nil 3784709173
   ("" (skeep)
    (("" (lemma " ρ_growth")
      (("" (inst -1 "P_exp" "A" "P")
        (("" (lemma "lemma_3_2_2")
          (("" (inst -1 "P_exp" "P" " ρ(P_exp, A, P)" "A+1")
            (("" (assert)
              ((""
                (case " r(P_exp, A, P) = r(P_exp, 1 + A, ρ(P_exp, A, P)) ")
                (("1" (replace -1 * LR) (("1" (propax) nil nil)) nil)
                 ("2" (hide 2 -)
                  (("2" (expand "r")
                    (("2"
                      (expand "recompute_nonTerminals_properties" 1 1)
                      (("2" (propax) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((ρ_growth formula-decl nil wf_peg nil)
    (lemma_3_2_2 formula-decl nil wf_peg nil)
    (recompute_nonTerminals_properties def-decl "C(P_exp)" wf_peg nil)
    (r const-decl "C(P_exp)" wf_peg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (ρ const-decl "C(P_exp)" wf_peg nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (C type-eq-decl nil wf_peg nil)
    (coherent_properties const-decl "bool" wf_peg nil)
    (nTprop type-eq-decl nil nTpred_order nil)
    (nTpred type-eq-decl nil nTpred_order nil)
    (below type-eq-decl nil naturalnumbers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (interp type-eq-decl nil wf_peg nil)
    (Δ type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (<= formal-const-decl "(total_order?[V_T])" wf_peg nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (V_N_b formal-const-decl "posnat" wf_peg nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (fix_point_TCC1 0
  (fix_point_TCC1-1 nil 3770412224 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (V_T formal-nonempty-type-decl nil wf_peg nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" wf_peg nil)
    (peg type-decl nil peg nil) (Δ type-eq-decl nil wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (nTpred type-eq-decl nil nTpred_order nil)
    (nTprop type-eq-decl nil nTpred_order nil)
    (coherent_properties const-decl "bool" wf_peg nil)
    (C type-eq-decl nil wf_peg nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (<= const-decl "bool" nTpred_order nil)
    (leq_inst const-decl "bool" nTpred_order nil))
   nil (fix_point subtype "0" "V_N[V_N_b]")))
 (fix_point_lemma 0
  (fix_point_lemma-1 nil 3784709765
   ("" (skolem 1 ("P_exp" "_" "_"))
    (("" (induct "A")
      (("1" (flatten)
        (("1" (skeep)
          (("1" (typepred "P")
            (("1" (expand "fix_point")
              (("1" (assert)
                (("1" (lemma "leq_rf")
                  (("1" (inst -1 "P" "r(P_exp, 0, P)")
                    (("1" (flatten)
                      (("1" (replace -4 * LR) (("1" (flatten) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (skolem 1 "j")
        (("2" (flatten)
          (("2" (skeep)
            (("2" (lemma "lemma_3_2_3")
              (("2" (inst -1 "P_exp" "P" "j")
                (("2" (inst -3 "P")
                  (("2" (lemma "leq_tr")
                    (("2"
                      (inst -1 "r(P_exp, j+1, P)" "r(P_exp, j, P)" "P")
                      (("2" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (nTpred type-eq-decl nil nTpred_order nil)
    (nTprop type-eq-decl nil nTpred_order nil)
    (V_T formal-nonempty-type-decl nil wf_peg nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" wf_peg nil)
    (peg type-decl nil peg nil) (Δ type-eq-decl nil wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (coherent_properties const-decl "bool" wf_peg nil)
    (C type-eq-decl nil wf_peg nil)
    (fix_point const-decl "bool" wf_peg nil)
    (F type-eq-decl nil wf_peg nil)
    (<= const-decl "bool" nTpred_order nil)
    (r const-decl "C(P_exp)" wf_peg nil)
    (V_N_b formal-const-decl "posnat" wf_peg nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (below_induction formula-decl nil bounded_nat_inductions nil)
    (leq_rf formula-decl nil nTpred_order nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (lemma_3_2_3 formula-decl nil wf_peg nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (leq_tr formula-decl nil nTpred_order nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (j skolem-const-decl "below(V_N_b)" wf_peg nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   shostak))
 (fix_point_theorem 0
  (fix_point_theorem-1 nil 3784710212
   ("" (skeep)
    (("" (case "P = r(P_exp, A, P)")
      (("1" (case "A=V_N_b-1")
        (("1" (replace -1 * LR)
          (("1" (expand "r")
            (("1" (expand "recompute_nonTerminals_properties")
              (("1" (propax) nil nil)) nil))
            nil))
          nil)
         ("2" (lemma "leq_rf")
          (("2" (inst -1 "P" " ρ(P_exp, A, P)")
            (("2" (assert)
              (("2" (hide 3)
                (("2" (lemma " ρ_growth")
                  (("2" (inst? -1)
                    (("2" (assert)
                      (("2" (hide -1)
                        (("2" (lemma "lemma_3_2_1")
                          (("2"
                            (inst -1 "P_exp" "ρ(P_exp, A, P)" "A+1")
                            (("2"
                              (case "r(P_exp, A + 1, ρ(P_exp, A, P)) = r(P_exp, A, P)")
                              (("1"
                                (replace -1 * LR)
                                (("1"
                                  (replace -3 -2 RL)
                                  (("1" (propax) nil nil))
                                  nil))
                                nil)
                               ("2"
                                (hide 2 3)
                                (("2"
                                  (expand "r")
                                  (("2"
                                    (expand
                                     "recompute_nonTerminals_properties"
                                     1
                                     2)
                                    (("2" (propax) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (hide 2)
        (("2" (use "leq_rf")
          (("2" (assert)
            (("2" (hide 2)
              (("2" (lemma "fix_point_lemma")
                (("2" (inst? -1)
                  (("2" (assert)
                    (("2" (hide -1)
                      (("2" (lemma "lemma_3_2_1")
                        (("2" (inst? -1) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((r const-decl "C(P_exp)" wf_peg nil)
    (F type-eq-decl nil wf_peg nil)
    (fix_point const-decl "bool" wf_peg nil)
    (C type-eq-decl nil wf_peg nil)
    (coherent_properties const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (Δ type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (<= formal-const-decl "(total_order?[V_T])" wf_peg nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil wf_peg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nTprop type-eq-decl nil nTpred_order nil)
    (nTpred type-eq-decl nil nTpred_order nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (V_N_b formal-const-decl "posnat" wf_peg nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (leq_rf formula-decl nil nTpred_order nil)
    (ρ_growth formula-decl nil wf_peg nil)
    (lemma_3_2_1 formula-decl nil wf_peg nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (ρ const-decl "C(P_exp)" wf_peg nil)
    (recompute_nonTerminals_properties def-decl "C(P_exp)" wf_peg nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (fix_point_lemma formula-decl nil wf_peg nil))
   shostak))
 (compute_properties_TCC1 0
  (compute_properties_TCC1-1 nil 3770412224 ("" (subtype-tcc) nil nil)
   ((posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (compute_properties subtype
    "((number_fields.-)(number_fields.*(3, wf_peg.V_N_b), wf_peg.currentState))"
    "naturalnumber")))
 (compute_properties_TCC2 0
  (compute_properties_TCC2-1 nil 3770412224
   ("" (skeep)
    (("" (skeep)
      (("" (expand "fix_point")
        (("" (typepred "currentState")
          (("" (replace -2 * LR)
            (("" (replace -4 * LR)
              (("" (hide -1 -2 -4)
                (("" (lemma "sum_inj")
                  (("" (inst -1 "P" "nP")
                    (("" (assert)
                      (("" (use "lemma_3_2_1") (("" (assert) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((fix_point const-decl "bool" wf_peg nil)
    (lemma_3_2_1 formula-decl nil wf_peg nil)
    (sum_inj formula-decl nil array_sum nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" wf_peg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (nTpred type-eq-decl nil nTpred_order nil)
    (nTprop type-eq-decl nil nTpred_order nil)
    (array_sum const-decl "upto(3 * V_N_b)" array_sum nil)
    (V_T formal-nonempty-type-decl nil wf_peg nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" wf_peg nil)
    (peg type-decl nil peg nil) (Δ type-eq-decl nil wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (coherent_properties const-decl "bool" wf_peg nil)
    (C type-eq-decl nil wf_peg nil))
   nil
   (compute_properties subtype "wf_peg.nP" "wf_peg.F(wf_peg.P_exp)")))
 (compute_properties_TCC3 0
  (compute_properties_TCC4-1 nil 3770412224
   ("" (skeep*)
    (("" (typepred "currentState")
      (("" (replace -2 * LR)
        (("" (replace -4 * LR)
          (("" (hide -2 -4 -1)
            (("" (lemma "lemma_3_2_1")
              (("" (inst -1 "P_exp" "P" "0")
                (("" (replace -2 * LR)
                  (("" (replace -2 * RL)
                    (("" (lemma "sum_growing")
                      (("" (inst? -1) (("" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((C type-eq-decl nil wf_peg nil)
    (coherent_properties const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (Δ type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (<= formal-const-decl "(total_order?[V_T])" wf_peg nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil wf_peg nil)
    (array_sum const-decl "upto(3 * V_N_b)" array_sum nil)
    (nTprop type-eq-decl nil nTpred_order nil)
    (nTpred type-eq-decl nil nTpred_order nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (V_N_b formal-const-decl "posnat" wf_peg nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (lemma_3_2_1 formula-decl nil wf_peg nil)
    (sum_growing formula-decl nil array_sum nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (compute_properties termination
    "wf_peg.compute_properties(wf_peg.P_exp, wf_peg.nP, wf_peg.newState)"
    "nil")))
 (g_wf_TCC1 0
  (g_wf_TCC1-1 nil 3784647385 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (injective? const-decl "bool" functions nil)
    (surjective? const-decl "bool" functions nil)
    (sum const-decl "nat" peg nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (< def-decl "bool" ordinals nil)
    (odd_plus_even_is_odd application-judgement "odd_int" integers nil)
    (pegMeasure const-decl "nat" peg nil)
    (lex2 const-decl "ordinal" lex2 nil))
   nil
   (g_wf termination
    "wf_peg.g_wf(wf_peg.σ, wf_peg.e1, wf_peg.A, wf_peg.P_0, wf_peg.δ)"
    "nil")))
 (g_wf_TCC2 0
  (g_wf_TCC2-1 nil 3784647385 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (injective? const-decl "bool" functions nil)
    (surjective? const-decl "bool" functions nil)
    (sum const-decl "nat" peg nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (< def-decl "bool" ordinals nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (pegMeasure const-decl "nat" peg nil)
    (lex2 const-decl "ordinal" lex2 nil))
   nil
   (g_wf termination
    "wf_peg.g_wf(wf_peg.σ, wf_peg.e2, wf_peg.A, wf_peg.P_0, booleans.∧(wf_peg.P_0(wf_peg.e1), wf_peg.δ))"
    "nil")))
 (g_wf_TCC3 0
  (g_wf_TCC3-1 nil 3784647385 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (injective? const-decl "bool" functions nil)
    (surjective? const-decl "bool" functions nil)
    (sum const-decl "nat" peg nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (< def-decl "bool" ordinals nil)
    (odd_plus_even_is_odd application-judgement "odd_int" integers nil)
    (pegMeasure const-decl "nat" peg nil)
    (lex2 const-decl "ordinal" lex2 nil))
   nil
   (g_wf termination
    "wf_peg.g_wf(wf_peg.σ, wf_peg.e1, wf_peg.A, wf_peg.P_0, wf_peg.δ)"
    "nil")))
 (g_wf_TCC4 0
  (g_wf_TCC4-1 nil 3784647385 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (injective? const-decl "bool" functions nil)
    (surjective? const-decl "bool" functions nil)
    (sum const-decl "nat" peg nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (< def-decl "bool" ordinals nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (pegMeasure const-decl "nat" peg nil)
    (lex2 const-decl "ordinal" lex2 nil))
   nil
   (g_wf termination
    "wf_peg.g_wf(wf_peg.σ, wf_peg.e2, wf_peg.A, wf_peg.P_0, wf_peg.δ)"
    "nil")))
 (g_wf_TCC5 0
  (g_wf_TCC5-1 nil 3784647385 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (injective? const-decl "bool" functions nil)
    (surjective? const-decl "bool" functions nil)
    (inc const-decl "nat" peg nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (< def-decl "bool" ordinals nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (pegMeasure const-decl "nat" peg nil)
    (lex2 const-decl "ordinal" lex2 nil))
   nil
   (g_wf termination
    "wf_peg.g_wf(wf_peg.σ, wf_peg.e, wf_peg.A, wf_peg.P_0, wf_peg.δ)"
    "nil")))
 (g_wf_TCC6 0
  (g_wf_TCC6-1 nil 3784647385 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (injective? const-decl "bool" functions nil)
    (surjective? const-decl "bool" functions nil)
    (inc const-decl "nat" peg nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (< def-decl "bool" ordinals nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (pegMeasure const-decl "nat" peg nil)
    (lex2 const-decl "ordinal" lex2 nil))
   nil
   (g_wf termination
    "wf_peg.g_wf(wf_peg.σ, wf_peg.e, wf_peg.A, wf_peg.P_0, wf_peg.δ)"
    "nil")))
 (g_wf_TCC7 0
  (g_wf_TCC7-1 nil 3784647385 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (injective? const-decl "bool" functions nil)
    (surjective? const-decl "bool" functions nil)
    (inc const-decl "nat" peg nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (< def-decl "bool" ordinals nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (pegMeasure const-decl "nat" peg nil)
    (lex2 const-decl "ordinal" lex2 nil))
   nil
   (g_wf termination
    "wf_peg.g_wf(wf_peg.σ, wf_peg.e, wf_peg.A, wf_peg.P_0, wf_peg.δ)"
    "nil")))
 (g_wf_TCC8 0
  (g_wf_TCC8-1 nil 3784647385 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (injective? const-decl "bool" functions nil)
    (surjective? const-decl "bool" functions nil)
    (inc const-decl "nat" peg nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (< def-decl "bool" ordinals nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (pegMeasure const-decl "nat" peg nil)
    (lex2 const-decl "ordinal" lex2 nil))
   nil
   (g_wf termination
    "wf_peg.g_wf(wf_peg.σ, wf_peg.e, wf_peg.A, wf_peg.P_0, wf_peg.δ)"
    "nil")))
 (g_wf_TCC9 0
  (g_wf_TCC9-1 nil 3784647385 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (injective? const-decl "bool" functions nil)
    (surjective? const-decl "bool" functions nil)
    (inc const-decl "nat" peg nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (< def-decl "bool" ordinals nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (pegMeasure const-decl "nat" peg nil)
    (lex2 const-decl "ordinal" lex2 nil))
   nil
   (g_wf termination
    "wf_peg.g_wf(wf_peg.σ, wf_peg.e, wf_peg.A, wf_peg.P_0, wf_peg.δ)"
    "nil")))
 (nT_properties_TCC1 0
  (nT_properties_TCC1-1 nil 3770412224 ("" (subtype-tcc) nil nil)
   ((all_false const-decl "nTpred" wf_peg nil)
    (V_N_b formal-const-decl "posnat" wf_peg nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (leq_inst const-decl "bool" nTpred_order nil)
    (<= const-decl "bool" nTpred_order nil)
    (coherent_properties const-decl "bool" wf_peg nil))
   nil
   (nT_properties subtype
    "(wf_peg.all_false, wf_peg.all_false, wf_peg.all_false)"
    "wf_peg.C(wf_peg.P_exp)")))
 (nT_properties_TCC2 0
  (nT_properties_TCC2-1 nil 3770412224
   ("" (assert)
    (("" (case "FORALL A : aux(A, 0, all_false) = 0")
      (("1" (inst -1 "V_N_b -1")
        (("1" (assert) (("1" (assert) (("1" (grind) nil nil)) nil))
          nil))
        nil)
       ("2" (hide 2)
        (("2" (induct "A")
          (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((all_false const-decl "nTpred" wf_peg nil)
    (nTpred type-eq-decl nil wf_peg nil)
    (aux def-decl "result" array_sum nil)
    (result type-eq-decl nil array_sum nil)
    (nTpred type-eq-decl nil nTpred_order nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (V_N_b formal-const-decl "posnat" wf_peg nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (array_sum const-decl "upto(3 * V_N_b)" array_sum nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (pred type-eq-decl nil defined_types nil)
    (below type-eq-decl nil naturalnumbers nil)
    (below_induction formula-decl nil bounded_nat_inductions nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil))
   nil
   (nT_properties subtype "0"
    "{k: naturalnumbers.upto(number_fields.*(3, wf_peg.V_N_b)) | k = array_sum[wf_peg.V_N_b].array_sum(wf_peg.all_false, wf_peg.all_false, wf_peg.all_false)}")))
 (complete_WF_no_order 0
  (complete_WF_no_order-1 nil 3847607482
   ("" (skeep)
    (("" (expand "complete_WF")
      (("" (expand "complete")
        (("" (iff 1)
          ((""
            (case "FORALL A, G: g_wf(σ, G, A, P_0c?(P_exp), FALSE) = g_wf(σ_p, G, A, P_0c?(P_exp), FALSE)")
            (("1" (grind) nil nil)
             ("2" (hide 2)
              (("2" (skolem 1 ("A" "_"))
                (("2" (induct "G")
                  (("1" (grind) nil nil) ("2" (grind) nil nil)
                   ("3" (grind) nil nil) ("4" (grind) nil nil)
                   ("5" (grind) nil nil) ("6" (grind) nil nil)
                   ("7" (grind) nil nil) ("8" (grind) nil nil)
                   ("9" (grind) nil nil) ("10" (grind) nil nil)
                   ("11" (grind) nil nil) ("12" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((complete_WF const-decl "bool" wf_peg nil)
    (peg_induction formula-decl nil peg nil)
    (nT_properties const-decl "F(P_exp)" wf_peg nil)
    (array_sum const-decl "upto(3 * V_N_b)" array_sum nil)
    (r const-decl "C(P_exp)" wf_peg nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (V_T formal-nonempty-type-decl nil wf_peg nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" wf_peg nil)
    (peg type-decl nil peg nil) (Δ type-eq-decl nil wf_peg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (FALSE const-decl "bool" booleans nil)
    (complete const-decl "bool" wf_peg nil))
   shostak))
 (strong_is_complete_WF 0
  (strong_is_complete_WF-1 nil 3771171785
   ("" (skeep)
    (("" (expand "complete_WF")
      (("" (expand "strong_WF")
        (("" (skeep)
          (("" (inst -1 "A")
            ((""
              (case "FORALL G : g_wf(σ, G, A, P_0c?(P_exp), strong) IMPLIES g_wf(σ, G, A, P_0c?(P_exp), complete)")
              (("1" (inst -1 "P_exp(A)") (("1" (assert) nil nil)) nil)
               ("2" (hide 2)
                (("2" (hide -1)
                  (("2" (induct "G")
                    (("1" (grind) nil nil) ("2" (grind) nil nil)
                     ("3" (grind) nil nil) ("4" (grind) nil nil)
                     ("5" (grind) nil nil)
                     ("6" (skeep)
                      (("6" (expand "g_wf" -3) (("6" (grind) nil nil))
                        nil))
                      nil)
                     ("7" (grind) nil nil) ("8" (grind) nil nil)
                     ("9" (grind) nil nil) ("10" (grind) nil nil)
                     ("11" (grind) nil nil) ("12" (grind) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((complete_WF const-decl "bool" wf_peg nil)
    (complete const-decl "bool" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (Δ type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (<= formal-const-decl "(total_order?[V_T])" wf_peg nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil wf_peg nil)
    (nT_properties const-decl "F(P_exp)" wf_peg nil)
    (array_sum const-decl "upto(3 * V_N_b)" array_sum nil)
    (r const-decl "C(P_exp)" wf_peg nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (peg_induction formula-decl nil peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (V_N_b formal-const-decl "posnat" wf_peg nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (strong_WF const-decl "bool" wf_peg nil))
   shostak))
 (complete_WF_theorem 0
  (complete_WF_theorem-1 nil 3771183719
   ("" (skeep)
    ((""
      (case "FORALL (j :nat) : FORALL (i : upto(j), G' : Δ) : (subterm(G,G') AND (pegMeasure(G') = pegMeasure(G) +i)) IMPLIES ((NOT g_wf(σ, G, A, P_0c?(P_exp), complete)) IMPLIES (NOT g_wf(σ, G', A, P_0c?(P_exp), complete)))")
      (("1" (inst -1 "pegMeasure(P_exp(A)) - pegMeasure(G)")
        (("1"
          (inst -1 "pegMeasure(P_exp(A)) - pegMeasure(G)" " P_exp(A)")
          (("1" (assert)
            (("1" (typepred "P_exp")
              (("1" (use "strong_is_complete_WF")
                (("1" (expand "complete_WF")
                  (("1" (inst -1 "A")
                    (("1" (use "peg[V_T, <=, V_N_b].subterm_lq")
                      (("1" (assert)
                        (("1" (use "peg[V_T, <=,  V_N_b].subterm_lq")
                          (("1" (assert)
                            (("1" (expand "complete")
                              (("1" (propax) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (use "peg[V_T, <=,  V_N_b].subterm_lq")
            (("2" (assert) nil nil)) nil))
          nil)
         ("2" (hide 2)
          (("2" (use "peg[V_T, <=, V_N_b].subterm_lq")
            (("2" (assert) nil nil)) nil))
          nil))
        nil)
       ("2" (expand "complete")
        (("2" (hide 2)
          (("2" (induct "j")
            (("1" (skeep)
              (("1" (case-replace "i=0")
                (("1" (use "peg[V_T, <=, V_N_b].subterm_eq")
                  (("1" (grind) nil nil)) nil)
                 ("2" (assert) nil nil))
                nil))
              nil)
             ("2" (skolem 1 "i")
              (("2" (flatten)
                (("2" (skolem 1 ("k" "_"))
                  (("2" (induct "G'")
                    (("1" (grind) nil nil) ("2" (grind) nil nil)
                     ("3" (grind) nil nil) ("4" (grind) nil nil)
                     ("5" (grind) nil nil)
                     ("6" (skeep)
                      (("6" (expand "subterm" -3)
                        (("6" (split -3)
                          (("1" (replace -1 * LR)
                            (("1" (propax) nil nil)) nil)
                           ("2"
                            (inst -6
                             "pegMeasure(seq1_var) - pegMeasure(G)"
                             "seq1_var")
                            (("1" (assert)
                              (("1"
                                (expand "g_wf" -5)
                                (("1" (propax) nil nil))
                                nil))
                              nil)
                             ("2"
                              (use "peg[V_T, <=, V_N_b].subterm_lq")
                              (("2"
                                (assert)
                                (("2" (grind) nil nil))
                                nil))
                              nil))
                            nil)
                           ("3" (expand "g_wf" -5)
                            (("3" (flatten)
                              (("3"
                                (use "peg[V_T, <=, V_N_b].subterm_lq")
                                (("3"
                                  (inst
                                   -
                                   "pegMeasure(seq2_var) - pegMeasure(G)"
                                   "seq2_var")
                                  (("1" (grind) nil nil)
                                   ("2"
                                    (use
                                     "peg[V_T, <=, V_N_b].subterm_lq")
                                    (("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("7" (skeep)
                      (("7" (copy -5)
                        (("7" (expand "g_wf" -1)
                          (("7" (flatten)
                            (("7" (expand "subterm" -5)
                              (("7"
                                (split -5)
                                (("1"
                                  (replace -1 * LR)
                                  (("1" (propax) nil nil))
                                  nil)
                                 ("2"
                                  (assert)
                                  (("2"
                                    (inst
                                     -6
                                     "pegMeasure(prior1_var) - pegMeasure(G)"
                                     "prior1_var")
                                    (("1" (grind) nil nil)
                                     ("2"
                                      (use
                                       "peg[V_T, <=, V_N_b].subterm_lq")
                                      (("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("3"
                                  (assert)
                                  (("3"
                                    (inst
                                     -6
                                     "pegMeasure(prior2_var) - pegMeasure(G)"
                                     "prior2_var")
                                    (("1" (grind) nil nil)
                                     ("2"
                                      (use
                                       "peg[V_T, <=, V_N_b].subterm_lq")
                                      (("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("8" (skeep)
                      (("8" (copy -4)
                        (("8" (expand "g_wf" -1)
                          (("8" (expand "subterm" -3)
                            (("8" (split -3)
                              (("1" (grind) nil nil)
                               ("2"
                                (inst
                                 -6
                                 "pegMeasure(star1_var) - pegMeasure(G)"
                                 "star1_var")
                                (("1" (grind) nil nil)
                                 ("2"
                                  (use
                                   "peg[V_T, <=, V_N_b].subterm_lq")
                                  (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("9" (skeep)
                      (("9" (copy -4)
                        (("9" (expand "g_wf" -1)
                          (("9" (expand "subterm" -3)
                            (("9" (split -3)
                              (("1" (grind) nil nil)
                               ("2"
                                (inst
                                 -6
                                 "pegMeasure(plus1_var) - pegMeasure(G)"
                                 "plus1_var")
                                (("1" (grind) nil nil)
                                 ("2"
                                  (use
                                   "peg[V_T, <=, V_N_b].subterm_lq")
                                  (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("10" (skeep)
                      (("10" (copy -4)
                        (("10" (expand "g_wf" -1)
                          (("10" (expand "subterm" -3)
                            (("10" (split -3)
                              (("1" (grind) nil nil)
                               ("2"
                                (inst
                                 -6
                                 "pegMeasure(opt1_var) - pegMeasure(G)"
                                 "opt1_var")
                                (("1" (grind) nil nil)
                                 ("2"
                                  (use
                                   "peg[V_T, <=, V_N_b].subterm_lq")
                                  (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("11" (skeep)
                      (("11" (copy -4)
                        (("11" (expand "g_wf" -1)
                          (("11" (expand "subterm" -3)
                            (("11" (split -3)
                              (("1" (grind) nil nil)
                               ("2"
                                (inst
                                 -6
                                 "pegMeasure(notP1_var) - pegMeasure(G)"
                                 "notP1_var")
                                (("1" (grind) nil nil)
                                 ("2"
                                  (use
                                   "peg[V_T, <=, V_N_b].subterm_lq")
                                  (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("12" (skeep)
                      (("12" (copy -4)
                        (("12" (expand "g_wf" -1)
                          (("12" (expand "subterm" -3)
                            (("12" (split -3)
                              (("1" (grind) nil nil)
                               ("2"
                                (inst
                                 -6
                                 "pegMeasure(andP1_var) - pegMeasure(G)"
                                 "andP1_var")
                                (("1" (grind) nil nil)
                                 ("2"
                                  (use
                                   "peg[V_T, <=, V_N_b].subterm_lq")
                                  (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((complete const-decl "bool" wf_peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (pegMeasure const-decl "nat" peg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (subterm adt-def-decl "boolean" peg nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (Δ type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (V_N_b formal-const-decl "posnat" wf_peg nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (<= formal-const-decl "(total_order?[V_T])" wf_peg nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil wf_peg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (complete_WF const-decl "bool" wf_peg nil)
    (subterm_lq formula-decl nil peg nil)
    (strong_is_complete_WF formula-decl nil wf_peg nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (G skolem-const-decl "Δ" wf_peg nil)
    (A skolem-const-decl "V_N[V_N_b]" wf_peg nil)
    (P_exp skolem-const-decl "WF_nT(σ)" wf_peg nil)
    (σ skolem-const-decl "order" wf_peg nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (andP1_var skolem-const-decl "peg[V_T, <=, V_N_b]" wf_peg nil)
    (notP1_var skolem-const-decl "peg[V_T, <=, V_N_b]" wf_peg nil)
    (opt1_var skolem-const-decl "peg[V_T, <=, V_N_b]" wf_peg nil)
    (plus1_var skolem-const-decl "peg[V_T, <=, V_N_b]" wf_peg nil)
    (r const-decl "C(P_exp)" wf_peg nil)
    (array_sum const-decl "upto(3 * V_N_b)" array_sum nil)
    (nT_properties const-decl "F(P_exp)" wf_peg nil)
    (inc const-decl "nat" peg nil)
    (star1_var skolem-const-decl "peg[V_T, <=, V_N_b]" wf_peg nil)
    (prior2_var skolem-const-decl "peg[V_T, <=, V_N_b]" wf_peg nil)
    (prior1_var skolem-const-decl "peg[V_T, <=, V_N_b]" wf_peg nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (sum const-decl "nat" peg nil)
    (seq1_var skolem-const-decl "peg[V_T, <=, V_N_b]" wf_peg nil)
    (seq2_var skolem-const-decl "peg[V_T, <=, V_N_b]" wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (nonTerminal1_var!1 skolem-const-decl "below(V_N_b)" wf_peg nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (i skolem-const-decl "nat" wf_peg nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (peg_induction formula-decl nil peg nil)
    (subterm_eq formula-decl nil peg nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (FALSE const-decl "bool" booleans nil))
   shostak))
 (complete_WF_theorem2 0
  (complete_WF_theorem2-1 nil 3813664218
   ("" (skeep)
    (("" (skeep)
      ((""
        (case "FORALL (j :nat) : FORALL (i : upto(j), G' : Δ) : (subterm(G,G') AND (pegMeasure(G') = pegMeasure(G) +i)) IMPLIES ((NOT g_wf(σ, G, A, P_0c?(P_exp), complete)) IMPLIES (NOT g_wf(σ, G', A, P_0c?(P_exp), complete)))")
        (("1" (inst -1 "pegMeasure(P_exp(A)) - pegMeasure(G)")
          (("1"
            (inst -1 "pegMeasure(P_exp(A)) - pegMeasure(G)"
             " P_exp(A)")
            (("1" (grind) nil nil)
             ("2" (use "peg[V_T, <=,  V_N_b].subterm_lq")
              (("2" (assert) nil nil)) nil))
            nil)
           ("2" (use "peg[V_T, <=, V_N_b].subterm_lq")
            (("2" (assert) nil nil)) nil))
          nil)
         ("2" (hide 2)
          (("2" (induct "j")
            (("1" (skeep)
              (("1" (typepred "i")
                (("1" (assert)
                  (("1" (case-replace "i=0")
                    (("1" (expand "complete")
                      (("1" (use "peg[V_T, <=, V_N_b].subterm_eq")
                        (("1" (grind) nil nil)) nil))
                      nil)
                     ("2" (assert) nil nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (skolem 1 "i")
              (("2" (flatten)
                (("2" (skolem 1 ("k" "_"))
                  (("2" (induct "G'")
                    (("1" (grind) nil nil) ("2" (grind) nil nil)
                     ("3" (grind) nil nil) ("4" (grind) nil nil)
                     ("5" (grind) nil nil)
                     ("6" (skolem 1 ("e1" "e2"))
                      (("6" (assert)
                        (("6" (flatten)
                          (("6" (expand "subterm" -3)
                            (("6" (split -3)
                              (("1" (assert) nil nil)
                               ("2"
                                (expand "complete")
                                (("2"
                                  (inst
                                   -6
                                   "pegMeasure(e1) - pegMeasure(G)"
                                   "e1")
                                  (("1"
                                    (assert)
                                    (("1"
                                      (expand "g_wf" -5)
                                      (("1" (propax) nil nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (use
                                     "peg[V_T, <=, V_N_b].subterm_lq")
                                    (("2"
                                      (assert)
                                      (("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("3"
                                (expand "g_wf" -5)
                                (("3"
                                  (use
                                   "peg[V_T, <=, V_N_b].subterm_lq")
                                  (("3"
                                    (inst
                                     -7
                                     "pegMeasure(e2) - pegMeasure(G)"
                                     "e2")
                                    (("1" (grind) nil nil)
                                     ("2"
                                      (use
                                       "peg[V_T, <=, V_N_b].subterm_lq")
                                      (("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("7" (skeep)
                      (("7" (copy -5)
                        (("7" (expand "g_wf" -1)
                          (("7" (flatten)
                            (("7" (expand "subterm" -5)
                              (("7"
                                (split -5)
                                (("1" (assert) nil nil)
                                 ("2"
                                  (assert)
                                  (("2"
                                    (inst
                                     -6
                                     "pegMeasure(prior1_var) - pegMeasure(G)"
                                     "prior1_var")
                                    (("1" (grind) nil nil)
                                     ("2"
                                      (use
                                       "peg[V_T, <=, V_N_b].subterm_lq")
                                      (("2"
                                        (expand "complete")
                                        (("2" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("3"
                                  (assert)
                                  (("3"
                                    (inst
                                     -6
                                     "pegMeasure(prior2_var) - pegMeasure(G)"
                                     "prior2_var")
                                    (("1" (grind) nil nil)
                                     ("2"
                                      (use
                                       "peg[V_T, <=, V_N_b].subterm_lq")
                                      (("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("8" (skeep)
                      (("8" (copy -4)
                        (("8" (expand "g_wf" -1)
                          (("8" (expand "subterm" -3)
                            (("8" (split -3)
                              (("1" (grind) nil nil)
                               ("2"
                                (inst
                                 -6
                                 "pegMeasure(star1_var) - pegMeasure(G)"
                                 "star1_var")
                                (("1" (grind) nil nil)
                                 ("2"
                                  (use
                                   "peg[V_T, <=, V_N_b].subterm_lq")
                                  (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("9" (skeep)
                      (("9" (copy -4)
                        (("9" (expand "g_wf" -1)
                          (("9" (expand "subterm" -3)
                            (("9" (split -3)
                              (("1" (grind) nil nil)
                               ("2"
                                (inst
                                 -6
                                 "pegMeasure(plus1_var) - pegMeasure(G)"
                                 "plus1_var")
                                (("1" (grind) nil nil)
                                 ("2"
                                  (use
                                   "peg[V_T, <=, V_N_b].subterm_lq")
                                  (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("10" (skeep)
                      (("10" (copy -4)
                        (("10" (expand "g_wf" -1)
                          (("10" (expand "subterm" -3)
                            (("10" (split -3)
                              (("1" (grind) nil nil)
                               ("2"
                                (inst
                                 -6
                                 "pegMeasure(opt1_var) - pegMeasure(G)"
                                 "opt1_var")
                                (("1" (grind) nil nil)
                                 ("2"
                                  (use
                                   "peg[V_T, <=, V_N_b].subterm_lq")
                                  (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("11" (skeep)
                      (("11" (copy -4)
                        (("11" (expand "g_wf" -1)
                          (("11" (expand "subterm" -3)
                            (("11" (split -3)
                              (("1" (grind) nil nil)
                               ("2"
                                (inst
                                 -6
                                 "pegMeasure(notP1_var) - pegMeasure(G)"
                                 "notP1_var")
                                (("1" (grind) nil nil)
                                 ("2"
                                  (use
                                   "peg[V_T, <=, V_N_b].subterm_lq")
                                  (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("12" (skeep)
                      (("12" (copy -4)
                        (("12" (expand "g_wf" -1)
                          (("12" (expand "subterm" -3)
                            (("12" (split -3)
                              (("1" (grind) nil nil)
                               ("2"
                                (inst
                                 -6
                                 "pegMeasure(andP1_var) - pegMeasure(G)"
                                 "andP1_var")
                                (("1" (grind) nil nil)
                                 ("2"
                                  (use
                                   "peg[V_T, <=, V_N_b].subterm_lq")
                                  (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((andP1_var skolem-const-decl "peg[V_T, <=, V_N_b]" wf_peg nil)
    (notP1_var skolem-const-decl "peg[V_T, <=, V_N_b]" wf_peg nil)
    (opt1_var skolem-const-decl "peg[V_T, <=, V_N_b]" wf_peg nil)
    (plus1_var skolem-const-decl "peg[V_T, <=, V_N_b]" wf_peg nil)
    (inc const-decl "nat" peg nil)
    (star1_var skolem-const-decl "peg[V_T, <=, V_N_b]" wf_peg nil)
    (prior2_var skolem-const-decl "peg[V_T, <=, V_N_b]" wf_peg nil)
    (prior1_var skolem-const-decl "peg[V_T, <=, V_N_b]" wf_peg nil)
    (e1 skolem-const-decl "peg[V_T, <=, V_N_b]" wf_peg nil)
    (sum const-decl "nat" peg nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nT_properties const-decl "F(P_exp)" wf_peg nil)
    (array_sum const-decl "upto(3 * V_N_b)" array_sum nil)
    (r const-decl "C(P_exp)" wf_peg nil)
    (e2 skolem-const-decl "peg[V_T, <=, V_N_b]" wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (nonTerminal1_var!1 skolem-const-decl "below(V_N_b)" wf_peg nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (i skolem-const-decl "nat" wf_peg nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (peg_induction formula-decl nil peg nil)
    (subterm_eq formula-decl nil peg nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (P_exp skolem-const-decl "interp" wf_peg nil)
    (A skolem-const-decl "V_N[V_N_b]" wf_peg nil)
    (G skolem-const-decl "Δ" wf_peg nil)
    (subterm_lq formula-decl nil peg nil)
    (complete_WF const-decl "bool" wf_peg nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (V_T formal-nonempty-type-decl nil wf_peg nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" wf_peg nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" wf_peg nil)
    (peg type-decl nil peg nil) (Δ type-eq-decl nil wf_peg nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (subterm adt-def-decl "boolean" peg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pegMeasure const-decl "nat" peg nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (complete const-decl "bool" wf_peg nil))
   shostak))
 (Star_cannot_be_P0_TCC1 0
  (Star_cannot_be_P0_TCC1-1 nil 3770412224 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (V_T formal-nonempty-type-decl nil wf_peg nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" wf_peg nil)
    (peg type-decl nil peg nil) (Δ type-eq-decl nil wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (Star_cannot_be_P0 subtype "wf_peg.G"
    "{x: peg[wf_peg.V_T, wf_peg.<=, wf_peg.V_N_b].peg |      peg[wf_peg.V_T, wf_peg.<=, wf_peg.V_N_b].star?(x) OR peg[wf_peg.V_T, wf_peg.<=, wf_peg.V_N_b].plus?(x) OR peg[wf_peg.V_T, wf_peg.<=, wf_peg.V_N_b].opt?(x) OR peg[wf_peg.V_T, wf_peg.<=, wf_peg.V_N_b].notP?(x) OR peg[wf_peg.V_T, wf_peg.<=, wf_peg.V_N_b].andP?(x)}")))
 (Star_cannot_be_P0 0
  (Star_cannot_be_P0-1 nil 3770493280
   ("" (skeep)
    (("" (typepred "P_exp")
      (("" (use "strong_is_complete_WF")
        (("" (use "complete_WF_theorem") (("" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (Δ type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (<= formal-const-decl "(total_order?[V_T])" wf_peg nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (V_N_b formal-const-decl "posnat" wf_peg nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (complete_WF_theorem formula-decl nil wf_peg nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (subterm adt-def-decl "boolean" peg nil)
    (strong const-decl "bool" wf_peg nil)
    (complete const-decl "bool" wf_peg nil)
    (complete_WF const-decl "bool" wf_peg nil)
    (r const-decl "C(P_exp)" wf_peg nil)
    (array_sum const-decl "upto(3 * V_N_b)" array_sum nil)
    (nT_properties const-decl "F(P_exp)" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (strong_is_complete_WF formula-decl nil wf_peg nil))
   shostak)))
(peg_extented
 (fold_left_TCC1 0
  (fold_left_TCC1-1 nil 3813664217 ("" (termination-tcc) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (length def-decl "nat" list_props nil))
   nil
   (fold_left termination
    "peg_extented.fold_left(peg_extented.l, peg_extented.op(peg_extented.acc, peg_extented.e), peg_extented.op)"
    "nil")))
 (string_aux_TCC1 0
  (string_aux_TCC1-1 nil 3813664217 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (int_max application-judgement "{k: int | i <= k AND j <= k}"
     real_defs nil)
    (rat_max application-judgement "{s: rat | s >= q AND s >= r}"
     real_defs nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (string_aux subtype
    "real_defs.max(((number_fields.-)(peg_extented.s`length, peg_extented.i)), 0)"
    "naturalnumber")))
 (string_aux_TCC2 0
  (string_aux_TCC2-1 nil 3813664217 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil (string_aux subtype "peg_extented.i" "below[s`length]")))
 (string_aux_TCC3 0
  (string_aux_TCC3-1 nil 3813664217 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (string_aux termination
    "peg_extented.string_aux((number_fields.+)(peg_extented.i, 1), peg_extented.s)"
    "nil"))))

