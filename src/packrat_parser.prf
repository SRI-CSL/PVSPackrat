(packrat_parser
 (results_TCC1 0
  (results_TCC2-1 nil 3771945369
   ("" (assert) (("" (expand "subterm") (("" (propax) nil nil)) nil))
    nil)
   ((subterm adt-def-decl "boolean" peg nil)
    (subterm_of? const-decl "bool" peg nil))
   nil
   (results subtype "packrat_parser.P_exp(packrat_parser.A)"
    "peg[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b].subterm_of(packrat_parser.P_exp(packrat_parser.A))")))
 (results_TCC2 0
  (results_TCC1-1 nil 3771945369
   ("" (skeep*)
    (("" (assert)
      (("" (typepred "P_exp")
        (("" (use "WF_nT_rewrite" (P_exp "P_exp"))
          (("" (flatten)
            (("" (expand "pattern_WF?") (("" (inst - A) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (WF_nT_rewrite formula-decl nil static_analysis nil)
    (pattern_WF? const-decl "bool" wf_peg nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" packrat_parser nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (V_T formal-nonempty-type-decl nil packrat_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" packrat_parser nil)
    (peg type-decl nil peg nil) (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (results subtype "packrat_parser.s"
    "{k: naturalnumbers.upto(packrat_parser.s) | booleans.IMPLIES((k = packrat_parser.s), wf_peg[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b].pattern_wf?(packrat_parser.P_exp(packrat_parser.A), packrat_parser.A, static_analysis[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b].σ(packrat_parser.P_exp), wf_peg[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b].P_0c(packrat_parser.P_exp)))}")))
 (packrat_parser_TCC1 0
  (packrat_parser_TCC1-1 nil 3848223916 ("" (assert) nil nil)
   ((subterm_of? const-decl "bool" peg nil)) nil
   (packrat_parser subtype "packrat_parser.G"
    "peg[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b].subterm_of(packrat_parser.P_exp(packrat_parser.A))")))
 (packrat_parser_TCC2 0
  (packrat_parser_TCC2-1 nil 3771945369 ("" (assert) nil nil) nil nil
   (packrat_parser subtype
    "(number_fields.-)(packrat_parser.bound, packrat_parser.s_T)"
    "nat")))
 (packrat_parser_TCC3 0
  (packrat_parser_TCC3-1 nil 3771945369 ("" (assert) nil nil) nil nil
   (packrat_parser subtype
    "(number_fields.-)(packrat_parser.bound, packrat_parser.s)"
    "nat")))
 (packrat_parser_TCC4 0
  (packrat_parser_TCC5-1 nil 3771945369
   ("" (assert)
    (("" (skeep*) (("" (typepred "z`6") (("" (assert) nil nil)) nil))
      nil))
    nil)
   ((TRUE const-decl "bool" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (V_T formal-nonempty-type-decl nil packrat_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" packrat_parser nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" packrat_parser nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (below type-eq-decl nil naturalnumbers nil)
    (peg type-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" packrat_parser nil)
    (V_S formal-type-decl nil packrat_parser nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (saved_result type-decl nil packrat_parser nil)
    (known? adt-recognizer-decl "[saved_result -> boolean]"
     packrat_parser nil)
    (pre_ast type-decl nil pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil)
    (T adt-accessor-decl
     "[(known?) -> ast[V_T, <=, V_N_b, bound, V_S]]" packrat_parser
     nil)
    (subterm_of type-eq-decl nil peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (results type-eq-decl nil packrat_parser nil))
   nil
   (packrat_parser subtype
    "(number_fields.-)(packrat_parser.bound, packrat_parser.z`6)"
    "nat")))
 (packrat_parser_TCC5 0
  (packrat_parser_TCC6-1 nil 3771945369
   ("" (skeep*) (("" (typepred "z`5") (("" (assert) nil nil)) nil))
    nil)
   ((results type-eq-decl nil packrat_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (subterm_of? const-decl "bool" peg nil)
    (subterm_of type-eq-decl nil peg nil)
    (T adt-accessor-decl
     "[(known?) -> ast[V_T, <=, V_N_b, bound, V_S]]" packrat_parser
     nil)
    (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (known? adt-recognizer-decl "[saved_result -> boolean]"
     packrat_parser nil)
    (saved_result type-decl nil packrat_parser nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (V_S formal-type-decl nil packrat_parser nil)
    (bound formal-const-decl "posnat" packrat_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" packrat_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= formal-const-decl "(total_order?[V_T])" packrat_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil packrat_parser nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (packrat_parser subtype
    "(number_fields.-)(packrat_parser.bound, packrat_parser.z`5)"
    "nat")))
 (packrat_parser_TCC6 0
  (packrat_parser_TCC7-1 nil 3771945369 ("" (assert) nil nil) nil nil
   (packrat_parser subtype
    "(number_fields.-)(packrat_parser.bound, packrat_parser.s_T)"
    "nat")))
 (packrat_parser_TCC7 0
  (packrat_parser_TCC8-1 nil 3771945369 ("" (assert) nil nil) nil nil
   (packrat_parser subtype
    "(number_fields.-)(packrat_parser.bound, packrat_parser.s)"
    "nat")))
 (packrat_parser_TCC8 0
  (packrat_parser_TCC9-1 nil 3771945369
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing") (("" (propax) nil nil)) nil)) nil))
    nil)
   ((parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (packrat_parser subtype
    "pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].ε(packrat_parser.s, packrat_parser.s)"
    "{T: pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].pre_ast | T = peg_parser[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].parsing(packrat_parser.P_exp, packrat_parser.A, packrat_parser.G, packrat_parser.inp, packrat_parser.s, packrat_parser.s_T)}")))
 (packrat_parser_TCC9 0
  (packrat_parser_TCC10-1 nil 3771945369 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" packrat_parser nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (V_T formal-nonempty-type-decl nil packrat_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" packrat_parser nil)
    (peg type-decl nil peg nil) (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (below type-eq-decl nil naturalnumbers nil)
    (subterm adt-def-decl "boolean" peg nil)
    (<= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" packrat_parser nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (saved_result type-decl nil packrat_parser nil)
    (known? adt-recognizer-decl "[saved_result -> boolean]"
     packrat_parser nil)
    (V_S formal-type-decl nil packrat_parser nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (pre_ast type-decl nil pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil)
    (T adt-accessor-decl
     "[(known?) -> ast[V_T, <=, V_N_b, bound, V_S]]" packrat_parser
     nil)
    (subterm_of type-eq-decl nil peg nil)
    (input type-eq-decl nil ast_props nil)
    (subterm_of? const-decl "bool" peg nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (results type-eq-decl nil packrat_parser nil)
    (structural_WF? const-decl "bool" wf_peg nil)
    (interval_list const-decl "list[nat]" interval_list nil)
    (nodes const-decl "node_ls" static_analysis nil)
    (dependency_graph const-decl "c_digraph[nat]" static_analysis nil)
    (size const-decl "nat" c_digraphs_def digraphs)
    (node const-decl "{v: T | member(v, data(cd))}" c_digraphs_def
     digraphs)
    (empty_marking const-decl "marking" c_topological_sort digraphs)
    (gen_seq1 const-decl "Seq(G)" walks_ digraphs)
    (topological_sort_aux def-decl
     "{res: [loop(G) + [non_temporary_marking, list[Vert(G)]]] |
   CASES res
     OF IN_1(loop): TRUE,
        IN_2(res):
          LET (mp, lp) = res IN
            topperm_list(G, mp)(lp) ∧
             greater_marking(mp, m) ∧
              suffix?(l, lp) ∧ FORALL (i: upto(n)): member(node(G)(i), lp)
     ENDCASES}" c_topological_sort digraphs)
    (topological_sort const-decl
     "{res: [loop(G) + (topological_ordering?(G))] | IN?_2(res) ⇔ is_dag(G)}"
     c_topological_sort digraphs)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (packrat_parser subtype
    "pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].any(packrat_parser.s, real_defs.min((number_fields.+)(packrat_parser.s, 1), packrat_parser.bound), packrat_parser.inp(packrat_parser.s))"
    "{T: pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].pre_ast | T = peg_parser[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].parsing(packrat_parser.P_exp, packrat_parser.A, packrat_parser.G, packrat_parser.inp, packrat_parser.s, packrat_parser.s_T)}")))
 (packrat_parser_TCC10 0
  (packrat_parser_TCC11-1 nil 3771945369
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing") (("" (propax) nil nil)) nil)) nil))
    nil)
   ((parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (packrat_parser subtype
    "pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].terminal(packrat_parser.s, real_defs.min((number_fields.+)(packrat_parser.s, 1), packrat_parser.bound), packrat_parser.a, packrat_parser.inp(packrat_parser.s))"
    "{T: pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].pre_ast | T = peg_parser[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].parsing(packrat_parser.P_exp, packrat_parser.A, packrat_parser.G, packrat_parser.inp, packrat_parser.s, packrat_parser.s_T)}")))
 (packrat_parser_TCC11 0
  (packrat_parser_TCC12-1 nil 3771945369
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing") (("" (propax) nil nil)) nil)) nil))
    nil)
   ((parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (packrat_parser subtype
    "pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].range(packrat_parser.s, real_defs.min((number_fields.+)(packrat_parser.s, 1), packrat_parser.bound), packrat_parser.a, packrat_parser.b, packrat_parser.inp(packrat_parser.s))"
    "{T: pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].pre_ast | T = peg_parser[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].parsing(packrat_parser.P_exp, packrat_parser.A, packrat_parser.G, packrat_parser.inp, packrat_parser.s, packrat_parser.s_T)}")))
 (packrat_parser_TCC12 0
  (packrat_parser_TCC23-1 nil 3771945369
   ("" (skeep*)
    (("" (typepred "T_B") (("" (ground) (("" (smash) nil nil)) nil))
      nil))
    nil)
   ((ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil packrat_parser nil)
    (bound formal-const-decl "posnat" packrat_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" packrat_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" packrat_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil packrat_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (packrat_parser subtype "packrat_parser.T_B"
    "{T: pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].pre_ast | (booleans.¬)(pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].skip?(T))}")))
 (packrat_parser_TCC13 0
  (packrat_parser_TCC13-1 nil 3771945369
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (assert)
        (("" (auto-rewrite! parsing)
          (("" (assert)
            (("" (typepred "res")
              (("" (inst -1 "B" "s")
                (("" (assert)
                  (("" (assert)
                    (("" (replace -3 -1 LR) (("" (assert) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((results type-eq-decl nil packrat_parser nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (input type-eq-decl nil ast_props nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (subterm_of type-eq-decl nil peg nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (T adt-accessor-decl
     "[(known?) -> ast[V_T, <=, V_N_b, bound, V_S]]" packrat_parser
     nil)
    (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (known? adt-recognizer-decl "[saved_result -> boolean]"
     packrat_parser nil)
    (saved_result type-decl nil packrat_parser nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (below type-eq-decl nil naturalnumbers nil)
    (V_S formal-type-decl nil packrat_parser nil)
    (bound formal-const-decl "posnat" packrat_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" packrat_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" packrat_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil packrat_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (packrat_parser subtype
    "pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].nonTerminal(packrat_parser.s, pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].e(packrat_parser.T_B), packrat_parser.B, packrat_parser.T_B)"
    "{T: pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].pre_ast | T = peg_parser[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].parsing(packrat_parser.P_exp, packrat_parser.A, packrat_parser.G, packrat_parser.inp, packrat_parser.s, packrat_parser.s_T)}")))
 (packrat_parser_TCC14 0
  (packrat_parser_TCC19-1 nil 3771945369
   ("" (expand "subterm") (("" (propax) nil nil)) nil)
   ((subterm adt-def-decl "boolean" peg nil)) nil
   (packrat_parser subtype "packrat_parser.P_exp(packrat_parser.B)"
    "{e: wf_peg[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b].Δ | peg[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b].subterm(e, packrat_parser.P_exp(packrat_parser.B))}")))
 (packrat_parser_TCC15 0
  (packrat_parser_TCC4-1 nil 3771945369
   ("" (skeep*)
    (("" (assert)
      (("" (typepred "P_exp")
        (("" (use "WF_nT_rewrite")
          (("" (expand "pattern_WF?")
            (("" (assert)
              (("" (flatten) (("" (inst -2 "B") nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (WF_nT_rewrite formula-decl nil static_analysis nil)
    (structural_WF? const-decl "bool" wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (pattern_WF? const-decl "bool" wf_peg nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" packrat_parser nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (V_T formal-nonempty-type-decl nil packrat_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" packrat_parser nil)
    (peg type-decl nil peg nil) (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (packrat_parser subtype "packrat_parser.s"
    "{k: naturalnumbers.upto(packrat_parser.s) | booleans.⇒((k = packrat_parser.s), wf_peg[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b].pattern_wf?(packrat_parser.P_exp(packrat_parser.B), packrat_parser.B, static_analysis[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b].σ(packrat_parser.P_exp), wf_peg[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b].P_0c(packrat_parser.P_exp)))}")))
 (packrat_parser_TCC16 0
  (packrat_parser_TCC21-1 nil 3771945369
   ("" (skeep*)
    (("" (rewrite "lex4_lt")
      (("" (rewrite "lex3_lt")
        (("" (rewrite "lex2_lt")
          (("" (assert)
            (("" (flatten)
              (("" (typepred "s_T")
                (("" (assert)
                  (("" (replace -3 * LR)
                    (("" (expand "g_wf")
                      (("" (expand "strong") (("" (assert) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (lex4_lt formula-decl nil lex4 nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" packrat_parser nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" packrat_parser nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (V_T formal-nonempty-type-decl nil packrat_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" packrat_parser nil)
    (peg type-decl nil peg nil) (interp type-eq-decl nil wf_peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (below type-eq-decl nil naturalnumbers nil)
    (pegMeasure const-decl "nat" peg nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lex2_lt formula-decl nil lex2 nil)
    (lex3_lt formula-decl nil lex3 nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (packrat_parser termination
    "packrat_parser.packrat_parser(packrat_parser.P_exp, packrat_parser.B, packrat_parser.P_exp(packrat_parser.B), packrat_parser.inp, packrat_parser.s, packrat_parser.s, packrat_parser.res)"
    "nil")))
 (packrat_parser_TCC17 0
  (packrat_parser_TCC14-1 nil 3771945369
   ("" (skeep*) (("" (wf-ast T_B) (("" (assert) nil nil)) nil)) nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil packrat_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" packrat_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" packrat_parser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" packrat_parser nil)
    (V_S formal-type-decl nil packrat_parser nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (subterm_of type-eq-decl nil peg nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (<= const-decl "bool" reals nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (below type-eq-decl nil naturalnumbers nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (packrat_parser subtype "packrat_parser.T_B"
    "{T: pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].pre_ast | (booleans.¬)(pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].skip?(T))}")))
 (packrat_parser_TCC18 0
  (packrat_parser_TCC15-1 nil 3771945369
   ("" (skeep*) (("" (replaces) (("" (assert) nil nil)) nil)) nil)
   ((V_S formal-type-decl nil packrat_parser nil)
    (bound formal-const-decl "posnat" packrat_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" packrat_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" packrat_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil packrat_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (packrat_parser subtype
    "pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].nonTerminal(packrat_parser.s, pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].e(packrat_parser.T_B), packrat_parser.B, packrat_parser.T_B)"
    "{T: pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].pre_ast | T = peg_parser[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].parsing(packrat_parser.P_exp, packrat_parser.A, packrat_parser.G, packrat_parser.inp, packrat_parser.s, packrat_parser.s_T)}")))
 (packrat_parser_TCC19 0
  (packrat_parser_TCC16-1 nil 3771945369
   ("" (skeep*)
    (("" (assert) (("" (typepred "T_B") (("" (assert) nil nil)) nil))
      nil))
    nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil packrat_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" packrat_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" packrat_parser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" packrat_parser nil)
    (V_S formal-type-decl nil packrat_parser nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (subterm_of type-eq-decl nil peg nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (<= const-decl "bool" reals nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (below type-eq-decl nil naturalnumbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (packrat_parser subtype "packrat_parser.T_B"
    "ast[V_T, <=, V_N_b, bound, V_S]")))
 (packrat_parser_TCC20 0
  (packrat_parser_TCC17-1 nil 3771945369
   ("" (skeep*)
    (("" (name-replace "C" "A!1")
      (("" (lift-if 1)
        (("" (lift-if 1)
          (("" (typepred "resB")
            (("" (typepred "T_B")
              (("" (assert)
                (("" (ground)
                  (("1" (inst -3 "B" "s_1") (("1" (assert) nil nil))
                    nil)
                   ("2" (inst -2 "C" "s_1") (("2" (assert) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" packrat_parser nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (below type-eq-decl nil naturalnumbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" packrat_parser nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (saved_result type-decl nil packrat_parser nil)
    (known? adt-recognizer-decl "[saved_result -> boolean]"
     packrat_parser nil)
    (V_T formal-nonempty-type-decl nil packrat_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" packrat_parser nil)
    (V_S formal-type-decl nil packrat_parser nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (pre_ast type-decl nil pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil)
    (T adt-accessor-decl
     "[(known?) -> ast[V_T, <=, V_N_b, bound, V_S]]" packrat_parser
     nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (subterm_of type-eq-decl nil peg nil) (peg type-decl nil peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (input type-eq-decl nil ast_props nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (results type-eq-decl nil packrat_parser nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (packrat_parser subtype
    "packrat_parser.resB WITH [(packrat_parser.B) := packrat_parser.resB(packrat_parser.B) WITH [(packrat_parser.s) := packrat_parser.known(packrat_parser.T_B)]]"
    "packrat_parser.results(packrat_parser.P_exp, packrat_parser.inp)")))
 (packrat_parser_TCC21 0
  (packrat_parser_TCC24-1 nil 3771945369
   ("" (skeep*)
    (("" (use "subterm_seq" (G "P_exp(A)")) (("" (assert) nil nil))
      nil))
    nil)
   ((subterm_seq formula-decl nil peg nil) (peg type-decl nil peg nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (below type-eq-decl nil naturalnumbers nil)
    (V_T formal-nonempty-type-decl nil packrat_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" packrat_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" packrat_parser nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (packrat_parser subtype "packrat_parser.e1"
    "{e: wf_peg[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b].Δ | peg[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b].subterm(e, packrat_parser.P_exp(packrat_parser.A))}")))
 (packrat_parser_TCC22 0
  (packrat_parser_TCC25-1 nil 3771945369
   ("" (skeep*)
    (("" (typepred "s_T")
      (("" (replaces) (("" (assert) (("" (flatten) nil nil)) nil))
        nil))
      nil))
    nil)
   ((P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" packrat_parser nil)
    (<= formal-const-decl "(total_order?[V_T])" packrat_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil packrat_parser nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bound formal-const-decl "posnat" packrat_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (packrat_parser subtype "packrat_parser.s_T"
    "{k: naturalnumbers.upto(packrat_parser.s) | booleans.⇒((k = packrat_parser.s), wf_peg[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b].pattern_wf?(packrat_parser.e1, packrat_parser.A, static_analysis[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b].σ(packrat_parser.P_exp), wf_peg[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b].P_0c(packrat_parser.P_exp)))}")))
 (packrat_parser_TCC23 0
  (packrat_parser_TCC26-1 nil 3771945369
   ("" (skeep*)
    (("" (assert)
      (("" (assert) (("" (replace -1 * LR) (("" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (lex4_lt formula-decl nil lex4 nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (sum_inc const-decl "nat" peg nil)
    (pegMeasure const-decl "nat" peg nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (lex3_lt formula-decl nil lex3 nil)
    (lex2_lt formula-decl nil lex2 nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (packrat_parser termination
    "packrat_parser.packrat_parser(packrat_parser.P_exp, packrat_parser.A, packrat_parser.e1, packrat_parser.inp, packrat_parser.s, packrat_parser.s_T, packrat_parser.res)"
    "nil")))
 (packrat_parser_TCC24 0
  (packrat_parser_TCC18-1 nil 3771945369
   ("" (skeep*) (("" (wf-ast T1) (("" (assert) nil nil)) nil)) nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil packrat_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" packrat_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" packrat_parser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" packrat_parser nil)
    (V_S formal-type-decl nil packrat_parser nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (subterm_of type-eq-decl nil peg nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (<= const-decl "bool" reals nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (below type-eq-decl nil naturalnumbers nil)
    (subterm adt-def-decl "boolean" peg nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (packrat_parser subtype "packrat_parser.T1"
    "{T: pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].pre_ast | (booleans.¬)(pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].skip?(T))}")))
 (packrat_parser_TCC25 0
  (packrat_parser_TCC28-1 nil 3771945369
   ("" (skeep*) (("" (replace -1 * LR) (("" (assert) nil nil)) nil))
    nil)
   ((V_S formal-type-decl nil packrat_parser nil)
    (bound formal-const-decl "posnat" packrat_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" packrat_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" packrat_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil packrat_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (packrat_parser subtype
    "pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].seq(packrat_parser.s, pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].e(packrat_parser.T1), packrat_parser.T1, pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].skip(pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].e(packrat_parser.T1), pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].e(packrat_parser.T1), packrat_parser.e2))"
    "{T: pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].pre_ast | T = peg_parser[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].parsing(packrat_parser.P_exp, packrat_parser.A, packrat_parser.G, packrat_parser.inp, packrat_parser.s, packrat_parser.s_T)}")))
 (packrat_parser_TCC26 0
  (packrat_parser_TCC29-1 nil 3771945369
   ("" (skeep*)
    (("" (use "subterm_seq" (G "P_exp(A)")) (("" (assert) nil nil))
      nil))
    nil)
   ((subterm_seq formula-decl nil peg nil) (peg type-decl nil peg nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (below type-eq-decl nil naturalnumbers nil)
    (V_T formal-nonempty-type-decl nil packrat_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" packrat_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" packrat_parser nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (packrat_parser subtype "packrat_parser.e2"
    "{e: wf_peg[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b].Δ | peg[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b].subterm(e, packrat_parser.P_exp(packrat_parser.A))}")))
 (packrat_parser_TCC27 0
  (packrat_parser_TCC31-1 nil 3771945369
   ("" (skeep*)
    (("" (typepred "s_T")
      (("" (wf-ast T1)
        (("" (typepred "parsing(P_exp, A, e1, inp, s, s_T)")
          (("" (assert)
            (("" (flatten)
              (("" (assert)
                (("" (flatten)
                  (("" (assert)
                    (("" (g_props)
                      (("" (replace -13 * LR) (("" (assert) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" packrat_parser nil)
    (<= formal-const-decl "(total_order?[V_T])" packrat_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil packrat_parser nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bound formal-const-decl "posnat" packrat_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (subterm_of? const-decl "bool" peg nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (subterm_of type-eq-decl nil peg nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil packrat_parser nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (packrat_parser subtype "packrat_parser.s_T"
    "{k: naturalnumbers.upto(pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].e(packrat_parser.T1)) | booleans.⇒((k = pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].e(packrat_parser.T1)), wf_peg[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b].pattern_wf?(packrat_parser.e2, packrat_parser.A, static_analysis[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b].σ(packrat_parser.P_exp), wf_peg[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b].P_0c(packrat_parser.P_exp)))}")))
 (packrat_parser_TCC28 0
  (packrat_parser_TCC32-1 nil 3771945369
   ("" (skeep*)
    (("" (assert)
      (("" (assert)
        (("" (assert)
          (("" (wf-ast T1)
            (("" (assert)
              (("" (flatten)
                (("" (assert)
                  (("" (replace -4 * LR) (("" (grind) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (lex2_lt formula-decl nil lex2 nil)
    (lex3_lt formula-decl nil lex3 nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (sum_inc const-decl "nat" peg nil)
    (pegMeasure const-decl "nat" peg nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (subterm adt-def-decl "boolean" peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (<= const-decl "bool" reals nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (< const-decl "bool" reals nil)
    (subterm_of type-eq-decl nil peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil packrat_parser nil)
    (bound formal-const-decl "posnat" packrat_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" packrat_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" packrat_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil packrat_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (lex4_lt formula-decl nil lex4 nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (packrat_parser termination
    "packrat_parser.packrat_parser(packrat_parser.P_exp, packrat_parser.A, packrat_parser.e2, packrat_parser.inp, pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].e(packrat_parser.T1), packrat_parser.s_T, packrat_parser.res1)"
    "nil")))
 (packrat_parser_TCC29 0
  (packrat_parser_TCC20-1 nil 3771945369
   ("" (skeep*) (("" (wf-ast T1) (("" (assert) nil nil)) nil)) nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil packrat_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" packrat_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" packrat_parser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" packrat_parser nil)
    (V_S formal-type-decl nil packrat_parser nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (subterm_of type-eq-decl nil peg nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (<= const-decl "bool" reals nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (below type-eq-decl nil naturalnumbers nil)
    (subterm adt-def-decl "boolean" peg nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (packrat_parser subtype "packrat_parser.T1"
    "{T: pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].pre_ast | (booleans.¬)(pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].skip?(T))}")))
 (packrat_parser_TCC30 0
  (packrat_parser_TCC34-1 nil 3771945369
   ("" (skeep*) (("" (replace -1 * LR) (("" (assert) nil nil)) nil))
    nil)
   ((V_S formal-type-decl nil packrat_parser nil)
    (bound formal-const-decl "posnat" packrat_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" packrat_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" packrat_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil packrat_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (packrat_parser subtype
    "pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].seq(packrat_parser.s, pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].e(packrat_parser.T2), packrat_parser.T1, packrat_parser.T2)"
    "{T: pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].pre_ast | T = peg_parser[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].parsing(packrat_parser.P_exp, packrat_parser.A, packrat_parser.G, packrat_parser.inp, packrat_parser.s, packrat_parser.s_T)}")))
 (packrat_parser_TCC31 0
  (packrat_parser_TCC35-1 nil 3771945369
   ("" (skeep*)
    (("" (use "subterm_prior" (G "P_exp(A)")) (("" (assert) nil nil))
      nil))
    nil)
   ((subterm_prior formula-decl nil peg nil)
    (peg type-decl nil peg nil) (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (below type-eq-decl nil naturalnumbers nil)
    (V_T formal-nonempty-type-decl nil packrat_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" packrat_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" packrat_parser nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (packrat_parser subtype "packrat_parser.e1"
    "{e: wf_peg[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b].Δ | peg[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b].subterm(e, packrat_parser.P_exp(packrat_parser.A))}")))
 (packrat_parser_TCC32 0
  (packrat_parser_TCC36-1 nil 3771945369
   ("" (skeep*)
    (("" (typepred "s_T")
      (("" (assert)
        (("" (flatten)
          (("" (replace -4 * LR) (("" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" packrat_parser nil)
    (<= formal-const-decl "(total_order?[V_T])" packrat_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil packrat_parser nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bound formal-const-decl "posnat" packrat_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (packrat_parser subtype "packrat_parser.s_T"
    "{k: naturalnumbers.upto(packrat_parser.s) | booleans.⇒((k = packrat_parser.s), wf_peg[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b].pattern_wf?(packrat_parser.e1, packrat_parser.A, static_analysis[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b].σ(packrat_parser.P_exp), wf_peg[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b].P_0c(packrat_parser.P_exp)))}")))
 (packrat_parser_TCC33 0
  (packrat_parser_TCC37-1 nil 3771945369
   ("" (skeep*)
    (("" (assert)
      (("" (assert) (("" (replace -1 * LR) (("" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (lex4_lt formula-decl nil lex4 nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (sum_inc const-decl "nat" peg nil)
    (pegMeasure const-decl "nat" peg nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (lex3_lt formula-decl nil lex3 nil)
    (lex2_lt formula-decl nil lex2 nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (packrat_parser termination
    "packrat_parser.packrat_parser(packrat_parser.P_exp, packrat_parser.A, packrat_parser.e1, packrat_parser.inp, packrat_parser.s, packrat_parser.s_T, packrat_parser.res)"
    "nil")))
 (packrat_parser_TCC34 0
  (packrat_parser_TCC22-1 nil 3771945369
   ("" (skeep*) (("" (wf-ast T1) (("" (assert) nil nil)) nil)) nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil packrat_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" packrat_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" packrat_parser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" packrat_parser nil)
    (V_S formal-type-decl nil packrat_parser nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (subterm_of type-eq-decl nil peg nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (<= const-decl "bool" reals nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (below type-eq-decl nil naturalnumbers nil)
    (subterm adt-def-decl "boolean" peg nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (packrat_parser subtype "packrat_parser.T1"
    "{T: pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].pre_ast | (booleans.¬)(pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].skip?(T))}")))
 (packrat_parser_TCC35 0
  (packrat_parser_TCC27-1 nil 3771945369
   ("" (skeep*) (("" (replace -1 * LR) (("" (assert) nil nil)) nil))
    nil)
   ((V_S formal-type-decl nil packrat_parser nil)
    (bound formal-const-decl "posnat" packrat_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" packrat_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" packrat_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil packrat_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (packrat_parser subtype
    "pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].prior(packrat_parser.s, pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].e(packrat_parser.T1), packrat_parser.T1, pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].skip(packrat_parser.s, packrat_parser.s, packrat_parser.e2))"
    "{T: pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].pre_ast | T = peg_parser[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].parsing(packrat_parser.P_exp, packrat_parser.A, packrat_parser.G, packrat_parser.inp, packrat_parser.s, packrat_parser.s_T)}")))
 (packrat_parser_TCC36 0
  (packrat_parser_TCC40-1 nil 3771945369
   ("" (skeep*)
    (("" (use "subterm_prior" (G "P_exp(A)")) (("" (assert) nil nil))
      nil))
    nil)
   ((subterm_prior formula-decl nil peg nil)
    (peg type-decl nil peg nil) (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (below type-eq-decl nil naturalnumbers nil)
    (V_T formal-nonempty-type-decl nil packrat_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" packrat_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" packrat_parser nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (packrat_parser subtype "packrat_parser.e2"
    "{e: wf_peg[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b].Δ | peg[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b].subterm(e, packrat_parser.P_exp(packrat_parser.A))}")))
 (packrat_parser_TCC37 0
  (packrat_parser_TCC41-1 nil 3771945369
   ("" (skeep*)
    (("" (typepred "s_T")
      (("" (replace -3 * LR) (("" (assert) nil nil)) nil)) nil))
    nil)
   ((P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" packrat_parser nil)
    (<= formal-const-decl "(total_order?[V_T])" packrat_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil packrat_parser nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bound formal-const-decl "posnat" packrat_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (packrat_parser subtype "packrat_parser.s_T"
    "{k: naturalnumbers.upto(packrat_parser.s) | booleans.⇒((k = packrat_parser.s), wf_peg[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b].pattern_wf?(packrat_parser.e2, packrat_parser.A, static_analysis[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b].σ(packrat_parser.P_exp), wf_peg[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b].P_0c(packrat_parser.P_exp)))}")))
 (packrat_parser_TCC38 0
  (packrat_parser_TCC42-1 nil 3771945369
   ("" (skeep*)
    (("" (assert)
      (("" (assert)
        (("" (replace -1 * LR) (("" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (lex4_lt formula-decl nil lex4 nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (pegMeasure_prior formula-decl nil peg nil)
    (lex3_lt formula-decl nil lex3 nil)
    (lex2_lt formula-decl nil lex2 nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (packrat_parser termination
    "packrat_parser.packrat_parser(packrat_parser.P_exp, packrat_parser.A, packrat_parser.e2, packrat_parser.inp, packrat_parser.s, packrat_parser.s_T, packrat_parser.res1)"
    "nil")))
 (packrat_parser_TCC39 0
  (packrat_parser_TCC39-1 nil 3771945369
   ("" (skeep*) (("" (wf-ast T1) (("" (assert) nil nil)) nil)) nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil packrat_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" packrat_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" packrat_parser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" packrat_parser nil)
    (V_S formal-type-decl nil packrat_parser nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (subterm_of type-eq-decl nil peg nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (<= const-decl "bool" reals nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (below type-eq-decl nil naturalnumbers nil)
    (subterm adt-def-decl "boolean" peg nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (packrat_parser subtype "packrat_parser.T1"
    "{T: pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].pre_ast | (booleans.¬)(pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].skip?(T))}")))
 (packrat_parser_TCC40 0
  (packrat_parser_TCC44-1 nil 3771945369
   ("" (skeep*) (("" (replace -1 * LR) (("" (assert) nil nil)) nil))
    nil)
   ((V_S formal-type-decl nil packrat_parser nil)
    (bound formal-const-decl "posnat" packrat_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" packrat_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" packrat_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil packrat_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (packrat_parser subtype
    "pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].prior(packrat_parser.s, pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].e(packrat_parser.T2), packrat_parser.T1, packrat_parser.T2)"
    "{T: pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].pre_ast | T = peg_parser[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].parsing(packrat_parser.P_exp, packrat_parser.A, packrat_parser.G, packrat_parser.inp, packrat_parser.s, packrat_parser.s_T)}")))
 (packrat_parser_TCC41 0
  (packrat_parser_TCC45-1 nil 3771945369
   ("" (skeep*)
    (("" (use "subterm_star" (G "P_exp(A)")) (("" (assert) nil nil))
      nil))
    nil)
   ((subterm_star formula-decl nil peg nil) (peg type-decl nil peg nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (below type-eq-decl nil naturalnumbers nil)
    (V_T formal-nonempty-type-decl nil packrat_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" packrat_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" packrat_parser nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (packrat_parser subtype "packrat_parser.e"
    "{e: wf_peg[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b].Δ | peg[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b].subterm(e, packrat_parser.P_exp(packrat_parser.A))}")))
 (packrat_parser_TCC42 0
  (packrat_parser_TCC46-1 nil 3771945369
   ("" (skeep*)
    (("" (typepred "s_T")
      (("" (replace -3 * LR) (("" (assert) nil nil)) nil)) nil))
    nil)
   ((P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" packrat_parser nil)
    (<= formal-const-decl "(total_order?[V_T])" packrat_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil packrat_parser nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bound formal-const-decl "posnat" packrat_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (packrat_parser subtype "packrat_parser.s_T"
    "{k: naturalnumbers.upto(packrat_parser.s) | booleans.⇒((k = packrat_parser.s), wf_peg[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b].pattern_wf?(packrat_parser.e, packrat_parser.A, static_analysis[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b].σ(packrat_parser.P_exp), wf_peg[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b].P_0c(packrat_parser.P_exp)))}")))
 (packrat_parser_TCC43 0
  (packrat_parser_TCC47-1 nil 3771945369
   ("" (skeep*)
    (("" (assert)
      (("" (assert)
        (("" (replace -1 * LR) (("" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (lex4_lt formula-decl nil lex4 nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (pegMeasure_star formula-decl nil peg nil)
    (lex3_lt formula-decl nil lex3 nil)
    (lex2_lt formula-decl nil lex2 nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (packrat_parser termination
    "packrat_parser.packrat_parser(packrat_parser.P_exp, packrat_parser.A, packrat_parser.e, packrat_parser.inp, packrat_parser.s, packrat_parser.s_T, packrat_parser.res)"
    "nil")))
 (packrat_parser_TCC44 0
  (packrat_parser_TCC33-1 nil 3771945369
   ("" (skeep*) (("" (wf-ast T0) (("" (assert) nil nil)) nil)) nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil packrat_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" packrat_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" packrat_parser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" packrat_parser nil)
    (V_S formal-type-decl nil packrat_parser nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (subterm_of type-eq-decl nil peg nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (<= const-decl "bool" reals nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (below type-eq-decl nil naturalnumbers nil)
    (subterm adt-def-decl "boolean" peg nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (packrat_parser subtype "packrat_parser.T0"
    "{T: pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].pre_ast | (booleans.¬)(pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].skip?(T))}")))
 (packrat_parser_TCC45 0
  (packrat_parser_TCC49-1 nil 3771945369
   ("" (skeep*) (("" (replace -1 * LR) (("" (assert) nil nil)) nil))
    nil)
   ((V_S formal-type-decl nil packrat_parser nil)
    (bound formal-const-decl "posnat" packrat_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" packrat_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" packrat_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil packrat_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (packrat_parser subtype
    "pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].star(packrat_parser.s, packrat_parser.s, packrat_parser.T0, pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].skip(pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].e(packrat_parser.T0), pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].e(packrat_parser.T0), peg[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b].star(packrat_parser.e)))"
    "{T: pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].pre_ast | T = peg_parser[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].parsing(packrat_parser.P_exp, packrat_parser.A, packrat_parser.G, packrat_parser.inp, packrat_parser.s, packrat_parser.s_T)}")))
 (packrat_parser_TCC46 0
  (packrat_parser_TCC50-1 nil 3771945369
   ("" (skeep*) (("" (typepred "G") (("" (assert) nil nil)) nil)) nil)
   ((below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" packrat_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" packrat_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil packrat_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (packrat_parser subtype
    "peg[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b].star(packrat_parser.e)"
    "{e: wf_peg[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b].Δ | peg[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b].subterm(e, packrat_parser.P_exp(packrat_parser.A))}")))
 (packrat_parser_TCC47 0
  (packrat_parser_TCC52-1 nil 3771945369
   ("" (skeep*)
    (("" (typepred "s_T")
      (("" (replace -3 * LR)
        (("" (assert)
          (("" (wf-ast T0)
            (("" (assert)
              (("" (flatten)
                (("" (assert) (("" (ground) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" packrat_parser nil)
    (<= formal-const-decl "(total_order?[V_T])" packrat_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil packrat_parser nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bound formal-const-decl "posnat" packrat_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (subterm_of? const-decl "bool" peg nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (subterm_of type-eq-decl nil peg nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil packrat_parser nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (packrat_parser subtype "packrat_parser.s_T"
    "{k: naturalnumbers.upto(pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].e(packrat_parser.T0)) | booleans.⇒((k = pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].e(packrat_parser.T0)), wf_peg[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b].pattern_wf?(peg[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b].star(packrat_parser.e), packrat_parser.A, static_analysis[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b].σ(packrat_parser.P_exp), wf_peg[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b].P_0c(packrat_parser.P_exp)))}")))
 (packrat_parser_TCC48 0
  (packrat_parser_TCC53-1 nil 3771945369
   ("" (skeep*)
    (("" (assert)
      (("" (assert)
        (("" (assert)
          (("" (wf-ast T0)
            (("" (assert)
              (("" (flatten)
                (("" (assert)
                  (("" (use "star_cannot_be_P_0")
                    (("" (typepred "G")
                      (("" (assert)
                        ((""
                          (typepred
                           "parsing(P_exp, A, e, inp, s, s_T)")
                          (("" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (pegMeasure_star formula-decl nil peg nil)
    (lex2_lt formula-decl nil lex2 nil)
    (lex3_lt formula-decl nil lex3 nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (wf_nT type-eq-decl nil wf_peg nil)
    (wf_nT? const-decl "bool" wf_peg nil)
    (star_cannot_be_P_0 formula-decl nil wf_peg nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (subterm adt-def-decl "boolean" peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (<= const-decl "bool" reals nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (< const-decl "bool" reals nil)
    (subterm_of type-eq-decl nil peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil packrat_parser nil)
    (bound formal-const-decl "posnat" packrat_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" packrat_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" packrat_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil packrat_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (lex4_lt formula-decl nil lex4 nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (packrat_parser termination
    "packrat_parser.packrat_parser(packrat_parser.P_exp, packrat_parser.A, peg[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b].star(packrat_parser.e), packrat_parser.inp, pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].e(packrat_parser.T0), packrat_parser.s_T, packrat_parser.res0)"
    "nil")))
 (packrat_parser_TCC49 0
  (packrat_parser_TCC30-1 nil 3771945369
   ("" (skeep*) (("" (wf-ast T0) (("" (assert) nil nil)) nil)) nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil packrat_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" packrat_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" packrat_parser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" packrat_parser nil)
    (V_S formal-type-decl nil packrat_parser nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (subterm_of type-eq-decl nil peg nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (<= const-decl "bool" reals nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (below type-eq-decl nil naturalnumbers nil)
    (subterm adt-def-decl "boolean" peg nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (packrat_parser subtype "packrat_parser.T0"
    "{T: pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].pre_ast | (booleans.¬)(pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].skip?(T))}")))
 (packrat_parser_TCC50 0
  (packrat_parser_TCC69-1 nil 3772336765
   ("" (skeep*)
    (("" (typepred "Ts")
      (("" (typepred "parsing(P_exp, A, star(e), inp, e(T0), s_T)")
        (("" (replace -8 * RL)
          (("" (expand "trueToGrammar")
            (("" (lift-if) (("" (assert) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((subterm adt-def-decl "boolean" peg nil)
    (star adt-constructor-decl "[peg -> (star?)]" peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (<= const-decl "bool" reals nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (< const-decl "bool" reals nil)
    (subterm_of type-eq-decl nil peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil packrat_parser nil)
    (bound formal-const-decl "posnat" packrat_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" packrat_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" packrat_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil packrat_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (packrat_parser subtype "packrat_parser.Ts"
    "{T: pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].pre_ast | booleans.OR(pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].skip?(T), pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].star?(T))}")))
 (packrat_parser_TCC51 0
  (packrat_parser_TCC38-1 nil 3771945369
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (typepred "T0")
          (("" (typepred "Ts")
            (("" (replace -2 * RL)
              (("" (replace -1 * RL) (("" (assert) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((subterm adt-def-decl "boolean" peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (<= const-decl "bool" reals nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (< const-decl "bool" reals nil)
    (subterm_of type-eq-decl nil peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil packrat_parser nil)
    (bound formal-const-decl "posnat" packrat_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" packrat_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" packrat_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil packrat_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star adt-constructor-decl "[peg -> (star?)]" peg nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (packrat_parser subtype
    "pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].star(packrat_parser.s, pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].e(packrat_parser.Ts), packrat_parser.T0, packrat_parser.Ts)"
    "{T: pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].pre_ast | T = peg_parser[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].parsing(packrat_parser.P_exp, packrat_parser.A, packrat_parser.G, packrat_parser.inp, packrat_parser.s, packrat_parser.s_T)}")))
 (packrat_parser_TCC52 0
  (packrat_parser_TCC56-1 nil 3771945369
   ("" (skeep*)
    (("" (use "subterm_plus" (G "P_exp(A)")) (("" (assert) nil nil))
      nil))
    nil)
   ((subterm_plus formula-decl nil peg nil) (peg type-decl nil peg nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (below type-eq-decl nil naturalnumbers nil)
    (V_T formal-nonempty-type-decl nil packrat_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" packrat_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" packrat_parser nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (packrat_parser subtype "packrat_parser.e"
    "{e: wf_peg[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b].Δ | peg[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b].subterm(e, packrat_parser.P_exp(packrat_parser.A))}")))
 (packrat_parser_TCC53 0
  (packrat_parser_TCC57-1 nil 3771945369
   ("" (skeep*)
    (("" (typepred "s_T")
      (("" (expand "grammar_wellformedness" -) (("" (grind) nil nil))
        nil))
      nil))
    nil)
   ((below type-eq-decl nil naturalnumbers nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" packrat_parser nil)
    (<= formal-const-decl "(total_order?[V_T])" packrat_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil packrat_parser nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bound formal-const-decl "posnat" packrat_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (r const-decl "C(P_exp)" wf_peg nil)
    (array_sum const-decl "upto(3 * V_N_b)" array_sum nil)
    (nT_properties const-decl "F(P_exp)" wf_peg nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (packrat_parser subtype "packrat_parser.s_T"
    "{k: naturalnumbers.upto(packrat_parser.s) | booleans.⇒((k = packrat_parser.s), wf_peg[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b].pattern_wf?(packrat_parser.e, packrat_parser.A, static_analysis[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b].σ(packrat_parser.P_exp), wf_peg[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b].P_0c(packrat_parser.P_exp)))}")))
 (packrat_parser_TCC54 0
  (packrat_parser_TCC58-1 nil 3771945369
   ("" (skeep *)
    (("" (assert) (("" (replace -1 * LR) (("" (assert) nil nil)) nil))
      nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (lex4_lt formula-decl nil lex4 nil)
    (pegMeasure_plus formula-decl nil peg nil)
    (lex2_lt formula-decl nil lex2 nil)
    (lex3_lt formula-decl nil lex3 nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (packrat_parser termination
    "packrat_parser.packrat_parser(packrat_parser.P_exp, packrat_parser.A, packrat_parser.e, packrat_parser.inp, packrat_parser.s, packrat_parser.s_T, packrat_parser.res)"
    "nil")))
 (packrat_parser_TCC55 0
  (packrat_parser_TCC55-1 nil 3771945369
   ("" (skeep*) (("" (wf-ast T0) (("" (assert) nil nil)) nil)) nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil packrat_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" packrat_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" packrat_parser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" packrat_parser nil)
    (V_S formal-type-decl nil packrat_parser nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (subterm_of type-eq-decl nil peg nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (<= const-decl "bool" reals nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (below type-eq-decl nil naturalnumbers nil)
    (subterm adt-def-decl "boolean" peg nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (packrat_parser subtype "packrat_parser.T0"
    "{T: pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].pre_ast | (booleans.¬)(pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].skip?(T))}")))
 (packrat_parser_TCC56 0
  (packrat_parser_TCC43-1 nil 3771945369
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (typepred "T0")
          (("" (replace -1 * RL) (("" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((subterm adt-def-decl "boolean" peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (<= const-decl "bool" reals nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (< const-decl "bool" reals nil)
    (subterm_of type-eq-decl nil peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil packrat_parser nil)
    (bound formal-const-decl "posnat" packrat_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" packrat_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" packrat_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil packrat_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (packrat_parser subtype
    "pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].plus(packrat_parser.s, packrat_parser.s, packrat_parser.T0, pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].skip(pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].e(packrat_parser.T0), pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].e(packrat_parser.T0), peg[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b].plus(packrat_parser.e)))"
    "{T: pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].pre_ast | T = peg_parser[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].parsing(packrat_parser.P_exp, packrat_parser.A, packrat_parser.G, packrat_parser.inp, packrat_parser.s, packrat_parser.s_T)}")))
 (packrat_parser_TCC57 0
  (packrat_parser_TCC64-1 nil 3772336765
   ("" (skeep*)
    (("" (use "subterm_plus" (G "P_exp(A)")) (("" (assert) nil nil))
      nil))
    nil)
   ((subterm_plus formula-decl nil peg nil) (peg type-decl nil peg nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (below type-eq-decl nil naturalnumbers nil)
    (V_T formal-nonempty-type-decl nil packrat_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" packrat_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" packrat_parser nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus adt-constructor-decl "[peg -> (plus?)]" peg nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (packrat_parser subtype
    "peg[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b].plus(packrat_parser.e)"
    "{e: wf_peg[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b].Δ | peg[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b].subterm(e, packrat_parser.P_exp(packrat_parser.A))}")))
 (packrat_parser_TCC58 0
  (packrat_parser_TCC66-1 nil 3772336765
   ("" (skeep*)
    (("" (wf-ast T0)
      (("" (assert)
        (("" (flatten)
          (("" (assert)
            (("" (typepred "s_T")
              (("" (assert)
                (("" (replace -6 * LR)
                  (("" (assert)
                    (("" (typepred "parsing(P_exp, A, e, inp, s, s_T)")
                      (("" (assert)
                        (("" (flatten) (("" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil packrat_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" packrat_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" packrat_parser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" packrat_parser nil)
    (V_S formal-type-decl nil packrat_parser nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (subterm_of type-eq-decl nil peg nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (<= const-decl "bool" reals nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (below type-eq-decl nil naturalnumbers nil)
    (subterm adt-def-decl "boolean" peg nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (packrat_parser subtype "packrat_parser.s_T"
    "{k: naturalnumbers.upto(pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].e(packrat_parser.T0)) | booleans.⇒((k = pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].e(packrat_parser.T0)), wf_peg[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b].pattern_wf?(peg[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b].plus(packrat_parser.e), packrat_parser.A, static_analysis[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b].σ(packrat_parser.P_exp), wf_peg[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b].P_0c(packrat_parser.P_exp)))}")))
 (packrat_parser_TCC59 0
  (packrat_parser_TCC67-1 nil 3772336765
   ("" (skeep*)
    (("" (assert)
      (("" (assert)
        (("" (assert)
          (("" (flatten)
            (("" (use "plus_cannot_be_P_0")
              (("" (assert)
                (("" (typepred "parsing(P_exp, A, e, inp, s, s_T)")
                  (("1" (assert)
                    (("1" (wf-ast T0)
                      (("1" (assert)
                        (("1" (flatten) (("1" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil)
                   ("2" (typepred "s_T")
                    (("2" (assert)
                      (("2" (flatten)
                        (("2" (assert)
                          (("2" (replace -4 * LR)
                            (("2" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("3" (use "subterm_plus" (G "P_exp(A)"))
                    (("3" (assert) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (pegMeasure_plus formula-decl nil peg nil)
    (lex2_lt formula-decl nil lex2 nil)
    (lex3_lt formula-decl nil lex3 nil)
    (plus_cannot_be_P_0 formula-decl nil wf_peg nil)
    (V_T formal-nonempty-type-decl nil packrat_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" packrat_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" packrat_parser nil)
    (peg type-decl nil peg nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (below type-eq-decl nil naturalnumbers nil)
    (interp type-eq-decl nil wf_peg nil)
    (wf_nT? const-decl "bool" wf_peg nil)
    (wf_nT type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (subterm adt-def-decl "boolean" peg nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ast type-eq-decl nil ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (<= const-decl "bool" reals nil)
    (subterm_of type-eq-decl nil peg nil)
    (astWellformed? def-decl "bool" ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil packrat_parser nil)
    (bound formal-const-decl "posnat" packrat_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (subterm_plus formula-decl nil peg nil)
    (lex4_lt formula-decl nil lex4 nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (packrat_parser termination
    "packrat_parser.packrat_parser(packrat_parser.P_exp, packrat_parser.A, peg[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b].plus(packrat_parser.e), packrat_parser.inp, pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].e(packrat_parser.T0), packrat_parser.s_T, packrat_parser.res0)"
    "nil")))
 (packrat_parser_TCC60 0
  (packrat_parser_TCC60-1 nil 3771945369
   ("" (skeep*) (("" (wf-ast T0) (("" (assert) nil nil)) nil)) nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil packrat_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" packrat_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" packrat_parser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" packrat_parser nil)
    (V_S formal-type-decl nil packrat_parser nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (subterm_of type-eq-decl nil peg nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (<= const-decl "bool" reals nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (below type-eq-decl nil naturalnumbers nil)
    (subterm adt-def-decl "boolean" peg nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (packrat_parser subtype "packrat_parser.T0"
    "{T: pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].pre_ast | (booleans.¬)(pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].skip?(T))}")))
 (packrat_parser_TCC61 0
  (packrat_parser_TCC81-1 nil 3772336765
   ("" (skeep*)
    (("" (typepred "Ts")
      (("" (typepred "parsing(P_exp, A, plus(e), inp, e(T0), s_T)")
        (("" (replace -8 * RL)
          (("" (expand "trueToGrammar")
            (("" (lift-if) (("" (ground) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((subterm adt-def-decl "boolean" peg nil)
    (plus adt-constructor-decl "[peg -> (plus?)]" peg nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (<= const-decl "bool" reals nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (< const-decl "bool" reals nil)
    (subterm_of type-eq-decl nil peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil packrat_parser nil)
    (bound formal-const-decl "posnat" packrat_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" packrat_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" packrat_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil packrat_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (packrat_parser subtype "packrat_parser.Ts"
    "{T: pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].pre_ast | booleans.OR(pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].skip?(T), booleans.OR(pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].plus?(T), pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].fail?(T)))}")))
 (packrat_parser_TCC62 0
  (packrat_parser_TCC48-1 nil 3771945369
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (typepred "T0")
          (("" (typepred "Ts")
            (("" (replace -2 * RL)
              (("" (replace -1 * RL) (("" (assert) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((subterm adt-def-decl "boolean" peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (<= const-decl "bool" reals nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (< const-decl "bool" reals nil)
    (subterm_of type-eq-decl nil peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil packrat_parser nil)
    (bound formal-const-decl "posnat" packrat_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" packrat_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" packrat_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil packrat_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus adt-constructor-decl "[peg -> (plus?)]" peg nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (packrat_parser subtype
    "pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].plus(packrat_parser.s, pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].e(packrat_parser.Ts), packrat_parser.T0, packrat_parser.Ts)"
    "{T: pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].pre_ast | T = peg_parser[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].parsing(packrat_parser.P_exp, packrat_parser.A, packrat_parser.G, packrat_parser.inp, packrat_parser.s, packrat_parser.s_T)}")))
 (packrat_parser_TCC63 0
  (packrat_parser_TCC70-1 nil 3772336765
   ("" (skeep*)
    (("" (use "subterm_opt" (G "P_exp(A)")) (("" (assert) nil nil))
      nil))
    nil)
   ((subterm_opt formula-decl nil peg nil) (peg type-decl nil peg nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (below type-eq-decl nil naturalnumbers nil)
    (V_T formal-nonempty-type-decl nil packrat_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" packrat_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" packrat_parser nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (packrat_parser subtype "packrat_parser.e"
    "{e: wf_peg[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b].Δ | peg[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b].subterm(e, packrat_parser.P_exp(packrat_parser.A))}")))
 (packrat_parser_TCC64 0
  (packrat_parser_TCC71-1 nil 3772336765
   ("" (skeep*)
    (("" (typepred "s_T")
      (("" (assert)
        (("" (replace -3 * LR) (("" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" packrat_parser nil)
    (<= formal-const-decl "(total_order?[V_T])" packrat_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil packrat_parser nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bound formal-const-decl "posnat" packrat_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (packrat_parser subtype "packrat_parser.s_T"
    "{k: naturalnumbers.upto(packrat_parser.s) | booleans.⇒((k = packrat_parser.s), wf_peg[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b].pattern_wf?(packrat_parser.e, packrat_parser.A, static_analysis[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b].σ(packrat_parser.P_exp), wf_peg[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b].P_0c(packrat_parser.P_exp)))}")))
 (packrat_parser_TCC65 0
  (packrat_parser_TCC72-1 nil 3772336765
   ("" (skeep*)
    (("" (assert)
      (("" (assert)
        (("" (replace -1 * LR) (("" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (lex4_lt formula-decl nil lex4 nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (pegMeasure_opt formula-decl nil peg nil)
    (lex3_lt formula-decl nil lex3 nil)
    (lex2_lt formula-decl nil lex2 nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (packrat_parser termination
    "packrat_parser.packrat_parser(packrat_parser.P_exp, packrat_parser.A, packrat_parser.e, packrat_parser.inp, packrat_parser.s, packrat_parser.s_T, packrat_parser.res)"
    "nil")))
 (packrat_parser_TCC66 0
  (packrat_parser_TCC57-1 nil 3771947610
   ("" (skeep*) (("" (wf-ast T!1) (("" (assert) nil nil)) nil)) nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil packrat_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" packrat_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" packrat_parser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" packrat_parser nil)
    (V_S formal-type-decl nil packrat_parser nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (subterm_of type-eq-decl nil peg nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (<= const-decl "bool" reals nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (below type-eq-decl nil naturalnumbers nil)
    (subterm adt-def-decl "boolean" peg nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (packrat_parser subtype "packrat_parser.T"
    "{T: pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].pre_ast | (booleans.¬)(pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].skip?(T))}")))
 (packrat_parser_TCC67 0
  (packrat_parser_TCC54-1 nil 3771945369
   ("" (skeep*) (("" (replace -1 * LR) (("" (assert) nil nil)) nil))
    nil)
   ((V_S formal-type-decl nil packrat_parser nil)
    (bound formal-const-decl "posnat" packrat_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" packrat_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" packrat_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil packrat_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (packrat_parser subtype
    "pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].opt(packrat_parser.s, packrat_parser.s, packrat_parser.T)"
    "{T: pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].pre_ast | T = peg_parser[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].parsing(packrat_parser.P_exp, packrat_parser.A, packrat_parser.G, packrat_parser.inp, packrat_parser.s, packrat_parser.s_T)}")))
 (packrat_parser_TCC68 0
  (packrat_parser_TCC63-1 nil 3771947610
   ("" (skeep*) (("" (wf-ast T!1) (("" (assert) nil nil)) nil)) nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil packrat_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" packrat_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" packrat_parser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" packrat_parser nil)
    (V_S formal-type-decl nil packrat_parser nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (subterm_of type-eq-decl nil peg nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (<= const-decl "bool" reals nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (below type-eq-decl nil naturalnumbers nil)
    (subterm adt-def-decl "boolean" peg nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (packrat_parser subtype "packrat_parser.T"
    "{T: pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].pre_ast | (booleans.¬)(pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].skip?(T))}")))
 (packrat_parser_TCC69 0
  (packrat_parser_TCC51-1 nil 3771945369
   ("" (skeep*) (("" (replaces) (("" (assert) nil nil)) nil)) nil)
   ((V_S formal-type-decl nil packrat_parser nil)
    (bound formal-const-decl "posnat" packrat_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" packrat_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" packrat_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil packrat_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (packrat_parser subtype
    "pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].opt(packrat_parser.s, pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].e(packrat_parser.T), packrat_parser.T)"
    "{T: pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].pre_ast | T = peg_parser[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].parsing(packrat_parser.P_exp, packrat_parser.A, packrat_parser.G, packrat_parser.inp, packrat_parser.s, packrat_parser.s_T)}")))
 (packrat_parser_TCC70 0
  (packrat_parser_TCC77-1 nil 3772336765
   ("" (skeep*)
    (("" (use "subterm_notP" (G "P_exp(A)")) (("" (assert) nil nil))
      nil))
    nil)
   ((subterm_notP formula-decl nil peg nil) (peg type-decl nil peg nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (below type-eq-decl nil naturalnumbers nil)
    (V_T formal-nonempty-type-decl nil packrat_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" packrat_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" packrat_parser nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (packrat_parser subtype "packrat_parser.e"
    "{e: wf_peg[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b].Δ | peg[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b].subterm(e, packrat_parser.P_exp(packrat_parser.A))}")))
 (packrat_parser_TCC71 0
  (packrat_parser_TCC78-1 nil 3772336765
   ("" (skeep*)
    (("" (typepred "s_T")
      (("" (assert)
        (("" (replace -3 * LR) (("" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" packrat_parser nil)
    (<= formal-const-decl "(total_order?[V_T])" packrat_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil packrat_parser nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bound formal-const-decl "posnat" packrat_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (packrat_parser subtype "packrat_parser.s_T"
    "{k: naturalnumbers.upto(packrat_parser.s) | booleans.⇒((k = packrat_parser.s), wf_peg[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b].pattern_wf?(packrat_parser.e, packrat_parser.A, static_analysis[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b].σ(packrat_parser.P_exp), wf_peg[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b].P_0c(packrat_parser.P_exp)))}")))
 (packrat_parser_TCC72 0
  (packrat_parser_TCC79-1 nil 3772336765
   ("" (skeep*)
    (("" (assert)
      (("" (assert)
        (("" (replace -1 * LR) (("" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (lex4_lt formula-decl nil lex4 nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (pegMeasure_notP formula-decl nil peg nil)
    (lex3_lt formula-decl nil lex3 nil)
    (lex2_lt formula-decl nil lex2 nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (packrat_parser termination
    "packrat_parser.packrat_parser(packrat_parser.P_exp, packrat_parser.A, packrat_parser.e, packrat_parser.inp, packrat_parser.s, packrat_parser.s_T, packrat_parser.res)"
    "nil")))
 (packrat_parser_TCC73 0
  (packrat_parser_TCC59-1 nil 3771945369
   ("" (skeep*) (("" (wf-ast T!1) (("" (assert) nil nil)) nil)) nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil packrat_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" packrat_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" packrat_parser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" packrat_parser nil)
    (V_S formal-type-decl nil packrat_parser nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (subterm_of type-eq-decl nil peg nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (<= const-decl "bool" reals nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (below type-eq-decl nil naturalnumbers nil)
    (subterm adt-def-decl "boolean" peg nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (packrat_parser subtype "packrat_parser.T"
    "{T: pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].pre_ast | (booleans.¬)(pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].skip?(T))}")))
 (packrat_parser_TCC74 0
  (packrat_parser_TCC74-1 nil 3772336765
   ("" (skeep*) (("" (replace -1 * LR) (("" (assert) nil nil)) nil))
    nil)
   ((V_S formal-type-decl nil packrat_parser nil)
    (bound formal-const-decl "posnat" packrat_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" packrat_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" packrat_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil packrat_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (packrat_parser subtype
    "pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].notP(packrat_parser.s, packrat_parser.s, packrat_parser.T)"
    "{T: pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].pre_ast | T = peg_parser[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].parsing(packrat_parser.P_exp, packrat_parser.A, packrat_parser.G, packrat_parser.inp, packrat_parser.s, packrat_parser.s_T)}")))
 (packrat_parser_TCC75 0
  (packrat_parser_TCC82-1 nil 3772336765
   ("" (skeep*)
    (("" (use "subterm_andP" (G "P_exp(A)")) (("" (assert) nil nil))
      nil))
    nil)
   ((subterm_andP formula-decl nil peg nil) (peg type-decl nil peg nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (below type-eq-decl nil naturalnumbers nil)
    (V_T formal-nonempty-type-decl nil packrat_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" packrat_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" packrat_parser nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (packrat_parser subtype "packrat_parser.e"
    "{e: wf_peg[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b].Δ | peg[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b].subterm(e, packrat_parser.P_exp(packrat_parser.A))}")))
 (packrat_parser_TCC76 0
  (packrat_parser_TCC83-1 nil 3772336765
   ("" (skeep*)
    (("" (typepred "s_T")
      (("" (replace -3 * LR) (("" (assert) nil nil)) nil)) nil))
    nil)
   ((P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" packrat_parser nil)
    (<= formal-const-decl "(total_order?[V_T])" packrat_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil packrat_parser nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bound formal-const-decl "posnat" packrat_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (packrat_parser subtype "packrat_parser.s_T"
    "{k: naturalnumbers.upto(packrat_parser.s) | booleans.⇒((k = packrat_parser.s), wf_peg[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b].pattern_wf?(packrat_parser.e, packrat_parser.A, static_analysis[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b].σ(packrat_parser.P_exp), wf_peg[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b].P_0c(packrat_parser.P_exp)))}")))
 (packrat_parser_TCC77 0
  (packrat_parser_TCC84-1 nil 3772336765
   ("" (skeep*)
    (("" (assert)
      (("" (assert)
        (("" (replace -1 * LR) (("" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (lex4_lt formula-decl nil lex4 nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (pegMeasure_andP formula-decl nil peg nil)
    (lex3_lt formula-decl nil lex3 nil)
    (lex2_lt formula-decl nil lex2 nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (packrat_parser termination
    "packrat_parser.packrat_parser(packrat_parser.P_exp, packrat_parser.A, packrat_parser.e, packrat_parser.inp, packrat_parser.s, packrat_parser.s_T, packrat_parser.res)"
    "nil")))
 (packrat_parser_TCC78 0
  (packrat_parser_TCC58-1 nil 3771947610
   ("" (skeep*) (("" (wf-ast T!1) (("" (assert) nil nil)) nil)) nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil packrat_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" packrat_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" packrat_parser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" packrat_parser nil)
    (V_S formal-type-decl nil packrat_parser nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (subterm_of type-eq-decl nil peg nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (<= const-decl "bool" reals nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (below type-eq-decl nil naturalnumbers nil)
    (subterm adt-def-decl "boolean" peg nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (packrat_parser subtype "packrat_parser.T"
    "{T: pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].pre_ast | (booleans.¬)(pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].skip?(T))}")))
 (packrat_parser_TCC79 0
  (packrat_parser_TCC76-1 nil 3772336765
   ("" (skeep*) (("" (replace -1 * LR) (("" (assert) nil nil)) nil))
    nil)
   ((V_S formal-type-decl nil packrat_parser nil)
    (bound formal-const-decl "posnat" packrat_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" packrat_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" packrat_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil packrat_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (packrat_parser subtype
    "pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].andP(packrat_parser.s, packrat_parser.s, packrat_parser.T)"
    "{T: pre_ast[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].pre_ast | T = peg_parser[packrat_parser.V_T, packrat_parser.<=, packrat_parser.V_N_b, packrat_parser.bound, packrat_parser.V_S].parsing(packrat_parser.P_exp, packrat_parser.A, packrat_parser.G, packrat_parser.inp, packrat_parser.s, packrat_parser.s_T)}"))))

