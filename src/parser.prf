(peg_parser
 (parsing_TCC1 0
  (parsing_TCC1-1 nil 3769177011 ("" (subtype-tcc) nil nil)
   ((int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (parsing subtype
    "(number_fields.-)(peg_parser.bound, peg_parser.s_T)" "nat")))
 (parsing_TCC2 0
  (parsing_TCC38-1 nil 3768836598
   ("" (skeep) (("" (typepred "s") (("" (assert) nil nil)) nil)) nil)
   ((inp_bound type-eq-decl nil ast_props nil)
    (V_S formal-type-decl nil peg_parser nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (parsing subtype "(number_fields.-)(peg_parser.bound, peg_parser.s)"
    "nat")))
 (parsing_TCC3 0
  (parsing_TCC4-1 nil 3769177011
   ("" (skeep)
    (("" (typepred "z`5")
      (("" (typepred "z`6") (("" (assert) nil nil)) nil)) nil))
    nil)
   ((strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (V_S formal-type-decl nil peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (parsing subtype
    "(number_fields.-)(peg_parser.bound, peg_parser.z`6)" "nat")))
 (parsing_TCC4 0
  (parsing_TCC40-1 nil 3768836598
   ("" (skeep)
    (("" (typepred "z`5")
      (("" (typepred "z`6") (("" (assert) nil nil)) nil)) nil))
    nil)
   ((strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (V_S formal-type-decl nil peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (parsing subtype
    "(number_fields.-)(peg_parser.bound, peg_parser.z`5)" "nat")))
 (parsing_TCC5 0
  (parsing_TCC52-1 nil 3768836598
   ("" (skeep *) (("" (typepred "s") (("" (assert) nil nil)) nil)) nil)
   ((inp_bound type-eq-decl nil ast_props nil)
    (V_S formal-type-decl nil peg_parser nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (parsing subtype "(number_fields.-)(peg_parser.bound, peg_parser.s)"
    "nat")))
 (parsing_TCC6 0
  (parsing_TCC5-1 nil 3768836598
   ("" (skeep*) (("" (grind) nil nil)) nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (V_S formal-type-decl nil peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (astType? def-decl "astType" ast nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (r const-decl "C(P_exp)" wf_peg nil)
    (array_sum const-decl "upto(3 * V_N_b)" array_sum nil)
    (nT_properties const-decl "F(P_exp)" wf_peg nil)
    (g_props def-decl "[bool, bool, bool]" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (astMeaningful? const-decl "bool" ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (parsing subtype
    "pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].ε(peg_parser.s, peg_parser.s)"
    "peg_parser.output(peg_parser.P_exp, peg_parser.A, peg_parser.G, peg_parser.inp, peg_parser.s, peg_parser.s_T)")))
 (parsing_TCC7 0
  (parsing_TCC15-1 nil 3768836598
   ("" (skeep)
    (("" (assert)
      (("" (expand "astWellformed?")
        (("" (expand "trueToGrammar")
          (("" (expand "trueToInput")
            (("" (expand "astMeaningful?") (("" (grind) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_min application-judgement "{k: posint | k <= i AND k <= j}"
     real_defs nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (astMeaningful? const-decl "bool" ast nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (g_props def-decl "[bool, bool, bool]" wf_peg nil)
    (nT_properties const-decl "F(P_exp)" wf_peg nil)
    (array_sum const-decl "upto(3 * V_N_b)" array_sum nil)
    (r const-decl "C(P_exp)" wf_peg nil)
    (astType? def-decl "astType" ast nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (V_S formal-type-decl nil peg_parser nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (trueToInput def-decl "bool" ast_props nil)
    (astWellformed? def-decl "bool" ast nil))
   nil
   (parsing subtype
    "pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].any(peg_parser.s, real_defs.min((number_fields.+)(peg_parser.s, 1), peg_parser.bound), peg_parser.inp(peg_parser.s))"
    "peg_parser.output(peg_parser.P_exp, peg_parser.A, peg_parser.G, peg_parser.inp, peg_parser.s, peg_parser.s_T)")))
 (parsing_TCC8 0
  (parsing_TCC17-1 nil 3768836598
   ("" (skeep) (("" (assert) (("" (grind) nil nil)) nil)) nil)
   ((nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_min application-judgement "{k: posint | k <= i AND k <= j}"
     real_defs nil)
    (astWellformed? def-decl "bool" ast nil)
    (astMeaningful? const-decl "bool" ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (/= const-decl "boolean" notequal nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (g_props def-decl "[bool, bool, bool]" wf_peg nil)
    (nT_properties const-decl "F(P_exp)" wf_peg nil)
    (array_sum const-decl "upto(3 * V_N_b)" array_sum nil)
    (r const-decl "C(P_exp)" wf_peg nil)
    (astType? def-decl "astType" ast nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (V_S formal-type-decl nil peg_parser nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (parsing subtype
    "pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].terminal(peg_parser.s, real_defs.min((number_fields.+)(peg_parser.s, 1), peg_parser.bound), peg_parser.a, peg_parser.inp(peg_parser.s))"
    "peg_parser.output(peg_parser.P_exp, peg_parser.A, peg_parser.G, peg_parser.inp, peg_parser.s, peg_parser.s_T)")))
 (parsing_TCC9 0
  (parsing_TCC9-1 nil 3768836598
   ("" (skeep)
    (("" (typepred "b")
      (("" (expand "min") (("" (grind) nil nil)) nil)) nil))
    nil)
   ((min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (astWellformed? def-decl "bool" ast nil)
    (astMeaningful? const-decl "bool" ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (astType? def-decl "astType" ast nil)
    (in_range const-decl "bool" ast nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (V_S formal-type-decl nil peg_parser nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (g_props def-decl "[bool, bool, bool]" wf_peg nil)
    (nT_properties const-decl "F(P_exp)" wf_peg nil)
    (array_sum const-decl "upto(3 * V_N_b)" array_sum nil)
    (r const-decl "C(P_exp)" wf_peg nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (parsing subtype
    "pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].range(peg_parser.s, real_defs.min((number_fields.+)(peg_parser.s, 1), peg_parser.bound), peg_parser.a, peg_parser.b, peg_parser.inp(peg_parser.s))"
    "peg_parser.output(peg_parser.P_exp, peg_parser.A, peg_parser.G, peg_parser.inp, peg_parser.s, peg_parser.s_T)")))
 (parsing_TCC10 0
  (parsing_TCC14-1 nil 3768836598
   ("" (skeep)
    (("" (typepred "G") (("" (ground) (("" (grind) nil nil)) nil))
      nil))
    nil)
   ((below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (parsing subtype "peg_parser.P_exp(peg_parser.B)"
    "{e: wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].Δ | peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].subterm(e, peg_parser.P_exp(peg_parser.B))}")))
 (parsing_TCC11 0
  (parsing_TCC29-1 nil 3771853966 ("" (subtype-tcc) nil nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil) (peg type-decl nil peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (subterm adt-def-decl "boolean" peg nil)
    (<= const-decl "bool" reals nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (V_S formal-type-decl nil peg_parser nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (strong const-decl "bool" wf_peg nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (parsing subtype "peg_parser.s"
    "{k: naturalnumbers.upto(peg_parser.s) | booleans.⇒((k = peg_parser.s), wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].g_wf(peg_parser.P_exp(peg_parser.B), peg_parser.B, wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].P_0c?(peg_parser.P_exp), wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].strong))}")))
 (parsing_TCC12 0
  (parsing_TCC16-1 nil 3768836598
   ("" (skeep)
    (("" (rewrites ("lex4_lt" "lex3_lt" "lex2_lt"))
      (("" (assert)
        (("" (flatten)
          (("" (assert)
            (("" (flatten)
              (("" (assert)
                (("" (typepred "s_T")
                  (("" (assert)
                    (("" (expand "g_wf")
                      (("" (replaces)
                        (("" (assert)
                          (("" (expand "strong")
                            (("" (propax) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (pegMeasure const-decl "nat" peg nil) (peg type-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (V_S formal-type-decl nil peg_parser nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (<= const-decl "bool" reals nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (lex4_lt formula-decl nil lex4 nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (lex3_lt formula-decl nil lex3 nil)
    (lex2_lt formula-decl nil lex2 nil)
    (TRUE const-decl "bool" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_times_int_is_int application-judgement "int" integers nil))
   nil
   (parsing termination
    "peg_parser.parsing(peg_parser.P_exp, peg_parser.B, peg_parser.P_exp(peg_parser.B), peg_parser.inp, peg_parser.s, peg_parser.s)"
    "nil")))
 (parsing_TCC13 0
  (parsing_TCC26-1 nil 3771853966
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (assert)
        (("" (expand "astWellformed?")
          (("" (typepred "nT_properties(P_exp)")
            (("" (lemma "fix_point_theorem")
              (("" (inst -1 "P_exp" "nT_properties(P_exp)" "B")
                (("" (typepred "T_B")
                  (("" (expand "P_0c?")
                    (("" (expand "P_sc?")
                      (("" (expand "P_fc?")
                        (("" (expand "g_props" +)
                          (("" (use "Wellformed_theorem")
                            (("" (assert)
                              ((""
                                (flatten)
                                ((""
                                  (expand "astType?" +)
                                  ((""
                                    (expand "ρ")
                                    ((""
                                      (assert)
                                      ((""
                                        (assert)
                                        ((""
                                          (split 2)
                                          (("1"
                                            (expand "trueToGrammar")
                                            (("1" (propax) nil nil))
                                            nil)
                                           ("2"
                                            (expand "trueToInput")
                                            (("2" (propax) nil nil))
                                            nil)
                                           ("3"
                                            (flatten)
                                            (("3"
                                              (assert)
                                              (("3"
                                                (assert)
                                                (("3"
                                                  (replace -14 * LR)
                                                  (("3"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("4"
                                            (flatten)
                                            (("4"
                                              (replace -14 1 LR)
                                              (("4" (assert) nil nil))
                                              nil))
                                            nil)
                                           ("5"
                                            (flatten)
                                            (("5"
                                              (replace -13 1 LR)
                                              (("5" (assert) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astWellformed? def-decl "bool" ast nil)
    (fix_point_theorem formula-decl nil wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ast type-eq-decl nil ast nil) (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (g_props def-decl "[bool, bool, bool]" wf_peg nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ρ const-decl "C(P_exp)" wf_peg nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (below type-eq-decl nil naturalnumbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (peg type-decl nil peg nil) (interp type-eq-decl nil wf_peg nil)
    (nTpred type-eq-decl nil nTpred_order nil)
    (nTprop type-eq-decl nil nTpred_order nil)
    (coherent_properties const-decl "bool" wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (WF_nT type-eq-decl nil wf_peg nil) (C type-eq-decl nil wf_peg nil)
    (fix_point const-decl "bool" wf_peg nil)
    (F type-eq-decl nil wf_peg nil)
    (nT_properties const-decl "F(P_exp)" wf_peg nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (parsing subtype
    "pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].nonTerminal(peg_parser.s, pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].e(peg_parser.T_B), peg_parser.B, peg_parser.T_B)"
    "peg_parser.output(peg_parser.P_exp, peg_parser.A, peg_parser.G, peg_parser.inp, peg_parser.s, peg_parser.s_T)")))
 (parsing_TCC14 0
  (parsing_TCC19-1 nil 3768836598
   ("" (skeep)
    (("" (lemma "peg[V_T, <=, V_N_b].subterm_transitivity")
      (("" (inst -1 "e1" "G" "P_exp(A)")
        (("" (typepred "G")
          (("" (assert)
            (("" (expand "subterm" 1)
              (("" (flatten)
                (("" (case "e1(G) = e1")
                  (("1" (replace -1 * LR)
                    (("1" (assert) (("1" (grind) nil nil)) nil)) nil)
                   ("2" (replace -2 * LR) (("2" (assert) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((V_N_b formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (subterm_transitivity formula-decl nil peg nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (e1 shared-adt-accessor-decl
     "[{x: peg | seq?(x) OR prior?(x)} -> peg]" peg nil)
    (prior? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (seq? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil))
   nil
   (parsing subtype "peg_parser.e1"
    "{e: wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].Δ | peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].subterm(e, peg_parser.P_exp(peg_parser.A))}")))
 (parsing_TCC15 0
  (parsing_TCC20-1 nil 3768836598
   ("" (skeep)
    (("" (typepred "s_T")
      (("" (assert)
        (("" (hide -1)
          (("" (expand "g_wf" -1)
            (("" (flatten)
              (("" (case-replace "e1(G) = e1")
                (("" (replace -3 * LR) (("" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (V_S formal-type-decl nil peg_parser nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (seq? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (prior? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (e1 shared-adt-accessor-decl
     "[{x: peg | seq?(x) OR prior?(x)} -> peg]" peg nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (parsing subtype "peg_parser.s_T"
    "{k: naturalnumbers.upto(peg_parser.s) | booleans.⇒((k = peg_parser.s), wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].g_wf(peg_parser.e1, peg_parser.A, wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].P_0c?(peg_parser.P_exp), wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].strong))}")))
 (parsing_TCC16 0
  (parsing_TCC21-1 nil 3768836598
   ("" (skeep)
    (("" (rewrite "lex4_lt")
      (("" (rewrite "lex3_lt")
        (("" (rewrite "lex2_lt") (("" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (lex4_lt formula-decl nil lex4 nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (<= const-decl "bool" reals nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (V_S formal-type-decl nil peg_parser nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (peg type-decl nil peg nil) (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (g_wf def-decl "bool" wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (pegMeasure const-decl "nat" peg nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lex2_lt formula-decl nil lex2 nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (sum const-decl "nat" peg nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (lex3_lt formula-decl nil lex3 nil))
   nil
   (parsing termination
    "peg_parser.parsing(peg_parser.P_exp, peg_parser.A, peg_parser.e1, peg_parser.inp, peg_parser.s, peg_parser.s_T)"
    "nil")))
 (parsing_TCC17 0
  (parsing_TCC30-1 nil 3771853966
   ("" (skeep*)
    (("" (assert)
      (("" (expand "astWellformed?")
        (("" (expand "astWellformed?")
          (("" (typepred "T1")
            (("" (expand "P_0c?")
              (("" (expand "P_sc?")
                (("" (expand "P_fc?")
                  (("" (expand "g_props" +)
                    (("" (expand "astType?" +)
                      (("" (replace -10 * LR)
                        (("" (assert)
                          (("" (expand "parseTree?")
                            (("" (skeep)
                              ((""
                                (inst -1 "T'")
                                ((""
                                  (expand "subterm" -11)
                                  ((""
                                    (assert)
                                    (("" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((r const-decl "C(P_exp)" wf_peg nil)
    (array_sum const-decl "upto(3 * V_N_b)" array_sum nil)
    (nT_properties const-decl "F(P_exp)" wf_peg nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (g_props def-decl "[bool, bool, bool]" wf_peg nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (V_S formal-type-decl nil peg_parser nil)
    (pre_ast type-decl nil pre_ast nil) (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (peg type-decl nil peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (below type-eq-decl nil naturalnumbers nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (g_wf def-decl "bool" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (astWellformed? def-decl "bool" ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (parsing subtype
    "pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].seq(peg_parser.s, pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].e(peg_parser.T1), peg_parser.T1, pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].skip(pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].e(peg_parser.T1), pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].e(peg_parser.T1), peg_parser.e2))"
    "peg_parser.output(peg_parser.P_exp, peg_parser.A, peg_parser.G, peg_parser.inp, peg_parser.s, peg_parser.s_T)")))
 (parsing_TCC18 0
  (parsing_TCC25-1 nil 3768836598
   ("" (skeep)
    (("" (skeep)
      (("" (typepred "G")
        (("" (lemma "peg[V_T, <=, V_N_b].subterm_transitivity")
          (("" (inst -1 "e2" "G" "P_exp(A)") (("" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (subterm_transitivity formula-decl nil peg nil))
   nil
   (parsing subtype "peg_parser.e2"
    "{e: wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].Δ | peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].subterm(e, peg_parser.P_exp(peg_parser.A))}")))
 (parsing_TCC19 0
  (parsing_TCC24-1 nil 3769177011
   ("" (skeep)
    (("" (skeep)
      (("" (typepred "s_T")
        (("" (lemma "Consumption_growth")
          (("" (inst -1 "T1")
            (("" (typepred T1)
              (("" (assert)
                (("" (flatten)
                  (("" (case "s_T = s")
                    (("1" (assert)
                      (("1" (lemma "Wellformedness_is_meaningfulness")
                        (("1" (inst -1 "T1")
                          (("1" (assert)
                            (("1" (expand "astMeaningful?")
                              (("1"
                                (assert)
                                (("1"
                                  (case-replace "e1(G) = e1")
                                  (("1"
                                    (assert)
                                    (("1"
                                      (case-replace "e2(G) = e2")
                                      (("1" (grind) nil nil)
                                       ("2" (grind) nil nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (case "s > s_T")
                                    (("1" (grind) nil nil)
                                     ("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (grind) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (V_S formal-type-decl nil peg_parser nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (pre_ast type-decl nil pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (Wellformedness_is_meaningfulness formula-decl nil ast nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (g_props def-decl "[bool, bool, bool]" wf_peg nil)
    (nT_properties const-decl "F(P_exp)" wf_peg nil)
    (array_sum const-decl "upto(3 * V_N_b)" array_sum nil)
    (r const-decl "C(P_exp)" wf_peg nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (e2 shared-adt-accessor-decl
     "[{x: peg | seq?(x) OR prior?(x)} -> peg]" peg nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (seq? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (prior? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (e1 shared-adt-accessor-decl
     "[{x: peg | seq?(x) OR prior?(x)} -> peg]" peg nil)
    (astMeaningful? const-decl "bool" ast nil)
    (Consumption_growth formula-decl nil ast nil))
   nil
   (parsing subtype "peg_parser.s_T"
    "{k: naturalnumbers.upto(pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].e(peg_parser.T1)) | booleans.⇒((k = pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].e(peg_parser.T1)), wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].g_wf(peg_parser.e2, peg_parser.A, wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].P_0c?(peg_parser.P_exp), wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].strong))}")))
 (parsing_TCC20 0
  (parsing_TCC27-1 nil 3768836598
   ("" (skeep*)
    (("" (rewrites ("lex4_lt" "lex3_lt" "lex2_lt"))
      (("" (flatten)
        (("" (assert)
          (("" (lemma "Wellformed_theorem" (T T1))
            (("" (assert)
              (("" (flatten)
                (("" (assert)
                  (("" (replace -3 * LR)
                    (("" (expand "pegMeasure")
                      (("" (expand "reduce_nat" 3 2)
                        (("" (assert)
                          (("" (expand "sum" 3 3)
                            (("" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (pegMeasure const-decl "nat" peg nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (V_S formal-type-decl nil peg_parser nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (<= const-decl "bool" reals nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (lex4_lt formula-decl nil lex4 nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (lex3_lt formula-decl nil lex3 nil)
    (lex2_lt formula-decl nil lex2 nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (sum const-decl "nat" peg nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (parsing termination
    "peg_parser.parsing(peg_parser.P_exp, peg_parser.A, peg_parser.e2, peg_parser.inp, pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].e(peg_parser.T1), peg_parser.s_T)"
    "nil")))
 (parsing_TCC21 0
  (parsing_TCC40-1 nil 3771853966
   ("" (skeep*)
    (("" (assert)
      (("" (replace -1 * LR)
        (("" (expand "astWellformed?")
          (("" (expand "trueToGrammar")
            (("" (expand "trueToInput")
              (("" (typepred "T1")
                (("" (lemma "Wellformed_theorem")
                  (("" (inst -1 "T1")
                    (("" (typepred "T2")
                      (("" (lemma "Wellformed_theorem")
                        (("" (inst -1 "T2")
                          (("" (assert)
                            (("" (flatten)
                              ((""
                                (expand "P_0c?")
                                ((""
                                  (expand "P_sc?")
                                  ((""
                                    (expand "P_fc?")
                                    ((""
                                      (expand "g_props" +)
                                      ((""
                                        (assert)
                                        ((""
                                          (expand "astType?" 4)
                                          ((""
                                            (assert)
                                            ((""
                                              (split -2)
                                              (("1"
                                                (assert)
                                                (("1"
                                                  (flatten)
                                                  (("1"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (assert)
                                                (("2"
                                                  (split 4)
                                                  (("1"
                                                    (flatten)
                                                    (("1"
                                                      (assert)
                                                      (("1"
                                                        (assert)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (flatten)
                                                    (("2"
                                                      (assert)
                                                      (("2"
                                                        (split 1)
                                                        (("1"
                                                          (assert)
                                                          (("1"
                                                            (assert)
                                                            (("1"
                                                              (split 2)
                                                              (("1"
                                                                (propax)
                                                                nil
                                                                nil)
                                                               ("2"
                                                                (propax)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("2"
                                                          (flatten)
                                                          (("2"
                                                            (assert)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astWellformed? def-decl "bool" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (g_props def-decl "[bool, bool, bool]" wf_peg nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (V_S formal-type-decl nil peg_parser nil)
    (pre_ast type-decl nil pre_ast nil) (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (peg type-decl nil peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (input type-eq-decl nil ast_props nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (below type-eq-decl nil naturalnumbers nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (g_wf def-decl "bool" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (parsing subtype
    "pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].seq(peg_parser.s, pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].e(peg_parser.T2), peg_parser.T1, peg_parser.T2)"
    "peg_parser.output(peg_parser.P_exp, peg_parser.A, peg_parser.G, peg_parser.inp, peg_parser.s, peg_parser.s_T)")))
 (parsing_TCC22 0
  (parsing_TCC31-1 nil 3768836598
   ("" (skeep)
    (("" (lemma "peg[V_T, <=, V_N_b].subterm_transitivity")
      (("" (inst -1 "e1" "G" "P_exp(A)")
        (("" (typepred "G")
          (("" (assert)
            (("" (replace -2 * LR)
              (("" (expand "subterm")
                (("" (expand "subterm") (("" (propax) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((V_N_b formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (subterm_transitivity formula-decl nil peg nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil))
   nil
   (parsing subtype "peg_parser.e1"
    "{e: wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].Δ | peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].subterm(e, peg_parser.P_exp(peg_parser.A))}")))
 (parsing_TCC23 0
  (parsing_TCC31-1 "" 3769982378
   ("" (skeep)
    (("" (typepred "s_T")
      (("" (expand "g_wf" -2)
        (("" (assert)
          (("" (flatten)
            (("" (case-replace "e1(G) = e1")
              (("" (replace -4 * LR) (("" (assert) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (V_S formal-type-decl nil peg_parser nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (e1 shared-adt-accessor-decl
     "[{x: peg | seq?(x) OR prior?(x)} -> peg]" peg nil)
    (prior? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (seq? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil))
   shostak
   (parsing subtype "peg_parser.s_T"
    "{k: naturalnumbers.upto(peg_parser.s) | booleans.⇒((k = peg_parser.s), wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].g_wf(peg_parser.e1, peg_parser.A, wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].P_0c?(peg_parser.P_exp), wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].strong))}"))
  (parsing_TCC46-1 nil 3768836598
   ("" (skeep)
    (("" (typepred "G")
      (("" (typepred "P_exp")
        (("" (expand "WF?")
          (("" (inst -1 "A" "G")
            (("" (assert)
              (("" (expand "grammar_wellformedness")
                (("" (flatten)
                  (("" (typepred "P_exp")
                    (("" (expand "WF?")
                      (("" (inst -1 "A" "e")
                        (("" (case "subterm(e, P_exp(A))")
                          (("1" (assert)
                            (("1" (name "B" "A(e)")
                              (("1"
                                (replace -1 * LR)
                                (("1"
                                  (expand "grammar_wellformedness" -4)
                                  (("1"
                                    (assert)
                                    (("1"
                                      (case "e=e(G)")
                                      (("1"
                                        (replace -1 * LR)
                                        (("1"
                                          (replace -1 * RL)
                                          (("1" (assert) nil nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (hide -4)
                                        (("2"
                                          (assert)
                                          (("2"
                                            (replace -5 * LR)
                                            (("2" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (case "subterm(e,G)")
                            (("1" (lemma "subterm_transitivity")
                              (("1"
                                (inst -1 "e" "G" "P_exp(A)")
                                (("1" (assert) nil nil))
                                nil))
                              nil)
                             ("2" (hide 2 3 4)
                              (("2"
                                (replace -4 * LR)
                                (("2"
                                  (assert)
                                  (("2"
                                    (expand "subterm")
                                    (("2"
                                      (expand "subterm")
                                      (("2" (propax) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil nil
   (parsing subtype "peg_parser.s_T"
    "{k: naturalnumbers.upto(peg_parser.s) | booleans.⇒((k = peg_parser.s), wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].g_wf(peg_parser.e1, peg_parser.A, wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].P_0c?(peg_parser.P_exp), wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].strong))}")))
 (parsing_TCC24 0
  (parsing_TCC32-1 nil 3768836598
   ("" (skeep*)
    (("" (rewrite "lex4_lt")
      (("" (rewrite "lex3_lt")
        (("" (rewrite "lex2_lt") (("" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (lex4_lt formula-decl nil lex4 nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (<= const-decl "bool" reals nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (V_S formal-type-decl nil peg_parser nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (peg type-decl nil peg nil) (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (g_wf def-decl "bool" wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (pegMeasure const-decl "nat" peg nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lex2_lt formula-decl nil lex2 nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (sum const-decl "nat" peg nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (lex3_lt formula-decl nil lex3 nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (parsing termination
    "peg_parser.parsing(peg_parser.P_exp, peg_parser.A, peg_parser.e1, peg_parser.inp, peg_parser.s, peg_parser.s_T)"
    "nil")))
 (parsing_TCC25 0
  (parsing_TCC45-1 nil 3771853966
   ("" (skeep*)
    (("" (assert)
      (("" (replace -1 * LR)
        (("" (expand "astWellformed?")
          (("" (expand "trueToGrammar")
            (("" (expand "trueToInput")
              (("" (typepred "T1")
                (("" (lemma "Wellformed_theorem")
                  (("" (inst -1 "T1")
                    (("" (assert)
                      (("" (expand "astType?" 2)
                        (("" (expand "P_0c?")
                          (("" (expand "P_sc?")
                            (("" (expand "g_props" +)
                              ((""
                                (split 2)
                                (("1"
                                  (assert)
                                  (("1"
                                    (expand "trueToGrammar")
                                    (("1" (propax) nil nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (assert)
                                  (("2"
                                    (expand "trueToInput")
                                    (("2" (propax) nil nil))
                                    nil))
                                  nil)
                                 ("3"
                                  (assert)
                                  (("3"
                                    (flatten)
                                    (("3" (assert) nil nil))
                                    nil))
                                  nil)
                                 ("4"
                                  (flatten)
                                  (("4" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astWellformed? def-decl "bool" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (g_props def-decl "[bool, bool, bool]" wf_peg nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (V_S formal-type-decl nil peg_parser nil)
    (pre_ast type-decl nil pre_ast nil) (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (peg type-decl nil peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (input type-eq-decl nil ast_props nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (below type-eq-decl nil naturalnumbers nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (g_wf def-decl "bool" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (parsing subtype
    "pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].prior(peg_parser.s, pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].e(peg_parser.T1), peg_parser.T1, pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].skip(peg_parser.s, peg_parser.s, peg_parser.e2))"
    "peg_parser.output(peg_parser.P_exp, peg_parser.A, peg_parser.G, peg_parser.inp, peg_parser.s, peg_parser.s_T)")))
 (parsing_TCC26 0
  (parsing_TCC43-1 nil 3768836598
   ("" (skeep*)
    (("" (lemma "peg[V_T, <=, V_N_b].subterm_transitivity")
      (("" (inst -1 "e2" "G" "P_exp(A)")
        (("" (typepred "G")
          (("" (assert)
            (("" (replace -2 1 LR)
              (("" (expand "subterm")
                (("" (expand "subterm") (("" (propax) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((V_N_b formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (subterm_transitivity formula-decl nil peg nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (parsing subtype "peg_parser.e2"
    "{e: wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].Δ | peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].subterm(e, peg_parser.P_exp(peg_parser.A))}")))
 (parsing_TCC27 0
  (parsing_TCC27-1 nil 3771774354
   ("" (skeep)
    (("" (skeep)
      (("" (typepred ("G" "s_T"))
        (("" (assert)
          (("" (expand "grammar_wellformedness" -)
            (("" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (V_S formal-type-decl nil peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (parsing subtype "peg_parser.s_T"
    "{k: naturalnumbers.upto(peg_parser.s) | booleans.⇒((k = peg_parser.s), wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].g_wf(peg_parser.e2, peg_parser.A, wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].P_0c?(peg_parser.P_exp), wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].strong))}")))
 (parsing_TCC28 0
  (parsing_TCC37-1 nil 3768836598
   ("" (skeep*)
    (("" (rewrite "lex4_lt")
      (("" (rewrite "lex3_lt")
        (("" (rewrite "lex2_lt") (("" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (lex4_lt formula-decl nil lex4 nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (<= const-decl "bool" reals nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (V_S formal-type-decl nil peg_parser nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (peg type-decl nil peg nil) (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (g_wf def-decl "bool" wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (pegMeasure const-decl "nat" peg nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lex2_lt formula-decl nil lex2 nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (sum const-decl "nat" peg nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (lex3_lt formula-decl nil lex3 nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (parsing termination
    "peg_parser.parsing(peg_parser.P_exp, peg_parser.A, peg_parser.e2, peg_parser.inp, peg_parser.s, peg_parser.s_T)"
    "nil")))
 (parsing_TCC29 0
  (parsing_TCC55-1 nil 3768836598
   ("" (skeep*)
    (("" (assert)
      (("" (replace -1 * LR)
        (("" (expand "astWellformed?")
          (("" (expand "trueToGrammar")
            (("" (expand "trueToInput")
              (("" (typepred "T1")
                (("" (lemma "Wellformed_theorem")
                  (("" (inst -1 "T1")
                    (("" (typepred "T2")
                      (("" (lemma "Wellformed_theorem")
                        (("" (inst -1 "T2")
                          (("" (assert)
                            (("" (flatten)
                              ((""
                                (expand "P_0c?")
                                ((""
                                  (expand "P_sc?")
                                  ((""
                                    (expand "P_fc?")
                                    ((""
                                      (expand "g_props" 4)
                                      ((""
                                        (expand "astType?" 4)
                                        ((""
                                          (assert)
                                          ((""
                                            (split 4)
                                            (("1"
                                              (flatten)
                                              (("1"
                                                (assert)
                                                (("1"
                                                  (lift-if -1)
                                                  (("1"
                                                    (split -1)
                                                    (("1"
                                                      (propax)
                                                      nil
                                                      nil)
                                                     ("2"
                                                      (flatten)
                                                      (("2"
                                                        (split -1)
                                                        (("1"
                                                          (flatten)
                                                          (("1"
                                                            (assert)
                                                            nil
                                                            nil))
                                                          nil)
                                                         ("2"
                                                          (flatten)
                                                          (("2"
                                                            (assert)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (flatten)
                                              (("2"
                                                (lift-if)
                                                (("2"
                                                  (split -1)
                                                  (("1"
                                                    (assert)
                                                    nil
                                                    nil)
                                                   ("2"
                                                    (flatten)
                                                    (("2"
                                                      (assert)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("3"
                                              (flatten)
                                              (("3"
                                                (lift-if)
                                                (("3"
                                                  (split -1)
                                                  (("1"
                                                    (flatten)
                                                    (("1"
                                                      (assert)
                                                      nil
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (flatten)
                                                    (("2"
                                                      (assert)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astWellformed? def-decl "bool" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (g_props def-decl "[bool, bool, bool]" wf_peg nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (V_S formal-type-decl nil peg_parser nil)
    (pre_ast type-decl nil pre_ast nil) (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (peg type-decl nil peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (input type-eq-decl nil ast_props nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (below type-eq-decl nil naturalnumbers nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (g_wf def-decl "bool" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (parsing subtype
    "pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].prior(peg_parser.s, pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].e(peg_parser.T2), peg_parser.T1, peg_parser.T2)"
    "peg_parser.output(peg_parser.P_exp, peg_parser.A, peg_parser.G, peg_parser.inp, peg_parser.s, peg_parser.s_T)")))
 (parsing_TCC30 0
  (parsing_TCC45-1 nil 3768836598
   ("" (skeep*)
    (("" (lemma "peg[V_T, <=, V_N_b].subterm_transitivity")
      (("" (inst -1 "e" "G" "P_exp(A)")
        (("" (typepred "G")
          (("" (assert)
            (("" (replace -2 * LR)
              (("" (expand "subterm")
                (("" (expand "subterm") (("" (propax) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((V_N_b formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (subterm_transitivity formula-decl nil peg nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (parsing subtype "peg_parser.e"
    "{e: wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].Δ | peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].subterm(e, peg_parser.P_exp(peg_parser.A))}")))
 (parsing_TCC31 0
  (parsing_TCC31-1 nil 3771774354
   ("" (skeep)
    (("" (typepred "s_T")
      (("" (assert)
        (("" (expand "grammar_wellformedness" -) (("" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (V_S formal-type-decl nil peg_parser nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (r const-decl "C(P_exp)" wf_peg nil)
    (array_sum const-decl "upto(3 * V_N_b)" array_sum nil)
    (nT_properties const-decl "F(P_exp)" wf_peg nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (parsing subtype "peg_parser.s_T"
    "{k: naturalnumbers.upto(peg_parser.s) | booleans.⇒((k = peg_parser.s), wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].g_wf(peg_parser.e, peg_parser.A, wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].P_0c?(peg_parser.P_exp), wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].strong))}")))
 (parsing_TCC32 0
  (parsing_TCC42-1 nil 3768836598 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (peg type-decl nil peg nil) (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (subterm adt-def-decl "boolean" peg nil)
    (<= const-decl "bool" reals nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (V_S formal-type-decl nil peg_parser nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (r const-decl "C(P_exp)" wf_peg nil)
    (array_sum const-decl "upto(3 * V_N_b)" array_sum nil)
    (nT_properties const-decl "F(P_exp)" wf_peg nil)
    (inc const-decl "nat" peg nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (< def-decl "bool" ordinals nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (pegMeasure const-decl "nat" peg nil)
    (lex2 const-decl "ordinal" lex2 nil)
    (lex3 const-decl "ordinal" lex3 nil)
    (lex4 const-decl "ordinal" lex4 nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (parsing termination
    "peg_parser.parsing(peg_parser.P_exp, peg_parser.A, peg_parser.e, peg_parser.inp, peg_parser.s, peg_parser.s_T)"
    "nil")))
 (parsing_TCC33 0
  (parsing_TCC52-1 nil 3771853966
   ("" (skeep*)
    (("" (assert)
      (("" (replace -1 * LR)
        (("" (expand "astWellformed?")
          (("" (typepred "T0")
            (("" (lemma "Wellformed_theorem")
              (("" (inst -1 "T0")
                (("" (expand "trueToGrammar" +)
                  (("" (expand "trueToGrammar" +)
                    (("" (expand "trueToInput" +)
                      (("" (expand "trueToInput" +)
                        (("" (assert)
                          (("" (expand "astType?" +)
                            (("" (expand "P_fc?")
                              ((""
                                (expand "P_0c?")
                                ((""
                                  (expand "g_props" +)
                                  (("" (propax) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astWellformed? def-decl "bool" ast nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (g_props def-decl "[bool, bool, bool]" wf_peg nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (V_S formal-type-decl nil peg_parser nil)
    (pre_ast type-decl nil pre_ast nil) (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (peg type-decl nil peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (below type-eq-decl nil naturalnumbers nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (g_wf def-decl "bool" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (parsing subtype
    "pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].star(peg_parser.s, peg_parser.s, peg_parser.T0, pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].skip(pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].e(peg_parser.T0), pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].e(peg_parser.T0), peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].star(peg_parser.e)))"
    "peg_parser.output(peg_parser.P_exp, peg_parser.A, peg_parser.G, peg_parser.inp, peg_parser.s, peg_parser.s_T)")))
 (parsing_TCC34 0
  (parsing_TCC57-1 nil 3771853966
   ("" (skeep*)
    (("" (assert)
      (("" (expand "astWellformed?")
        (("" (expand "astType?")
          (("" (typepred "T")
            (("" (lemma "Wellformedness_is_meaningfulness")
              (("" (inst -1 "T")
                (("" (expand "astMeaningful?")
                  (("" (split -1)
                    (("1" (assert)
                      (("1" (expand "P_fc?")
                        (("1" (expand "grammar_props" +)
                          (("1" (expand "P_0c?")
                            (("1" (expand "P_sc?")
                              (("1"
                                (flatten)
                                (("1"
                                  (assert)
                                  (("1"
                                    (case-replace "e(G) = e")
                                    (("1"
                                      (assert)
                                      (("1"
                                        (use "Consumption_growth")
                                        (("1" (assert) nil nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (replace -9 * LR)
                                      (("2" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (assert)
                      (("2" (expand "P_0c?")
                        (("2" (expand "P_fc?")
                          (("2" (expand "grammar_props" +)
                            (("2" (expand "P_sc?")
                              (("2"
                                (assert)
                                (("2"
                                  (case-replace "e(G) = e")
                                  (("2"
                                    (assert)
                                    (("2"
                                      (use "Consumption_growth")
                                      (("2"
                                        (assert)
                                        (("2"
                                          (replace -10 * LR)
                                          (("2" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (parsing subtype
    "peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].star(peg_parser.e)"
    "{e: wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].Δ | peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].subterm(e, peg_parser.P_exp(peg_parser.A))}")))
 (parsing_TCC35 0
  (parsing_TCC35-1 nil 3771774354
   ("" (skeep)
    (("" (skeep)
      (("" (typepred ("T0" "G" "s_T"))
        (("" (typepred ("T0" "G" "s_T"))
          (("" (lemma "Consumption_growth")
            (("" (inst -1 "T0")
              (("" (assert)
                (("" (flatten) (("" (assert) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((subterm adt-def-decl "boolean" peg nil)
    (strong const-decl "bool" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (peg type-decl nil peg nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Consumption_growth formula-decl nil ast nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (parsing subtype "peg_parser.s_T"
    "{k: naturalnumbers.upto(pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].e(peg_parser.T0)) | booleans.⇒((k = pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].e(peg_parser.T0)), wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].g_wf(peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].star(peg_parser.e), peg_parser.A, wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].P_0c?(peg_parser.P_exp), wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].strong))}")))
 (parsing_TCC36 0
  (parsing_TCC48-1 nil 3768836598
   ("" (skeep*)
    (("" (rewrites ("lex4_lt" "lex3_lt" "lex2_lt"))
      (("" (assert)
        (("" (lemma "Wellformed_theorem" (T T0))
          (("" (assert)
            (("" (typepred "s_T")
              (("" (assert)
                (("" (flatten)
                  (("" (assert)
                    (("" (case "e(T0) =s ")
                      (("1"
                        (lemma
                         "wf_peg[V_T, <=, V_N_b].Star_cannot_be_P0")
                        (("1" (inst -1 "P_exp" "G" "A")
                          (("1" (assert)
                            (("1" (replace -6 * LR)
                              (("1"
                                (assert)
                                (("1"
                                  (typepred "T0")
                                  (("1" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (assert) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (star adt-constructor-decl "[peg -> (star?)]" peg nil)
    (pegMeasure const-decl "nat" peg nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (V_S formal-type-decl nil peg_parser nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (<= const-decl "bool" reals nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (lex4_lt formula-decl nil lex4 nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (lex3_lt formula-decl nil lex3 nil)
    (lex2_lt formula-decl nil lex2 nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (Star_cannot_be_P0 formula-decl nil wf_peg nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (parsing termination
    "peg_parser.parsing(peg_parser.P_exp, peg_parser.A, peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].star(peg_parser.e), peg_parser.inp, pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].e(peg_parser.T0), peg_parser.s_T)"
    "nil")))
 (parsing_TCC37 0
  (parsing_TCC65-1 nil 3769177011
   ("" (skeep*) (("" (typepred "Ts") (("" (propax) nil nil)) nil)) nil)
   ((star adt-constructor-decl "[peg -> (star?)]" peg nil)
    (strong const-decl "bool" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (peg type-decl nil peg nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (parsing subtype "peg_parser.Ts"
    "{T: pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].pre_ast | booleans.OR(pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].skip?(T), pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].star?(T))}")))
 (parsing_TCC38 0
  (parsing_TCC57-1 nil 3772300931
   ("" (skeep*)
    (("" (assert)
      (("" (replace -1 * LR)
        (("" (typepred "T0")
          (("" (lemma "Wellformed_theorem")
            (("" (inst -1 "T0")
              (("" (typepred "Ts")
                (("" (lemma "Wellformed_theorem")
                  (("" (inst -1 "Ts")
                    (("" (assert)
                      (("" (flatten)
                        (("" (expand "astWellformed?" +)
                          (("" (expand "trueToGrammar" +)
                            (("" (expand "trueToInput" +)
                              ((""
                                (expand "astType?" 4)
                                ((""
                                  (expand "P_0c?")
                                  ((""
                                    (expand "P_sc?")
                                    ((""
                                      (expand "P_fc?")
                                      ((""
                                        (expand "g_props" +)
                                        ((""
                                          (expand "g_props" -8)
                                          ((""
                                            (expand "g_props" -9)
                                            ((""
                                              (expand "g_props" -10)
                                              ((""
                                                (assert)
                                                ((""
                                                  (split 5)
                                                  (("1"
                                                    (flatten)
                                                    (("1"
                                                      (assert)
                                                      nil
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (flatten)
                                                    (("2"
                                                      (assert)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((strong const-decl "bool" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (peg type-decl nil peg nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (g_props def-decl "[bool, bool, bool]" wf_peg nil)
    (star adt-constructor-decl "[peg -> (star?)]" peg nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (parsing subtype
    "pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].star(peg_parser.s, pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].e(peg_parser.Ts), peg_parser.T0, peg_parser.Ts)"
    "peg_parser.output(peg_parser.P_exp, peg_parser.A, peg_parser.G, peg_parser.inp, peg_parser.s, peg_parser.s_T)")))
 (parsing_TCC39 0
  (parsing_TCC53-1 nil 3769284018
   ("" (skeep*)
    (("" (lemma "peg[V_T, <=, V_N_b].subterm_transitivity")
      (("" (inst -1 "e" "G" "P_exp(A)")
        (("" (typepred "G")
          (("" (assert)
            (("" (replace -2 1 LR)
              (("" (expand "subterm")
                (("" (expand "subterm") (("" (propax) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((V_N_b formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (subterm_transitivity formula-decl nil peg nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (parsing subtype "peg_parser.e"
    "{e: wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].Δ | peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].subterm(e, peg_parser.P_exp(peg_parser.A))}")))
 (parsing_TCC40 0
  (parsing_TCC40-1 nil 3771774354
   ("" (skeep)
    (("" (typepred "G")
      (("" (typepred "P_exp")
        (("" (typepred "s_T")
          (("" (assert)
            (("" (expand "g_wf" -2)
              (("" (case-replace "e = e(G)")
                (("1" (flatten) nil nil)
                 ("2" (replace -5 * LR) (("2" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (V_S formal-type-decl nil peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (opt? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (notP? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (andP? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (e shared-adt-accessor-decl
     "[{x: peg |      star?(x) OR plus?(x) OR opt?(x) OR notP?(x) OR andP?(x)} ->
   peg]" peg nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (parsing subtype "peg_parser.s_T"
    "{k: naturalnumbers.upto(peg_parser.s) | booleans.⇒((k = peg_parser.s), wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].g_wf(peg_parser.e, peg_parser.A, wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].P_0c?(peg_parser.P_exp), wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].strong))}")))
 (parsing_TCC41 0
  (parsing_TCC54-1 nil 3768836598 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (peg type-decl nil peg nil) (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (subterm adt-def-decl "boolean" peg nil)
    (<= const-decl "bool" reals nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (V_S formal-type-decl nil peg_parser nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (r const-decl "C(P_exp)" wf_peg nil)
    (array_sum const-decl "upto(3 * V_N_b)" array_sum nil)
    (nT_properties const-decl "F(P_exp)" wf_peg nil)
    (inc const-decl "nat" peg nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (< def-decl "bool" ordinals nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (pegMeasure const-decl "nat" peg nil)
    (lex2 const-decl "ordinal" lex2 nil)
    (lex3 const-decl "ordinal" lex3 nil)
    (lex4 const-decl "ordinal" lex4 nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (parsing termination
    "peg_parser.parsing(peg_parser.P_exp, peg_parser.A, peg_parser.e, peg_parser.inp, peg_parser.s, peg_parser.s_T)"
    "nil")))
 (parsing_TCC42 0
  (parsing_TCC62-1 nil 3772300931
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (assert)
        (("" (typepred "T0")
          (("" (lemma "Wellformed_theorem")
            (("" (inst -1 "T0")
              (("" (assert)
                (("" (expand "astType?" +)
                  (("" (expand "astWellformed?" +)
                    (("" (expand "trueToGrammar" +)
                      (("" (expand "trueToGrammar")
                        (("" (assert) (("" (grind) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((strong const-decl "bool" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (peg type-decl nil peg nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (r const-decl "C(P_exp)" wf_peg nil)
    (array_sum const-decl "upto(3 * V_N_b)" array_sum nil)
    (nT_properties const-decl "F(P_exp)" wf_peg nil)
    (g_props def-decl "[bool, bool, bool]" wf_peg nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (parsing subtype
    "pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].plus(peg_parser.s, peg_parser.s, peg_parser.T0, pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].skip(pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].e(peg_parser.T0), pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].e(peg_parser.T0), peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].plus(peg_parser.e)))"
    "peg_parser.output(peg_parser.P_exp, peg_parser.A, peg_parser.G, peg_parser.inp, peg_parser.s, peg_parser.s_T)")))
 (parsing_TCC43 0
  (parsing_TCC63-1 nil 3772300931 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (peg type-decl nil peg nil) (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (subterm adt-def-decl "boolean" peg nil)
    (<= const-decl "bool" reals nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (V_S formal-type-decl nil peg_parser nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (pre_ast type-decl nil pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (parsing subtype
    "peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].plus(peg_parser.e)"
    "{e: wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].Δ | peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].subterm(e, peg_parser.P_exp(peg_parser.A))}")))
 (parsing_TCC44 0
  (parsing_TCC65-1 nil 3772300931
   ("" (skeep*)
    (("" (typepred "s_T")
      (("" (use "Consumption_growth")
        (("" (typepred "T0")
          (("" (assert)
            (("" (expand "grammar_wellformedness" -)
              (("" (flatten)
                (("" (assert)
                  (("" (replace -12 * LR)
                    (("" (assert)
                      (("" (flatten)
                        (("" (assert)
                          (("" (assert) (("" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (V_S formal-type-decl nil peg_parser nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (pre_ast type-decl nil pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (Consumption_growth formula-decl nil ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (parsing subtype "peg_parser.s_T"
    "{k: naturalnumbers.upto(pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].e(peg_parser.T0)) | booleans.⇒((k = pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].e(peg_parser.T0)), wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].g_wf(peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].plus(peg_parser.e), peg_parser.A, wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].P_0c?(peg_parser.P_exp), wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].strong))}")))
 (parsing_TCC45 0
  (parsing_TCC66-1 nil 3772300931
   ("" (skeep*)
    (("" (rewrites ("lex4_lt" "lex3_lt" "lex2_lt"))
      (("" (flatten)
        (("" (assert)
          (("" (typepred "P_exp")
            (("" (use "strong_is_complete_WF")
              (("" (lemma "complete_WF_theorem")
                (("" (inst -1 "P_exp" "A" "G")
                  (("" (assert)
                    (("" (replace -4 * LR)
                      (("" (expand "g_wf" -)
                        (("" (flatten)
                          (("" (assert)
                            (("" (typepred "T0")
                              ((""
                                (assert)
                                ((""
                                  (lemma "Wellformed_theorem" (T T0))
                                  ((""
                                    (assert)
                                    ((""
                                      (flatten)
                                      (("" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (plus adt-constructor-decl "[peg -> (plus?)]" peg nil)
    (pegMeasure const-decl "nat" peg nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (V_S formal-type-decl nil peg_parser nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (<= const-decl "bool" reals nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (lex4_lt formula-decl nil lex4 nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (lex3_lt formula-decl nil lex3 nil)
    (lex2_lt formula-decl nil lex2 nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (strong_is_complete_WF formula-decl nil wf_peg nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (complete_WF_theorem formula-decl nil wf_peg nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (parsing termination
    "peg_parser.parsing(peg_parser.P_exp, peg_parser.A, peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].plus(peg_parser.e), peg_parser.inp, pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].e(peg_parser.T0), peg_parser.s_T)"
    "nil")))
 (parsing_TCC46 0
  (parsing_TCC68-1 nil 3772300931 ("" (subtype-tcc) nil nil)
   ((int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (parsing subtype "peg_parser.Ts"
    "{T: pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].pre_ast | booleans.OR(pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].skip?(T), booleans.OR(pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].plus?(T), pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].fail?(T)))}")))
 (parsing_TCC47 0
  (parsing_TCC69-1 nil 3772300931
   ("" (skeep*)
    (("" (assert)
      (("" (replace -1 * LR)
        (("" (expand "astWellformed?")
          (("" (expand "astType?" 2)
            (("" (typepred "T0")
              (("" (typepred "Ts")
                (("" (use "Wellformed_theorem")
                  (("" (use "Wellformed_theorem" ("T" "T0"))
                    (("" (assert)
                      (("" (flatten)
                        (("" (assert)
                          (("" (expand "P_0c?")
                            (("" (expand "P_sc?")
                              ((""
                                (expand "P_fc?")
                                ((""
                                  (expand "g_props" +)
                                  ((""
                                    (expand "g_props" -10)
                                    ((""
                                      (typepred "P_exp")
                                      ((""
                                        (use "strong_is_complete_WF")
                                        ((""
                                          (lemma "complete_WF_theorem")
                                          ((""
                                            (inst
                                             -1
                                             "P_exp"
                                             "A"
                                             "plus(e)")
                                            ((""
                                              (typepred "G")
                                              ((""
                                                (assert)
                                                ((""
                                                  (expand "g_wf")
                                                  ((""
                                                    (expand "P_0c?")
                                                    ((""
                                                      (flatten)
                                                      ((""
                                                        (split -8)
                                                        (("1"
                                                          (assert)
                                                          (("1"
                                                            (expand
                                                             "trueToGrammar")
                                                            (("1"
                                                              (expand
                                                               "trueToInput")
                                                              (("1"
                                                                (propax)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("2"
                                                          (assert)
                                                          (("2"
                                                            (expand
                                                             "trueToGrammar")
                                                            (("2"
                                                              (expand
                                                               "trueToInput")
                                                              (("2"
                                                                (propax)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astWellformed? def-decl "bool" ast nil)
    (strong const-decl "bool" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType type-decl nil ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (peg type-decl nil peg nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ast type-eq-decl nil ast nil) (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (g_props def-decl "[bool, bool, bool]" wf_peg nil)
    (complete_WF_theorem formula-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (strong_is_complete_WF formula-decl nil wf_peg nil)
    (plus adt-constructor-decl "[peg -> (plus?)]" peg nil)
    (astType? def-decl "astType" ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (parsing subtype
    "pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].plus(peg_parser.s, pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].e(peg_parser.Ts), peg_parser.T0, peg_parser.Ts)"
    "peg_parser.output(peg_parser.P_exp, peg_parser.A, peg_parser.G, peg_parser.inp, peg_parser.s, peg_parser.s_T)")))
 (parsing_TCC48 0
  (parsing_TCC70-1 nil 3772300931
   ("" (skeep*)
    (("" (typepred "G")
      (("" (lemma "peg[V_T, <=, V_N_b].subterm_transitivity")
        (("" (inst -1 "e" "G" " P_exp(A)") (("" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (subterm_transitivity formula-decl nil peg nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (parsing subtype "peg_parser.e"
    "{e: wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].Δ | peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].subterm(e, peg_parser.P_exp(peg_parser.A))}")))
 (parsing_TCC49 0
  (parsing_TCC71-1 nil 3772300931
   ("" (skeep*) (("" (typepred "s_T") (("" (grind) nil nil)) nil)) nil)
   ((strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (V_S formal-type-decl nil peg_parser nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (parsing subtype "peg_parser.s_T"
    "{k: naturalnumbers.upto(peg_parser.s) | booleans.⇒((k = peg_parser.s), wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].g_wf(peg_parser.e, peg_parser.A, wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].P_0c?(peg_parser.P_exp), wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].strong))}")))
 (parsing_TCC50 0
  (parsing_TCC72-1 nil 3772300931 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (peg type-decl nil peg nil) (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (subterm adt-def-decl "boolean" peg nil)
    (<= const-decl "bool" reals nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (V_S formal-type-decl nil peg_parser nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (inc const-decl "nat" peg nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (< def-decl "bool" ordinals nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (pegMeasure const-decl "nat" peg nil)
    (lex2 const-decl "ordinal" lex2 nil)
    (lex3 const-decl "ordinal" lex3 nil)
    (lex4 const-decl "ordinal" lex4 nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (parsing termination
    "peg_parser.parsing(peg_parser.P_exp, peg_parser.A, peg_parser.e, peg_parser.inp, peg_parser.s, peg_parser.s_T)"
    "nil")))
 (parsing_TCC51 0
  (parsing_TCC74-1 nil 3772307450
   ("" (skeep*)
    (("" (expand "astWellformed?")
      (("" (expand "trueToGrammar")
        (("" (expand "trueToInput")
          (("" (replace -1 * LR)
            (("" (assert)
              (("" (typepred "T")
                (("" (lemma "Wellformed_theorem")
                  (("" (inst -1 "T")
                    (("" (assert)
                      (("" (expand "P_0c?")
                        (("" (expand "P_fc?")
                          (("" (expand "g_props" +)
                            (("" (expand "astType?" 2)
                              (("" (flatten) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astWellformed? def-decl "bool" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (g_props def-decl "[bool, bool, bool]" wf_peg nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (V_S formal-type-decl nil peg_parser nil)
    (pre_ast type-decl nil pre_ast nil) (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (peg type-decl nil peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (input type-eq-decl nil ast_props nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (below type-eq-decl nil naturalnumbers nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (g_wf def-decl "bool" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (parsing subtype
    "pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].opt(peg_parser.s, peg_parser.s, peg_parser.T)"
    "peg_parser.output(peg_parser.P_exp, peg_parser.A, peg_parser.G, peg_parser.inp, peg_parser.s, peg_parser.s_T)")))
 (parsing_TCC52 0
  (parsing_TCC74-1 nil 3772300931
   ("" (skeep*)
    (("" (expand "astWellformed?")
      (("" (replace -1 * LR)
        (("" (assert)
          (("" (expand "trueToGrammar")
            (("" (expand "trueToInput")
              (("" (typepred "T")
                (("" (use "Wellformed_theorem")
                  (("" (assert)
                    (("" (flatten)
                      (("" (expand "P_0c?")
                        (("" (expand "P_sc?")
                          (("" (expand "P_fc?")
                            (("" (expand "g_props" 3)
                              ((""
                                (expand "astType?" 3)
                                ((""
                                  (assert)
                                  ((""
                                    (split 3)
                                    (("1"
                                      (flatten)
                                      (("1" (assert) nil nil))
                                      nil)
                                     ("2" (propax) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astWellformed? def-decl "bool" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (g_props def-decl "[bool, bool, bool]" wf_peg nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (V_S formal-type-decl nil peg_parser nil)
    (pre_ast type-decl nil pre_ast nil) (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (peg type-decl nil peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (input type-eq-decl nil ast_props nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (below type-eq-decl nil naturalnumbers nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (g_wf def-decl "bool" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (parsing subtype
    "pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].opt(peg_parser.s, pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].e(peg_parser.T), peg_parser.T)"
    "peg_parser.output(peg_parser.P_exp, peg_parser.A, peg_parser.G, peg_parser.inp, peg_parser.s, peg_parser.s_T)")))
 (parsing_TCC53 0
  (parsing_TCC75-1 nil 3772300931
   ("" (skeep)
    (("" (lemma "peg[V_T, <=, V_N_b].subterm_transitivity")
      (("" (inst -1 "e" "G" "P_exp(A)")
        (("" (typepred "G") (("" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((V_N_b formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (subterm_transitivity formula-decl nil peg nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil))
   nil
   (parsing subtype "peg_parser.e"
    "{e: wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].Δ | peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].subterm(e, peg_parser.P_exp(peg_parser.A))}")))
 (parsing_TCC54 0
  (parsing_TCC76-1 nil 3772300931
   ("" (skeep) (("" (typepred "s_T") (("" (grind) nil nil)) nil)) nil)
   ((strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (V_S formal-type-decl nil peg_parser nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (parsing subtype "peg_parser.s_T"
    "{k: naturalnumbers.upto(peg_parser.s) | booleans.⇒((k = peg_parser.s), wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].g_wf(peg_parser.e, peg_parser.A, wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].P_0c?(peg_parser.P_exp), wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].strong))}")))
 (parsing_TCC55 0
  (parsing_TCC77-1 nil 3772300931
   ("" (skeep)
    (("" (rewrite "lex4_lt")
      (("" (replace -1 * LR) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (lex4_lt formula-decl nil lex4 nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (<= const-decl "bool" reals nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (V_S formal-type-decl nil peg_parser nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (peg type-decl nil peg nil) (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (g_wf def-decl "bool" wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (pegMeasure const-decl "nat" peg nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (lex2 const-decl "ordinal" lex2 nil)
    (lex3 const-decl "ordinal" lex3 nil) (inc const-decl "nat" peg nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (< def-decl "bool" ordinals nil))
   nil
   (parsing termination
    "peg_parser.parsing(peg_parser.P_exp, peg_parser.A, peg_parser.e, peg_parser.inp, peg_parser.s, peg_parser.s_T)"
    "nil")))
 (parsing_TCC56 0
  (parsing_TCC79-1 nil 3772300931
   ("" (skeep*)
    (("" (assert)
      (("" (replace -1 * LR)
        (("" (expand "astType?")
          (("" (expand "astWellformed?")
            (("" (expand "trueToGrammar")
              (("" (expand "trueToInput")
                (("" (typepred "T")
                  (("" (use "Wellformed_theorem")
                    (("" (assert)
                      (("" (flatten)
                        (("" (assert)
                          (("" (expand "P_0c?")
                            (("" (expand "P_sc?")
                              ((""
                                (expand "P_fc?")
                                ((""
                                  (expand "g_props" +)
                                  ((""
                                    (assert)
                                    (("" (ground) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (strong const-decl "bool" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType type-decl nil ast nil)
    (input type-eq-decl nil ast_props nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (peg type-decl nil peg nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ast type-eq-decl nil ast nil) (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (g_props def-decl "[bool, bool, bool]" wf_peg nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (astWellformed? def-decl "bool" ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (parsing subtype
    "pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].notP(peg_parser.s, peg_parser.s, peg_parser.T)"
    "peg_parser.output(peg_parser.P_exp, peg_parser.A, peg_parser.G, peg_parser.inp, peg_parser.s, peg_parser.s_T)")))
 (parsing_TCC57 0
  (parsing_TCC80-1 nil 3772300931
   ("" (skeep)
    (("" (lemma "peg[V_T, <=, V_N_b].subterm_transitivity")
      (("" (inst -1 "e" "G" "P_exp(A)")
        (("" (typepred "G") (("" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((V_N_b formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (subterm_transitivity formula-decl nil peg nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil))
   nil
   (parsing subtype "peg_parser.e"
    "{e: wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].Δ | peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].subterm(e, peg_parser.P_exp(peg_parser.A))}")))
 (parsing_TCC58 0
  (parsing_TCC81-1 nil 3772300931
   ("" (skeep) (("" (typepred "s_T") (("" (grind) nil nil)) nil)) nil)
   ((strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (V_S formal-type-decl nil peg_parser nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (parsing subtype "peg_parser.s_T"
    "{k: naturalnumbers.upto(peg_parser.s) | booleans.⇒((k = peg_parser.s), wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].g_wf(peg_parser.e, peg_parser.A, wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].P_0c?(peg_parser.P_exp), wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].strong))}")))
 (parsing_TCC59 0
  (parsing_TCC82-1 nil 3772300931 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (peg type-decl nil peg nil) (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (subterm adt-def-decl "boolean" peg nil)
    (<= const-decl "bool" reals nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (V_S formal-type-decl nil peg_parser nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (inc const-decl "nat" peg nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (< def-decl "bool" ordinals nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (pegMeasure const-decl "nat" peg nil)
    (lex2 const-decl "ordinal" lex2 nil)
    (lex3 const-decl "ordinal" lex3 nil)
    (lex4 const-decl "ordinal" lex4 nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (parsing termination
    "peg_parser.parsing(peg_parser.P_exp, peg_parser.A, peg_parser.e, peg_parser.inp, peg_parser.s, peg_parser.s_T)"
    "nil")))
 (parsing_TCC60 0
  (parsing_TCC84-1 nil 3772300931
   ("" (skeep*)
    (("" (assert)
      (("" (replace -1 * LR)
        (("" (expand "trueToGrammar")
          (("" (expand "trueToInput")
            (("" (typepred "T")
              (("" (use "Wellformed_theorem")
                (("" (assert)
                  (("" (flatten)
                    (("" (expand "astWellformed?" +)
                      (("" (expand "P_0c?")
                        (("" (expand "P_sc?")
                          (("" (expand "P_fc?")
                            (("" (expand "g_props" +)
                              ((""
                                (expand "astType?" +)
                                ((""
                                  (assert)
                                  (("" (ground) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((trueToGrammar def-decl "bool" ast_props nil)
    (strong const-decl "bool" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (input type-eq-decl nil ast_props nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (peg type-decl nil peg nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (g_props def-decl "[bool, bool, bool]" wf_peg nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (parsing subtype
    "pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].andP(peg_parser.s, peg_parser.s, peg_parser.T)"
    "peg_parser.output(peg_parser.P_exp, peg_parser.A, peg_parser.G, peg_parser.inp, peg_parser.s, peg_parser.s_T)")))
 (reference_parser_theorem 0
  (reference_parser_theorem-1 nil 3784800164
   ("" (skolem 1 ("P_exp" "_" "_" "inp" "_" "_"))
    ((""
      (case "FORALL (i : nat, A: below(V_N_b), G: {e: Δ | subterm(e, P_exp(A))},
                                                 s: upto(bound),
                                                 s_T:
                                                   {k: upto(s) | (k = s) ⇒ g_wf(G, A, P_0c?(P_exp), strong)}):
                                           astMeasure(parsing(P_exp, A, G, inp, s, s_T)) <= i IMPLIES parseTree?(parsing(P_exp, A, G, inp, s, s_T))")
      (("1" (skeep)
        (("1"
          (inst -1 "astMeasure(parsing(P_exp, A, G, inp, s, s_T))" "A"
           "G" "s" "s_T")
          (("1" (assert) nil nil)) nil))
        nil)
       ("2" (hide 2)
        (("2" (induct "i")
          (("1" (skolem 1 ("A" "_" "_" "_"))
            (("1" (induct "G")
              (("1" (assert) nil nil)
               ("2" (assert) (("2" (grind) nil nil)) nil)
               ("3" (grind) nil nil) ("4" (grind) nil nil)
               ("5" (grind) nil nil) ("6" (grind) nil nil)
               ("7" (skeep)
                (("7" (skeep)
                  (("7" (hide -1 -2 -3 1) (("7" (grind) nil nil)) nil))
                  nil))
                nil)
               ("8" (skeep*)
                (("8" (hide -1 -2 -3 1)
                  (("8" (expand "parsing") (("8" (grind) nil nil))
                    nil))
                  nil))
                nil)
               ("9" (skeep*)
                (("9" (hide -1 -2 1)
                  (("9" (expand "parsing")
                    (("9" (lift-if)
                      (("9" (split)
                        (("1" (flatten)
                          (("1" (assert)
                            (("1" (expand "astMeasure")
                              (("1"
                                (expand "reduce_nat")
                                (("1" (ground) nil nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (flatten)
                          (("2" (assert)
                            (("2" (expand "astMeasure")
                              (("2"
                                (expand "reduce_nat")
                                (("2" (ground) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("10" (skeep*)
                (("10" (hide 1 -1 -2)
                  (("10" (expand "parsing")
                    (("10" (expand "astMeasure")
                      (("10" (expand "reduce_nat")
                        (("10" (lift-if) (("10" (ground) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("11" (grind) nil nil) ("12" (grind) nil nil)
               ("13" (grind) nil nil))
              nil))
            nil)
           ("2" (skolem 1 "i")
            (("2" (flatten)
              (("2" (skolem 1 ("A" "_" "_" "_"))
                (("2" (induct "G" 1)
                  (("1" (assert) nil nil)
                   ("2" (assert) (("2" (grind) nil nil)) nil)
                   ("3" (grind) nil nil) ("4" (grind) nil nil)
                   ("5" (grind) nil nil)
                   ("6" (skolem 1 "B")
                    (("6" (flatten)
                      (("6" (skeep)
                        (("6" (expand "parsing" -2)
                          (("6" (inst -3 "B" "P_exp(B)" "s" "s")
                            (("6" (assert)
                              (("6"
                                (split -3)
                                (("1"
                                  (expand "parseTree?")
                                  (("1"
                                    (skeep)
                                    (("1"
                                      (inst - "T_p")
                                      (("1"
                                        (expand "parsing" -4)
                                        (("1"
                                          (expand "subterm" -4)
                                          (("1" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (hide 2)
                                  (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("7" (skolem 1 ("e1" "e2"))
                    (("7" (flatten)
                      (("7" (skeep)
                        (("7" (assert)
                          (("7" (split -1)
                            (("1" (split -2)
                              (("1"
                                (expand "parsing" 1)
                                (("1"
                                  (inst -2 "s" "s_T")
                                  (("1"
                                    (expand "parsing" -4)
                                    (("1"
                                      (split 1)
                                      (("1"
                                        (flatten)
                                        (("1"
                                          (assert)
                                          (("1"
                                            (expand "parseTree?")
                                            (("1"
                                              (skeep)
                                              (("1"
                                                (split -5)
                                                (("1"
                                                  (inst - "T_p")
                                                  (("1"
                                                    (expand
                                                     "subterm"
                                                     -3)
                                                    (("1"
                                                      (assert)
                                                      (("1"
                                                        (expand
                                                         "subterm"
                                                         -2)
                                                        (("1"
                                                          (propax)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (hide
                                                   -1
                                                   -2
                                                   -3
                                                   -4
                                                   -5
                                                   -7)
                                                  (("2"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (flatten)
                                        (("2"
                                          (expand "parseTree?")
                                          (("2"
                                            (assert)
                                            (("2"
                                              (skeep)
                                              (("2"
                                                (inst
                                                 -3
                                                 "e(parsing(P_exp, A, e1, inp, s, s_T))"
                                                 "s_T")
                                                (("2"
                                                  (assert)
                                                  (("2"
                                                    (split -3)
                                                    (("1"
                                                      (split -4)
                                                      (("1"
                                                        (inst - "T_p")
                                                        (("1"
                                                          (inst
                                                           -
                                                           "T_p")
                                                          (("1"
                                                            (expand
                                                             "subterm"
                                                             -3)
                                                            (("1"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil)
                                                       ("2"
                                                        (hide
                                                         2
                                                         -1
                                                         -2
                                                         -3
                                                         -4
                                                         -6)
                                                        (("2"
                                                          (grind)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (hide
                                                       2
                                                       -1
                                                       -2
                                                       -3
                                                       -4
                                                       -6)
                                                      (("2"
                                                        (grind)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (typepred "s_T")
                                    (("2"
                                      (flatten)
                                      (("2"
                                        (assert)
                                        (("2"
                                          (expand "g_wf" -2)
                                          (("2" (propax) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (lemma
                                 "peg[V_T, <=, V_N_b].subterm_transitivity")
                                (("2"
                                  (inst
                                   -1
                                   "e2"
                                   "seq(e1,e2)"
                                   "P_exp(A)")
                                  (("2"
                                    (assert)
                                    (("2"
                                      (expand "subterm" 1)
                                      (("2"
                                        (expand "subterm" 1)
                                        (("2" (propax) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2"
                              (lemma
                               "peg[V_T, <=, V_N_b].subterm_transitivity")
                              (("2"
                                (inst -1 "e1" "seq(e1,e2)" "P_exp(A)")
                                (("2"
                                  (assert)
                                  (("2"
                                    (expand "subterm" 1)
                                    (("2"
                                      (expand "subterm" 1)
                                      (("2" (propax) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("8" (skolem 1 ("e1" "e2"))
                    (("8" (flatten)
                      (("8"
                        (lemma
                         "peg[V_T, <=, V_N_b].subterm_transitivity")
                        (("8"
                          (lemma
                           "peg[V_T, <=, V_N_b].subterm_transitivity")
                          (("8"
                            (inst -1 "e1" "prior(e1,e2)" "P_exp(A)")
                            (("8" (assert)
                              (("8"
                                (expand "subterm" -1 1)
                                (("8"
                                  (expand "subterm" -1 1)
                                  (("8"
                                    (assert)
                                    (("8"
                                      (lemma
                                       "peg[V_T, <=, V_N_b].subterm_transitivity")
                                      (("8"
                                        (inst
                                         -1
                                         "e2"
                                         "prior(e1,e2)"
                                         "P_exp(A)")
                                        (("8"
                                          (assert)
                                          (("8"
                                            (expand "subterm" -1 1)
                                            (("8"
                                              (expand "subterm" -1 2)
                                              (("8"
                                                (assert)
                                                (("8"
                                                  (skeep)
                                                  (("8"
                                                    (inst -4 "s" "s_T")
                                                    (("1"
                                                      (inst
                                                       -5
                                                       "s"
                                                       "s_T")
                                                      (("1"
                                                        (expand
                                                         "parsing"
                                                         1)
                                                        (("1"
                                                          (expand
                                                           "parsing"
                                                           -7)
                                                          (("1"
                                                            (hide -8)
                                                            (("1"
                                                              (split 1)
                                                              (("1"
                                                                (assert)
                                                                (("1"
                                                                  (flatten)
                                                                  (("1"
                                                                    (assert)
                                                                    (("1"
                                                                      (split
                                                                       -5)
                                                                      (("1"
                                                                        (split
                                                                         -6)
                                                                        (("1"
                                                                          (hide
                                                                           -6)
                                                                          (("1"
                                                                            (assert)
                                                                            (("1"
                                                                              (expand
                                                                               "parseTree?")
                                                                              (("1"
                                                                                (skeep)
                                                                                (("1"
                                                                                  (inst
                                                                                   -
                                                                                   "T_p")
                                                                                  (("1"
                                                                                    (inst
                                                                                     -
                                                                                     "T_p")
                                                                                    (("1"
                                                                                      (grind)
                                                                                      nil
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil)
                                                                         ("2"
                                                                          (assert)
                                                                          (("2"
                                                                            (hide
                                                                             1)
                                                                            (("2"
                                                                              (expand
                                                                               "parseTree?")
                                                                              (("2"
                                                                                (skeep)
                                                                                (("2"
                                                                                  (inst
                                                                                   -
                                                                                   "T_p")
                                                                                  (("2"
                                                                                    (grind)
                                                                                    nil
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil)
                                                                       ("2"
                                                                        (hide
                                                                         2)
                                                                        (("2"
                                                                          (label
                                                                           "m"
                                                                           -7)
                                                                          (("2"
                                                                            (hide
                                                                             -)
                                                                            (("2"
                                                                              (reveal
                                                                               "m")
                                                                              (("2"
                                                                                (grind)
                                                                                nil
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil)
                                                               ("2"
                                                                (flatten)
                                                                (("2"
                                                                  (assert)
                                                                  (("2"
                                                                    (expand
                                                                     "parseTree?")
                                                                    (("2"
                                                                      (skeep)
                                                                      (("2"
                                                                        (split
                                                                         -6)
                                                                        (("1"
                                                                          (split
                                                                           -7)
                                                                          (("1"
                                                                            (inst
                                                                             -
                                                                             "T_p")
                                                                            (("1"
                                                                              (inst
                                                                               -
                                                                               "T_p")
                                                                              (("1"
                                                                                (grind)
                                                                                nil
                                                                                nil))
                                                                              nil))
                                                                            nil)
                                                                           ("2"
                                                                            (grind)
                                                                            nil
                                                                            nil))
                                                                          nil)
                                                                         ("2"
                                                                          (grind)
                                                                          nil
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil)
                                                       ("2"
                                                        (typepred
                                                         "s_T")
                                                        (("2"
                                                          (assert)
                                                          (("2"
                                                            (flatten)
                                                            (("2"
                                                              (assert)
                                                              (("2"
                                                                (expand
                                                                 "g_wf"
                                                                 -2)
                                                                (("2"
                                                                  (propax)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (typepred "s_T")
                                                      (("2"
                                                        (flatten)
                                                        (("2"
                                                          (assert)
                                                          (("2"
                                                            (expand
                                                             "g_wf"
                                                             -2)
                                                            (("2"
                                                              (propax)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("9" (skolem 1 "e")
                    (("9" (flatten)
                      (("9"
                        (lemma
                         "peg[V_T, <=, V_N_b].subterm_transitivity")
                        (("9" (inst -1 "e" "star(e)" "P_exp(A)")
                          (("9" (expand "subterm" -1 1)
                            (("9" (expand "subterm" -1 1)
                              (("9"
                                (assert)
                                (("9"
                                  (skeep)
                                  (("9"
                                    (inst -2 "s" "s_T")
                                    (("1"
                                      (assert)
                                      (("1"
                                        (inst
                                         -5
                                         "A"
                                         "star(e)"
                                         "e(parsing(P_exp, A, e, inp, s, s_T))"
                                         "s_T")
                                        (("1"
                                          (expand "parsing" 1)
                                          (("1"
                                            (expand "parsing" -4)
                                            (("1"
                                              (expand "parseTree?")
                                              (("1"
                                                (assert)
                                                (("1"
                                                  (ground)
                                                  (("1"
                                                    (skeep)
                                                    (("1"
                                                      (inst - "T_p")
                                                      (("1"
                                                        (inst - "T_p")
                                                        (("1"
                                                          (assert)
                                                          (("1"
                                                            (expand
                                                             "subterm"
                                                             -2)
                                                            (("1"
                                                              (expand
                                                               "subterm"
                                                               -2)
                                                              (("1"
                                                                (propax)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (skeep)
                                                    (("2"
                                                      (inst - "T_p")
                                                      (("2"
                                                        (assert)
                                                        (("2"
                                                          (expand
                                                           "subterm"
                                                           -2)
                                                          (("2"
                                                            (expand
                                                             "subterm"
                                                             -2)
                                                            (("2"
                                                              (propax)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("3"
                                                    (skeep)
                                                    (("3"
                                                      (inst - "T_p")
                                                      (("3"
                                                        (inst - "T_p")
                                                        (("3"
                                                          (assert)
                                                          (("3"
                                                            (expand
                                                             "subterm"
                                                             -1)
                                                            (("3"
                                                              (propax)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("4"
                                                    (skeep)
                                                    (("4"
                                                      (inst - "T_p")
                                                      (("4"
                                                        (assert)
                                                        (("4"
                                                          (expand
                                                           "subterm"
                                                           -1)
                                                          (("4"
                                                            (assert)
                                                            (("4"
                                                              (hide
                                                               2
                                                               3
                                                               -1
                                                               -2
                                                               -3
                                                               -4)
                                                              (("4"
                                                                (expand
                                                                 "astMeasure")
                                                                (("4"
                                                                  (expand
                                                                   "reduce_nat"
                                                                   -1)
                                                                  (("4"
                                                                    (assert)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("5"
                                                    (skeep)
                                                    (("5"
                                                      (inst - "T_p")
                                                      (("5"
                                                        (hide
                                                         -1
                                                         -2
                                                         -3
                                                         -4
                                                         -5
                                                         -6)
                                                        (("5"
                                                          (expand
                                                           "astMeasure")
                                                          (("5"
                                                            (expand
                                                             "reduce_nat"
                                                             -)
                                                            (("5"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("6"
                                                    (skeep)
                                                    (("6"
                                                      (assert)
                                                      (("6"
                                                        (expand
                                                         "subterm"
                                                         -2)
                                                        (("6"
                                                          (expand
                                                           "subterm"
                                                           -2
                                                           2)
                                                          (("6"
                                                            (hide
                                                             -1
                                                             -2
                                                             -3
                                                             -4
                                                             -5)
                                                            (("6"
                                                              (expand
                                                               "astMeasure")
                                                              (("6"
                                                                (expand
                                                                 "reduce_nat"
                                                                 -)
                                                                (("6"
                                                                  (assert)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("7"
                                                    (skeep)
                                                    (("7"
                                                      (inst - "T_p")
                                                      (("7"
                                                        (assert)
                                                        (("7"
                                                          (expand
                                                           "subterm"
                                                           -1)
                                                          (("7"
                                                            (assert)
                                                            (("7"
                                                              (expand
                                                               "astMeasure")
                                                              (("7"
                                                                (expand
                                                                 "reduce_nat"
                                                                 -)
                                                                (("7"
                                                                  (assert)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("8"
                                                    (expand
                                                     "astMeasure")
                                                    (("8"
                                                      (expand
                                                       "reduce_nat"
                                                       -)
                                                      (("8"
                                                        (assert)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (typepred "s_T")
                                          (("2"
                                            (assert)
                                            (("2"
                                              (typepred
                                               "parsing(P_exp, A, e, inp, s, s_T)")
                                              (("1"
                                                (lemma
                                                 "Wellformed_theorem")
                                                (("1"
                                                  (inst
                                                   -1
                                                   "parsing(P_exp, A, e, inp, s, s_T)")
                                                  (("1"
                                                    (assert)
                                                    (("1"
                                                      (flatten)
                                                      (("1"
                                                        (assert)
                                                        (("1"
                                                          (flatten)
                                                          (("1"
                                                            (assert)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (typepred "s_T")
                                                (("2"
                                                  (flatten)
                                                  (("2"
                                                    (assert)
                                                    (("2"
                                                      (expand "g_wf" -)
                                                      (("2"
                                                        (propax)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("3"
                                          (typepred "s_T")
                                          (("3"
                                            (flatten)
                                            (("3"
                                              (assert)
                                              (("3"
                                                (expand "g_wf" -)
                                                (("3"
                                                  (propax)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (typepred "s_T")
                                      (("2"
                                        (assert)
                                        (("2"
                                          (flatten)
                                          (("2"
                                            (assert)
                                            (("2"
                                              (expand "g_wf" -)
                                              (("2" (propax) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("10" (skolem 1 "e")
                    (("10" (flatten)
                      (("10" (skeep)
                        (("10"
                          (lemma
                           "peg[V_T, <=, V_N_b].subterm_transitivity")
                          (("10" (inst -1 "e" "plus(e)" "P_exp(A)")
                            (("10" (assert)
                              (("10"
                                (expand "subterm" -1 1)
                                (("10"
                                  (expand "subterm" -1 1)
                                  (("10"
                                    (assert)
                                    (("10"
                                      (inst -2 "s" "s_T")
                                      (("1"
                                        (inst
                                         -5
                                         "A"
                                         "plus(e)"
                                         "e(parsing(P_exp, A, e, inp, s, s_T))"
                                         "s_T")
                                        (("1"
                                          (expand "parsing" 1)
                                          (("1"
                                            (expand "parseTree?")
                                            (("1"
                                              (ground)
                                              (("1"
                                                (skeep)
                                                (("1"
                                                  (inst - "T_p")
                                                  (("1"
                                                    (inst - "T_p")
                                                    (("1"
                                                      (assert)
                                                      (("1"
                                                        (expand
                                                         "subterm"
                                                         -2)
                                                        (("1"
                                                          (expand
                                                           "subterm"
                                                           -2)
                                                          (("1"
                                                            (propax)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (skeep)
                                                (("2"
                                                  (inst - "T_p")
                                                  (("2"
                                                    (assert)
                                                    (("2"
                                                      (expand
                                                       "subterm"
                                                       -2)
                                                      (("2"
                                                        (expand
                                                         "subterm"
                                                         -2)
                                                        (("2"
                                                          (propax)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("3"
                                                (skeep)
                                                (("3"
                                                  (inst - "T_p")
                                                  (("3"
                                                    (inst - "T_p")
                                                    (("3"
                                                      (assert)
                                                      (("3"
                                                        (expand
                                                         "subterm"
                                                         -1)
                                                        (("3"
                                                          (propax)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("4"
                                                (skeep)
                                                (("4"
                                                  (inst - "T_p")
                                                  (("4"
                                                    (assert)
                                                    (("4"
                                                      (expand
                                                       "subterm"
                                                       -1)
                                                      (("4"
                                                        (expand
                                                         "parsing"
                                                         -5)
                                                        (("4"
                                                          (name-replace
                                                           "ep"
                                                           "e(parsing(P_exp, A, e, inp, s, s_T))")
                                                          (("4"
                                                            (expand
                                                             "astMeasure")
                                                            (("4"
                                                              (expand
                                                               "reduce_nat"
                                                               -)
                                                              (("4"
                                                                (assert)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("5"
                                                (skeep*)
                                                (("5"
                                                  (inst - "T_p")
                                                  (("5"
                                                    (assert)
                                                    (("5"
                                                      (expand
                                                       "parsing"
                                                       -6)
                                                      (("5"
                                                        (name-replace
                                                         "ep"
                                                         "e(parsing(P_exp, A, e, inp, s, s_T))")
                                                        (("5"
                                                          (expand
                                                           "astMeasure")
                                                          (("5"
                                                            (expand
                                                             "reduce_nat"
                                                             -)
                                                            (("5"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("6"
                                                (expand "parsing" -4)
                                                (("6"
                                                  (name-replace
                                                   "ep"
                                                   "e(parsing(P_exp, A, e, inp, s, s_T))")
                                                  (("6"
                                                    (expand
                                                     "astMeasure")
                                                    (("6"
                                                      (expand
                                                       "reduce_nat"
                                                       -)
                                                      (("6"
                                                        (assert)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("7"
                                                (skeep)
                                                (("7"
                                                  (inst - "T_p")
                                                  (("7"
                                                    (expand
                                                     "parsing"
                                                     -6)
                                                    (("7"
                                                      (name-replace
                                                       "ep"
                                                       "e(parsing(P_exp, A, e, inp, s, s_T))")
                                                      (("7"
                                                        (expand
                                                         "astMeasure")
                                                        (("7"
                                                          (expand
                                                           "reduce_nat"
                                                           -)
                                                          (("7"
                                                            (assert)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("8"
                                                (expand "parsing" -)
                                                (("8"
                                                  (name-replace
                                                   "ep"
                                                   "e(parsing(P_exp, A, e, inp, s, s_T))")
                                                  (("8"
                                                    (expand
                                                     "astMeasure")
                                                    (("8"
                                                      (expand
                                                       "reduce_nat"
                                                       -)
                                                      (("8"
                                                        (assert)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (typepred "s_T")
                                          (("2"
                                            (typepred
                                             "parsing(P_exp, A, e, inp, s, s_T)")
                                            (("1"
                                              (lemma
                                               "Wellformed_theorem")
                                              (("1"
                                                (inst? -1)
                                                (("1"
                                                  (assert)
                                                  (("1"
                                                    (flatten)
                                                    (("1"
                                                      (assert)
                                                      (("1"
                                                        (flatten)
                                                        (("1"
                                                          (expand
                                                           "g_wf"
                                                           2)
                                                          (("1"
                                                            (expand
                                                             "strong")
                                                            (("1"
                                                              (assert)
                                                              (("1"
                                                                (expand
                                                                 "g_wf"
                                                                 -13)
                                                                (("1"
                                                                  (propax)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (assert)
                                              (("2"
                                                (flatten)
                                                (("2"
                                                  (assert)
                                                  (("2"
                                                    (expand "g_wf" -3)
                                                    (("2"
                                                      (propax)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("3"
                                          (lemma
                                           "peg[V_T, <=, V_N_b].subterm_transitivity")
                                          (("3"
                                            (inst
                                             -1
                                             "e"
                                             "plus(e)"
                                             "P_exp(A)")
                                            (("3"
                                              (assert)
                                              (("3"
                                                (typepred "s_T")
                                                (("3"
                                                  (flatten)
                                                  (("3"
                                                    (assert)
                                                    (("3"
                                                      (expand
                                                       "g_wf"
                                                       -2)
                                                      (("3"
                                                        (propax)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (lemma
                                         "peg[V_T, <=, V_N_b].subterm_transitivity")
                                        (("2"
                                          (inst
                                           -1
                                           "e"
                                           "plus(e)"
                                           "P_exp(A)")
                                          (("2"
                                            (assert)
                                            (("2"
                                              (expand "subterm" -1 1)
                                              (("2"
                                                (expand "subterm" -1 1)
                                                (("2"
                                                  (typepred "s_T")
                                                  (("2"
                                                    (flatten)
                                                    (("2"
                                                      (assert)
                                                      (("2"
                                                        (expand
                                                         "g_wf"
                                                         -2)
                                                        (("2"
                                                          (propax)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("11"
                    (lemma "peg[V_T, <=, V_N_b].subterm_transitivity")
                    (("11" (skolem 1 "e")
                      (("11" (flatten)
                        (("11" (inst -1 "e" "opt(e)" "P_exp(A)")
                          (("11" (assert)
                            (("11" (expand "subterm" -1 1)
                              (("11"
                                (expand "subterm" -1 1)
                                (("11"
                                  (assert)
                                  (("11"
                                    (skeep)
                                    (("11"
                                      (inst -2 "s" "s_T")
                                      (("1"
                                        (expand "parsing" 1)
                                        (("1"
                                          (expand "parseTree?")
                                          (("1"
                                            (ground)
                                            (("1"
                                              (skeep)
                                              (("1"
                                                (inst - "T_p")
                                                (("1"
                                                  (assert)
                                                  (("1"
                                                    (expand
                                                     "subterm"
                                                     -2)
                                                    (("1"
                                                      (propax)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (skeep)
                                              (("2"
                                                (inst - "T_p")
                                                (("2"
                                                  (assert)
                                                  (("2"
                                                    (expand
                                                     "subterm"
                                                     -1)
                                                    (("2"
                                                      (propax)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("3"
                                              (hide -5)
                                              (("3"
                                                (expand "parsing" -4)
                                                (("3"
                                                  (expand "astMeasure")
                                                  (("3"
                                                    (expand
                                                     "reduce_nat"
                                                     -)
                                                    (("3"
                                                      (assert)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("4"
                                              (hide -4)
                                              (("4"
                                                (expand "parsing" -)
                                                (("4"
                                                  (expand "astMeasure")
                                                  (("4"
                                                    (expand
                                                     "reduce_nat"
                                                     -)
                                                    (("4"
                                                      (assert)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (typepred "s_T")
                                        (("2"
                                          (assert)
                                          (("2"
                                            (flatten)
                                            (("2"
                                              (assert)
                                              (("2"
                                                (expand "g_wf" -)
                                                (("2"
                                                  (propax)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("12" (skolem 1 "e")
                    (("12" (flatten)
                      (("12" (hide -3)
                        (("12" (skeep)
                          (("12" (expand "parsing" 1)
                            (("12" (expand "parsing" -3)
                              (("12"
                                (expand "parseTree?")
                                (("12"
                                  (ground)
                                  (("1"
                                    (inst -1 "s" "s_T")
                                    (("1"
                                      (split -1)
                                      (("1"
                                        (skeep)
                                        (("1"
                                          (inst - "T_p")
                                          (("1"
                                            (assert)
                                            (("1"
                                              (expand "subterm" -3)
                                              (("1" (propax) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (expand "astMeasure")
                                        (("2"
                                          (expand "reduce_nat" -)
                                          (("2" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (lemma
                                     "peg[V_T, <=, V_N_b].subterm_transitivity")
                                    (("2"
                                      (inst
                                       -1
                                       "e"
                                       "notP(e)"
                                       "P_exp(A)")
                                      (("2"
                                        (assert)
                                        (("2"
                                          (expand "subterm" 1)
                                          (("2"
                                            (expand "subterm" 1)
                                            (("2" (propax) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("13" (skolem 1 "e")
                    (("13" (flatten)
                      (("13" (skeep)
                        (("13" (hide -4)
                          (("13" (split -1)
                            (("1" (inst -1 "s" "s_T")
                              (("1"
                                (expand "parsing" 1)
                                (("1"
                                  (expand "parsing" -3)
                                  (("1"
                                    (split -1)
                                    (("1"
                                      (expand "parseTree?")
                                      (("1"
                                        (skeep)
                                        (("1"
                                          (inst -1 "T_p")
                                          (("1"
                                            (expand "subterm" -4)
                                            (("1" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (expand "astMeasure")
                                      (("2"
                                        (expand "reduce_nat" -)
                                        (("2" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (typepred "s_T")
                                (("2"
                                  (flatten)
                                  (("2"
                                    (assert)
                                    (("2"
                                      (expand "g_wf" -)
                                      (("2" (propax) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2"
                              (lemma
                               "peg[V_T, <=, V_N_b].subterm_transitivity")
                              (("2"
                                (inst -1 "e" "andP(e)" "P_exp(A)")
                                (("2"
                                  (assert)
                                  (("2"
                                    (expand "subterm" 1)
                                    (("2"
                                      (expand "subterm" 1)
                                      (("2" (propax) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((parseTree? const-decl "bool" pre_ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (astMeasure const-decl "nat" pre_ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil peg_parser nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (<= const-decl "bool" reals nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (below type-eq-decl nil naturalnumbers nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (peg_induction formula-decl nil peg nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (ε? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (ε adt-constructor-decl "(ε?)" peg nil)
    (subterm adt-def-decl "boolean" pre_ast nil)
    (reduce_nat adt-def-decl "[pre_ast -> nat]" pre_ast nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (any adt-constructor-decl "(any?)" peg nil)
    (any? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (terminal? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (terminal adt-constructor-decl "[V_T -> (terminal?)]" peg nil)
    (range? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (range adt-constructor-decl "[[V_T, V_T] -> (range?)]" peg nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nonTerminal? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (nonTerminal adt-constructor-decl
     "[below(V_N_b) -> (nonTerminal?)]" peg nil)
    (TRUE const-decl "bool" booleans nil)
    (opt adt-constructor-decl "[peg -> (opt?)]" peg nil)
    (opt? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (notP? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (notP adt-constructor-decl "[peg -> (notP?)]" peg nil)
    (andP? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (andP adt-constructor-decl "[peg -> (andP?)]" peg nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (s skolem-const-decl "upto(bound)" peg_parser nil)
    (seq? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (seq adt-constructor-decl "[[peg, peg] -> (seq?)]" peg nil)
    (e1 skolem-const-decl "peg[V_T, <=, V_N_b]" peg_parser nil)
    (e2 skolem-const-decl "peg[V_T, <=, V_N_b]" peg_parser nil)
    (A skolem-const-decl "below(V_N_b)" peg_parser nil)
    (P_exp skolem-const-decl "WF_nT[V_T, <=, V_N_b]" peg_parser nil)
    (s_T skolem-const-decl
     "{k: upto(s) | (k = s) ⇒ g_wf(seq(e1, e2), A, P_0c?(P_exp), strong)}"
     peg_parser nil)
    (subterm_transitivity formula-decl nil peg nil)
    (s_T skolem-const-decl
     "{k: upto(s) | (k = s) ⇒ g_wf(prior(e1, e2), A, P_0c?(P_exp), strong)}"
     peg_parser nil)
    (e2 skolem-const-decl "peg[V_T, <=, V_N_b]" peg_parser nil)
    (e1 skolem-const-decl "peg[V_T, <=, V_N_b]" peg_parser nil)
    (s skolem-const-decl "upto(bound)" peg_parser nil)
    (prior? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (prior adt-constructor-decl "[[peg, peg] -> (prior?)]" peg nil)
    (star adt-constructor-decl "[peg -> (star?)]" peg nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (inp skolem-const-decl "input[V_T, <=, V_N_b, bound, V_S]"
     peg_parser nil)
    (s_T skolem-const-decl
     "{k: upto(s) | (k = s) ⇒ g_wf(star(e), A, P_0c?(P_exp), strong)}"
     peg_parser nil)
    (e skolem-const-decl "peg[V_T, <=, V_N_b]" peg_parser nil)
    (s skolem-const-decl "upto(bound)" peg_parser nil)
    (s skolem-const-decl "upto(bound)" peg_parser nil)
    (e skolem-const-decl "peg[V_T, <=, V_N_b]" peg_parser nil)
    (s_T skolem-const-decl
     "{k: upto(s) | (k = s) ⇒ g_wf(plus(e), A, P_0c?(P_exp), strong)}"
     peg_parser nil)
    (plus adt-constructor-decl "[peg -> (plus?)]" peg nil)
    (s_T skolem-const-decl
     "{k: upto(s) | (k = s) ⇒ g_wf(opt(e), A, P_0c?(P_exp), strong)}"
     peg_parser nil)
    (e skolem-const-decl "peg[V_T, <=, V_N_b]" peg_parser nil)
    (s skolem-const-decl "upto(bound)" peg_parser nil)
    (s skolem-const-decl "upto(bound)" peg_parser nil)
    (e skolem-const-decl "peg[V_T, <=, V_N_b]" peg_parser nil)
    (s_T skolem-const-decl
     "{k: upto(s) | (k = s) ⇒ g_wf(andP(e), A, P_0c?(P_exp), strong)}"
     peg_parser nil))
   shostak))
 (reference_parser_grammar 0
  (reference_parser_grammar-1 nil 3785520629
   ("" (skeep)
    (("" (typepred "parsing(P_exp, A, G, inp, s, s_T)")
      (("" (propax) nil nil)) nil))
    nil)
   ((parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ast type-eq-decl nil ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (<= const-decl "bool" reals nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (astWellformed? def-decl "bool" ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak)))

