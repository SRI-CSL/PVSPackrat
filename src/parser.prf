(peg_parser
 (parsing_TCC1 0
  (parsing_TCC1-1 nil 3769177011 ("" (subtype-tcc) nil nil)
   ((int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (parsing subtype
    "(number_fields.-)(peg_parser.bound, peg_parser.s_T)" "nat")))
 (parsing_TCC2 0
  (parsing_TCC38-1 nil 3768836598
   ("" (skeep) (("" (typepred "s") (("" (assert) nil nil)) nil)) nil)
   ((inp_bound type-eq-decl nil ast_props nil)
    (V_S formal-type-decl nil peg_parser nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (parsing subtype "(number_fields.-)(peg_parser.bound, peg_parser.s)"
    "nat")))
 (parsing_TCC3 0
  (parsing_TCC4-1 nil 3769177011
   ("" (skeep)
    (("" (typepred "z`5")
      (("" (typepred "z`6") (("" (assert) nil nil)) nil)) nil))
    nil)
   ((P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (wf_nT type-eq-decl nil wf_peg nil)
    (wf_nT? const-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (V_S formal-type-decl nil peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (subterm_of type-eq-decl nil peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (parsing subtype
    "(number_fields.-)(peg_parser.bound, peg_parser.z`6)" "nat")))
 (parsing_TCC4 0
  (parsing_TCC40-1 nil 3768836598
   ("" (skeep)
    (("" (typepred "z`5")
      (("" (typepred "z`6") (("" (assert) nil nil)) nil)) nil))
    nil)
   ((P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (wf_nT type-eq-decl nil wf_peg nil)
    (wf_nT? const-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (V_S formal-type-decl nil peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (subterm_of type-eq-decl nil peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (parsing subtype
    "(number_fields.-)(peg_parser.bound, peg_parser.z`5)" "nat")))
 (parsing_TCC5 0
  (parsing_TCC52-1 nil 3768836598
   ("" (skeep *) (("" (typepred "s") (("" (assert) nil nil)) nil)) nil)
   ((inp_bound type-eq-decl nil ast_props nil)
    (V_S formal-type-decl nil peg_parser nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (parsing subtype "(number_fields.-)(peg_parser.bound, peg_parser.s)"
    "nat")))
 (parsing_TCC6 0
  (parsing_TCC5-1 nil 3768836598
   ("" (skeep*) (("" (grind) nil nil)) nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (V_S formal-type-decl nil peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (astType? def-decl "astType" ast nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (r const-decl "C(P_exp)" wf_peg nil)
    (array_sum const-decl "upto(3 * V_N_b)" array_sum nil)
    (nT_properties const-decl "F(P_exp)" wf_peg nil)
    (g_props def-decl "[bool, bool, bool]" wf_peg nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (astMeaningful? const-decl "bool" ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (parsing subtype
    "pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].ε(peg_parser.s, peg_parser.s)"
    "peg_parser.output(peg_parser.P_exp, peg_parser.A, peg_parser.G, peg_parser.inp, peg_parser.s, peg_parser.s_T)")))
 (parsing_TCC7 0
  (parsing_TCC15-1 nil 3768836598
   ("" (skeep)
    (("" (assert)
      (("" (expand "astWellformed?")
        (("" (expand "trueToGrammar")
          (("" (expand "trueToInput")
            (("" (expand "astMeaningful?") (("" (grind) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_min application-judgement "{k: posint | k <= i AND k <= j}"
     real_defs nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (astWellformed? def-decl "bool" ast nil)
    (astMeaningful? const-decl "bool" ast nil)
    (astType? def-decl "astType" ast nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (V_S formal-type-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (r const-decl "C(P_exp)" wf_peg nil)
    (array_sum const-decl "upto(3 * V_N_b)" array_sum nil)
    (nT_properties const-decl "F(P_exp)" wf_peg nil)
    (g_props def-decl "[bool, bool, bool]" wf_peg nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (parsing subtype
    "pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].any(peg_parser.s, real_defs.min((number_fields.+)(peg_parser.s, 1), peg_parser.bound), peg_parser.inp(peg_parser.s))"
    "peg_parser.output(peg_parser.P_exp, peg_parser.A, peg_parser.G, peg_parser.inp, peg_parser.s, peg_parser.s_T)")))
 (parsing_TCC8 0
  (parsing_TCC17-1 nil 3768836598
   ("" (skeep) (("" (assert) (("" (grind) nil nil)) nil)) nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_min application-judgement "{k: posint | k <= i AND k <= j}"
     real_defs nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (astWellformed? def-decl "bool" ast nil)
    (astMeaningful? const-decl "bool" ast nil)
    (astType? def-decl "astType" ast nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (V_S formal-type-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (/= const-decl "boolean" notequal nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (r const-decl "C(P_exp)" wf_peg nil)
    (array_sum const-decl "upto(3 * V_N_b)" array_sum nil)
    (nT_properties const-decl "F(P_exp)" wf_peg nil)
    (g_props def-decl "[bool, bool, bool]" wf_peg nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (parsing subtype
    "pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].terminal(peg_parser.s, real_defs.min((number_fields.+)(peg_parser.s, 1), peg_parser.bound), peg_parser.a, peg_parser.inp(peg_parser.s))"
    "peg_parser.output(peg_parser.P_exp, peg_parser.A, peg_parser.G, peg_parser.inp, peg_parser.s, peg_parser.s_T)")))
 (parsing_TCC9 0
  (parsing_TCC9-1 nil 3768836598
   ("" (skeep)
    (("" (typepred "b")
      (("" (expand "min") (("" (grind) nil nil)) nil)) nil))
    nil)
   ((min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (astWellformed? def-decl "bool" ast nil)
    (astMeaningful? const-decl "bool" ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (astType? def-decl "astType" ast nil)
    (in_range const-decl "bool" ast nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (V_S formal-type-decl nil peg_parser nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (g_props def-decl "[bool, bool, bool]" wf_peg nil)
    (nT_properties const-decl "F(P_exp)" wf_peg nil)
    (array_sum const-decl "upto(3 * V_N_b)" array_sum nil)
    (r const-decl "C(P_exp)" wf_peg nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (parsing subtype
    "pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].range(peg_parser.s, real_defs.min((number_fields.+)(peg_parser.s, 1), peg_parser.bound), peg_parser.a, peg_parser.b, peg_parser.inp(peg_parser.s))"
    "peg_parser.output(peg_parser.P_exp, peg_parser.A, peg_parser.G, peg_parser.inp, peg_parser.s, peg_parser.s_T)")))
 (parsing_TCC10 0
  (parsing_TCC14-1 nil 3768836598
   ("" (skeep)
    (("" (typepred "G") (("" (ground) (("" (grind) nil nil)) nil))
      nil))
    nil)
   ((subterm_of type-eq-decl nil peg nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (subterm_of? const-decl "bool" peg nil) (peg type-decl nil peg nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (subterm adt-def-decl "boolean" peg nil))
   nil
   (parsing subtype "peg_parser.P_exp(peg_parser.B)"
    "peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].subterm_of(peg_parser.P_exp(peg_parser.B))")))
 (parsing_TCC11 0
  (parsing_TCC29-1 nil 3771853966 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (peg type-decl nil peg nil) (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (subterm_of? const-decl "bool" peg nil)
    (subterm_of type-eq-decl nil peg nil)
    (<= const-decl "bool" reals nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (V_S formal-type-decl nil peg_parser nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (wf_nT? const-decl "bool" wf_peg nil)
    (wf_nT type-eq-decl nil wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (pattern_WF? const-decl "bool" wf_peg nil)
    (structural_WF? const-decl "bool" wf_peg nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (parsing subtype "peg_parser.s"
    "{k: naturalnumbers.upto(peg_parser.s) | booleans.⇒((k = peg_parser.s), wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].pattern_wf?(peg_parser.P_exp(peg_parser.B), peg_parser.B, static_analysis[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].σ(peg_parser.P_exp), wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].P_0c(peg_parser.P_exp)))}")))
 (parsing_TCC12 0
  (parsing_TCC16-1 nil 3768836598
   ("" (skeep)
    (("" (rewrites ("lex4_lt" "lex3_lt" "lex2_lt"))
      (("" (assert)
        (("" (flatten)
          (("" (assert)
            (("" (flatten)
              (("" (assert)
                (("" (typepred "s_T")
                  (("" (assert)
                    (("" (expand "g_wf")
                      (("" (replaces)
                        (("" (assert)
                          (("" (expand "strong")
                            (("" (propax) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((lex3_lt formula-decl nil lex3 nil)
    (lex2_lt formula-decl nil lex2 nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (subterm_of type-eq-decl nil peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (pegMeasure const-decl "nat" peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (wf_nT type-eq-decl nil wf_peg nil)
    (wf_nT? const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (V_S formal-type-decl nil peg_parser nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (<= const-decl "bool" reals nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (lex4_lt formula-decl nil lex4 nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (TRUE const-decl "bool" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_times_int_is_int application-judgement "int" integers nil))
   nil
   (parsing termination
    "peg_parser.parsing(peg_parser.P_exp, peg_parser.B, peg_parser.P_exp(peg_parser.B), peg_parser.inp, peg_parser.s, peg_parser.s)"
    "nil")))
 (parsing_TCC13 0
  (parsing_TCC13-1 nil 3847126951
   ("" (skeep*)
    (("" (typepred "T_B")
      (("" (expand "trueToGrammar")
        (("" (assert) (("" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((σ const-decl "order" static_analysis nil)
    (wf_nT type-eq-decl nil wf_peg nil)
    (wf_nT? const-decl "bool" wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (trueToInput def-decl "bool" ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (parsing subtype "peg_parser.T_B"
    "{T: pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].pre_ast | (booleans.¬)(pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].skip?(T))}")))
 (parsing_TCC14 0
  (parsing_TCC26-1 nil 3771853966
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (replaces)
        (("" (assert)
          (("" (assert)
            (("" (expand "P_0c")
              (("" (expand "P_sc")
                (("" (expand "P_fc")
                  (("" (expand "g_props" +)
                    (("" (typepred "nT_properties(P_exp!1)")
                      (("" (lemma "fix_point_theorem")
                        ((""
                          (inst -1 "P_exp!1" "nT_properties(P_exp!1)"
                           "B!1")
                          (("" (expand "ρ")
                            (("" (replace -1 1 LR)
                              ((""
                                (assert)
                                ((""
                                  (split 1)
                                  (("1" (propax) nil nil)
                                   ("2" (propax) nil nil)
                                   ("3" (propax) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (structural_WF? const-decl "bool" wf_peg nil)
    (nTpred type-eq-decl nil nTpred_order nil)
    (nTprop type-eq-decl nil nTpred_order nil)
    (coherent_properties const-decl "bool" wf_peg nil)
    (C type-eq-decl nil wf_peg nil)
    (fix_point const-decl "bool" wf_peg nil)
    (F type-eq-decl nil wf_peg nil)
    (nT_properties const-decl "F(P_exp)" wf_peg nil)
    (ρ const-decl "C(P_exp)" wf_peg nil)
    (fix_point_theorem formula-decl nil wf_peg nil)
    (g_props def-decl "[bool, bool, bool]" wf_peg nil)
    (TRUE const-decl "bool" booleans nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (below type-eq-decl nil naturalnumbers nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (wf_nT type-eq-decl nil wf_peg nil)
    (wf_nT? const-decl "bool" wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (V_S formal-type-decl nil peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (<= const-decl "bool" reals nil)
    (subterm_of type-eq-decl nil peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil
   (parsing subtype
    "pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].nonTerminal(peg_parser.s, pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].e(peg_parser.T_B), peg_parser.B, peg_parser.T_B)"
    "peg_parser.output(peg_parser.P_exp, peg_parser.A, peg_parser.G, peg_parser.inp, peg_parser.s, peg_parser.s_T)")))
 (parsing_TCC15 0
  (parsing_TCC19-1 nil 3768836598
   ("" (skeep)
    (("" (lemma "peg[V_T, <=, V_N_b].subterm_transitivity")
      (("" (inst -1 "e1" "G" "P_exp(A)")
        (("" (typepred "G")
          (("" (assert)
            (("" (expand "subterm" 1)
              (("" (flatten)
                (("" (case "e1(G) = e1")
                  (("1" (replace -1 * LR)
                    (("1" (assert) (("1" (grind) nil nil)) nil)) nil)
                   ("2" (replace -2 * LR) (("2" (assert) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((V_N_b formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (subterm_transitivity formula-decl nil peg nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (subterm adt-def-decl "boolean" peg nil)
    (e1 shared-adt-accessor-decl
     "[{x: peg | seq?(x) OR prior?(x)} -> peg]" peg nil)
    (prior? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (seq? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (subterm_of type-eq-decl nil peg nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (subterm_of? const-decl "bool" peg nil)
    (peg type-decl nil peg nil))
   nil
   (parsing subtype "peg_parser.e1"
    "peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].subterm_of(peg_parser.P_exp(peg_parser.A))")))
 (parsing_TCC16 0
  (parsing_TCC20-1 nil 3768836598
   ("" (skeep)
    (("" (typepred "s_T")
      (("" (assert)
        (("" (hide -1)
          (("" (expand "g_wf" -1)
            (("" (flatten)
              (("" (case-replace "e1(G) = e1")
                (("" (replace -3 * LR) (("" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (wf_nT type-eq-decl nil wf_peg nil)
    (wf_nT? const-decl "bool" wf_peg nil)
    (subterm_of type-eq-decl nil peg nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (V_S formal-type-decl nil peg_parser nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (e1 shared-adt-accessor-decl
     "[{x: peg | seq?(x) OR prior?(x)} -> peg]" peg nil)
    (prior? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (seq? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (parsing subtype "peg_parser.s_T"
    "{k: naturalnumbers.upto(peg_parser.s) | booleans.⇒((k = peg_parser.s), wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].pattern_wf?(peg_parser.e1, peg_parser.A, static_analysis[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].σ(peg_parser.P_exp), wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].P_0c(peg_parser.P_exp)))}")))
 (parsing_TCC17 0
  (parsing_TCC21-1 nil 3768836598
   ("" (skeep)
    (("" (rewrite "lex4_lt")
      (("" (rewrite "lex3_lt")
        (("" (rewrite "lex2_lt") (("" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (lex4_lt formula-decl nil lex4 nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (<= const-decl "bool" reals nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (V_S formal-type-decl nil peg_parser nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (peg type-decl nil peg nil) (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (subterm_of type-eq-decl nil peg nil)
    (wf_nT? const-decl "bool" wf_peg nil)
    (wf_nT type-eq-decl nil wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (pegMeasure const-decl "nat" peg nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lex2_lt formula-decl nil lex2 nil)
    (lex3_lt formula-decl nil lex3 nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (sum const-decl "nat" peg nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (parsing termination
    "peg_parser.parsing(peg_parser.P_exp, peg_parser.A, peg_parser.e1, peg_parser.inp, peg_parser.s, peg_parser.s_T)"
    "nil")))
 (parsing_TCC18 0
  (parsing_TCC18-1 nil 3847126951
   ("" (skeep*)
    (("" (typepred "T1")
      (("" (expand "astWellformed?") (("" (assert) nil nil)) nil))
      nil))
    nil)
   ((σ const-decl "order" static_analysis nil)
    (wf_nT type-eq-decl nil wf_peg nil)
    (wf_nT? const-decl "bool" wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (trueToInput def-decl "bool" ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (parsing subtype "peg_parser.T1"
    "{T: pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].pre_ast | (booleans.¬)(pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].skip?(T))}")))
 (parsing_TCC19 0
  (parsing_TCC30-1 nil 3771853966
   ("" (skeep*)
    (("" (assert)
      (("" (expand "astWellformed?")
        (("" (expand "astWellformed?")
          (("" (typepred "T1")
            (("" (expand "P_0c?")
              (("" (expand "P_sc?")
                (("" (expand "P_fc?")
                  (("" (expand "g_props" +)
                    (("" (expand "astType?" +)
                      (("" (replace -10 * LR)
                        (("" (assert)
                          (("" (expand "parseTree?")
                            (("" (skeep)
                              ((""
                                (inst -1 "T'")
                                ((""
                                  (expand "subterm" -11)
                                  ((""
                                    (assert)
                                    (("" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (astWellformed? def-decl "bool" ast nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (V_S formal-type-decl nil peg_parser nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (g_props def-decl "[bool, bool, bool]" wf_peg nil)
    (nT_properties const-decl "F(P_exp)" wf_peg nil)
    (array_sum const-decl "upto(3 * V_N_b)" array_sum nil)
    (r const-decl "C(P_exp)" wf_peg nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (pre_ast type-decl nil pre_ast nil) (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (peg type-decl nil peg nil) (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (input type-eq-decl nil ast_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (astType type-decl nil ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (wf_nT? const-decl "bool" wf_peg nil)
    (wf_nT type-eq-decl nil wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (parsing subtype
    "pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].seq(peg_parser.s, pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].e(peg_parser.T1), peg_parser.T1, pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].skip(pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].e(peg_parser.T1), pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].e(peg_parser.T1), peg_parser.e2))"
    "peg_parser.output(peg_parser.P_exp, peg_parser.A, peg_parser.G, peg_parser.inp, peg_parser.s, peg_parser.s_T)")))
 (parsing_TCC20 0
  (parsing_TCC25-1 nil 3768836598
   ("" (skeep)
    (("" (skeep)
      (("" (typepred "G")
        (("" (lemma "peg[V_T, <=, V_N_b].subterm_transitivity")
          (("" (inst -1 "e2" "G" "P_exp(A)") (("" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((subterm_of type-eq-decl nil peg nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (subterm_of? const-decl "bool" peg nil) (peg type-decl nil peg nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (subterm adt-def-decl "boolean" peg nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (subterm_transitivity formula-decl nil peg nil))
   nil
   (parsing subtype "peg_parser.e2"
    "peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].subterm_of(peg_parser.P_exp(peg_parser.A))")))
 (parsing_TCC21 0
  (parsing_TCC24-1 nil 3769177011
   ("" (skeep)
    (("" (skeep)
      (("" (typepred "s_T")
        (("" (lemma "Consumption_growth")
          (("" (inst -1 "T1")
            (("" (typepred T1)
              (("" (assert)
                (("" (flatten)
                  (("" (case "s_T = s")
                    (("1" (assert)
                      (("1" (lemma "Wellformedness_is_meaningfulness")
                        (("1" (inst -1 "T1")
                          (("1" (assert)
                            (("1" (expand "astMeaningful?")
                              (("1"
                                (assert)
                                (("1"
                                  (case-replace "e1(G) = e1")
                                  (("1"
                                    (assert)
                                    (("1"
                                      (case-replace "e2(G) = e2")
                                      (("1" (grind) nil nil)
                                       ("2" (grind) nil nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (case "s > s_T")
                                    (("1" (grind) nil nil)
                                     ("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (grind) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (wf_nT type-eq-decl nil wf_peg nil)
    (wf_nT? const-decl "bool" wf_peg nil)
    (subterm_of type-eq-decl nil peg nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (V_S formal-type-decl nil peg_parser nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (pre_ast type-decl nil pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (Wellformedness_is_meaningfulness formula-decl nil ast nil)
    (astMeaningful? const-decl "bool" ast nil)
    (nT_properties const-decl "F(P_exp)" wf_peg nil)
    (array_sum const-decl "upto(3 * V_N_b)" array_sum nil)
    (r const-decl "C(P_exp)" wf_peg nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (e2 shared-adt-accessor-decl
     "[{x: peg | seq?(x) OR prior?(x)} -> peg]" peg nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (seq? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (prior? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (e1 shared-adt-accessor-decl
     "[{x: peg | seq?(x) OR prior?(x)} -> peg]" peg nil)
    (Consumption_growth formula-decl nil ast nil))
   nil
   (parsing subtype "peg_parser.s_T"
    "{k: naturalnumbers.upto(pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].e(peg_parser.T1)) | booleans.⇒((k = pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].e(peg_parser.T1)), wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].pattern_wf?(peg_parser.e2, peg_parser.A, static_analysis[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].σ(peg_parser.P_exp), wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].P_0c(peg_parser.P_exp)))}")))
 (parsing_TCC22 0
  (parsing_TCC27-1 nil 3768836598
   ("" (skeep*)
    (("" (rewrites ("lex4_lt" "lex3_lt" "lex2_lt"))
      (("" (flatten)
        (("" (assert)
          (("" (lemma "Wellformed_theorem" (T T1))
            (("" (assert)
              (("" (flatten)
                (("" (assert)
                  (("" (replace -3 * LR)
                    (("" (expand "pegMeasure")
                      (("" (expand "reduce_nat" 3 2)
                        (("" (assert)
                          (("" (expand "sum" 3 3)
                            (("" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (pegMeasure const-decl "nat" peg nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (wf_nT type-eq-decl nil wf_peg nil)
    (wf_nT? const-decl "bool" wf_peg nil)
    (subterm_of type-eq-decl nil peg nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (V_S formal-type-decl nil peg_parser nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (<= const-decl "bool" reals nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (lex4_lt formula-decl nil lex4 nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (lex2_lt formula-decl nil lex2 nil)
    (lex3_lt formula-decl nil lex3 nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (sum const-decl "nat" peg nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (parsing termination
    "peg_parser.parsing(peg_parser.P_exp, peg_parser.A, peg_parser.e2, peg_parser.inp, pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].e(peg_parser.T1), peg_parser.s_T)"
    "nil")))
 (parsing_TCC23 0
  (parsing_TCC23-1 nil 3847126951
   ("" (skeep*)
    (("" (typepred "T1")
      (("" (expand "astWellformed?") (("" (assert) nil nil)) nil))
      nil))
    nil)
   ((σ const-decl "order" static_analysis nil)
    (wf_nT type-eq-decl nil wf_peg nil)
    (wf_nT? const-decl "bool" wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (trueToInput def-decl "bool" ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (parsing subtype "peg_parser.T1"
    "{T: pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].pre_ast | (booleans.¬)(pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].skip?(T))}")))
 (parsing_TCC24 0
  (parsing_TCC40-1 nil 3771853966
   ("" (skeep*)
    (("" (assert)
      (("" (replace -1 * LR)
        (("" (assert)
          (("" (typepred "T1")
            (("" (lemma "Wellformed_theorem")
              (("" (inst -1 "T1")
                (("" (typepred "T2")
                  (("" (lemma "Wellformed_theorem")
                    (("" (inst -1 "T2")
                      (("" (assert)
                        (("" (flatten)
                          (("" (expand "P_0c")
                            (("" (expand "P_sc")
                              ((""
                                (expand "P_fc")
                                ((""
                                  (expand "g_props" +)
                                  ((""
                                    (assert)
                                    (("" (ground) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (astWellformed? def-decl "bool" ast nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (V_S formal-type-decl nil peg_parser nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (g_props def-decl "[bool, bool, bool]" wf_peg nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (pre_ast type-decl nil pre_ast nil) (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (peg type-decl nil peg nil) (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (input type-eq-decl nil ast_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (astType type-decl nil ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (wf_nT? const-decl "bool" wf_peg nil)
    (wf_nT type-eq-decl nil wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (parsing subtype
    "pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].seq(peg_parser.s, pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].e(peg_parser.T2), peg_parser.T1, peg_parser.T2)"
    "peg_parser.output(peg_parser.P_exp, peg_parser.A, peg_parser.G, peg_parser.inp, peg_parser.s, peg_parser.s_T)")))
 (parsing_TCC25 0
  (parsing_TCC31-1 nil 3768836598
   ("" (skeep)
    (("" (lemma "peg[V_T, <=, V_N_b].subterm_transitivity")
      (("" (inst -1 "e1" "G" "P_exp(A)")
        (("" (typepred "G")
          (("" (assert)
            (("" (replace -2 * LR)
              (("" (expand "subterm")
                (("" (expand "subterm") (("" (propax) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((V_N_b formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (subterm_transitivity formula-decl nil peg nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (subterm adt-def-decl "boolean" peg nil)
    (subterm_of type-eq-decl nil peg nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (subterm_of? const-decl "bool" peg nil)
    (peg type-decl nil peg nil))
   nil
   (parsing subtype "peg_parser.e1"
    "peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].subterm_of(peg_parser.P_exp(peg_parser.A))")))
 (parsing_TCC26 0
  (parsing_TCC31-1 "" 3769982378
   ("" (skeep)
    (("" (typepred "s_T")
      (("" (expand "g_wf" -2)
        (("" (assert)
          (("" (flatten)
            (("" (case-replace "e1(G) = e1")
              (("" (replace -4 * LR) (("" (assert) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (wf_nT type-eq-decl nil wf_peg nil)
    (wf_nT? const-decl "bool" wf_peg nil)
    (subterm_of type-eq-decl nil peg nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (V_S formal-type-decl nil peg_parser nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (seq? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (prior? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (e1 shared-adt-accessor-decl
     "[{x: peg | seq?(x) OR prior?(x)} -> peg]" peg nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   shostak
   (parsing subtype "peg_parser.s_T"
    "{k: naturalnumbers.upto(peg_parser.s) | booleans.⇒((k = peg_parser.s), wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].pattern_wf?(peg_parser.e1, peg_parser.A, static_analysis[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].σ(peg_parser.P_exp), wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].P_0c(peg_parser.P_exp)))}"))
  (parsing_TCC46-1 nil 3768836598
   ("" (skeep)
    (("" (typepred "G")
      (("" (typepred "P_exp")
        (("" (expand "WF?")
          (("" (inst -1 "A" "G")
            (("" (assert)
              (("" (expand "grammar_wellformedness")
                (("" (flatten)
                  (("" (typepred "P_exp")
                    (("" (expand "WF?")
                      (("" (inst -1 "A" "e")
                        (("" (case "subterm(e, P_exp(A))")
                          (("1" (assert)
                            (("1" (name "B" "A(e)")
                              (("1"
                                (replace -1 * LR)
                                (("1"
                                  (expand "grammar_wellformedness" -4)
                                  (("1"
                                    (assert)
                                    (("1"
                                      (case "e=e(G)")
                                      (("1"
                                        (replace -1 * LR)
                                        (("1"
                                          (replace -1 * RL)
                                          (("1" (assert) nil nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (hide -4)
                                        (("2"
                                          (assert)
                                          (("2"
                                            (replace -5 * LR)
                                            (("2" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (case "subterm(e,G)")
                            (("1" (lemma "subterm_transitivity")
                              (("1"
                                (inst -1 "e" "G" "P_exp(A)")
                                (("1" (assert) nil nil))
                                nil))
                              nil)
                             ("2" (hide 2 3 4)
                              (("2"
                                (replace -4 * LR)
                                (("2"
                                  (assert)
                                  (("2"
                                    (expand "subterm")
                                    (("2"
                                      (expand "subterm")
                                      (("2" (propax) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil nil
   (parsing subtype "peg_parser.s_T"
    "{k: naturalnumbers.upto(peg_parser.s) | booleans.⇒((k = peg_parser.s), wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].pattern_wf?(peg_parser.e1, peg_parser.A, static_analysis[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].σ(peg_parser.P_exp), wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].P_0c(peg_parser.P_exp)))}")))
 (parsing_TCC27 0
  (parsing_TCC32-1 nil 3768836598
   ("" (skeep*)
    (("" (rewrite "lex4_lt")
      (("" (rewrite "lex3_lt")
        (("" (rewrite "lex2_lt") (("" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (lex4_lt formula-decl nil lex4 nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (<= const-decl "bool" reals nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (V_S formal-type-decl nil peg_parser nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (peg type-decl nil peg nil) (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (subterm_of type-eq-decl nil peg nil)
    (wf_nT? const-decl "bool" wf_peg nil)
    (wf_nT type-eq-decl nil wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (pegMeasure const-decl "nat" peg nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lex2_lt formula-decl nil lex2 nil)
    (lex3_lt formula-decl nil lex3 nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (sum const-decl "nat" peg nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (parsing termination
    "peg_parser.parsing(peg_parser.P_exp, peg_parser.A, peg_parser.e1, peg_parser.inp, peg_parser.s, peg_parser.s_T)"
    "nil")))
 (parsing_TCC28 0
  (parsing_TCC28-1 nil 3847126951
   ("" (skeep*)
    (("" (typepred "T1")
      (("" (expand "astWellformed?") (("" (assert) nil nil)) nil))
      nil))
    nil)
   ((σ const-decl "order" static_analysis nil)
    (wf_nT type-eq-decl nil wf_peg nil)
    (wf_nT? const-decl "bool" wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (trueToInput def-decl "bool" ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (parsing subtype "peg_parser.T1"
    "{T: pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].pre_ast | (booleans.¬)(pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].skip?(T))}")))
 (parsing_TCC29 0
  (parsing_TCC45-1 nil 3771853966
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (assert)
        (("" (wf-ast T1) (("" (g_props) (("" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (pre_ast type-decl nil pre_ast nil) (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (peg type-decl nil peg nil) (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (input type-eq-decl nil ast_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (astType type-decl nil ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (wf_nT? const-decl "bool" wf_peg nil)
    (wf_nT type-eq-decl nil wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (g_props def-decl "[bool, bool, bool]" wf_peg nil)
    (V_S formal-type-decl nil peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (astWellformed? def-decl "bool" ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (astType? def-decl "astType" ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (parsing subtype
    "pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].prior(peg_parser.s, pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].e(peg_parser.T1), peg_parser.T1, pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].skip(peg_parser.s, peg_parser.s, peg_parser.e2))"
    "peg_parser.output(peg_parser.P_exp, peg_parser.A, peg_parser.G, peg_parser.inp, peg_parser.s, peg_parser.s_T)")))
 (parsing_TCC30 0
  (parsing_TCC43-1 nil 3768836598
   ("" (skeep*)
    (("" (lemma "peg[V_T, <=, V_N_b].subterm_transitivity")
      (("" (inst -1 "e2" "G" "P_exp(A)")
        (("" (typepred "G")
          (("" (assert)
            (("" (replace -2 1 LR)
              (("" (expand "subterm")
                (("" (expand "subterm") (("" (propax) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((V_N_b formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (subterm_transitivity formula-decl nil peg nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (subterm adt-def-decl "boolean" peg nil)
    (subterm_of type-eq-decl nil peg nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (subterm_of? const-decl "bool" peg nil) (peg type-decl nil peg nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (parsing subtype "peg_parser.e2"
    "peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].subterm_of(peg_parser.P_exp(peg_parser.A))")))
 (parsing_TCC31 0
  (parsing_TCC31-1 nil 3771774354
   ("" (skeep)
    (("" (typepred "s_T")
      (("" (assert)
        (("" (expand "grammar_wellformedness" -) (("" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (wf_nT type-eq-decl nil wf_peg nil)
    (wf_nT? const-decl "bool" wf_peg nil)
    (subterm_of type-eq-decl nil peg nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (V_S formal-type-decl nil peg_parser nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (parsing subtype "peg_parser.s_T"
    "{k: naturalnumbers.upto(peg_parser.s) | booleans.⇒((k = peg_parser.s), wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].pattern_wf?(peg_parser.e2, peg_parser.A, static_analysis[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].σ(peg_parser.P_exp), wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].P_0c(peg_parser.P_exp)))}")))
 (parsing_TCC32 0
  (parsing_TCC37-1 nil 3768836598
   ("" (skeep*)
    (("" (rewrite "lex4_lt")
      (("" (rewrite "lex3_lt")
        (("" (rewrite "lex2_lt") (("" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (lex4_lt formula-decl nil lex4 nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (<= const-decl "bool" reals nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (V_S formal-type-decl nil peg_parser nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (peg type-decl nil peg nil) (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (subterm_of type-eq-decl nil peg nil)
    (wf_nT? const-decl "bool" wf_peg nil)
    (wf_nT type-eq-decl nil wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (pegMeasure const-decl "nat" peg nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lex2_lt formula-decl nil lex2 nil)
    (lex3_lt formula-decl nil lex3 nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (sum const-decl "nat" peg nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (parsing termination
    "peg_parser.parsing(peg_parser.P_exp, peg_parser.A, peg_parser.e2, peg_parser.inp, peg_parser.s, peg_parser.s_T)"
    "nil")))
 (parsing_TCC33 0
  (parsing_TCC33-1 nil 3847126951
   ("" (skeep*)
    (("" (typepred "T1")
      (("" (expand "astWellformed?") (("" (assert) nil nil)) nil))
      nil))
    nil)
   ((σ const-decl "order" static_analysis nil)
    (wf_nT type-eq-decl nil wf_peg nil)
    (wf_nT? const-decl "bool" wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (trueToInput def-decl "bool" ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (parsing subtype "peg_parser.T1"
    "{T: pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].pre_ast | (booleans.¬)(pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].skip?(T))}")))
 (parsing_TCC34 0
  (parsing_TCC55-1 nil 3768836598
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "astWellformed?")
        (("" (expand "trueToGrammar")
          (("" (expand "trueToInput")
            (("" (typepred "T1")
              (("" (lemma "Wellformed_theorem")
                (("" (inst -1 "T1")
                  (("" (typepred "T2")
                    (("" (lemma "Wellformed_theorem")
                      (("" (inst -1 "T2")
                        (("" (assert)
                          (("" (flatten)
                            (("" (expand "P_0c?")
                              ((""
                                (expand "P_sc?")
                                ((""
                                  (expand "P_fc?")
                                  ((""
                                    (expand "g_props" +)
                                    ((""
                                      (split 2)
                                      (("1"
                                        (flatten)
                                        (("1"
                                          (assert)
                                          (("1" (grind) nil nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (flatten)
                                        (("2" (grind) nil nil))
                                        nil)
                                       ("3"
                                        (flatten)
                                        (("3" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((trueToGrammar def-decl "bool" ast_props nil)
    (σ const-decl "order" static_analysis nil)
    (wf_nT type-eq-decl nil wf_peg nil)
    (wf_nT? const-decl "bool" wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (input type-eq-decl nil ast_props nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ast type-eq-decl nil ast nil) (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (r const-decl "C(P_exp)" wf_peg nil)
    (array_sum const-decl "upto(3 * V_N_b)" array_sum nil)
    (nT_properties const-decl "F(P_exp)" wf_peg nil)
    (g_props def-decl "[bool, bool, bool]" wf_peg nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (astWellformed? def-decl "bool" ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (parsing subtype
    "pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].prior(peg_parser.s, pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].e(peg_parser.T2), peg_parser.T1, peg_parser.T2)"
    "peg_parser.output(peg_parser.P_exp, peg_parser.A, peg_parser.G, peg_parser.inp, peg_parser.s, peg_parser.s_T)")))
 (parsing_TCC35 0
  (parsing_TCC45-1 nil 3768836598
   ("" (skeep*)
    (("" (lemma "peg[V_T, <=, V_N_b].subterm_transitivity")
      (("" (inst -1 "e" "G" "P_exp(A)")
        (("" (typepred "G")
          (("" (assert)
            (("" (replace -2 * LR)
              (("" (expand "subterm")
                (("" (expand "subterm") (("" (propax) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((V_N_b formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (subterm_transitivity formula-decl nil peg nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (subterm adt-def-decl "boolean" peg nil)
    (subterm_of type-eq-decl nil peg nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (subterm_of? const-decl "bool" peg nil) (peg type-decl nil peg nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (parsing subtype "peg_parser.e"
    "peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].subterm_of(peg_parser.P_exp(peg_parser.A))")))
 (parsing_TCC36 0
  (parsing_TCC27-1 nil 3771774354
   ("" (skeep)
    (("" (skeep)
      (("" (typepred ("G" "s_T"))
        (("" (assert)
          (("" (expand "grammar_wellformedness" -)
            (("" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (wf_nT type-eq-decl nil wf_peg nil)
    (wf_nT? const-decl "bool" wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (V_S formal-type-decl nil peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (<= const-decl "bool" reals nil)
    (subterm_of type-eq-decl nil peg nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (subterm_of? const-decl "bool" peg nil) (peg type-decl nil peg nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (subterm adt-def-decl "boolean" peg nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (parsing subtype "peg_parser.s_T"
    "{k: naturalnumbers.upto(peg_parser.s) | booleans.⇒((k = peg_parser.s), wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].pattern_wf?(peg_parser.e, peg_parser.A, static_analysis[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].σ(peg_parser.P_exp), wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].P_0c(peg_parser.P_exp)))}")))
 (parsing_TCC37 0
  (parsing_TCC42-1 nil 3768836598 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (peg type-decl nil peg nil) (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (subterm_of? const-decl "bool" peg nil)
    (subterm_of type-eq-decl nil peg nil)
    (<= const-decl "bool" reals nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (V_S formal-type-decl nil peg_parser nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (wf_nT? const-decl "bool" wf_peg nil)
    (wf_nT type-eq-decl nil wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (structural_WF? const-decl "bool" wf_peg nil)
    (pattern_WF? const-decl "bool" wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (inc const-decl "nat" peg nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (< def-decl "bool" ordinals nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (pegMeasure const-decl "nat" peg nil)
    (lex2 const-decl "ordinal" lex2 nil)
    (lex3 const-decl "ordinal" lex3 nil)
    (lex4 const-decl "ordinal" lex4 nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (parsing termination
    "peg_parser.parsing(peg_parser.P_exp, peg_parser.A, peg_parser.e, peg_parser.inp, peg_parser.s, peg_parser.s_T)"
    "nil")))
 (parsing_TCC38 0
  (parsing_TCC38-1 nil 3847126951
   ("" (skeep*)
    (("" (typepred "T0")
      (("" (expand "astWellformed?") (("" (assert) nil nil)) nil))
      nil))
    nil)
   ((σ const-decl "order" static_analysis nil)
    (wf_nT type-eq-decl nil wf_peg nil)
    (wf_nT? const-decl "bool" wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (trueToInput def-decl "bool" ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (parsing subtype "peg_parser.T0"
    "{T: pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].pre_ast | (booleans.¬)(pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].skip?(T))}")))
 (parsing_TCC39 0
  (parsing_TCC52-1 nil 3771853966
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (assert) (("" (wf-ast T0) (("" (g_props) nil nil)) nil))
        nil))
      nil))
    nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (pre_ast type-decl nil pre_ast nil) (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (peg type-decl nil peg nil) (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (input type-eq-decl nil ast_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (astType type-decl nil ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (wf_nT? const-decl "bool" wf_peg nil)
    (wf_nT type-eq-decl nil wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (g_props def-decl "[bool, bool, bool]" wf_peg nil)
    (V_S formal-type-decl nil peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (astWellformed? def-decl "bool" ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (astType? def-decl "astType" ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (parsing subtype
    "pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].star(peg_parser.s, peg_parser.s, peg_parser.T0, pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].skip(pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].e(peg_parser.T0), pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].e(peg_parser.T0), peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].star(peg_parser.e)))"
    "peg_parser.output(peg_parser.P_exp, peg_parser.A, peg_parser.G, peg_parser.inp, peg_parser.s, peg_parser.s_T)")))
 (parsing_TCC40 0
  (parsing_TCC57-1 nil 3771853966
   ("" (skeep*) (("" (typepred "G") (("" (assert) nil nil)) nil)) nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (structural_WF? const-decl "bool" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (wf_nT type-eq-decl nil wf_peg nil)
    (wf_nT? const-decl "bool" wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (V_S formal-type-decl nil peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (<= const-decl "bool" reals nil)
    (subterm_of type-eq-decl nil peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil
   (parsing subtype
    "peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].star(peg_parser.e)"
    "peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].subterm_of(peg_parser.P_exp(peg_parser.A))")))
 (parsing_TCC41 0
  (parsing_TCC35-1 nil 3771774354
   ("" (skeep*)
    (("" (wf-ast T0)
      (("" (typepred "s_T")
        (("" (replaces) (("" (ground) nil nil)) nil)) nil))
      nil))
    nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (V_S formal-type-decl nil peg_parser nil)
    (pre_ast type-decl nil pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (peg type-decl nil peg nil) (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (input type-eq-decl nil ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (wf_nT? const-decl "bool" wf_peg nil)
    (wf_nT type-eq-decl nil wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (subterm_of type-eq-decl nil peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (parsing subtype "peg_parser.s_T"
    "{k: naturalnumbers.upto(pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].e(peg_parser.T0)) | booleans.⇒((k = pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].e(peg_parser.T0)), wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].pattern_wf?(peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].star(peg_parser.e), peg_parser.A, static_analysis[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].σ(peg_parser.P_exp), wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].P_0c(peg_parser.P_exp)))}")))
 (parsing_TCC42 0
  (parsing_TCC48-1 nil 3768836598
   ("" (skeep*)
    (("" (wf-ast T0)
      (("" (assert)
        (("" (assert)
          (("" (flatten)
            (("" (assert)
              (("" (case "e(T0) = s")
                (("1"
                  (lemma "wf_peg[V_T, <=, V_N_b].star_cannot_be_P_0")
                  (("1" (inst -1 "A" "P_exp" "e")
                    (("1" (assert)
                      (("1" (typepred "G") (("1" (assert) nil nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (assert) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (V_S formal-type-decl nil peg_parser nil)
    (pre_ast type-decl nil pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (peg type-decl nil peg nil) (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (input type-eq-decl nil ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (wf_nT? const-decl "bool" wf_peg nil)
    (wf_nT type-eq-decl nil wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lex4_lt formula-decl nil lex4 nil)
    (lex2_lt formula-decl nil lex2 nil)
    (lex3_lt formula-decl nil lex3 nil)
    (star_cannot_be_P_0 formula-decl nil wf_peg nil)
    (subterm_of type-eq-decl nil peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (parsing termination
    "peg_parser.parsing(peg_parser.P_exp, peg_parser.A, peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].star(peg_parser.e), peg_parser.inp, pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].e(peg_parser.T0), peg_parser.s_T)"
    "nil")))
 (parsing_TCC43 0
  (parsing_TCC43-1 nil 3847126951
   ("" (skeep*) (("" (typepred "T0") (("" (grind) nil nil)) nil)) nil)
   ((σ const-decl "order" static_analysis nil)
    (wf_nT type-eq-decl nil wf_peg nil)
    (wf_nT? const-decl "bool" wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (trueToInput def-decl "bool" ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (r const-decl "C(P_exp)" wf_peg nil)
    (array_sum const-decl "upto(3 * V_N_b)" array_sum nil)
    (nT_properties const-decl "F(P_exp)" wf_peg nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (parsing subtype "peg_parser.T0"
    "{T: pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].pre_ast | (booleans.¬)(pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].skip?(T))}")))
 (parsing_TCC44 0
  (parsing_TCC65-1 nil 3769177011
   ("" (skeep*)
    (("" (typepred "Ts")
      (("" (expand "trueToGrammar")
        (("" (lift-if) (("" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((star adt-constructor-decl "[peg -> (star?)]" peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (σ const-decl "order" static_analysis nil)
    (wf_nT type-eq-decl nil wf_peg nil)
    (wf_nT? const-decl "bool" wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (trueToInput def-decl "bool" ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (parsing subtype "peg_parser.Ts"
    "{T: pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].pre_ast | booleans.OR(pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].skip?(T), pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].star?(T))}")))
 (parsing_TCC45 0
  (parsing_TCC57-1 nil 3772300931
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (assert)
        (("" (wf-ast T0)
          (("" (wf-ast Ts)
            (("" (assert)
              (("" (flatten)
                (("" (split -2)
                  (("1" (assert) nil nil) ("2" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (pre_ast type-decl nil pre_ast nil) (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (peg type-decl nil peg nil) (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (input type-eq-decl nil ast_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (astType type-decl nil ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (wf_nT? const-decl "bool" wf_peg nil)
    (wf_nT type-eq-decl nil wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (r const-decl "C(P_exp)" wf_peg nil)
    (array_sum const-decl "upto(3 * V_N_b)" array_sum nil)
    (nT_properties const-decl "F(P_exp)" wf_peg nil)
    (g_props def-decl "[bool, bool, bool]" wf_peg nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (star adt-constructor-decl "[peg -> (star?)]" peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (V_S formal-type-decl nil peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (astWellformed? def-decl "bool" ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (astType? def-decl "astType" ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (parsing subtype
    "pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].star(peg_parser.s, pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].e(peg_parser.Ts), peg_parser.T0, peg_parser.Ts)"
    "peg_parser.output(peg_parser.P_exp, peg_parser.A, peg_parser.G, peg_parser.inp, peg_parser.s, peg_parser.s_T)")))
 (parsing_TCC46 0
  (parsing_TCC53-1 nil 3769284018
   ("" (skeep*)
    (("" (lemma "peg[V_T, <=, V_N_b].subterm_transitivity")
      (("" (inst -1 "e" "G" "P_exp(A)")
        (("" (typepred "G")
          (("" (assert)
            (("" (replace -2 1 LR)
              (("" (expand "subterm")
                (("" (expand "subterm") (("" (propax) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((V_N_b formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (subterm_transitivity formula-decl nil peg nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (subterm adt-def-decl "boolean" peg nil)
    (subterm_of type-eq-decl nil peg nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (subterm_of? const-decl "bool" peg nil) (peg type-decl nil peg nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (parsing subtype "peg_parser.e"
    "peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].subterm_of(peg_parser.P_exp(peg_parser.A))")))
 (parsing_TCC47 0
  (parsing_TCC40-1 nil 3771774354
   ("" (skeep)
    (("" (typepred "s_T") (("" (replaces) (("" (assert) nil nil)) nil))
      nil))
    nil)
   ((P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (wf_nT type-eq-decl nil wf_peg nil)
    (wf_nT? const-decl "bool" wf_peg nil)
    (subterm_of type-eq-decl nil peg nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (V_S formal-type-decl nil peg_parser nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (parsing subtype "peg_parser.s_T"
    "{k: naturalnumbers.upto(peg_parser.s) | booleans.⇒((k = peg_parser.s), wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].pattern_wf?(peg_parser.e, peg_parser.A, static_analysis[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].σ(peg_parser.P_exp), wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].P_0c(peg_parser.P_exp)))}")))
 (parsing_TCC48 0
  (parsing_TCC54-1 nil 3768836598 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (peg type-decl nil peg nil) (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (subterm_of? const-decl "bool" peg nil)
    (subterm_of type-eq-decl nil peg nil)
    (<= const-decl "bool" reals nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (V_S formal-type-decl nil peg_parser nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (wf_nT? const-decl "bool" wf_peg nil)
    (wf_nT type-eq-decl nil wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (structural_WF? const-decl "bool" wf_peg nil)
    (pattern_WF? const-decl "bool" wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (inc const-decl "nat" peg nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (< def-decl "bool" ordinals nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (pegMeasure const-decl "nat" peg nil)
    (lex2 const-decl "ordinal" lex2 nil)
    (lex3 const-decl "ordinal" lex3 nil)
    (lex4 const-decl "ordinal" lex4 nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (parsing termination
    "peg_parser.parsing(peg_parser.P_exp, peg_parser.A, peg_parser.e, peg_parser.inp, peg_parser.s, peg_parser.s_T)"
    "nil")))
 (parsing_TCC49 0
  (parsing_TCC49-1 nil 3847126951
   ("" (skeep*)
    (("" (typepred "T0")
      (("" (expand "astWellformed?") (("" (assert) nil nil)) nil))
      nil))
    nil)
   ((σ const-decl "order" static_analysis nil)
    (wf_nT type-eq-decl nil wf_peg nil)
    (wf_nT? const-decl "bool" wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (trueToInput def-decl "bool" ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (parsing subtype "peg_parser.T0"
    "{T: pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].pre_ast | (booleans.¬)(pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].skip?(T))}")))
 (parsing_TCC50 0
  (parsing_TCC62-1 nil 3772300931
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (assert)
        (("" (typepred "T0")
          (("" (lemma "Wellformed_theorem")
            (("" (inst -1 "T0")
              (("" (assert)
                (("" (expand "astType?" +)
                  (("" (expand "astWellformed?" +)
                    (("" (expand "trueToGrammar" +)
                      (("" (expand "trueToGrammar")
                        (("" (assert) (("" (grind) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((σ const-decl "order" static_analysis nil)
    (wf_nT type-eq-decl nil wf_peg nil)
    (wf_nT? const-decl "bool" wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType type-decl nil ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (input type-eq-decl nil ast_props nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ast type-eq-decl nil ast nil) (pre_ast type-decl nil pre_ast nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (g_props def-decl "[bool, bool, bool]" wf_peg nil)
    (nT_properties const-decl "F(P_exp)" wf_peg nil)
    (array_sum const-decl "upto(3 * V_N_b)" array_sum nil)
    (r const-decl "C(P_exp)" wf_peg nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (V_S formal-type-decl nil peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (astWellformed? def-decl "bool" ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (astType? def-decl "astType" ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (parsing subtype
    "pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].plus(peg_parser.s, peg_parser.s, peg_parser.T0, pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].skip(pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].e(peg_parser.T0), pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].e(peg_parser.T0), peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].plus(peg_parser.e)))"
    "peg_parser.output(peg_parser.P_exp, peg_parser.A, peg_parser.G, peg_parser.inp, peg_parser.s, peg_parser.s_T)")))
 (parsing_TCC51 0
  (parsing_TCC63-1 nil 3772300931 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (peg type-decl nil peg nil) (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (subterm_of type-eq-decl nil peg nil)
    (<= const-decl "bool" reals nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (V_S formal-type-decl nil peg_parser nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (wf_nT? const-decl "bool" wf_peg nil)
    (wf_nT type-eq-decl nil wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (pre_ast type-decl nil pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (pattern_WF? const-decl "bool" wf_peg nil)
    (structural_WF? const-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (parsing subtype
    "peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].plus(peg_parser.e)"
    "peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].subterm_of(peg_parser.P_exp(peg_parser.A))")))
 (parsing_TCC52 0
  (parsing_TCC65-1 nil 3772300931
   ("" (skeep*)
    (("" (typepred "s_T")
      (("" (use "Consumption_growth")
        (("" (typepred "T0")
          (("" (assert)
            (("" (expand "grammar_wellformedness" -)
              (("" (flatten)
                (("" (assert)
                  (("" (replace -12 * LR)
                    (("" (assert)
                      (("" (flatten)
                        (("" (assert)
                          (("" (assert) (("" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (wf_nT type-eq-decl nil wf_peg nil)
    (wf_nT? const-decl "bool" wf_peg nil)
    (subterm_of type-eq-decl nil peg nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (V_S formal-type-decl nil peg_parser nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (r const-decl "C(P_exp)" wf_peg nil)
    (array_sum const-decl "upto(3 * V_N_b)" array_sum nil)
    (nT_properties const-decl "F(P_exp)" wf_peg nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (pre_ast type-decl nil pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (Consumption_growth formula-decl nil ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (parsing subtype "peg_parser.s_T"
    "{k: naturalnumbers.upto(pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].e(peg_parser.T0)) | booleans.⇒((k = pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].e(peg_parser.T0)), wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].pattern_wf?(peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].plus(peg_parser.e), peg_parser.A, static_analysis[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].σ(peg_parser.P_exp), wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].P_0c(peg_parser.P_exp)))}")))
 (parsing_TCC53 0
  (parsing_TCC66-1 nil 3772300931
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (typepred "s_T")
        (("" (wf-ast T0)
          (("" (assert)
            (("" (flatten)
              (("" (assert)
                (("" (assert)
                  (("" (case "e(T0) = s")
                    (("1" (use "plus_cannot_be_P_0")
                      (("1" (typepred "G") (("1" (assert) nil nil))
                        nil))
                      nil)
                     ("2" (assert) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((pre_ast type-decl nil pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (lex2_lt formula-decl nil lex2 nil)
    (lex3_lt formula-decl nil lex3 nil)
    (plus_cannot_be_P_0 formula-decl nil wf_peg nil)
    (lex4_lt formula-decl nil lex4 nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (V_S formal-type-decl nil peg_parser nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (peg type-decl nil peg nil) (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (subterm_of type-eq-decl nil peg nil)
    (wf_nT? const-decl "bool" wf_peg nil)
    (wf_nT type-eq-decl nil wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (parsing termination
    "peg_parser.parsing(peg_parser.P_exp, peg_parser.A, peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].plus(peg_parser.e), peg_parser.inp, pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].e(peg_parser.T0), peg_parser.s_T)"
    "nil")))
 (parsing_TCC54 0
  (parsing_TCC54-1 nil 3847126951
   ("" (skeep*)
    (("" (typepred "T0")
      (("" (expand "astWellformed?") (("" (assert) nil nil)) nil))
      nil))
    nil)
   ((σ const-decl "order" static_analysis nil)
    (wf_nT type-eq-decl nil wf_peg nil)
    (wf_nT? const-decl "bool" wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (trueToInput def-decl "bool" ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (parsing subtype "peg_parser.T0"
    "{T: pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].pre_ast | (booleans.¬)(pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].skip?(T))}")))
 (parsing_TCC55 0
  (parsing_TCC68-1 nil 3772300931
   ("" (skeep*)
    (("" (typepred "Ts")
      (("" (expand "trueToGrammar")
        (("" (assert) (("" (lift-if) (("" (assert) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((plus adt-constructor-decl "[peg -> (plus?)]" peg nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (σ const-decl "order" static_analysis nil)
    (wf_nT type-eq-decl nil wf_peg nil)
    (wf_nT? const-decl "bool" wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (trueToInput def-decl "bool" ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (parsing subtype "peg_parser.Ts"
    "{T: pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].pre_ast | booleans.OR(pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].skip?(T), booleans.OR(pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].plus?(T), pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].fail?(T)))}")))
 (parsing_TCC56 0
  (parsing_TCC69-1 nil 3772300931
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (wf-ast T0)
        (("" (wf-ast Ts)
          (("" (assert)
            (("" (flatten)
              (("" (assert)
                (("" (g_props)
                  (("" (use "plus_cannot_be_P_0")
                    (("" (typepred "G")
                      (("" (assert) (("" (grind) nil nil)) nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus adt-constructor-decl "[peg -> (plus?)]" peg nil)
    (g_props def-decl "[bool, bool, bool]" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (subterm_of type-eq-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (r const-decl "C(P_exp)" wf_peg nil)
    (array_sum const-decl "upto(3 * V_N_b)" array_sum nil)
    (nT_properties const-decl "F(P_exp)" wf_peg nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (plus_cannot_be_P_0 formula-decl nil wf_peg nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (σ const-decl "order" static_analysis nil)
    (wf_nT type-eq-decl nil wf_peg nil)
    (wf_nT? const-decl "bool" wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (trueToInput def-decl "bool" ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (parsing subtype
    "pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].plus(peg_parser.s, pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].e(peg_parser.Ts), peg_parser.T0, peg_parser.Ts)"
    "peg_parser.output(peg_parser.P_exp, peg_parser.A, peg_parser.G, peg_parser.inp, peg_parser.s, peg_parser.s_T)")))
 (parsing_TCC57 0
  (parsing_TCC70-1 nil 3772300931
   ("" (skeep*)
    (("" (typepred "G")
      (("" (lemma "peg[V_T, <=, V_N_b].subterm_transitivity")
        (("" (inst -1 "e" "G" " P_exp(A)") (("" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((subterm_of type-eq-decl nil peg nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (subterm_of? const-decl "bool" peg nil) (peg type-decl nil peg nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (subterm adt-def-decl "boolean" peg nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (subterm_transitivity formula-decl nil peg nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (parsing subtype "peg_parser.e"
    "peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].subterm_of(peg_parser.P_exp(peg_parser.A))")))
 (parsing_TCC58 0
  (parsing_TCC81-1 nil 3772300931
   ("" (skeep) (("" (typepred "s_T") (("" (grind) nil nil)) nil)) nil)
   ((P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (wf_nT type-eq-decl nil wf_peg nil)
    (wf_nT? const-decl "bool" wf_peg nil)
    (subterm_of type-eq-decl nil peg nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (V_S formal-type-decl nil peg_parser nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (parsing subtype "peg_parser.s_T"
    "{k: naturalnumbers.upto(peg_parser.s) | booleans.⇒((k = peg_parser.s), wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].pattern_wf?(peg_parser.e, peg_parser.A, static_analysis[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].σ(peg_parser.P_exp), wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].P_0c(peg_parser.P_exp)))}")))
 (parsing_TCC59 0
  (parsing_TCC72-1 nil 3772300931 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (peg type-decl nil peg nil) (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (subterm_of? const-decl "bool" peg nil)
    (subterm_of type-eq-decl nil peg nil)
    (<= const-decl "bool" reals nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (V_S formal-type-decl nil peg_parser nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (wf_nT? const-decl "bool" wf_peg nil)
    (wf_nT type-eq-decl nil wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (structural_WF? const-decl "bool" wf_peg nil)
    (pattern_WF? const-decl "bool" wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (inc const-decl "nat" peg nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (< def-decl "bool" ordinals nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (pegMeasure const-decl "nat" peg nil)
    (lex2 const-decl "ordinal" lex2 nil)
    (lex3 const-decl "ordinal" lex3 nil)
    (lex4 const-decl "ordinal" lex4 nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (parsing termination
    "peg_parser.parsing(peg_parser.P_exp, peg_parser.A, peg_parser.e, peg_parser.inp, peg_parser.s, peg_parser.s_T)"
    "nil")))
 (parsing_TCC60 0
  (parsing_TCC60-1 nil 3847126951
   ("" (skeep*) (("" (typepred "T") (("" (grind) nil nil)) nil)) nil)
   ((σ const-decl "order" static_analysis nil)
    (wf_nT type-eq-decl nil wf_peg nil)
    (wf_nT? const-decl "bool" wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (trueToInput def-decl "bool" ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (r const-decl "C(P_exp)" wf_peg nil)
    (array_sum const-decl "upto(3 * V_N_b)" array_sum nil)
    (nT_properties const-decl "F(P_exp)" wf_peg nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (parsing subtype "peg_parser.T"
    "{T: pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].pre_ast | (booleans.¬)(pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].skip?(T))}")))
 (parsing_TCC61 0
  (parsing_TCC74-1 nil 3772307450
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (wf-ast T) (("" (g_props) nil nil)) nil)) nil))
    nil)
   ((g_props def-decl "[bool, bool, bool]" wf_peg nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (σ const-decl "order" static_analysis nil)
    (wf_nT type-eq-decl nil wf_peg nil)
    (wf_nT? const-decl "bool" wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (trueToInput def-decl "bool" ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (parsing subtype
    "pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].opt(peg_parser.s, peg_parser.s, peg_parser.T)"
    "peg_parser.output(peg_parser.P_exp, peg_parser.A, peg_parser.G, peg_parser.inp, peg_parser.s, peg_parser.s_T)")))
 (parsing_TCC62 0
  (parsing_TCC62-1 nil 3847126951
   ("" (skeep*) (("" (typepred "T") (("" (grind) nil nil)) nil)) nil)
   ((σ const-decl "order" static_analysis nil)
    (wf_nT type-eq-decl nil wf_peg nil)
    (wf_nT? const-decl "bool" wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (trueToInput def-decl "bool" ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (r const-decl "C(P_exp)" wf_peg nil)
    (array_sum const-decl "upto(3 * V_N_b)" array_sum nil)
    (nT_properties const-decl "F(P_exp)" wf_peg nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (parsing subtype "peg_parser.T"
    "{T: pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].pre_ast | (booleans.¬)(pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].skip?(T))}")))
 (parsing_TCC63 0
  (parsing_TCC74-1 nil 3772300931
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "trueToGrammar")
        (("" (expand "trueToInput")
          (("" (expand "astType?" 2)
            (("" (assert)
              (("" (expand "astWellformed?")
                (("" (lift-if)
                  (("" (assert)
                    (("" (use "Wellformed_theorem")
                      (("" (assert)
                        (("" (flatten)
                          (("" (assert)
                            (("" (typepred "T")
                              ((""
                                (expand "P_0c?")
                                ((""
                                  (expand "P_sc?")
                                  ((""
                                    (expand "g_props" +)
                                    ((""
                                      (assert)
                                      (("" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((trueToInput def-decl "bool" ast_props nil)
    (astWellformed? def-decl "bool" ast nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (V_S formal-type-decl nil peg_parser nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (r const-decl "C(P_exp)" wf_peg nil)
    (array_sum const-decl "upto(3 * V_N_b)" array_sum nil)
    (nT_properties const-decl "F(P_exp)" wf_peg nil)
    (g_props def-decl "[bool, bool, bool]" wf_peg nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (pre_ast type-decl nil pre_ast nil) (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (peg type-decl nil peg nil) (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (input type-eq-decl nil ast_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (astType type-decl nil ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (wf_nT? const-decl "bool" wf_peg nil)
    (wf_nT type-eq-decl nil wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (parsing subtype
    "pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].opt(peg_parser.s, pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].e(peg_parser.T), peg_parser.T)"
    "peg_parser.output(peg_parser.P_exp, peg_parser.A, peg_parser.G, peg_parser.inp, peg_parser.s, peg_parser.s_T)")))
 (parsing_TCC64 0
  (parsing_TCC75-1 nil 3772300931
   ("" (skeep)
    (("" (lemma "peg[V_T, <=, V_N_b].subterm_transitivity")
      (("" (inst -1 "e" "G" "P_exp(A)")
        (("" (typepred "G") (("" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((V_N_b formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (subterm_transitivity formula-decl nil peg nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (subterm adt-def-decl "boolean" peg nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (subterm_of type-eq-decl nil peg nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (subterm_of? const-decl "bool" peg nil)
    (peg type-decl nil peg nil))
   nil
   (parsing subtype "peg_parser.e"
    "peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].subterm_of(peg_parser.P_exp(peg_parser.A))")))
 (parsing_TCC65 0
  (parsing_TCC71-1 nil 3772300931
   ("" (skeep*) (("" (typepred "s_T") (("" (grind) nil nil)) nil)) nil)
   ((P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (wf_nT type-eq-decl nil wf_peg nil)
    (wf_nT? const-decl "bool" wf_peg nil)
    (subterm_of type-eq-decl nil peg nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (V_S formal-type-decl nil peg_parser nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (parsing subtype "peg_parser.s_T"
    "{k: naturalnumbers.upto(peg_parser.s) | booleans.⇒((k = peg_parser.s), wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].pattern_wf?(peg_parser.e, peg_parser.A, static_analysis[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].σ(peg_parser.P_exp), wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].P_0c(peg_parser.P_exp)))}")))
 (parsing_TCC66 0
  (parsing_TCC77-1 nil 3772300931
   ("" (skeep)
    (("" (rewrite "lex4_lt")
      (("" (replace -1 * LR) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (lex4_lt formula-decl nil lex4 nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (<= const-decl "bool" reals nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (V_S formal-type-decl nil peg_parser nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (peg type-decl nil peg nil) (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (subterm_of type-eq-decl nil peg nil)
    (wf_nT? const-decl "bool" wf_peg nil)
    (wf_nT type-eq-decl nil wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (pegMeasure const-decl "nat" peg nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lex2_lt formula-decl nil lex2 nil)
    (lex3_lt formula-decl nil lex3 nil) (inc const-decl "nat" peg nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil))
   nil
   (parsing termination
    "peg_parser.parsing(peg_parser.P_exp, peg_parser.A, peg_parser.e, peg_parser.inp, peg_parser.s, peg_parser.s_T)"
    "nil")))
 (parsing_TCC67 0
  (parsing_TCC67-1 nil 3847126951 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (peg type-decl nil peg nil) (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (subterm_of? const-decl "bool" peg nil)
    (subterm_of type-eq-decl nil peg nil)
    (<= const-decl "bool" reals nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (V_S formal-type-decl nil peg_parser nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (wf_nT? const-decl "bool" wf_peg nil)
    (wf_nT type-eq-decl nil wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (pre_ast type-decl nil pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (nT_properties const-decl "F(P_exp)" wf_peg nil)
    (array_sum const-decl "upto(3 * V_N_b)" array_sum nil)
    (r const-decl "C(P_exp)" wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (pattern_WF? const-decl "bool" wf_peg nil)
    (structural_WF? const-decl "bool" wf_peg nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (parsing subtype "peg_parser.T"
    "{T: pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].pre_ast | (booleans.¬)(pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].skip?(T))}")))
 (parsing_TCC68 0
  (parsing_TCC79-1 nil 3772300931
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (wf-ast T)
        (("" (g_props)
          (("" (flatten) (("" (assert) (("" (grind) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((g_props def-decl "[bool, bool, bool]" wf_peg nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (r const-decl "C(P_exp)" wf_peg nil)
    (array_sum const-decl "upto(3 * V_N_b)" array_sum nil)
    (nT_properties const-decl "F(P_exp)" wf_peg nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (σ const-decl "order" static_analysis nil)
    (wf_nT type-eq-decl nil wf_peg nil)
    (wf_nT? const-decl "bool" wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (trueToInput def-decl "bool" ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (parsing subtype
    "pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].notP(peg_parser.s, peg_parser.s, peg_parser.T)"
    "peg_parser.output(peg_parser.P_exp, peg_parser.A, peg_parser.G, peg_parser.inp, peg_parser.s, peg_parser.s_T)")))
 (parsing_TCC69 0
  (parsing_TCC80-1 nil 3772300931
   ("" (skeep)
    (("" (lemma "peg[V_T, <=, V_N_b].subterm_transitivity")
      (("" (inst -1 "e" "G" "P_exp(A)")
        (("" (typepred "G") (("" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((V_N_b formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (subterm_transitivity formula-decl nil peg nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (subterm adt-def-decl "boolean" peg nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (subterm_of type-eq-decl nil peg nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (subterm_of? const-decl "bool" peg nil)
    (peg type-decl nil peg nil))
   nil
   (parsing subtype "peg_parser.e"
    "peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].subterm_of(peg_parser.P_exp(peg_parser.A))")))
 (parsing_TCC70 0
  (parsing_TCC76-1 nil 3772300931
   ("" (skeep) (("" (typepred "s_T") (("" (grind) nil nil)) nil)) nil)
   ((P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (wf_nT type-eq-decl nil wf_peg nil)
    (wf_nT? const-decl "bool" wf_peg nil)
    (subterm_of type-eq-decl nil peg nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (V_S formal-type-decl nil peg_parser nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (parsing subtype "peg_parser.s_T"
    "{k: naturalnumbers.upto(peg_parser.s) | booleans.⇒((k = peg_parser.s), wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].pattern_wf?(peg_parser.e, peg_parser.A, static_analysis[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].σ(peg_parser.P_exp), wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].P_0c(peg_parser.P_exp)))}")))
 (parsing_TCC71 0
  (parsing_TCC82-1 nil 3772300931 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (peg type-decl nil peg nil) (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (subterm_of? const-decl "bool" peg nil)
    (subterm_of type-eq-decl nil peg nil)
    (<= const-decl "bool" reals nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (V_S formal-type-decl nil peg_parser nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (wf_nT? const-decl "bool" wf_peg nil)
    (wf_nT type-eq-decl nil wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (structural_WF? const-decl "bool" wf_peg nil)
    (pattern_WF? const-decl "bool" wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (inc const-decl "nat" peg nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (< def-decl "bool" ordinals nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (pegMeasure const-decl "nat" peg nil)
    (lex2 const-decl "ordinal" lex2 nil)
    (lex3 const-decl "ordinal" lex3 nil)
    (lex4 const-decl "ordinal" lex4 nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (parsing termination
    "peg_parser.parsing(peg_parser.P_exp, peg_parser.A, peg_parser.e, peg_parser.inp, peg_parser.s, peg_parser.s_T)"
    "nil")))
 (parsing_TCC72 0
  (parsing_TCC72-1 nil 3847126951 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (peg type-decl nil peg nil) (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (subterm_of? const-decl "bool" peg nil)
    (subterm_of type-eq-decl nil peg nil)
    (<= const-decl "bool" reals nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (V_S formal-type-decl nil peg_parser nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (wf_nT? const-decl "bool" wf_peg nil)
    (wf_nT type-eq-decl nil wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (pre_ast type-decl nil pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (nT_properties const-decl "F(P_exp)" wf_peg nil)
    (array_sum const-decl "upto(3 * V_N_b)" array_sum nil)
    (r const-decl "C(P_exp)" wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (pattern_WF? const-decl "bool" wf_peg nil)
    (structural_WF? const-decl "bool" wf_peg nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (parsing subtype "peg_parser.T"
    "{T: pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].pre_ast | (booleans.¬)(pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].skip?(T))}")))
 (parsing_TCC73 0
  (parsing_TCC84-1 nil 3772300931
   ("" (skeep*)
    (("" (expand "trueToGrammar")
      (("" (expand "trueToInput")
        (("" (replace -1 * LR)
          (("" (expand "astWellformed?")
            (("" (expand "astType?")
              (("" (typepred "T")
                (("" (expand "P_0c?")
                  (("" (expand "P_fc?")
                    (("" (expand "g_props" +)
                      (("" (assert)
                        (("" (use "Wellformed_theorem")
                          (("" (assert)
                            (("" (flatten)
                              ((""
                                (assert)
                                (("" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((trueToGrammar def-decl "bool" ast_props nil)
    (astType? def-decl "astType" ast nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (r const-decl "C(P_exp)" wf_peg nil)
    (array_sum const-decl "upto(3 * V_N_b)" array_sum nil)
    (nT_properties const-decl "F(P_exp)" wf_peg nil)
    (g_props def-decl "[bool, bool, bool]" wf_peg nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (V_S formal-type-decl nil peg_parser nil)
    (pre_ast type-decl nil pre_ast nil) (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (peg type-decl nil peg nil) (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (input type-eq-decl nil ast_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (astType type-decl nil ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (wf_nT? const-decl "bool" wf_peg nil)
    (wf_nT type-eq-decl nil wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (astWellformed? def-decl "bool" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (parsing subtype
    "pre_ast[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b, peg_parser.bound, peg_parser.V_S].andP(peg_parser.s, peg_parser.s, peg_parser.T)"
    "peg_parser.output(peg_parser.P_exp, peg_parser.A, peg_parser.G, peg_parser.inp, peg_parser.s, peg_parser.s_T)")))
 (reference_parser_theorem 0
  (reference_parser_theorem-1 nil 3784800164
   ("" (skolem 1 ("P_exp" "_" "_" "inp" "_" "_"))
    ((""
      (case "FORALL (i : nat, A: below(V_N_b),
                        G: subterm_of(P_exp(A)),
                        s: upto(bound), s_T: {k: upto(s) | (k = s) ⇒ pattern_wf?(G, A, σ(P_exp), P_0c(P_exp))}):
                        astMeasure(parsing( P_exp, A, G, inp, s, s_T)) <= i IMPLIES
        								parseTree?(parsing( P_exp, A, G, inp, s, s_T))")
      (("1" (skeep)
        (("1"
          (inst -1 "astMeasure(parsing( P_exp, A, G, inp, s, s_T))" "A"
           "G" "s" "s_T")
          (("1" (assert) nil nil)) nil))
        nil)
       ("2" (hide 2)
        (("2" (induct "i")
          (("1" (skolem 1 ("A" "_" "_" "_"))
            (("1" (induct "G")
              (("1" (assert) nil nil) ("2" (grind) nil nil)
               ("3" (grind) nil nil) ("4" (grind) nil nil)
               ("5" (grind) nil nil) ("6" (grind) nil nil)
               ("7" (skeep*)
                (("7" (hide -1 -2 -3 1) (("7" (grind) nil nil)) nil))
                nil)
               ("8" (skeep*)
                (("8" (hide -1 -2 -3 1)
                  (("8" (expand "parsing") (("8" (grind) nil nil))
                    nil))
                  nil))
                nil)
               ("9" (skeep*)
                (("9" (hide -1 -2 1)
                  (("9" (assert)
                    (("9" (expand "parsing")
                      (("9" (assert)
                        (("9" (lift-if)
                          (("9" (split)
                            (("1" (flatten) (("1" (grind) nil nil))
                              nil)
                             ("2" (flatten)
                              (("2"
                                (assert)
                                (("2"
                                  (expand "astMeasure")
                                  (("2"
                                    (expand "reduce_nat")
                                    (("2" (ground) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("10" (skeep*)
                (("10" (hide 1 -1 -2)
                  (("10" (expand "parsing")
                    (("10" (expand "astMeasure")
                      (("10" (expand "reduce_nat")
                        (("10" (lift-if) (("10" (ground) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("11" (grind) nil nil) ("12" (grind) nil nil)
               ("13" (grind) nil nil))
              nil))
            nil)
           ("2" (skolem 1 "i")
            (("2" (flatten)
              (("2" (skolem 1 ("A" "_" "_" "_"))
                (("2" (induct "G" 1)
                  (("1" (assert) nil nil) ("2" (grind) nil nil)
                   ("3" (grind) nil nil) ("4" (grind) nil nil)
                   ("5" (grind) nil nil)
                   ("6" (skolem 1 "B")
                    (("6" (flatten)
                      (("6" (skeep)
                        (("6" (expand "parsing" -2)
                          (("6" (inst -3 "B" "P_exp(B)" "s" "s")
                            (("6" (assert)
                              (("6"
                                (split -3)
                                (("1"
                                  (expand "parseTree?")
                                  (("1"
                                    (skeep)
                                    (("1"
                                      (inst - "T_p")
                                      (("1"
                                        (expand "parsing" -4)
                                        (("1"
                                          (assert)
                                          (("1" (grind) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("7" (skolem 1 ("e1" "e2"))
                    (("7" (flatten)
                      (("7" (skeep)
                        (("7" (assert)
                          (("7" (use "subterm_seq" (G "P_exp(A)"))
                            (("7" (assert)
                              (("7"
                                (flatten)
                                (("7"
                                  (assert)
                                  (("7"
                                    (expand "parsing" 1)
                                    (("7"
                                      (inst -3 "s" "s_T")
                                      (("1"
                                        (expand "parsing" -6)
                                        (("1"
                                          (split 1)
                                          (("1"
                                            (flatten)
                                            (("1"
                                              (assert)
                                              (("1"
                                                (expand "parseTree?")
                                                (("1"
                                                  (skeep)
                                                  (("1"
                                                    (split -6)
                                                    (("1"
                                                      (inst - "T_p")
                                                      (("1"
                                                        (expand
                                                         "subterm"
                                                         -3)
                                                        (("1"
                                                          (assert)
                                                          (("1"
                                                            (expand
                                                             "subterm"
                                                             -2)
                                                            (("1"
                                                              (propax)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (hide
                                                       -1
                                                       -2
                                                       -3
                                                       -4
                                                       -5
                                                       -7)
                                                      (("2"
                                                        (grind)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (flatten)
                                            (("2"
                                              (expand "parseTree?")
                                              (("2"
                                                (assert)
                                                (("2"
                                                  (skeep)
                                                  (("2"
                                                    (assert)
                                                    (("2"
                                                      (split -5)
                                                      (("1"
                                                        (inst - "T_p")
                                                        (("1"
                                                          (expand
                                                           "subterm"
                                                           -2)
                                                          (("1"
                                                            (assert)
                                                            (("1"
                                                              (inst
                                                               -5
                                                               "e(parsing(P_exp, A, e1, inp, s, s_T))"
                                                               "s_T")
                                                              (("1"
                                                                (assert)
                                                                (("1"
                                                                  (split
                                                                   -5)
                                                                  (("1"
                                                                    (inst
                                                                     -
                                                                     "T_p")
                                                                    (("1"
                                                                      (assert)
                                                                      nil
                                                                      nil))
                                                                    nil)
                                                                   ("2"
                                                                    (grind)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil)
                                                       ("2"
                                                        (grind)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (assert)
                                        (("2"
                                          (flatten)
                                          (("2"
                                            (assert)
                                            (("2"
                                              (typepred "s_T")
                                              (("2" (assert) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("8" (skolem 1 ("e1" "e2"))
                    (("8" (flatten)
                      (("8" (assert)
                        (("8" (use "subterm_prior" (G "P_exp(A)"))
                          (("8" (assert)
                            (("8" (flatten)
                              (("8"
                                (assert)
                                (("8"
                                  (skeep)
                                  (("8"
                                    (inst -3 "s" "s_T")
                                    (("1"
                                      (inst -4 "s" "s_T")
                                      (("1"
                                        (expand "parsing" 1)
                                        (("1"
                                          (expand "parsing" -6)
                                          (("1"
                                            (hide -7)
                                            (("1"
                                              (split 1)
                                              (("1"
                                                (flatten)
                                                (("1"
                                                  (assert)
                                                  (("1"
                                                    (ground)
                                                    (("1"
                                                      (expand
                                                       "parseTree?")
                                                      (("1"
                                                        (skeep)
                                                        (("1"
                                                          (inst
                                                           -
                                                           "T_p")
                                                          (("1"
                                                            (inst
                                                             -
                                                             "T_p")
                                                            (("1"
                                                              (grind)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (hide 1)
                                                      (("2"
                                                        (expand
                                                         "parseTree?")
                                                        (("2"
                                                          (skeep)
                                                          (("2"
                                                            (inst
                                                             -
                                                             "T_p")
                                                            (("2"
                                                              (grind)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("3"
                                                      (hide 2)
                                                      (("3"
                                                        (grind)
                                                        nil
                                                        nil))
                                                      nil)
                                                     ("4"
                                                      (grind)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (flatten)
                                                (("2"
                                                  (assert)
                                                  (("2"
                                                    (expand
                                                     "parseTree?")
                                                    (("2"
                                                      (skeep)
                                                      (("2"
                                                        (ground)
                                                        (("1"
                                                          (inst
                                                           -
                                                           "T_p")
                                                          (("1"
                                                            (inst
                                                             -
                                                             "T_p")
                                                            (("1"
                                                              (grind)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("2"
                                                          (inst
                                                           -
                                                           "T_p")
                                                          (("2"
                                                            (grind)
                                                            nil
                                                            nil))
                                                          nil)
                                                         ("3"
                                                          (grind)
                                                          nil
                                                          nil)
                                                         ("4"
                                                          (grind)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (typepred "s_T")
                                        (("2"
                                          (flatten)
                                          (("2" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (typepred "s_T")
                                      (("2"
                                        (flatten)
                                        (("2" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("9" (skolem 1 "e")
                    (("9" (flatten)
                      (("9" (assert)
                        (("9" (use "subterm_star" (G "P_exp(A)"))
                          (("9" (assert)
                            (("9" (skeep)
                              (("9"
                                (inst -2 "s" "s_T")
                                (("1"
                                  (assert)
                                  (("1"
                                    (inst
                                     -5
                                     "A"
                                     "star(e)"
                                     "e(parsing(P_exp, A, e, inp, s, s_T))"
                                     "s_T")
                                    (("1"
                                      (expand "parsing" 1)
                                      (("1"
                                        (expand "parsing" -4)
                                        (("1"
                                          (expand "parseTree?")
                                          (("1"
                                            (assert)
                                            (("1"
                                              (ground)
                                              (("1"
                                                (skeep)
                                                (("1"
                                                  (inst - "T_p")
                                                  (("1"
                                                    (inst - "T_p")
                                                    (("1"
                                                      (assert)
                                                      (("1"
                                                        (expand
                                                         "subterm"
                                                         -2)
                                                        (("1"
                                                          (expand
                                                           "subterm"
                                                           -2)
                                                          (("1"
                                                            (propax)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (skeep)
                                                (("2"
                                                  (inst - "T_p")
                                                  (("2"
                                                    (assert)
                                                    (("2"
                                                      (expand
                                                       "subterm"
                                                       -2)
                                                      (("2"
                                                        (expand
                                                         "subterm"
                                                         -2)
                                                        (("2"
                                                          (propax)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("3"
                                                (skeep)
                                                (("3"
                                                  (inst - "T_p")
                                                  (("3"
                                                    (inst - "T_p")
                                                    (("3"
                                                      (assert)
                                                      (("3"
                                                        (expand
                                                         "subterm"
                                                         -1)
                                                        (("3"
                                                          (propax)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("4"
                                                (skeep)
                                                (("4"
                                                  (inst - "T_p")
                                                  (("4"
                                                    (assert)
                                                    (("4"
                                                      (expand
                                                       "subterm"
                                                       -1)
                                                      (("4"
                                                        (assert)
                                                        (("4"
                                                          (hide
                                                           2
                                                           3
                                                           -1
                                                           -2
                                                           -3
                                                           -4)
                                                          (("4"
                                                            (expand
                                                             "astMeasure")
                                                            (("4"
                                                              (expand
                                                               "reduce_nat"
                                                               -1)
                                                              (("4"
                                                                (assert)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("5"
                                                (skeep)
                                                (("5"
                                                  (inst - "T_p")
                                                  (("5"
                                                    (hide
                                                     -1
                                                     -2
                                                     -3
                                                     -4
                                                     -5
                                                     -6)
                                                    (("5"
                                                      (expand
                                                       "astMeasure")
                                                      (("5"
                                                        (expand
                                                         "reduce_nat"
                                                         -)
                                                        (("5"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("6"
                                                (skeep)
                                                (("6"
                                                  (assert)
                                                  (("6"
                                                    (expand
                                                     "subterm"
                                                     -2)
                                                    (("6"
                                                      (expand
                                                       "subterm"
                                                       -2
                                                       2)
                                                      (("6"
                                                        (hide
                                                         -1
                                                         -2
                                                         -3
                                                         -4
                                                         -5)
                                                        (("6"
                                                          (expand
                                                           "astMeasure")
                                                          (("6"
                                                            (expand
                                                             "reduce_nat"
                                                             -)
                                                            (("6"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("7"
                                                (skeep)
                                                (("7"
                                                  (inst - "T_p")
                                                  (("7"
                                                    (assert)
                                                    (("7"
                                                      (expand
                                                       "subterm"
                                                       -1)
                                                      (("7"
                                                        (assert)
                                                        (("7"
                                                          (expand
                                                           "astMeasure")
                                                          (("7"
                                                            (expand
                                                             "reduce_nat"
                                                             -)
                                                            (("7"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("8"
                                                (expand "astMeasure")
                                                (("8"
                                                  (expand
                                                   "reduce_nat"
                                                   -)
                                                  (("8"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (typepred "s_T")
                                      (("2"
                                        (assert)
                                        (("2"
                                          (typepred
                                           "parsing(P_exp, A, e, inp, s, s_T)")
                                          (("1"
                                            (lemma
                                             "Wellformed_theorem")
                                            (("1"
                                              (inst
                                               -1
                                               "parsing(P_exp, A, e, inp, s, s_T)")
                                              (("1"
                                                (assert)
                                                (("1"
                                                  (flatten)
                                                  (("1"
                                                    (assert)
                                                    (("1"
                                                      (flatten)
                                                      (("1"
                                                        (assert)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2" (propax) nil nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("3"
                                      (typepred "s_T")
                                      (("3"
                                        (flatten)
                                        (("3" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (typepred "s_T")
                                  (("2"
                                    (flatten)
                                    (("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("10" (assert)
                    (("10" (skolem 1 "e")
                      (("10" (flatten)
                        (("10" (skeep)
                          (("10"
                            (lemma
                             "peg[V_T, <=, V_N_b].subterm_transitivity")
                            (("10" (inst -1 "e" "plus(e)" "P_exp(A)")
                              (("10"
                                (assert)
                                (("10"
                                  (expand "subterm" -1 1)
                                  (("10"
                                    (assert)
                                    (("10"
                                      (inst -2 "s" "s_T")
                                      (("1"
                                        (inst
                                         -5
                                         "A"
                                         "plus(e)"
                                         "e(parsing(P_exp, A, e, inp, s, s_T))"
                                         "s_T")
                                        (("1"
                                          (expand "parsing" 1)
                                          (("1"
                                            (expand "parseTree?")
                                            (("1"
                                              (ground)
                                              (("1"
                                                (skeep)
                                                (("1"
                                                  (inst - "T_p")
                                                  (("1"
                                                    (inst - "T_p")
                                                    (("1"
                                                      (assert)
                                                      (("1"
                                                        (expand
                                                         "subterm"
                                                         -2)
                                                        (("1"
                                                          (expand
                                                           "subterm"
                                                           -2)
                                                          (("1"
                                                            (propax)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (skeep)
                                                (("2"
                                                  (inst - "T_p")
                                                  (("2"
                                                    (assert)
                                                    (("2"
                                                      (expand
                                                       "subterm"
                                                       -2)
                                                      (("2"
                                                        (expand
                                                         "subterm"
                                                         -2)
                                                        (("2"
                                                          (propax)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("3"
                                                (skeep)
                                                (("3"
                                                  (inst - "T_p")
                                                  (("3"
                                                    (inst - "T_p")
                                                    (("3"
                                                      (assert)
                                                      (("3"
                                                        (expand
                                                         "subterm"
                                                         -1)
                                                        (("3"
                                                          (propax)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("4"
                                                (skeep)
                                                (("4"
                                                  (inst - "T_p")
                                                  (("4"
                                                    (assert)
                                                    (("4"
                                                      (expand
                                                       "subterm"
                                                       -1)
                                                      (("4"
                                                        (expand
                                                         "parsing"
                                                         -5)
                                                        (("4"
                                                          (name-replace
                                                           "ep"
                                                           "e(parsing(P_exp, A, e, inp, s, s_T))")
                                                          (("4"
                                                            (expand
                                                             "astMeasure")
                                                            (("4"
                                                              (expand
                                                               "reduce_nat"
                                                               -)
                                                              (("4"
                                                                (assert)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("5"
                                                (skeep*)
                                                (("5"
                                                  (inst - "T_p")
                                                  (("5"
                                                    (assert)
                                                    (("5"
                                                      (expand
                                                       "parsing"
                                                       -6)
                                                      (("5"
                                                        (name-replace
                                                         "ep"
                                                         "e(parsing(P_exp, A, e, inp, s, s_T))")
                                                        (("5"
                                                          (expand
                                                           "astMeasure")
                                                          (("5"
                                                            (expand
                                                             "reduce_nat"
                                                             -)
                                                            (("5"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("6"
                                                (expand "parsing" -4)
                                                (("6"
                                                  (name-replace
                                                   "ep"
                                                   "e(parsing(P_exp, A, e, inp, s, s_T))")
                                                  (("6"
                                                    (expand
                                                     "astMeasure")
                                                    (("6"
                                                      (expand
                                                       "reduce_nat"
                                                       -)
                                                      (("6"
                                                        (assert)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("7"
                                                (skeep)
                                                (("7"
                                                  (inst - "T_p")
                                                  (("7"
                                                    (expand
                                                     "parsing"
                                                     -6)
                                                    (("7"
                                                      (name-replace
                                                       "ep"
                                                       "e(parsing(P_exp, A, e, inp, s, s_T))")
                                                      (("7"
                                                        (expand
                                                         "astMeasure")
                                                        (("7"
                                                          (expand
                                                           "reduce_nat"
                                                           -)
                                                          (("7"
                                                            (assert)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("8"
                                                (expand "parsing" -)
                                                (("8"
                                                  (name-replace
                                                   "ep"
                                                   "e(parsing(P_exp, A, e, inp, s, s_T))")
                                                  (("8"
                                                    (expand
                                                     "astMeasure")
                                                    (("8"
                                                      (expand
                                                       "reduce_nat"
                                                       -)
                                                      (("8"
                                                        (assert)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (typepred "s_T")
                                          (("2"
                                            (typepred
                                             "parsing(P_exp, A, e, inp, s, s_T)")
                                            (("1"
                                              (lemma
                                               "Wellformed_theorem")
                                              (("1"
                                                (inst? -1)
                                                (("1"
                                                  (assert)
                                                  (("1"
                                                    (flatten)
                                                    (("1"
                                                      (assert)
                                                      (("1"
                                                        (flatten)
                                                        (("1"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2" (assert) nil nil))
                                            nil))
                                          nil)
                                         ("3"
                                          (flatten)
                                          (("3"
                                            (assert)
                                            (("3"
                                              (lemma
                                               "peg[V_T, <=, V_N_b].subterm_transitivity")
                                              (("3"
                                                (inst
                                                 -1
                                                 "e"
                                                 "plus(e)"
                                                 "P_exp(A)")
                                                (("3"
                                                  (assert)
                                                  (("3"
                                                    (typepred "s_T")
                                                    (("3"
                                                      (assert)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (lemma
                                         "peg[V_T, <=, V_N_b].subterm_transitivity")
                                        (("2"
                                          (inst
                                           -1
                                           "e"
                                           "plus(e)"
                                           "P_exp(A)")
                                          (("2"
                                            (assert)
                                            (("2"
                                              (expand "subterm" -1 1)
                                              (("2"
                                                (typepred "s_T")
                                                (("2"
                                                  (flatten)
                                                  (("2"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("11"
                    (lemma "peg[V_T, <=, V_N_b].subterm_transitivity")
                    (("11" (skolem 1 "e")
                      (("11" (flatten)
                        (("11" (inst -1 "e" "opt(e)" "P_exp(A)")
                          (("11" (assert)
                            (("11" (expand "subterm" -1 1)
                              (("11"
                                (assert)
                                (("11"
                                  (skeep)
                                  (("11"
                                    (inst -2 "s" "s_T")
                                    (("1"
                                      (expand "parsing" 1)
                                      (("1"
                                        (expand "parseTree?")
                                        (("1"
                                          (ground)
                                          (("1"
                                            (skeep)
                                            (("1"
                                              (inst - "T_p")
                                              (("1"
                                                (assert)
                                                (("1"
                                                  (expand "subterm" -2)
                                                  (("1"
                                                    (propax)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (skeep)
                                            (("2"
                                              (inst - "T_p")
                                              (("2"
                                                (assert)
                                                (("2"
                                                  (expand "subterm" -1)
                                                  (("2"
                                                    (propax)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("3"
                                            (hide -5)
                                            (("3"
                                              (expand "parsing" -4)
                                              (("3"
                                                (expand "astMeasure")
                                                (("3"
                                                  (expand
                                                   "reduce_nat"
                                                   -)
                                                  (("3"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("4"
                                            (hide -4)
                                            (("4"
                                              (expand "parsing" -)
                                              (("4"
                                                (expand "astMeasure")
                                                (("4"
                                                  (expand
                                                   "reduce_nat"
                                                   -)
                                                  (("4"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (typepred "s_T")
                                      (("2" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("12" (assert)
                    (("12" (skolem 1 "e")
                      (("12" (flatten)
                        (("12" (hide -3)
                          (("12" (skeep)
                            (("12" (expand "parsing" 1)
                              (("12"
                                (expand "parsing" -3)
                                (("12"
                                  (expand "parseTree?")
                                  (("12"
                                    (ground)
                                    (("1"
                                      (inst -1 "s" "s_T")
                                      (("1"
                                        (split -1)
                                        (("1"
                                          (skeep)
                                          (("1"
                                            (inst - "T_p")
                                            (("1"
                                              (assert)
                                              (("1"
                                                (expand "subterm" -3)
                                                (("1"
                                                  (propax)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (expand "astMeasure")
                                          (("2"
                                            (expand "reduce_nat" -)
                                            (("2" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (lemma
                                       "peg[V_T, <=, V_N_b].subterm_transitivity")
                                      (("2"
                                        (inst
                                         -1
                                         "e"
                                         "notP(e)"
                                         "P_exp(A)")
                                        (("2"
                                          (assert)
                                          (("2"
                                            (expand "subterm" 1)
                                            (("2" (propax) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("13" (skolem 1 "e")
                    (("13" (flatten)
                      (("13" (skeep)
                        (("13" (assert)
                          (("13" (hide -4)
                            (("13" (split -1)
                              (("1"
                                (inst -1 "s" "s_T")
                                (("1"
                                  (expand "parsing" 1)
                                  (("1"
                                    (expand "parsing" -3)
                                    (("1"
                                      (split -1)
                                      (("1"
                                        (expand "parseTree?")
                                        (("1"
                                          (skeep)
                                          (("1"
                                            (inst -1 "T_p")
                                            (("1"
                                              (expand "subterm" -4)
                                              (("1" (assert) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (expand "astMeasure")
                                        (("2"
                                          (expand "reduce_nat" -)
                                          (("2" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (typepred "s_T")
                                  (("2"
                                    (flatten)
                                    (("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (lemma
                                 "peg[V_T, <=, V_N_b].subterm_transitivity")
                                (("2"
                                  (inst -1 "e" "andP(e)" "P_exp(A)")
                                  (("2"
                                    (assert)
                                    (("2"
                                      (expand "subterm" 1)
                                      (("2" (propax) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((parseTree? const-decl "bool" pre_ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (astMeasure const-decl "nat" pre_ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil peg_parser nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (wf_nT type-eq-decl nil wf_peg nil)
    (wf_nT? const-decl "bool" wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bound formal-const-decl "posnat" peg_parser nil)
    (<= const-decl "bool" reals nil)
    (subterm_of type-eq-decl nil peg nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (subterm_of? const-decl "bool" peg nil) (peg type-decl nil peg nil)
    (<= formal-const-decl "(total_order?[V_T])" peg_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil peg_parser nil)
    (below type-eq-decl nil naturalnumbers nil)
    (V_N_b formal-const-decl "posnat" peg_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (peg_induction formula-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (reduce_nat adt-def-decl "[pre_ast -> nat]" pre_ast nil)
    (subterm adt-def-decl "boolean" pre_ast nil)
    (ε adt-constructor-decl "(ε?)" peg nil)
    (ε? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (any adt-constructor-decl "(any?)" peg nil)
    (any? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (terminal? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (terminal adt-constructor-decl "[V_T -> (terminal?)]" peg nil)
    (range? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (range adt-constructor-decl "[[V_T, V_T] -> (range?)]" peg nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nonTerminal? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (nonTerminal adt-constructor-decl
     "[below(V_N_b) -> (nonTerminal?)]" peg nil)
    (TRUE const-decl "bool" booleans nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (opt adt-constructor-decl "[peg -> (opt?)]" peg nil)
    (opt? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (notP? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (notP adt-constructor-decl "[peg -> (notP?)]" peg nil)
    (andP? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (andP adt-constructor-decl "[peg -> (andP?)]" peg nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (s_T skolem-const-decl
     "{k: upto(s) | (k = s) ⇒ pattern_wf?(seq(e1, e2), A, σ(P_exp), P_0c(P_exp))}"
     peg_parser nil)
    (P_exp skolem-const-decl "WF_nT[V_T, <=, V_N_b]" peg_parser nil)
    (A skolem-const-decl "below(V_N_b)" peg_parser nil)
    (e2 skolem-const-decl "peg[V_T, <=, V_N_b]" peg_parser nil)
    (e1 skolem-const-decl "peg[V_T, <=, V_N_b]" peg_parser nil)
    (seq adt-constructor-decl "[[peg, peg] -> (seq?)]" peg nil)
    (seq? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (s skolem-const-decl "upto(bound)" peg_parser nil)
    (subterm_seq formula-decl nil peg nil)
    (subterm_prior formula-decl nil peg nil)
    (s skolem-const-decl "upto(bound)" peg_parser nil)
    (prior? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (prior adt-constructor-decl "[[peg, peg] -> (prior?)]" peg nil)
    (e1 skolem-const-decl "peg[V_T, <=, V_N_b]" peg_parser nil)
    (e2 skolem-const-decl "peg[V_T, <=, V_N_b]" peg_parser nil)
    (s_T skolem-const-decl
     "{k: upto(s) | (k = s) ⇒ pattern_wf?(prior(e1, e2), A, σ(P_exp), P_0c(P_exp))}"
     peg_parser nil)
    (subterm_star formula-decl nil peg nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (inp skolem-const-decl "input[V_T, <=, V_N_b, bound, V_S]"
     peg_parser nil)
    (s skolem-const-decl "upto(bound)" peg_parser nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star adt-constructor-decl "[peg -> (star?)]" peg nil)
    (e skolem-const-decl "peg[V_T, <=, V_N_b]" peg_parser nil)
    (s_T skolem-const-decl
     "{k: upto(s) | (k = s) ⇒ pattern_wf?(star(e), A, σ(P_exp), P_0c(P_exp))}"
     peg_parser nil)
    (plus adt-constructor-decl "[peg -> (plus?)]" peg nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (s_T skolem-const-decl
     "{k: upto(s) | (k = s) ⇒ pattern_wf?(plus(e), A, σ(P_exp), P_0c(P_exp))}"
     peg_parser nil)
    (e skolem-const-decl "peg[V_T, <=, V_N_b]" peg_parser nil)
    (s skolem-const-decl "upto(bound)" peg_parser nil)
    (sub_plus formula-decl nil peg nil)
    (subterm_transitivity formula-decl nil peg nil)
    (s skolem-const-decl "upto(bound)" peg_parser nil)
    (e skolem-const-decl "peg[V_T, <=, V_N_b]" peg_parser nil)
    (s_T skolem-const-decl
     "{k: upto(s) | (k = s) ⇒ pattern_wf?(opt(e), A, σ(P_exp), P_0c(P_exp))}"
     peg_parser nil)
    (sub_opt formula-decl nil peg nil)
    (sub_notP formula-decl nil peg nil)
    (s_T skolem-const-decl
     "{k: upto(s) | (k = s) ⇒ pattern_wf?(andP(e), A, σ(P_exp), P_0c(P_exp))}"
     peg_parser nil)
    (e skolem-const-decl "peg[V_T, <=, V_N_b]" peg_parser nil)
    (s skolem-const-decl "upto(bound)" peg_parser nil)
    (sub_andP formula-decl nil peg nil))
   shostak))
 (reference_parser_grammar 0
  (reference_parser_grammar-1 nil 3785520629
   ("" (skeep) (("" (grind) nil nil)) nil)
   ((int_minus_int_is_int application-judgement "int" integers nil))
   shostak)))

