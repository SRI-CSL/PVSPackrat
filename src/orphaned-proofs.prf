("ast" ast seq_2_TCC1 0 (seq_2_TCC1-1 nil 3785499487 ("" (subtype-tcc) nil nil) nil nil (seq_2 subtype "ast.T" "{x: pre_ast[ast.V_T, ast.<=, ast.V_N_b, ast.bound, ast.V_S].pre_ast | booleans.OR(pre_ast[ast.V_T, ast.<=, ast.V_N_b, ast.bound, ast.V_S].seq?(x), pre_ast[ast.V_T, ast.<=, ast.V_N_b, ast.bound, ast.V_S].prior?(x))}")))("ast" ast seq_2 0 (seq_2-1 nil 3785499490 ("" (skeep) (("" (typepred "T") (("" (expand "astWellformed?") (("" (assert) (("" (flatten) (("" (assert) (("" (expand "astType?" 2 1) (("" (lift-if 2) (("" (split 2) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ast type-eq-decl nil ast nil) (astWellformed? def-decl "bool" ast nil) (pre_ast type-decl nil pre_ast nil) (V_S formal-type-decl nil ast nil) (bound formal-const-decl "nat" ast nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (V_N_b formal-const-decl "posnat" ast nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (<= formal-const-decl "(total_order?[V_T])" ast nil) (total_order? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (V_T formal-nonempty-type-decl nil ast nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (astType? def-decl "astType" ast nil)) shostak))("json" json_parser extract_number_TCC1 0 (extract_number_TCC1-1 nil 3786428596 ("" (skeep) (("" (ground) nil nil)) nil) ((real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (extract_number disjointness "TABLE
  %---------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------------------------------------------------------++
  |[ json_parser.x = 48 | json_parser.x = 49 | json_parser.x = 50 | json_parser.x = 51 | json_parser.x = 52 | json_parser.x = 53 | json_parser.x = 54 | json_parser.x = 55 | json_parser.x = 56 | json_parser.x = 57 | booleans.∨(reals.<(json_parser.x, 48), reals.>(json_parser.x, 57)) ]|
  %---------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------------------------------------------------------++
  | 0                   | 1                  | 2                  | 3                  | 4                  | 5                  | 6                  | 7                  | 8                  | 9                  | 0                                                                  ||
  %---------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------------------------------------------------------++
ENDTABLE" "nil")))("json" json_parser extract_number_TCC2 0 (extract_number_TCC2-1 nil 3786428596 ("" (skeep) (("" (assert) nil nil)) nil) ((real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (extract_number coverage "TABLE
  %---------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------------------------------------------------------++
  |[ json_parser.x = 48 | json_parser.x = 49 | json_parser.x = 50 | json_parser.x = 51 | json_parser.x = 52 | json_parser.x = 53 | json_parser.x = 54 | json_parser.x = 55 | json_parser.x = 56 | json_parser.x = 57 | booleans.∨(reals.<(json_parser.x, 48), reals.>(json_parser.x, 57)) ]|
  %---------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------------------------------------------------------++
  | 0                   | 1                  | 2                  | 3                  | 4                  | 5                  | 6                  | 7                  | 8                  | 9                  | 0                                                                  ||
  %---------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------------------------------------------------------++
ENDTABLE" "nil")))("parser" peg_parser tree_is_parsing_TCC1 0 (tree_is_parsing_TCC1-1 nil 3788207491 ("" (subtype-tcc) nil nil) nil nil (tree_is_parsing subtype "peg_parser.s" "{k: naturalnumbers.upto(peg_parser.s) | booleans.⇒((k = peg_parser.s), wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].g_wf(peg_parser.G, peg_parser.A, wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].P_0c?(peg_parser.P_exp), wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].strong))}")))("parser" peg_parser tree_is_parsing 0 (tree_is_parsing-1 nil 3788207599 ("" (case "Forall (n: nat) : FORALL (T: ast): astMeasure(T) <= n Implies ( 
        EXISTS (P_exp: WF_nT, A: below(V_N_b),
                G: {e: Δ | subterm(e, P_exp(A))}, inp: input, s: inp_bound,
                s_T:
                  {k: upto(s) |
                     (k = s) ⇒ g_wf(G, A, P_0c?(P_exp), strong)}):
          T = parsing(P_exp, A, G, inp, s, s))") (("1" (skeep) (("1" (inst -1 "astMeasure(T)") (("1" (inst -1 "T") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (induct "n") (("1" (postpone) nil nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil)) nil)) nil) ("3" (postpone) nil nil)) nil) nil shostak))("ascii" test_ascii P_exp_TCC1 0 (P_exp_TCC1-1 nil 3785834693 ("" (assert) (("" (inst 1 "0") nil nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (V_T type-eq-decl nil arith_expr nil)) nil (P_exp existence "" "V_T")))("ascii" test_ascii P_exp_TCC2 0 (P_exp_TCC1-1 nil 3780642089 ("" (subtype-tcc) nil nil) ((V_N_b const-decl "nat" arith_expr nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (P_exp subtype "arith_expr.V_N_b" "posnat")))("ascii" test_ascii P_exp_TCC3 0 (P_exp_TCC17-1 nil 3785828602 ("" (subtype-tcc) nil nil) ((V_N_b const-decl "nat" arith_expr nil)) nil (P_exp subtype "8" "naturalnumbers.below(arith_expr.V_N_b)")))("ascii" test_ascii P_exp_TCC4 0 (P_exp_TCC2-1 nil 3780633797 ("" (subtype-tcc) nil nil) ((V_N_b const-decl "nat" arith_expr nil)) nil (P_exp subtype "1" "naturalnumbers.below(arith_expr.V_N_b)")))("ascii" test_ascii P_exp_TCC5 0 (P_exp_TCC7-1 nil 3780633797 ("" (subtype-tcc) nil nil) ((V_N_b const-decl "nat" arith_expr nil)) nil (P_exp subtype "0" "naturalnumbers.below(arith_expr.V_N_b)")))("ascii" test_ascii P_exp_TCC6 0 (P_exp_TCC5-1 nil 3780633797 ("" (subtype-tcc) nil nil) ((V_N_b const-decl "nat" arith_expr nil)) nil (P_exp subtype "2" "naturalnumbers.below(arith_expr.V_N_b)")))("ascii" test_ascii P_exp_TCC7 0 (P_exp_TCC13-1 nil 3780633797 ("" (subtype-tcc) nil nil) ((V_N_b const-decl "nat" arith_expr nil)) nil (P_exp subtype "2" "naturalnumbers.below(arith_expr.V_N_b)")))("ascii" test_ascii P_exp_TCC8 0 (P_exp_TCC6-1 nil 3780633797 ("" (subtype-tcc) nil nil) ((V_N_b const-decl "nat" arith_expr nil)) nil (P_exp subtype "4" "naturalnumbers.below(arith_expr.V_N_b)")))("ascii" test_ascii P_exp_TCC9 0 (P_exp_TCC4-1 nil 3780633797 ("" (subtype-tcc) nil nil) ((V_N_b const-decl "nat" arith_expr nil)) nil (P_exp subtype "3" "naturalnumbers.below(arith_expr.V_N_b)")))("ascii" test_ascii P_exp_TCC10 0 (P_exp_TCC9-1 nil 3780633797 ("" (subtype-tcc) nil nil) ((V_N_b const-decl "nat" arith_expr nil)) nil (P_exp subtype "2" "naturalnumbers.below(arith_expr.V_N_b)")))("ascii" test_ascii P_exp_TCC11 0 (P_exp_TCC11-1 nil 3780633797 ("" (subtype-tcc) nil nil) ((V_N_b const-decl "nat" arith_expr nil)) nil (P_exp subtype "5" "naturalnumbers.below(arith_expr.V_N_b)")))("ascii" test_ascii P_exp_TCC12 0 (P_exp_TCC12-1 nil 3780633797 ("" (subtype-tcc) nil nil) ((V_N_b const-decl "nat" arith_expr nil)) nil (P_exp subtype "5" "naturalnumbers.below(arith_expr.V_N_b)")))("ascii" test_ascii P_exp_TCC13 0 (P_exp_TCC1-1 nil 3780633797 ("" (subtype-tcc) nil nil) ((V_N_b const-decl "nat" arith_expr nil)) nil (P_exp subtype "7" "naturalnumbers.below(arith_expr.V_N_b)")))("ascii" test_ascii P_exp_TCC14 0 (P_exp_TCC10-1 nil 3780633797 ("" (subtype-tcc) nil nil) ((V_N_b const-decl "nat" arith_expr nil)) nil (P_exp subtype "6" "naturalnumbers.below(arith_expr.V_N_b)")))("ascii" test_ascii P_exp_TCC15 0 (P_exp_TCC15-1 nil 3780633797 ("" (subtype-tcc) nil nil) ((V_N_b const-decl "nat" arith_expr nil)) nil (P_exp subtype "4" "naturalnumbers.below(arith_expr.V_N_b)")))("ascii" test_ascii P_exp_TCC16 0 (P_exp_TCC8-1 nil 3780633797 ("" (subtype-tcc) nil nil) ((V_N_b const-decl "nat" arith_expr nil)) nil (P_exp subtype "3" "naturalnumbers.below(arith_expr.V_N_b)")))("ascii" test_ascii P_exp_TCC17 0 (P_exp_TCC3-1 nil 3780633797 ("" (subtype-tcc) nil nil) ((V_N_b const-decl "nat" arith_expr nil)) nil (P_exp subtype "1" "naturalnumbers.below(arith_expr.V_N_b)")))("ascii" test_ascii P_exp_TCC18 0 (P_exp_TCC14-1 nil 3780633797 ("" (subtype-tcc) nil nil) ((V_N_b const-decl "nat" arith_expr nil)) nil (P_exp subtype "0" "naturalnumbers.below(arith_expr.V_N_b)")))("ascii" test_ascii P_exp_TCC19 0 (P_exp_TCC19-1 nil 3785834693 ("" (subtype-tcc) nil nil) ((V_N_b const-decl "nat" arith_expr nil)) nil (P_exp subtype "8" "naturalnumbers.below(arith_expr.V_N_b)")))("json" json_parser extractJsonNumber_TCC1 0 (extractJsonNumber_TCC1-1 nil 3797853245 ("" (subtype-tcc) nil nil) ((V_T type-eq-decl nil json_grammar nil) (<= const-decl "bool" json_grammar nil) (V_N_b const-decl "nat" json_grammar nil) (JSON type-decl nil json_object nil) (pre_ast type-decl nil pre_ast nil) (astWellformed? def-decl "bool" ast nil) (ast type-eq-decl nil ast nil)) nil (extractJsonNumber subtype "json_parser.T" "{x: pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].pre_ast | booleans.OR(pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].seq?(x), pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].prior?(x))}")))("json" json_parser extractJsonNumber_TCC2 0 (extractJsonNumber_TCC2-1 nil 3797853245 ("" (subtype-tcc) nil nil) ((V_T type-eq-decl nil json_grammar nil) (<= const-decl "bool" json_grammar nil) (V_N_b const-decl "nat" json_grammar nil) (JSON type-decl nil json_object nil) (pre_ast type-decl nil pre_ast nil) (astWellformed? def-decl "bool" ast nil) (ast type-eq-decl nil ast nil)) nil (extractJsonNumber subtype "pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].T2(json_parser.T)" "{x: pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].pre_ast | booleans.OR(pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].seq?(x), pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].prior?(x))}")))("json" json_parser extractJsonNumber_TCC3 0 (extractJsonNumber_TCC3-1 nil 3797853245 ("" (subtype-tcc) nil nil) ((V_T type-eq-decl nil json_grammar nil) (<= const-decl "bool" json_grammar nil) (V_N_b const-decl "nat" json_grammar nil) (JSON type-decl nil json_object nil) (pre_ast type-decl nil pre_ast nil) (astWellformed? def-decl "bool" ast nil) (ast type-eq-decl nil ast nil)) nil (extractJsonNumber subtype "pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].T2(pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].T2(json_parser.T))" "{x: pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].pre_ast | booleans.OR(pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].seq?(x), pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].prior?(x))}")))("json" json_parser extractJsonNumber_TCC4 0 (extractJsonNumber_TCC4-1 nil 3797853245 ("" (subtype-tcc) nil nil) nil nil (extractJsonNumber subtype "pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].T1(json_parser.T)" "{x: pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].pre_ast | booleans.OR(pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].nonTerminal?(x), booleans.OR(pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].notP?(x), pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].andP?(x)))}")))("json" json_parser extractJsonNumber_TCC5 0 (extractJsonNumber_TCC5-1 nil 3797853245 ("" (subtype-tcc) nil nil) nil nil (extractJsonNumber subtype "json_parser.intAST" "{x: pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].pre_ast | booleans.OR(pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].seq?(x), pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].prior?(x))}")))("json" json_parser extractJsonNumber_TCC6 0 (extractJsonNumber_TCC6-1 nil 3797853245 ("" (subtype-tcc) nil nil) nil nil (extractJsonNumber subtype "pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].T2(json_parser.intAST)" "ast[V_T, <=, V_N_b, 1000, V_S]")))("json" json_parser extractJsonNumber_TCC7 0 (extractJsonNumber_TCC7-1 nil 3797853245 ("" (subtype-tcc) nil nil) nil nil (extractJsonNumber subtype "json_parser.fracAST" "{x: pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].pre_ast | booleans.OR(pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].nonTerminal?(x), booleans.OR(pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].notP?(x), pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].andP?(x)))}")))("json" json_parser extractJsonNumber_TCC8 0 (extractJsonNumber_TCC8-1 nil 3797853245 ("" (subtype-tcc) nil nil) nil nil (extractJsonNumber subtype "pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].T(json_parser.fracAST)" "ast[V_T, <=, V_N_b, 1000, V_S]")))("json" json_parser extractJsonNumber_TCC9 0 (extractJsonNumber_TCC9-1 nil 3797853245 ("" (subtype-tcc) nil nil) nil nil (extractJsonNumber subtype "json_parser.expAST" "{x: pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].pre_ast | booleans.OR(pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].nonTerminal?(x), booleans.OR(pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].notP?(x), pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].andP?(x)))}")))("json" json_parser extractJsonNumber_TCC10 0 (extractJsonNumber_TCC10-1 nil 3797853245 ("" (subtype-tcc) nil nil) nil nil (extractJsonNumber subtype "pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].T(json_parser.expAST)" "ast[V_T, <=, V_N_b, 1000, V_S]")))("semantic_tlparser" semantic_tlparser memoïzed_does_not_change 0 (memoïzed_does_not_change-1 nil 3804503631 ("" (skolem 1 ("P_exp" "P_inp" "_" "_" "inp" "_" "_" "_" "_" "_")) (("" (case "FORALL (A: below(V_N_b)),
                            (G: Δ),
                            (s: upto(bound)),
                            (s_T: upto(bound)):
               subterm(G, P_exp(A)) IMPLIES (s_T <= s AND (s_T = s IMPLIES  g_wf(G, A, P_0c?(P_exp), strong))) IMPLIES forall
                            (cont:
                               [[astTypeOf(parsing(P_exp, A, G, inp, s, s_T)),
                                 sem_result(P_inp, P_exp, A, G, inp, s, s_T),
                                 results(P_exp, P_inp, inp)] ->
                                  [astType, pre_ast]]),
                            (res1, res2: results(P_exp, P_inp, inp)):
			    (FORALL (status: astTypeOf(parsing(P_exp, A, G, inp, s, s_T))),
			    (T: sem_result(P_inp, P_exp, A, G, inp, s, s_T)),
			    (res1, res2: results(P_exp, P_inp, inp)):
			    cont(status, T, res1) = cont(status, T, res2))
			    ⇒
                       semtlpp(P_exp, P_inp, A, G, inp, s, s_T, res1, cont) =
                        semtlpp(P_exp, P_inp, A, G, inp, s, s_T, res2, cont)") (("1" (skeep) (("1" (inst -1 A G s s_T) (("1" (ground) (("1" (inst -1 "cont" "res1" "res2") (("1" (assert) nil nil)) nil) ("2" (typepred "s_T") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (measure-induct+ " lex4(bound - s_T, bound - s,  A, pegMeasure(G))" ("A" "G" "s" "s_T")) (("1" (name-replace "s_T" "x!4") (("1" (name-replace "s" "x!3") (("1" (name-replace "G" "x!2") (("1" (name-replace "A" "x!1") (("1" (skeep) (("1" (assert) (("1" (label "H_Cont" -5) (("1" (case "G = ε") (("1" (replace -1 * LR) (("1" (expand "semtlpp" +) (("1" (inst -6 success " ε(s, s)" res1 res2) nil nil)) nil)) nil) ("2" (case "G = any") (("1" (replace -1 * LR) (("1" (expand "semtlpp" +) (("1" (assert) (("1" (lift-if 2) (("1" (split +) (("1" (flatten) (("1" (assert) (("1" (inst? -7) nil nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (inst? -) (("2" (inst? -) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "terminal?(G)") (("1" (expand "semtlpp" 3) (("1" (assert) (("1" (lift-if) (("1" (split +) (("1" (flatten) (("1" (inst? -8) nil nil)) nil) ("2" (flatten) (("2" (inst? -6) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "range?(G)") (("1" (expand "semtlpp" +) (("1" (assert) (("1" (lift-if) (("1" (split 4) (("1" (flatten) (("1" (assert) (("1" (inst? -) (("1" (inst? -) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst? -) (("2" (inst? -) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "nonTerminal?(G)") (("1" (name "B" "A(G)") (("1" (postpone) nil nil) ("2" (propax) nil nil)) nil) ("2" (case "seq?(G)") (("1" (expand "semtlpp" +) (("1" (assert) (("1" (inst-cp -2 "A" "e1(G)" "s" "s_T") (("1" (split -3) (("1" (inst -1 "cont" "res1" "res2") (("1" (split -1) (("1" (assert) (("1" (postpone) nil nil)) nil) ("2" (postpone) nil nil)) nil) ("2" (postpone) nil nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil) ("4" (postpone) nil nil) ("5" (postpone) nil nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil) ("4" (postpone) nil nil) ("5" (postpone) nil nil) ("6" (postpone) nil nil) ("7" (postpone) nil nil)) nil)) nil)) nil)) nil) nil shostak))("semantic_tlparser" semantic_tlparser results_TCC1 0 (results_TCC1-1 nil 3804395188 ("" (assert) (("" (expand "subterm") (("" (propax) nil nil)) nil)) nil) ((subterm adt-def-decl "boolean" peg nil)) nil (results subtype "semantic_tlparser.P_exp(semantic_tlparser.A)" "{e: wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].Δ | peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].subterm(e, semantic_tlparser.P_exp(semantic_tlparser.A))}")))("semantic_tlparser" semantic_tlparser results_TCC2 0 (results_TCC2-1 nil 3804395188 ("" (subtype-tcc) nil nil) ((NOT const-decl "[bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (V_N type-eq-decl nil nTpred_order nil) (peg type-decl nil peg nil) (interp type-eq-decl nil wf_peg nil) (strong_WF const-decl "bool" wf_peg nil) (WF_nT type-eq-decl nil wf_peg nil) (<= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (bound formal-const-decl "posnat" semantic_tlparser nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil) (> const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil) (total_order? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (V_T formal-nonempty-type-decl nil semantic_tlparser nil) (strong const-decl "bool" wf_peg nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (results subtype "semantic_tlparser.s" "{k: naturalnumbers.upto(semantic_tlparser.s) | booleans.⇒((k = semantic_tlparser.s), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].g_wf(semantic_tlparser.P_exp(semantic_tlparser.A), semantic_tlparser.A, wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].P_0c?(semantic_tlparser.P_exp), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].strong))}")))("json" json_parser IMP_semantic_parser_TCC1 0 (IMP_semantic_parser_TCC2-1 nil 3786377705 ("" (lemma "isTotalOrder") (("" (propax) nil nil)) nil) ((isTotalOrder formula-decl nil json_grammar nil)) nil (IMP_semantic_parser subtype "json_grammar.<=" "(orders[V_T].total_order?)")))("json" json_parser IMP_semantic_parser_TCC2 0 (IMP_semantic_parser_TCC3-1 nil 3786377705 ("" (subtype-tcc) nil nil) ((V_N_b const-decl "nat" json_grammar nil)) nil (IMP_semantic_parser subtype "json_grammar.V_N_b" "{k: naturalnumbers.nat | reals.>(k, 0)}")))("json" json_parser parser_TCC1 0 (parser_TCC1-1 nil 3798639263 ("" (lemma "correct_grammar") (("" (propax) nil nil)) nil) ((correct_grammar formula-decl nil json_grammar nil)) nil (parser subtype "json_grammar.P_exp" "WF_nT[V_T, <=, V_N_b]")))("json" json_parser parser_TCC2 0 (parser_TCC2-1 nil 3798639263 ("" (subtype-tcc) nil nil) nil nil (parser subtype "json_parser.P_inp" "semantic_interp[V_T, <=, V_N_b, 1000, V_S]")))("json" json_parser parser_TCC3 0 (parser_TCC3-1 nil 3798639263 ("" (subtype-tcc) nil nil) ((V_N_b const-decl "nat" json_grammar nil) (entry const-decl "int" json_grammar nil)) nil (parser subtype "json_grammar.entry" "naturalnumbers.below(json_grammar.V_N_b)")))("json" json_parser parser_TCC4 0 (parser_TCC4-1 nil 3798639263 ("" (assert) (("" (expand "subterm") (("" (propax) nil nil)) nil)) nil) ((subterm adt-def-decl "boolean" peg nil)) nil (parser subtype "json_grammar.P_exp(json_grammar.entry)" "{e: wf_peg[V_T, json_grammar.<=, json_grammar.V_N_b].Δ | peg[V_T, json_grammar.<=, json_grammar.V_N_b].subterm(e, json_grammar.P_exp(json_grammar.entry))}")))("json" json_parser parser_TCC5 0 (parser_TCC5-1 nil 3798639263 ("" (subtype-tcc) nil nil) nil nil (parser subtype "(LAMBDA (A: nTpred_order[json_grammar.V_N_b].V_N, s: ast_props[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].inp_bound): semantic_parser[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].unknown)" "semantic_parser[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].results(json_grammar.P_exp, json_parser.P_inp, json_parser.inp)")))("json" json_parser parser_TCC6 0 (parser_TCC6-1 nil 3798639263 ("" (skeep*) (("" (typepred "(sempp[V_T, <=, V_N_b, 1000, V_S]
                (P_exp, P_inp, entry, P_exp(entry), inp, 0, 0,
                 (LAMBDA (A: V_N[V_N_b],
                          s: inp_bound[V_T, <=, V_N_b, 1000, V_S]):
                    unknown[V_T, <=, V_N_b, 1000, V_S]))`1)") (("1" (use "semantic_interp_props") (("1" (assert) nil nil) ("2" (expand "V_N_b") (("2" (assert) nil nil)) nil) ("3" (lemma "isTotalOrder") (("3" (propax) nil nil)) nil) ("4" (expand "entry") (("4" (assert) nil nil)) nil)) nil) ("2" (lemma "isTotalOrder") (("2" (propax) nil nil)) nil) ("3" (skeep 1) (("3" (lemma "isTotalOrder") (("3" (propax) nil nil)) nil)) nil) ("4" (expand "V_N_b") (("4" (assert) nil nil)) nil) ("5" (expand "entry") (("5" (assert) nil nil)) nil)) nil)) nil) ((unknown adt-constructor-decl "(unknown?)" semantic_parser nil) (unknown? adt-recognizer-decl "[saved_result -> boolean]" semantic_parser nil) (entry const-decl "int" json_grammar nil) (P_inp const-decl "[V_N, ast -> V_S]" json_parser nil) (P_exp const-decl "Δ" json_grammar nil) (sempp def-decl "[{T: pre_ast | T = s_inp(P_inp, parsing(P_exp, A, G, inp, s, s_T))},
 results(P_exp, P_inp, inp)]" semantic_parser nil) (results type-eq-decl nil semantic_parser nil) (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}" semantic_interp nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (semanticTree type-eq-decl nil pre_ast nil) (semanticTree? const-decl "bool" pre_ast nil) (semantic adt-constructor-decl "[[below, below, V_N[V_N_b], V_S] -> (semantic?)]" pre_ast nil) (semantic? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil) (fail adt-constructor-decl "[[below, below] -> (fail?)]" pre_ast nil) (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil) (T adt-accessor-decl "[(known?) -> (valuedTree?)]" semantic_parser nil) (valuedTree? const-decl "bool" semantic_interp nil) (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser nil) (output type-eq-decl nil peg_parser nil) (P_fc? const-decl "[Δ -> bool]" wf_peg nil) (failure adt-constructor-decl "(failure?)" ast nil) (failure? adt-recognizer-decl "[astType -> boolean]" ast nil) (P_sc? const-decl "[Δ -> bool]" wf_peg nil) (> const-decl "bool" reals nil) (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil) (success adt-constructor-decl "(success?)" ast nil) (success? adt-recognizer-decl "[astType -> boolean]" ast nil) (trueToInput def-decl "bool" ast_props nil) (trueToGrammar def-decl "bool" ast_props nil) (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil) (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil) (plus? adt-recognizer-decl "[peg -> boolean]" peg nil) (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil) (star? adt-recognizer-decl "[peg -> boolean]" peg nil) (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil) (below type-eq-decl nil pre_ast nil) (ast type-eq-decl nil ast nil) (astWellformed? def-decl "bool" ast nil) (astType? def-decl "astType" ast nil) (astType type-decl nil ast nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (known? adt-recognizer-decl "[saved_result -> boolean]" semantic_parser nil) (saved_result type-decl nil semantic_parser nil) (inp_bound type-eq-decl nil ast_props nil) (strong const-decl "bool" wf_peg nil) (P_0c? const-decl "[Δ -> bool]" wf_peg nil) (g_wf def-decl "bool" wf_peg nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (input type-eq-decl nil ast_props nil) (strong_WF const-decl "bool" wf_peg nil) (interp type-eq-decl nil wf_peg nil) (V_N type-eq-decl nil nTpred_order nil) (< const-decl "bool" reals nil) (subterm adt-def-decl "boolean" peg nil) (peg type-decl nil peg nil) (below type-eq-decl nil naturalnumbers nil) (semantic_interp type-eq-decl nil semantic_interp nil) (WF_nT type-eq-decl nil wf_peg nil) (= const-decl "[T, T -> boolean]" equalities nil) (pre_ast type-decl nil pre_ast nil) (V_S type-eq-decl nil json_parser nil) (JSON type-decl nil json_object nil) (V_N_b const-decl "nat" json_grammar nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (<= const-decl "bool" json_grammar nil) (char type-eq-decl nil strings nil) (V_T type-eq-decl nil json_grammar nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (character type-decl nil character_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (total_order? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (isTotalOrder formula-decl nil json_grammar nil) (semantic_interp_props formula-decl nil semantic_interp nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (parser subtype "(semantic_parser[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].sempp(json_grammar.P_exp, json_parser.P_inp, json_grammar.entry, json_grammar.P_exp(json_grammar.entry), json_parser.inp, 0, 0, (LAMBDA (A: nTpred_order[json_grammar.V_N_b].V_N, s: ast_props[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].inp_bound): semantic_parser[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].unknown))`1)" "ast[V_T, <=, V_N_b, 1000, V_S]")))("json" json_parser strToInp_TCC1 0 (strToInp_TCC1-1 nil 3805351806 ("" (subtype-tcc) nil nil) nil nil (strToInp subtype "LAMBDA (x: naturalnumbers.below(1000)): IF (reals.<(x, json_parser.s`length)) THEN json_parser.s`seq(x) ELSE character_adt.char(0) ENDIF" "input[V_T, <=, V_N_b, 1000, V_S]")))("json" json_grammar quotation_mark_TCC1 0 (quotation_mark_TCC1-1 nil 3786305814 ("" (subtype-tcc) nil nil) ((V_N_b const-decl "nat" json_grammar nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (quotation_mark subtype "24" "naturalnumbers.below(json_grammar.V_N_b)")))("delta" wf_peg Plus_cannot_be_P0_TCC1 0 (Plus_cannot_be_P0_TCC1-1 nil 3813666933 ("" (subtype-tcc) nil nil) nil nil (Plus_cannot_be_P0 subtype "wf_peg.G" "{x: peg[wf_peg.V_T, wf_peg.<=, wf_peg.V_N_b].peg |      peg[wf_peg.V_T, wf_peg.<=, wf_peg.V_N_b].star?(x) OR peg[wf_peg.V_T, wf_peg.<=, wf_peg.V_N_b].plus?(x) OR peg[wf_peg.V_T, wf_peg.<=, wf_peg.V_N_b].opt?(x) OR peg[wf_peg.V_T, wf_peg.<=, wf_peg.V_N_b].notP?(x) OR peg[wf_peg.V_T, wf_peg.<=, wf_peg.V_N_b].andP?(x)}")))("static_analysis" inferred_order_wf_peg nT_properties_reorders 0 (nT_properties_reorders-1 nil 3813656553 ("" (skolem 1 ("P_exp" "s")) (("" (expand "nT_properties") (("" (postpone) nil nil)) nil)) nil) nil shostak))("static_analysis" inferred_order_wf_peg sub_nT_and_wellformedness_TCC1 0 (sub_nT_and_wellformedness_TCC1-1 nil 3813611401 ("" (subtype-tcc) nil nil) nil nil (sub_nT_and_wellformedness subtype "inferred_order_wf_peg.A" "naturalnumbers.upto(inferred_order_wf_peg.V_N_b)")))("static_analysis" inferred_order_wf_peg well_orders_orderly 0 (well_orders_orderly-1 nil 3813604031 ("" (expand "well_orders?") (("" (expand "orderly_WF_nT?") (("" (skeep*) (("" (inst? 1) nil nil)) nil)) nil)) nil) ((orderly_WF_nT? const-decl "bool" inferred_order_wf_peg nil) (nT_Permutation type-eq-decl nil inferred_order_wf_peg nil) (bijective? const-decl "bool" functions nil) (V_N type-eq-decl nil nTpred_order nil) (V_N_b formal-const-decl "posnat" inferred_order_wf_peg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (well_orders? const-decl "bool" inferred_order_wf_peg nil)) shostak))("delta" wf_peg strong_WF_TCC1 0 (strong_WF_TCC1-1 nil 3771171781 ("" (subtype-tcc) nil nil) nil nil (strong_WF subtype "wf_peg.A" "naturalnumbers.upto(wf_peg.V_N_b)")))("parser" peg_parser output_TCC1 0 (output_TCC1-1 nil 3771774354 ("" (subtype-tcc) nil nil) nil nil (output subtype "peg_parser.A" "naturalnumbers.upto(peg_parser.V_N_b)")))("parser_props" parser_props parsing_correctness_ε_TCC1 0 (parsing_correctness_ε_TCC2-1 nil 3785592840 ("" (assert) nil nil) nil nil (parsing_correctness_ε subtype "parser_props.A" "naturalnumbers.upto(parser_props.V_N_b)")))("semantic_tlparser" semantic_tlparser sem_result_TCC1 0 (sem_result_TCC1-1 nil 3804417092 ("" (subtype-tcc) nil nil) nil nil (sem_result subtype "semantic_tlparser.A" "naturalnumbers.upto(semantic_tlparser.V_N_b)")))("parser" peg_parser reference_parser_nonzero 0 (reference_parser_nonzero-1 nil 3847170769 ("" (skolem 1 ("σ" "P_exp" "A" "_" "_" "_" "_")) (("" (induct "G") (("1" (typepred "G!1") (("1" (propax) nil nil)) nil) ("2" (flatten) (("2" (skeep*) (("2" (expand "parsing") (("2" (assert) (("2" (expand "astMeasure") (("2" (expand "reduce_nat") (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (postpone) nil nil) ("4" (postpone) nil nil) ("5" (postpone) nil nil) ("6" (postpone) nil nil) ("7" (postpone) nil nil) ("8" (postpone) nil nil) ("9" (postpone) nil nil) ("10" (postpone) nil nil) ("11" (postpone) nil nil) ("12" (postpone) nil nil) ("13" (postpone) nil nil)) nil)) nil) nil shostak))("static_analysis" inferred_order_wf_peg inv_TCC1 0 (inv_TCC1-1 nil 3813650237 ("" (lemma "function_inverse_def[V_N,V_N].bijective_inverse_exists") (("" (postpone) nil nil)) nil) nil nil (inv existence "" "[σ: inferred_order_wf_peg.nT_Permutation -> {σ' | function_props[V_N[V_N_b], V_N[V_N_b], V_N[V_N_b]].o(σ, inferred_order_wf_peg.σ') = identity[V_N[V_N_b]].identity}]")))("static_analysis" inferred_order_wf_peg g_wf_perm_TCC1 0 (g_wf_perm_TCC1-1 nil 3813750082 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (V_N_b formal-const-decl "posnat" inferred_order_wf_peg nil) (V_N type-eq-decl nil nTpred_order nil) (bijective? const-decl "bool" functions nil) (nT_Permutation type-eq-decl nil inferred_order_wf_peg nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (reduce_nat adt-def-decl "[peg -> nat]" peg nil) (sum const-decl "nat" peg nil) (surjective? const-decl "bool" functions nil) (injective? const-decl "bool" functions nil) (pegMeasure const-decl "nat" peg nil)) nil (g_wf_perm termination "inferred_order_wf_peg.g_wf_perm(inferred_order_wf_peg.σ)(inferred_order_wf_peg.e1, inferred_order_wf_peg.A, inferred_order_wf_peg.P_0, inferred_order_wf_peg.δ)" "nil")))("static_analysis" inferred_order_wf_peg g_wf_perm_TCC2 0 (g_wf_perm_TCC2-1 nil 3813750082 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (V_N_b formal-const-decl "posnat" inferred_order_wf_peg nil) (V_N type-eq-decl nil nTpred_order nil) (bijective? const-decl "bool" functions nil) (nT_Permutation type-eq-decl nil inferred_order_wf_peg nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (reduce_nat adt-def-decl "[peg -> nat]" peg nil) (sum const-decl "nat" peg nil) (surjective? const-decl "bool" functions nil) (injective? const-decl "bool" functions nil) (pegMeasure const-decl "nat" peg nil)) nil (g_wf_perm termination "inferred_order_wf_peg.g_wf_perm(inferred_order_wf_peg.σ)(inferred_order_wf_peg.e2, inferred_order_wf_peg.A, inferred_order_wf_peg.P_0, booleans.∧(inferred_order_wf_peg.P_0(inferred_order_wf_peg.e1), inferred_order_wf_peg.δ))" "nil")))("static_analysis" inferred_order_wf_peg g_wf_perm_TCC3 0 (g_wf_perm_TCC3-1 nil 3813750082 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (V_N_b formal-const-decl "posnat" inferred_order_wf_peg nil) (V_N type-eq-decl nil nTpred_order nil) (bijective? const-decl "bool" functions nil) (nT_Permutation type-eq-decl nil inferred_order_wf_peg nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (reduce_nat adt-def-decl "[peg -> nat]" peg nil) (sum const-decl "nat" peg nil) (surjective? const-decl "bool" functions nil) (injective? const-decl "bool" functions nil) (pegMeasure const-decl "nat" peg nil)) nil (g_wf_perm termination "inferred_order_wf_peg.g_wf_perm(inferred_order_wf_peg.σ)(inferred_order_wf_peg.e1, inferred_order_wf_peg.A, inferred_order_wf_peg.P_0, inferred_order_wf_peg.δ)" "nil")))("static_analysis" inferred_order_wf_peg g_wf_perm_TCC4 0 (g_wf_perm_TCC4-1 nil 3813750082 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (V_N_b formal-const-decl "posnat" inferred_order_wf_peg nil) (V_N type-eq-decl nil nTpred_order nil) (bijective? const-decl "bool" functions nil) (nT_Permutation type-eq-decl nil inferred_order_wf_peg nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (reduce_nat adt-def-decl "[peg -> nat]" peg nil) (sum const-decl "nat" peg nil) (surjective? const-decl "bool" functions nil) (injective? const-decl "bool" functions nil) (pegMeasure const-decl "nat" peg nil)) nil (g_wf_perm termination "inferred_order_wf_peg.g_wf_perm(inferred_order_wf_peg.σ)(inferred_order_wf_peg.e2, inferred_order_wf_peg.A, inferred_order_wf_peg.P_0, inferred_order_wf_peg.δ)" "nil")))("static_analysis" inferred_order_wf_peg g_wf_perm_TCC5 0 (g_wf_perm_TCC5-1 nil 3813750082 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (V_N_b formal-const-decl "posnat" inferred_order_wf_peg nil) (V_N type-eq-decl nil nTpred_order nil) (bijective? const-decl "bool" functions nil) (nT_Permutation type-eq-decl nil inferred_order_wf_peg nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (reduce_nat adt-def-decl "[peg -> nat]" peg nil) (inc const-decl "nat" peg nil) (surjective? const-decl "bool" functions nil) (injective? const-decl "bool" functions nil) (pegMeasure const-decl "nat" peg nil)) nil (g_wf_perm termination "inferred_order_wf_peg.g_wf_perm(inferred_order_wf_peg.σ)(inferred_order_wf_peg.e, inferred_order_wf_peg.A, inferred_order_wf_peg.P_0, inferred_order_wf_peg.δ)" "nil")))("static_analysis" inferred_order_wf_peg g_wf_perm_TCC6 0 (g_wf_perm_TCC6-1 nil 3813750082 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (V_N_b formal-const-decl "posnat" inferred_order_wf_peg nil) (V_N type-eq-decl nil nTpred_order nil) (bijective? const-decl "bool" functions nil) (nT_Permutation type-eq-decl nil inferred_order_wf_peg nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (reduce_nat adt-def-decl "[peg -> nat]" peg nil) (inc const-decl "nat" peg nil) (surjective? const-decl "bool" functions nil) (injective? const-decl "bool" functions nil) (pegMeasure const-decl "nat" peg nil)) nil (g_wf_perm termination "inferred_order_wf_peg.g_wf_perm(inferred_order_wf_peg.σ)(inferred_order_wf_peg.e, inferred_order_wf_peg.A, inferred_order_wf_peg.P_0, inferred_order_wf_peg.δ)" "nil")))("static_analysis" inferred_order_wf_peg g_wf_perm_TCC7 0 (g_wf_perm_TCC7-1 nil 3813750082 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (V_N_b formal-const-decl "posnat" inferred_order_wf_peg nil) (V_N type-eq-decl nil nTpred_order nil) (bijective? const-decl "bool" functions nil) (nT_Permutation type-eq-decl nil inferred_order_wf_peg nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (reduce_nat adt-def-decl "[peg -> nat]" peg nil) (inc const-decl "nat" peg nil) (surjective? const-decl "bool" functions nil) (injective? const-decl "bool" functions nil) (pegMeasure const-decl "nat" peg nil)) nil (g_wf_perm termination "inferred_order_wf_peg.g_wf_perm(inferred_order_wf_peg.σ)(inferred_order_wf_peg.e, inferred_order_wf_peg.A, inferred_order_wf_peg.P_0, inferred_order_wf_peg.δ)" "nil")))("static_analysis" inferred_order_wf_peg g_wf_perm_TCC8 0 (g_wf_perm_TCC8-1 nil 3813750082 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (V_N_b formal-const-decl "posnat" inferred_order_wf_peg nil) (V_N type-eq-decl nil nTpred_order nil) (bijective? const-decl "bool" functions nil) (nT_Permutation type-eq-decl nil inferred_order_wf_peg nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (reduce_nat adt-def-decl "[peg -> nat]" peg nil) (inc const-decl "nat" peg nil) (surjective? const-decl "bool" functions nil) (injective? const-decl "bool" functions nil) (pegMeasure const-decl "nat" peg nil)) nil (g_wf_perm termination "inferred_order_wf_peg.g_wf_perm(inferred_order_wf_peg.σ)(inferred_order_wf_peg.e, inferred_order_wf_peg.A, inferred_order_wf_peg.P_0, inferred_order_wf_peg.δ)" "nil")))("static_analysis" inferred_order_wf_peg g_wf_perm_TCC9 0 (g_wf_perm_TCC9-1 nil 3813750082 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (V_N_b formal-const-decl "posnat" inferred_order_wf_peg nil) (V_N type-eq-decl nil nTpred_order nil) (bijective? const-decl "bool" functions nil) (nT_Permutation type-eq-decl nil inferred_order_wf_peg nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (reduce_nat adt-def-decl "[peg -> nat]" peg nil) (inc const-decl "nat" peg nil) (surjective? const-decl "bool" functions nil) (injective? const-decl "bool" functions nil) (pegMeasure const-decl "nat" peg nil)) nil (g_wf_perm termination "inferred_order_wf_peg.g_wf_perm(inferred_order_wf_peg.σ)(inferred_order_wf_peg.e, inferred_order_wf_peg.A, inferred_order_wf_peg.P_0, inferred_order_wf_peg.δ)" "nil")))("static_analysis" inferred_order_wf_peg sub_nT_TCC1 0 (sub_nT_TCC1-1 nil 3813611401 ("" (subtype-tcc) nil nil) ((∅ const-decl "set[V_N[V_N_b]]" inferred_order_wf_peg nil) (finite_emptyset name-judgement "finite_set" finite_sets nil)) nil (sub_nT subtype "inferred_order_wf_peg.∅" "finite_set[V_N[V_N_b]]")))("static_analysis" inferred_order_wf_peg sub_nT_TCC2 0 (sub_nT_TCC2-1 nil 3813611401 ("" (subtype-tcc) nil nil) ((∅ const-decl "set[V_N[V_N_b]]" inferred_order_wf_peg nil) (finite_emptyset name-judgement "finite_set" finite_sets nil)) nil (sub_nT subtype "inferred_order_wf_peg.∅" "finite_set[V_N[V_N_b]]")))("static_analysis" inferred_order_wf_peg sub_nT_TCC3 0 (sub_nT_TCC3-1 nil 3813611401 ("" (subtype-tcc) nil nil) ((∅ const-decl "set[V_N[V_N_b]]" inferred_order_wf_peg nil) (finite_emptyset name-judgement "finite_set" finite_sets nil)) nil (sub_nT subtype "inferred_order_wf_peg.∅" "finite_set[V_N[V_N_b]]")))("static_analysis" inferred_order_wf_peg sub_nT_TCC4 0 (sub_nT_TCC4-1 nil 3813611401 ("" (subtype-tcc) nil nil) ((∅ const-decl "set[V_N[V_N_b]]" inferred_order_wf_peg nil) (finite_emptyset name-judgement "finite_set" finite_sets nil)) nil (sub_nT subtype "inferred_order_wf_peg.∅" "finite_set[V_N[V_N_b]]")))("static_analysis" inferred_order_wf_peg sub_nT_TCC5 0 (sub_nT_TCC5-1 nil 3813611401 ("" (termination-tcc) nil nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (reduce_nat adt-def-decl "[peg -> nat]" peg nil) (sum const-decl "nat" peg nil) (pegMeasure const-decl "nat" peg nil)) nil (sub_nT termination "inferred_order_wf_peg.sub_nT(inferred_order_wf_peg.e1, inferred_order_wf_peg.P_0)" "nil")))("static_analysis" inferred_order_wf_peg sub_nT_TCC6 0 (sub_nT_TCC6-1 nil 3813611401 ("" (termination-tcc) nil nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (reduce_nat adt-def-decl "[peg -> nat]" peg nil) (sum const-decl "nat" peg nil) (pegMeasure const-decl "nat" peg nil)) nil (sub_nT termination "inferred_order_wf_peg.sub_nT(inferred_order_wf_peg.e2, inferred_order_wf_peg.P_0)" "nil")))("static_analysis" inferred_order_wf_peg sub_nT_TCC7 0 (sub_nT_TCC7-1 nil 3813611401 ("" (termination-tcc) nil nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (reduce_nat adt-def-decl "[peg -> nat]" peg nil) (sum const-decl "nat" peg nil) (pegMeasure const-decl "nat" peg nil)) nil (sub_nT termination "inferred_order_wf_peg.sub_nT(inferred_order_wf_peg.e1, inferred_order_wf_peg.P_0)" "nil")))("static_analysis" inferred_order_wf_peg sub_nT_TCC8 0 (sub_nT_TCC8-1 nil 3813611401 ("" (termination-tcc) nil nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (reduce_nat adt-def-decl "[peg -> nat]" peg nil) (sum const-decl "nat" peg nil) (pegMeasure const-decl "nat" peg nil)) nil (sub_nT termination "inferred_order_wf_peg.sub_nT(inferred_order_wf_peg.e1, inferred_order_wf_peg.P_0)" "nil")))("static_analysis" inferred_order_wf_peg sub_nT_TCC9 0 (sub_nT_TCC9-1 nil 3813611401 ("" (termination-tcc) nil nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (reduce_nat adt-def-decl "[peg -> nat]" peg nil) (sum const-decl "nat" peg nil) (pegMeasure const-decl "nat" peg nil)) nil (sub_nT termination "inferred_order_wf_peg.sub_nT(inferred_order_wf_peg.e2, inferred_order_wf_peg.P_0)" "nil")))("static_analysis" inferred_order_wf_peg sub_nT_TCC10 0 (sub_nT_TCC10-1 nil 3813611401 ("" (termination-tcc) nil nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (reduce_nat adt-def-decl "[peg -> nat]" peg nil) (inc const-decl "nat" peg nil) (pegMeasure const-decl "nat" peg nil)) nil (sub_nT termination "inferred_order_wf_peg.sub_nT(inferred_order_wf_peg.e, inferred_order_wf_peg.P_0)" "nil")))("static_analysis" inferred_order_wf_peg sub_nT_TCC11 0 (sub_nT_TCC11-1 nil 3813611401 ("" (termination-tcc) nil nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (reduce_nat adt-def-decl "[peg -> nat]" peg nil) (inc const-decl "nat" peg nil) (pegMeasure const-decl "nat" peg nil)) nil (sub_nT termination "inferred_order_wf_peg.sub_nT(inferred_order_wf_peg.e, inferred_order_wf_peg.P_0)" "nil")))("static_analysis" inferred_order_wf_peg sub_nT_TCC12 0 (sub_nT_TCC12-1 nil 3813611401 ("" (termination-tcc) nil nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (reduce_nat adt-def-decl "[peg -> nat]" peg nil) (inc const-decl "nat" peg nil) (pegMeasure const-decl "nat" peg nil)) nil (sub_nT termination "inferred_order_wf_peg.sub_nT(inferred_order_wf_peg.e, inferred_order_wf_peg.P_0)" "nil")))("static_analysis" inferred_order_wf_peg sub_nT_TCC13 0 (sub_nT_TCC13-1 nil 3813611401 ("" (termination-tcc) nil nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (reduce_nat adt-def-decl "[peg -> nat]" peg nil) (inc const-decl "nat" peg nil) (pegMeasure const-decl "nat" peg nil)) nil (sub_nT termination "inferred_order_wf_peg.sub_nT(inferred_order_wf_peg.e, inferred_order_wf_peg.P_0)" "nil")))("static_analysis" inferred_order_wf_peg sub_nT_TCC14 0 (sub_nT_TCC14-1 nil 3813611401 ("" (termination-tcc) nil nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (reduce_nat adt-def-decl "[peg -> nat]" peg nil) (inc const-decl "nat" peg nil) (pegMeasure const-decl "nat" peg nil)) nil (sub_nT termination "inferred_order_wf_peg.sub_nT(inferred_order_wf_peg.e, inferred_order_wf_peg.P_0)" "nil")))("static_analysis" inferred_order_wf_peg sub_nT_and_wellformedness_TCC1 0 (sub_nT_and_wellformedness_TCC1-1 nil 3813611401 ("" (subtype-tcc) nil nil) nil nil (sub_nT_and_wellformedness subtype "inferred_order_wf_peg.A" "naturalnumbers.upto(inferred_order_wf_peg.V_N_b)")))("static_analysis" inferred_order_wf_peg sub_nT_and_wellformedness 0 (sub_nT_and_wellformedness-1 nil 3813611424 ("" (induct G) (("1" (skeep*) (("1" (assert) (("1" (expand "g_wf") (("1" (expand "sub_nT") (("1" (assert) (("1" (skeep) (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (skolem 1 ("e1" "e2")) (("6" (flatten) (("6" (skeep*) (("6" (expand "g_wf" +) (("6" (assert) (("6" (inst -1 "A" "P_0") (("6" (inst -2 "A" "P_0") (("6" (split 1) (("1" (flatten) (("1" (assert) (("1" (split) (("1" (assert) nil nil) ("2" (flatten) (("2" (assert) (("2" (expand "complete") (("2" (expand "strong") (("2" (assert) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) (("3" (flatten) (("3" (assert) (("3" (skeep*) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "strong") (("2" (expand "complete") (("2" (flatten) (("2" (split) (("1" (assert) (("1" (skeep) (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (ground) (("1" (grind) nil nil) ("2" (skeep*) (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (skolem 1 ("e1" "e2")) (("7" (flatten) (("7" (skeep*) (("7" (inst -1 "A" "P_0") (("7" (inst - "A" "P_0") (("7" (expand "strong") (("7" (expand "complete") (("7" (expand "g_wf" +) (("7" (split 1) (("1" (flatten) (("1" (assert) (("1" (split 1) (("1" (flatten) nil nil) ("2" (assert) nil nil) ("3" (skeep*) (("3" (assert) (("3" (expand "sub_nT" -1) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 1) (("1" (assert) (("1" (skeep) (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (skeep) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("8" (skolem 1 ("e")) (("8" (flatten) (("8" (skeep) (("8" (inst? -) (("8" (inst? -) (("8" (expand "g_wf" +) (("8" (split 1) (("1" (flatten) (("1" (assert) (("1" (split 2) (("1" (assert) nil nil) ("2" (skeep) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (skeep) (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("9" (skolem 1 ("e")) (("9" (flatten) (("9" (skeep) (("9" (inst? -) (("9" (inst? -) (("9" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("10" (skolem 1 ("e")) (("10" (flatten) (("10" (skeep) (("10" (inst? -) (("10" (inst? -) (("10" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("11" (skolem 1 ("e")) (("11" (flatten) (("11" (skeep) (("11" (inst? -) (("11" (inst? -) (("11" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("12" (skolem 1 ("e")) (("12" (flatten) (("12" (skeep) (("12" (inst? -) (("12" (inst? -) (("12" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((finite_union application-judgement "finite_set" finite_sets nil) (member const-decl "bool" sets nil) (union const-decl "set" sets nil) (singleton const-decl "(singleton?)" sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (below type-eq-decl nil naturalnumbers nil) (TRUE const-decl "bool" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (finite_emptyset name-judgement "finite_set" finite_sets nil) (emptyset const-decl "set" sets nil) (∅ const-decl "set[V_N[V_N_b]]" inferred_order_wf_peg nil) (peg_induction formula-decl nil peg nil) (V_T formal-nonempty-type-decl nil inferred_order_wf_peg nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (pred type-eq-decl nil defined_types nil) (total_order? const-decl "bool" orders nil) (<= formal-const-decl "(total_order?[V_T])" inferred_order_wf_peg nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (V_N_b formal-const-decl "posnat" inferred_order_wf_peg nil) (sub_nT def-decl "finite_set[V_N[V_N_b]]" inferred_order_wf_peg nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (complete const-decl "bool" wf_peg nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (strong const-decl "bool" wf_peg nil) (g_wf def-decl "bool" wf_peg nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (V_N type-eq-decl nil nTpred_order nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (peg type-decl nil peg nil)) shostak))("static_analysis" inferred_order_wf_peg sub_nT_and_wellformedness_perm 0 (sub_nT_and_wellformedness_perm-1 nil 3813751386 ("" (skolem 1 ("s" "_" "_" "_")) (("" (expand "strong") (("" (expand "complete") (("" (induct G) (("1" (skeep*) (("1" (expand "g_wf_perm" +) (("1" (ground) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (skeep*) (("2" (expand "g_wf_perm" +) (("2" (ground) (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (skeep*) (("3" (expand "g_wf_perm" +) (("3" (ground) (("3" (grind) nil nil)) nil)) nil)) nil) ("4" (skeep*) (("4" (expand "g_wf_perm" +) (("4" (ground) (("4" (grind) nil nil)) nil)) nil)) nil) ("5" (skeep*) (("5" (expand "g_wf_perm" +) (("5" (ground) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("6" (skeep*) (("6" (expand "g_wf_perm" +) (("6" (ground) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (inst? -4) (("4" (assert) (("4" (skeep) (("4" (grind) nil nil)) nil)) nil)) nil) ("5" (inst? -5) (("5" (assert) (("5" (case "P_0(seq1_var)") (("1" (assert) (("1" (skeep) (("1" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (skeep*) (("7" (expand "g_wf_perm" +) (("7" (assert) (("7" (split 1) (("1" (flatten) (("1" (assert) (("1" (split) (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil) ("3" (expand "sub_nT" 1) (("3" (expand "union" 1) (("3" (skeep) (("3" (assert) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 1) (("1" (inst? -4) (("1" (assert) (("1" (skeep) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (inst? -5) (("2" (assert) (("2" (skeep) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("8" (skeep*) (("8" (expand "g_wf_perm" +) (("8" (ground) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil) ("9" (skeep*) (("9" (expand "g_wf_perm" +) (("9" (ground) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil) ("10" (skeep*) (("10" (expand "g_wf_perm" +) (("10" (ground) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil) ("11" (skeep*) (("11" (expand "g_wf_perm" +) (("11" (ground) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil) ("12" (skeep*) (("12" (expand "g_wf_perm" +) (("12" (ground) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((strong const-decl "bool" wf_peg nil) (union const-decl "set" sets nil) (member const-decl "bool" sets nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (singleton const-decl "(singleton?)" sets nil) (below type-eq-decl nil naturalnumbers nil) (emptyset const-decl "set" sets nil) (∅ const-decl "set[V_N[V_N_b]]" inferred_order_wf_peg nil) (peg_induction formula-decl nil peg nil) (V_T formal-nonempty-type-decl nil inferred_order_wf_peg nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (pred type-eq-decl nil defined_types nil) (total_order? const-decl "bool" orders nil) (<= formal-const-decl "(total_order?[V_T])" inferred_order_wf_peg nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (V_N_b formal-const-decl "posnat" inferred_order_wf_peg nil) (sub_nT def-decl "finite_set[V_N[V_N_b]]" inferred_order_wf_peg nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (FALSE const-decl "bool" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (TRUE const-decl "bool" booleans nil) (g_wf_perm def-decl "bool" inferred_order_wf_peg nil) (nT_Permutation type-eq-decl nil inferred_order_wf_peg nil) (bijective? const-decl "bool" functions nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (V_N type-eq-decl nil nTpred_order nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (peg type-decl nil peg nil) (complete const-decl "bool" wf_peg nil)) shostak))("static_analysis" inferred_order_wf_peg kahns_algorithm_TCC1 0 (kahns_algorithm_TCC1-1 nil 3813648570 ("" (inst 1 "LAMBDA (P_exp: interp[V_T, <=, V_N_b]): None") nil nil) ((None adt-constructor-decl "(None?)" inferred_order_wf_peg nil) (None? adt-recognizer-decl "[option_permutation -> boolean]" inferred_order_wf_peg nil) (σ adt-accessor-decl "[(Some?) -> nT_Permutation]" inferred_order_wf_peg nil) (topologically_sorts? const-decl "bool" inferred_order_wf_peg nil) (nT_Permutation type-eq-decl nil inferred_order_wf_peg nil) (bijective? const-decl "bool" functions nil) (peg type-decl nil peg nil) (V_N type-eq-decl nil nTpred_order nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Some? adt-recognizer-decl "[option_permutation -> boolean]" inferred_order_wf_peg nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (option_permutation type-decl nil inferred_order_wf_peg nil) (interp type-eq-decl nil wf_peg nil) (V_N_b formal-const-decl "posnat" inferred_order_wf_peg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (<= formal-const-decl "(total_order?[V_T])" inferred_order_wf_peg nil) (total_order? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (V_T formal-nonempty-type-decl nil inferred_order_wf_peg nil)) nil (kahns_algorithm existence "" "[P_exp: wf_peg[inferred_order_wf_peg.V_T, inferred_order_wf_peg.<=, inferred_order_wf_peg.V_N_b].interp -> {Σ: inferred_order_wf_peg.option_permutation | (booleans.⇒(inferred_order_wf_peg.Some?(Σ), inferred_order_wf_peg.topologically_sorts?(P_exp, inferred_order_wf_peg.σ(Σ))))}]")))("static_analysis" inferred_order_wf_peg complete_WF_reorders 0 (complete_WF_reorders-2 "Tried to unfold a g_wf in hypothesis, spotted a problem" 3813747419 ("" (skolem 1 ("P_exp" "s")) (("" (flatten) (("" (case "(FORALL (A: V_N[V_N_b]), G: subterm(G, P_exp(A)) IMPLIES g_wf(G, A, P_0c?(P_exp), FALSE)) ⇒
                     FORALL (A: V_N[V_N_b]), G: subterm(G, (P_exp)(A)) IMPLIES g_wf_perm(s)(G, A, P_0c?(P_exp), FALSE)") (("1" (expand "complete_WF_perm") (("1" (split -1) (("1" (grind) nil nil) ("2" (hide 2) (("2" (use "complete_WF_theorem2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (flatten) (("2" (skolem 1 ("A" "_")) (("2" (induct "G") (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (skolem 1 (e1 e2)) (("6" (assert) (("6" (flatten) (("6" (assert) (("6" (expand g_wf_perm 1) (("6" (split 1) (("1" (assert) (("1" (use "peg[V_T, <=, V_N_b].subterm_transitivity" (e1 "seq(e1,e2)")) (("1" (grind) nil nil)) nil)) nil) ("2" (assert) (("2" (use "peg[V_T, <=, V_N_b].subterm_transitivity" (e1 "seq(e1,e2)")) (("2" (assert) (("2" (use "peg[V_T, <=, V_N_b].subterm_transitivity" (e1 "seq(e1,e2)" e e2)) (("2" (assert) (("2" (ground) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (skolem 1 (e1 e2)) (("7" (flatten) (("7" (assert) (("7" (expand g_wf_perm 1) (("7" (split 1) (("1" (assert) (("1" (use "peg[V_T, <=, V_N_b].subterm_transitivity" (e1 "prior(e1,e2)")) (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (use "peg[V_T, <=, V_N_b].subterm_transitivity" (e1 "prior(e1,e2)")) (("2" (use "peg[V_T, <=, V_N_b].subterm_transitivity" (e1 "prior(e1,e2)" e e2)) (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("8" (skolem 1 (e)) (("8" (flatten) (("8" (assert) (("8" (expand g_wf_perm 1) (("8" (split 1) (("1" (assert) (("1" (use "peg[V_T, <=, V_N_b].subterm_transitivity" (e1 "star(e)")) (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (inst -4 "A" "star(e)") (("2" (assert) (("2" (expand "g_wf") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("9" (skolem 1 (e)) (("9" (flatten) (("9" (assert) (("9" (expand g_wf_perm 1) (("9" (split 1) (("1" (assert) (("1" (use "peg[V_T, <=, V_N_b].subterm_transitivity" (e1 "plus(e)")) (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (inst - "A" "plus(e)") (("2" (assert) (("2" (expand "g_wf") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("10" (skolem 1 (e)) (("10" (flatten) (("10" (assert) (("10" (expand g_wf_perm 1) (("10" (assert) (("10" (use "peg[V_T, <=, V_N_b].subterm_transitivity" (e1 "opt(e)")) (("10" (assert) (("10" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("11" (skolem 1 (e)) (("11" (flatten) (("11" (assert) (("11" (expand g_wf_perm 1) (("11" (assert) (("11" (use "peg[V_T, <=, V_N_b].subterm_transitivity" (e1 "notP(e)")) (("11" (assert) (("11" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("12" (skolem 1 (e)) (("12" (flatten) (("12" (assert) (("12" (expand g_wf_perm 1) (("12" (assert) (("12" (use "peg[V_T, <=, V_N_b].subterm_transitivity" (e1 "andP(e)")) (("12" (assert) (("12" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((andP? adt-recognizer-decl "[peg -> boolean]" peg nil) (andP adt-constructor-decl "[peg -> (andP?)]" peg nil) (notP? adt-recognizer-decl "[peg -> boolean]" peg nil) (notP adt-constructor-decl "[peg -> (notP?)]" peg nil) (opt? adt-recognizer-decl "[peg -> boolean]" peg nil) (opt adt-constructor-decl "[peg -> (opt?)]" peg nil) (plus adt-constructor-decl "[peg -> (plus?)]" peg nil) (plus? adt-recognizer-decl "[peg -> boolean]" peg nil) (star adt-constructor-decl "[peg -> (star?)]" peg nil) (star? adt-recognizer-decl "[peg -> boolean]" peg nil) (prior adt-constructor-decl "[[peg, peg] -> (prior?)]" peg nil) (prior? adt-recognizer-decl "[peg -> boolean]" peg nil) (subterm_transitivity formula-decl nil peg nil) (seq? adt-recognizer-decl "[peg -> boolean]" peg nil) (seq adt-constructor-decl "[[peg, peg] -> (seq?)]" peg nil) (peg_induction formula-decl nil peg nil) (complete_WF_perm const-decl "bool" inferred_order_wf_peg nil) (complete_WF_theorem2 formula-decl nil wf_peg nil) (int_minus_int_is_int application-judgement "int" integers nil) (complete const-decl "bool" wf_peg nil) (complete_WF const-decl "bool" wf_peg nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (V_N_b formal-const-decl "posnat" inferred_order_wf_peg nil) (V_N type-eq-decl nil nTpred_order nil) (V_T formal-nonempty-type-decl nil inferred_order_wf_peg nil) (pred type-eq-decl nil defined_types nil) (total_order? const-decl "bool" orders nil) (<= formal-const-decl "(total_order?[V_T])" inferred_order_wf_peg nil) (peg type-decl nil peg nil) (subterm adt-def-decl "boolean" peg nil) (interp type-eq-decl nil wf_peg nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (g_wf def-decl "bool" wf_peg nil) (P_0c? const-decl "[Δ -> bool]" wf_peg nil) (FALSE const-decl "bool" booleans nil) (bijective? const-decl "bool" functions nil) (nT_Permutation type-eq-decl nil inferred_order_wf_peg nil) (g_wf_perm def-decl "bool" inferred_order_wf_peg nil)) shostak) (complete_WF_reorders-1 nil 3813650558 ("" (skolem 1 ("P_exp" "s")) (("" (flatten) (("" (expand "complete_WF" 1) (("" (skeep) (("" (case "(FORALL (A: V_N[V_N_b]), G: subterm(G, P_exp(A)) IMPLIES g_wf(G, A, P_0c?(P_exp), FALSE)) ⇒
              FORALL (A: V_N[V_N_b]), G: subterm(G, (P_exp o s)(A)) IMPLIES g_wf(G, A, P_0c?(P_exp o s), FALSE)") (("1" (split -1) (("1" (inst -1 "A" "(P_exp o s)(A)") (("1" (assert) (("1" (expand "complete") (("1" (assert) (("1" (expand "subterm") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "complete_WF_theorem2") (("2" (inst? -) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (hide 2) (("2" (skolem 1 (B _)) (("2" (induct "G") (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (skolem 1 (e1 e2)) (("6" (flatten) (("6" (expand "g_wf" 1) (("6" (split) (("1" (assert) (("1" (assert) (("1" (use "peg[V_T, <=, V_N_b].subterm_transitivity" (e1 "seq(e1,e2)")) (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (use "peg[V_T, <=, V_N_b].subterm_transitivity" (e1 "seq(e1,e2)")) (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (skolem 1 (e1 e2)) (("7" (flatten) (("7" (expand "g_wf" 1) (("7" (split) (("1" (assert) (("1" (use "peg[V_T, <=, V_N_b].subterm_transitivity" (e1 "prior(e1,e2)")) (("1" (assert) (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (use "peg[V_T, <=, V_N_b].subterm_transitivity" (e1 "prior(e1,e2)")) (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("8" (skolem 1 (e)) (("8" (assert) (("8" (flatten) (("8" (postpone) nil nil)) nil)) nil)) nil) ("9" (skolem 1 (e)) (("9" (flatten) (("9" (assert) (("9" (expand "g_wf" +) (("9" (split 1) (("1" (assert) (("1" (use "peg[V_T, <=, V_N_b].subterm_transitivity" (e1 "plus(e)")) (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("10" (skolem 1 (e)) (("10" (flatten) (("10" (simplify) (("10" (expand "g_wf" +) (("10" (assert) (("10" (use "peg[V_T, <=, V_N_b].subterm_transitivity" (e1 "opt(e)")) (("10" (assert) (("10" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("11" (skolem 1 (e)) (("11" (flatten) (("11" (expand "g_wf" +) (("11" (assert) (("11" (use "peg[V_T, <=, V_N_b].subterm_transitivity" (e1 "notP(e)")) (("11" (assert) (("11" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("12" (skolem 1 (e)) (("12" (flatten) (("12" (expand "g_wf" +) (("12" (assert) (("12" (use "peg[V_T, <=, V_N_b].subterm_transitivity" (e1 "andP(e)")) (("12" (assert) (("12" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("static_analysis" inferred_order_wf_peg topological_sort_well_orders 0 (topological_sort_well_orders-1 nil 3813648698 ("" (skolem 1 (P_exp "s")) (("" (flatten) (("" (typepred "kahns_algorithm(P_exp)") (("" (replace -2 * LR) (("" (assert) (("" (hide -2) (("" (expand "topologically_sorts?") (("" (expand "well_orders?") (("" (expand "strong_WF_perm") (("" (use "complete_WF_reorders") (("" (assert) (("" (lemma "sub_nT_and_wellformedness_perm") (("" (skeep) (("" (inst -1 "s" "P_exp(A)" "A" "P_0c?(P_exp)") (("" (assert) (("" (hide 2) (("" (expand "complete_WF_perm") (("" (split 1) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((well_orders? const-decl "bool" inferred_order_wf_peg nil) (complete_WF_reorders formula-decl nil inferred_order_wf_peg nil) (sub_nT_and_wellformedness_perm formula-decl nil inferred_order_wf_peg nil) (P_0c? const-decl "[Δ -> bool]" wf_peg nil) (complete_WF const-decl "bool" wf_peg nil) (complete const-decl "bool" wf_peg nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (complete_WF_perm const-decl "bool" inferred_order_wf_peg nil) (strong_WF_perm const-decl "bool" inferred_order_wf_peg nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (option_permutation type-decl nil inferred_order_wf_peg nil) (Some? adt-recognizer-decl "[option_permutation -> boolean]" inferred_order_wf_peg nil) (V_T formal-nonempty-type-decl nil inferred_order_wf_peg nil) (pred type-eq-decl nil defined_types nil) (total_order? const-decl "bool" orders nil) (<= formal-const-decl "(total_order?[V_T])" inferred_order_wf_peg nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (V_N_b formal-const-decl "posnat" inferred_order_wf_peg nil) (interp type-eq-decl nil wf_peg nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (V_N type-eq-decl nil nTpred_order nil) (peg type-decl nil peg nil) (bijective? const-decl "bool" functions nil) (nT_Permutation type-eq-decl nil inferred_order_wf_peg nil) (topologically_sorts? const-decl "bool" inferred_order_wf_peg nil) (σ adt-accessor-decl "[(Some?) -> nT_Permutation]" inferred_order_wf_peg nil) (kahns_algorithm const-decl "{Σ: option_permutation | (Some?(Σ) ⇒ topologically_sorts?(P_exp, σ(Σ)))}" inferred_order_wf_peg nil)) shostak))("static_analysis" static_analysis no_repetitions_union 0 (no_repetitions_union-1 nil 3847278310 ("" (induct "l1") (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (skolem 1 ("x" "l")) (("3" (flatten) (("3" (use "no_rep_cdr[V_N]") (("3" (assert) (("3" (flatten) (("3" (assert) (("3" (skeep) (("3" (hide -3) (("3" (inst -2 "l2") (("3" (hide -1) (("3" (expand "union_sl" +) (("3" (typepred "add_sl(x, union_sl(l, l2))") (("3" (hide -1 -2) (("3" (expand "no_repetitions?") (("3" (skeep) (("3" (inst-cp -1 "nth(add_sl(x, union_sl(l, l2)), i)") (("3" (inst -1 "nth(add_sl(x, union_sl(l, l2)), j)") (("3" (flatten) (("3" (assert) (("3" (hide -2 -4) (("3" (split -1 -2) (("1" (split -2) (("1" (postpone) nil nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("static_analysis" static_analysis IMP_c_topological_sort_TCC1 0 (IMP_c_topological_sort_TCC1-1 nil 3847268234 ("" (typepred "V_N_b") (("" (inst 1 0) (("" (assert) nil nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (V_N type-eq-decl nil nTpred_order nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (V_N_b formal-const-decl "posnat" static_analysis nil)) nil (IMP_c_topological_sort existence "" "V_N[V_N_b]")))("static_analysis" static_analysis IMP_c_topological_sort_TCC1 0 (IMP_c_topological_sort_TCC1-1 nil 3847362076 ("" (inst 1 0) (("" (assert) nil nil)) nil) ((V_N type-eq-decl nil nTpred_order nil) (V_N_b formal-const-decl "posnat" static_analysis nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (IMP_c_topological_sort existence "" "V_N[V_N_b]")))("static_analysis" static_analysis IMP_c_topological_sort_TCC1 0 (IMP_c_topological_sort_TCC1-1 nil 3847444706 ("" (grind) (("" (inst 1 0) (("" (grind) nil nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (V_N_b formal-const-decl "posnat" static_analysis nil) (V_N type-eq-decl nil nTpred_order nil)) nil (IMP_c_topological_sort existence "" "V_N[V_N_b]")))("static_analysis" static_analysis IMP_c_topological_sort_TCC1 0 (IMP_c_topological_sort_TCC1-1 nil 3847453131 ("" (existence-tcc) nil nil) nil nil (IMP_c_topological_sort existence "" "V_N[V_N_b]")))("static_analysis" static_analysis IMP_c_topological_sort_TCC1 0 (IMP_c_topological_sort_TCC1-1 nil 3847455549 ("" (existence-tcc) nil nil) nil nil (IMP_c_topological_sort existence "" "V_N[V_N_b]")))("static_analysis" static_analysis IMP_c_topological_sort_TCC1 0 (IMP_c_topological_sort_TCC1-1 nil 3847455549 ("" (inst 1 0) (("" (grind) nil nil)) nil) ((V_N type-eq-decl nil nTpred_order nil) (V_N_b formal-const-decl "posnat" static_analysis nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (IMP_c_topological_sort existence "" "V_N[V_N_b]")))("static_analysis" static_analysis IMP_c_topological_sort_TCC1 0 (IMP_c_topological_sort_TCC1-1 nil 3847461392 ("" (inst 1 0) (("" (grind) nil nil)) nil) ((V_N type-eq-decl nil nTpred_order nil) (V_N_b formal-const-decl "posnat" static_analysis nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (IMP_c_topological_sort existence "" "V_N[V_N_b]")))("static_analysis" static_analysis IMP_c_topological_sort_TCC1 0 (IMP_c_topological_sort_TCC1-1 nil 3847461898 ("" (existence-tcc) nil nil) nil nil (IMP_c_topological_sort existence "" "V_N[V_N_b]")))("subrange_list" interval_list interval_list_rec_TCC1 0 (interval_list_rec_TCC1-1 nil 3847474782 ("" (subtype-tcc) nil nil) nil nil (interval_list_rec subtype "(number_fields.-)(interval_list.j, interval_list.i)" "naturalnumber")))("subrange_list" interval_list interval_list_rec_TCC2 0 (interval_list_rec_TCC2-1 nil 3847474782 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (upfrom nonempty-type-eq-decl nil integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (interval_list_rec subtype "interval_list.j" "integers.upfrom((number_fields.+)(1, interval_list.i))")))("subrange_list" interval_list interval_list_rec_TCC3 0 (interval_list_rec_TCC3-1 nil 3847474782 ("" (termination-tcc) nil nil) ((int_minus_int_is_int application-judgement "int" integers nil)) nil (interval_list_rec termination "interval_list.interval_list_rec((number_fields.+)(interval_list.i, 1), interval_list.j)" "nil")))("subrange_list" interval_list interval_list_TCC1 0 (interval_list_TCC1-1 nil 3847474782 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (interval_list subtype "interval_list.j" "integers.upfrom(interval_list.i)")))("subrange_list" interval_list interval_list_length 0 (interval_list_length-1 nil 3847474795 ("" (skeep) (("" (expand "interval_list") (("" (case "forall (i:below(n+1)) : length(interval_list_rec((n-i),n)) = i +1") (("1" (inst -1 n) (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (induct i) (("1" (grind) nil nil) ("2" (skolem 1 "i") (("2" (ground) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((interval_list const-decl "list[nat]" interval_list nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (even_plus_odd_is_odd application-judgement "odd_int" integers nil) (below_induction formula-decl nil bounded_nat_inductions nil) (pred type-eq-decl nil defined_types nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (length def-decl "nat" list_props nil) (upfrom nonempty-type-eq-decl nil integers nil) (interval_list_rec def-decl "list[nat]" interval_list nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil)) shostak))("subrange_list" interval_list interval_list_idx_TCC1 0 (interval_list_idx_TCC1-1 nil 3847474782 ("" (subtype-tcc) nil nil) nil nil (interval_list_idx subtype "interval_list.j" "{a: numbers.number | list_props[numbers.number].member(a, interval_list.interval_list(0, interval_list.n))}")))("static_analysis" static_analysis IMP_c_topological_sort_TCC1 0 (IMP_c_topological_sort_TCC1-1 nil 3847472036 ("" (existence-tcc) nil nil) nil nil (IMP_c_topological_sort existence "" "V_N[V_N_b]")))("static_analysis" static_analysis make_srl_length 0 (make_srl_length-1 nil 3847362913 ("" (skeep) (("" (expand "make_srl") (("" (lift-if) (("" (assert) (("" (case "forall (i:below(n+1)) : length(make_srl_rec((n-i),n)) = i +1") (("1" (inst -1 n) (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (induct i) (("1" (grind) nil nil) ("2" (skolem 1 "i") (("2" (ground) (("2" (expand "make_srl_rec" +) (("2" (expand "length" +) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((make_srl const-decl "subrange_list(i, j)" subrange_list structures) (int_plus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (even_plus_odd_is_odd application-judgement "odd_int" integers nil) (below_induction formula-decl nil bounded_nat_inductions nil) (pred type-eq-decl nil defined_types nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (length def-decl "nat" list_props nil) (upfrom nonempty-type-eq-decl nil integers nil) (subrange_list? const-decl "bool" subrange_list structures) (subrange_list type-eq-decl nil subrange_list structures) (make_srl_rec def-decl "subrange_list(i, j)" subrange_list structures) (- const-decl "[numfield, numfield -> numfield]" number_fields nil)) shostak))("static_analysis" static_analysis make_srl_idx_TCC1 0 (make_srl_idx_TCC1-1 nil 3847454216 ("" (skeep) (("" (typepred "make_srl(0, n)") (("" (rewrite "every_iff_member[number]") (("" (grind) nil nil)) nil)) nil)) nil) ((nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (make_srl const-decl "subrange_list(i, j)" subrange_list structures) (subrange_list type-eq-decl nil subrange_list structures) (subrange_list? const-decl "bool" subrange_list structures) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (/= const-decl "boolean" notequal nil) (no_repetitions? const-decl "bool" more_list_props structures) (every_iff_member formula-decl nil static_analysis nil)) nil (make_srl_idx subtype "static_analysis.j" "{a: numbers.number | list_props[numbers.number].member(a, subrange_list.make_srl(0, static_analysis.n))}")))("static_analysis" static_analysis make_srl_idx 0 (make_srl_idx-1 nil 3847454221 ("" (skolem 1 ("n" "_")) (("" (case "FORALL (k : upto(n), j: nat) : (n-k) <= j <= n IMPLIES idx(make_srl(n-k, n), j) = j-(n-k)") (("1" (skeep) (("1" (inst -1 "n" j) (("1" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (induct "k") (("1" (skeep) (("1" (assert) (("1" (expand "make_srl") (("1" (expand "make_srl_rec") (("1" (case-replace "j=n") (("1" (assert) (("1" (expand "idx") (("1" (propax) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 "i") (("2" (flatten) (("2" (skeep) (("2" (expand "make_srl") (("2" (expand "make_srl_rec" +) (("2" (assert) (("2" (expand "idx" +) (("2" (lift-if) (("2" (assert) (("2" (inst -2 j) (("2" (assert) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (typepred "make_srl(n-k, n)") (("3" (expand "subrange_list?") (("3" (flatten) (("3" (inst -2 j) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (typepred "make_srl(n-k, n)") (("3" (expand "subrange_list?") (("3" (flatten) (("3" (inst -2 j) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((make_srl const-decl "subrange_list(i, j)" subrange_list structures) (subrange_list type-eq-decl nil subrange_list structures) (subrange_list? const-decl "bool" subrange_list structures) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (idx def-decl "{i: below(length(l)) | nth(l, i) = a}" more_list_props structures) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (member def-decl "bool" list_props nil) (list type-decl nil list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (n skolem-const-decl "nat" static_analysis nil) (pred type-eq-decl nil defined_types nil) (upto_induction formula-decl nil bounded_nat_inductions nil) (make_srl_rec def-decl "subrange_list(i, j)" subrange_list structures) (int_plus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil)) shostak))("static_analysis" static_analysis IMP_c_topological_sort_TCC1 0 (IMP_c_topological_sort_TCC1-1 nil 3847517706 ("" (existence-tcc) nil nil) nil nil (IMP_c_topological_sort existence "" "V_N[V_N_b]")))("static_analysis" static_analysis strong_WF_path 0 (strong_WF_path-1 nil 3847451834 ("" (skeep*) (("" (expand "strong_WF") (("" (inst -1 "A") (("" (case "member(B, sub_nT(P_exp(A), P_0c?(P_exp)))") (("1" (hide -3) (("1" (name-replace "G" "P_exp(A)") (("1" (case "subterm(G, P_exp(A))") (("1" (generalize "G" "G") (("1" (induct "G") (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (skolem 1 ("e1" "e2")) (("6" (flatten) (("6" (use "subterm_seq[V_T, <=, V_N_b]") (("6" (expand "sub_nT" -5) (("6" (expand "g_wf" -6) (("6" (flatten) (("6" (assert) (("6" (flatten) (("6" (lift-if) (("6" (typepred "union_sl(sub_nT(e1, P_0c?(P_exp)), sub_nT(e2, P_0c?(P_exp)))") (("6" (hide -1) (("6" (inst -1 B) (("6" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (skolem 1 ("e1" "e2")) (("7" (flatten) (("7" (use "subterm_prior[V_T, <=, V_N_b]") (("7" (expand "sub_nT" -5) (("7" (expand "g_wf" -6) (("7" (flatten) (("7" (assert) (("7" (flatten) (("7" (typepred "union_sl(sub_nT(e1, P_0c?(P_exp)), sub_nT(e2, P_0c?(P_exp)))") (("7" (hide -1) (("7" (inst -1 B) (("7" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("8" (skolem 1 ("e")) (("8" (flatten) (("8" (use "subterm_star[V_T, <=, V_N_b]") (("8" (grind) nil nil)) nil)) nil)) nil) ("9" (skolem 1 ("e")) (("9" (flatten) (("9" (use "subterm_plus[V_T, <=, V_N_b]") (("9" (grind) nil nil)) nil)) nil)) nil) ("10" (skolem 1 ("e")) (("10" (flatten) (("10" (use "subterm_opt[V_T, <=, V_N_b]") (("10" (grind) nil nil)) nil)) nil)) nil) ("11" (skolem 1 ("e")) (("11" (flatten) (("11" (use "subterm_notP[V_T, <=, V_N_b]") (("11" (grind) nil nil)) nil)) nil)) nil) ("12" (skolem 1 ("e")) (("12" (flatten) (("12" (use "subterm_andP[V_T, <=, V_N_b]") (("12" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind :exclude "subterm") (("2" (expand "G") (("2" (expand "subterm") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (expand "restrict") (("2" (expand "edges") (("2" (flatten) (("2" (expand "dependency_graph" -3) (("2" (expand "nodes" -3 1) (("2" (lemma "interval_list_idx") (("2" (inst -1 "0" "V_N_b - 1" "B") (("2" (assert) (("2" (replace -1 * LR) (("2" (expand "nodes" -4 2) (("2" (lemma "interval_list_idx") (("2" (inst -1 0 "V_N_b-1" "A") (("2" (assert) (("2" (replace -1 * LR) (("2" (case-replace "nth(map(adjacents(P_exp))(nodes(P_exp)), A) = adjacents(P_exp)(nth(nodes(P_exp),A))") (("1" (expand "adjacents") (("1" (expand "nodes") (("1" (rewrite "interval_list_nth") nil nil)) nil)) nil) ("2" (hide - 2) (("2" (lemma "map_nth_rw[V_N, {l : list[V_N] | no_repetitions?(l)}]") (("2" (inst -1 "adjacents(P_exp)" "nodes(P_exp)" "A") nil nil)) nil)) nil) ("3" (typepred "A") (("3" (expand "nodes") (("3" (rewrite "interval_list_length") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((strong_WF const-decl "bool" wf_peg nil) (P_0c? const-decl "[Δ -> bool]" wf_peg nil) (interp type-eq-decl nil wf_peg nil) (sub_nT def-decl "(no_repetitions?[V_N])" static_analysis nil) (no_repetitions? const-decl "bool" more_list_props structures) (peg type-decl nil peg nil) (<= formal-const-decl "(total_order?[V_T])" static_analysis nil) (total_order? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (V_T formal-nonempty-type-decl nil static_analysis nil) (member def-decl "bool" list_props nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (G skolem-const-decl "peg[V_T, <=, V_N_b]" static_analysis nil) (strong const-decl "bool" wf_peg nil) (g_wf def-decl "bool" wf_peg nil) (order type-eq-decl nil wf_peg nil) (bijective? const-decl "bool" functions nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (subterm_andP formula-decl nil peg nil) (subterm_notP formula-decl nil peg nil) (subterm_opt formula-decl nil peg nil) (subterm_plus formula-decl nil peg nil) (subterm_star formula-decl nil peg nil) (subterm_prior formula-decl nil peg nil) (subterm_seq formula-decl nil peg nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nT_properties const-decl "F(P_exp)" wf_peg nil) (array_sum const-decl "upto(3 * V_N_b)" array_sum nil) (r const-decl "C(P_exp)" wf_peg nil) (union_sl def-decl "{ll: list[T] | FORALL x: member(x, ll) IFF (member(x, l1) OR member(x, l2))}" set_as_list structures) (OR const-decl "[bool, bool -> bool]" booleans nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (below type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (peg_induction formula-decl nil peg nil) (subterm adt-def-decl "boolean" peg nil) (restrict const-decl "R" restrict nil) (nodes const-decl "list[V_N]" static_analysis nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (map adt-def-decl "list[T1]" list_adt_map nil) (adjacents const-decl "{l: list[V_N] | no_repetitions?(l)}" static_analysis nil) (interval_list_nth formula-decl nil interval_list nil) (map_nth_rw formula-decl nil more_map_props nil) (interval_list_length formula-decl nil interval_list nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (interval_list_idx formula-decl nil interval_list nil) (dependency_graph const-decl "c_digraph[nat]" static_analysis nil) (edges const-decl "bool" c_digraphs_def digraphs) (V_N type-eq-decl nil nTpred_order nil) (V_N_b formal-const-decl "posnat" static_analysis nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak))("static_analysis" static_analysis IMP_c_topological_sort_TCC1 0 (IMP_c_topological_sort_TCC1-1 nil 3847523273 ("" (existence-tcc) nil nil) nil nil (IMP_c_topological_sort existence "" "V_N[V_N_b]")))("static_analysis" static_analysis V_N_subtype_nat 0 (V_N_subtype_nat-1 nil 3847461585 ("" (judgement-tcc) nil nil) nil nil (V_N_subtype_nat_ subtype "nTpred_order[static_analysis.V_N_b].V_N" "naturalnumbers.nat")))("static_analysis" static_analysis V_N_subtype_int 0 (V_N_subtype_int-1 nil 3847470924 ("" (judgement-tcc) nil nil) nil nil (V_N_subtype_int_ subtype "nTpred_order[static_analysis.V_N_b].V_N" "integers.int")))