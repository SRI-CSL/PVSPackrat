("ast" ast seq_2_TCC1 0 (seq_2_TCC1-1 nil 3785499487 ("" (subtype-tcc) nil nil) nil nil (seq_2 subtype "ast.T" "{x: pre_ast[ast.V_T, ast.<=, ast.V_N_b, ast.bound, ast.V_S].pre_ast | booleans.OR(pre_ast[ast.V_T, ast.<=, ast.V_N_b, ast.bound, ast.V_S].seq?(x), pre_ast[ast.V_T, ast.<=, ast.V_N_b, ast.bound, ast.V_S].prior?(x))}")))("ast" ast seq_2 0 (seq_2-1 nil 3785499490 ("" (skeep) (("" (typepred "T") (("" (expand "astWellformed?") (("" (assert) (("" (flatten) (("" (assert) (("" (expand "astType?" 2 1) (("" (lift-if 2) (("" (split 2) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ast type-eq-decl nil ast nil) (astWellformed? def-decl "bool" ast nil) (pre_ast type-decl nil pre_ast nil) (V_S formal-type-decl nil ast nil) (bound formal-const-decl "nat" ast nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (V_N_b formal-const-decl "posnat" ast nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (<= formal-const-decl "(total_order?[V_T])" ast nil) (total_order? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (V_T formal-nonempty-type-decl nil ast nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (astType? def-decl "astType" ast nil)) shostak))("json" json_parser extract_number_TCC1 0 (extract_number_TCC1-1 nil 3786428596 ("" (skeep) (("" (ground) nil nil)) nil) ((real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (extract_number disjointness "TABLE
  %---------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------------------------------------------------------++
  |[ json_parser.x = 48 | json_parser.x = 49 | json_parser.x = 50 | json_parser.x = 51 | json_parser.x = 52 | json_parser.x = 53 | json_parser.x = 54 | json_parser.x = 55 | json_parser.x = 56 | json_parser.x = 57 | booleans.∨(reals.<(json_parser.x, 48), reals.>(json_parser.x, 57)) ]|
  %---------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------------------------------------------------------++
  | 0                   | 1                  | 2                  | 3                  | 4                  | 5                  | 6                  | 7                  | 8                  | 9                  | 0                                                                  ||
  %---------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------------------------------------------------------++
ENDTABLE" "nil")))("json" json_parser extract_number_TCC2 0 (extract_number_TCC2-1 nil 3786428596 ("" (skeep) (("" (assert) nil nil)) nil) ((real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (extract_number coverage "TABLE
  %---------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------------------------------------------------------++
  |[ json_parser.x = 48 | json_parser.x = 49 | json_parser.x = 50 | json_parser.x = 51 | json_parser.x = 52 | json_parser.x = 53 | json_parser.x = 54 | json_parser.x = 55 | json_parser.x = 56 | json_parser.x = 57 | booleans.∨(reals.<(json_parser.x, 48), reals.>(json_parser.x, 57)) ]|
  %---------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------------------------------------------------------++
  | 0                   | 1                  | 2                  | 3                  | 4                  | 5                  | 6                  | 7                  | 8                  | 9                  | 0                                                                  ||
  %---------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------------------------------------------------------++
ENDTABLE" "nil")))("parser" peg_parser tree_is_parsing_TCC1 0 (tree_is_parsing_TCC1-1 nil 3788207491 ("" (subtype-tcc) nil nil) nil nil (tree_is_parsing subtype "peg_parser.s" "{k: naturalnumbers.upto(peg_parser.s) | booleans.⇒((k = peg_parser.s), wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].g_wf(peg_parser.G, peg_parser.A, wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].P_0c?(peg_parser.P_exp), wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].strong))}")))("parser" peg_parser tree_is_parsing 0 (tree_is_parsing-1 nil 3788207599 ("" (case "Forall (n: nat) : FORALL (T: ast): astMeasure(T) <= n Implies ( 
        EXISTS (P_exp: WF_nT, A: below(V_N_b),
                G: {e: Δ | subterm(e, P_exp(A))}, inp: input, s: inp_bound,
                s_T:
                  {k: upto(s) |
                     (k = s) ⇒ g_wf(G, A, P_0c?(P_exp), strong)}):
          T = parsing(P_exp, A, G, inp, s, s))") (("1" (skeep) (("1" (inst -1 "astMeasure(T)") (("1" (inst -1 "T") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (induct "n") (("1" (postpone) nil nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil)) nil)) nil) ("3" (postpone) nil nil)) nil) nil shostak))("ascii" test_ascii P_exp_TCC1 0 (P_exp_TCC1-1 nil 3785834693 ("" (assert) (("" (inst 1 "0") nil nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (V_T type-eq-decl nil arith_expr nil)) nil (P_exp existence "" "V_T")))("ascii" test_ascii P_exp_TCC2 0 (P_exp_TCC1-1 nil 3780642089 ("" (subtype-tcc) nil nil) ((V_N_b const-decl "nat" arith_expr nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (P_exp subtype "arith_expr.V_N_b" "posnat")))("ascii" test_ascii P_exp_TCC3 0 (P_exp_TCC17-1 nil 3785828602 ("" (subtype-tcc) nil nil) ((V_N_b const-decl "nat" arith_expr nil)) nil (P_exp subtype "8" "naturalnumbers.below(arith_expr.V_N_b)")))("ascii" test_ascii P_exp_TCC4 0 (P_exp_TCC2-1 nil 3780633797 ("" (subtype-tcc) nil nil) ((V_N_b const-decl "nat" arith_expr nil)) nil (P_exp subtype "1" "naturalnumbers.below(arith_expr.V_N_b)")))("ascii" test_ascii P_exp_TCC5 0 (P_exp_TCC7-1 nil 3780633797 ("" (subtype-tcc) nil nil) ((V_N_b const-decl "nat" arith_expr nil)) nil (P_exp subtype "0" "naturalnumbers.below(arith_expr.V_N_b)")))("ascii" test_ascii P_exp_TCC6 0 (P_exp_TCC5-1 nil 3780633797 ("" (subtype-tcc) nil nil) ((V_N_b const-decl "nat" arith_expr nil)) nil (P_exp subtype "2" "naturalnumbers.below(arith_expr.V_N_b)")))("ascii" test_ascii P_exp_TCC7 0 (P_exp_TCC13-1 nil 3780633797 ("" (subtype-tcc) nil nil) ((V_N_b const-decl "nat" arith_expr nil)) nil (P_exp subtype "2" "naturalnumbers.below(arith_expr.V_N_b)")))("ascii" test_ascii P_exp_TCC8 0 (P_exp_TCC6-1 nil 3780633797 ("" (subtype-tcc) nil nil) ((V_N_b const-decl "nat" arith_expr nil)) nil (P_exp subtype "4" "naturalnumbers.below(arith_expr.V_N_b)")))("ascii" test_ascii P_exp_TCC9 0 (P_exp_TCC4-1 nil 3780633797 ("" (subtype-tcc) nil nil) ((V_N_b const-decl "nat" arith_expr nil)) nil (P_exp subtype "3" "naturalnumbers.below(arith_expr.V_N_b)")))("ascii" test_ascii P_exp_TCC10 0 (P_exp_TCC9-1 nil 3780633797 ("" (subtype-tcc) nil nil) ((V_N_b const-decl "nat" arith_expr nil)) nil (P_exp subtype "2" "naturalnumbers.below(arith_expr.V_N_b)")))("ascii" test_ascii P_exp_TCC11 0 (P_exp_TCC11-1 nil 3780633797 ("" (subtype-tcc) nil nil) ((V_N_b const-decl "nat" arith_expr nil)) nil (P_exp subtype "5" "naturalnumbers.below(arith_expr.V_N_b)")))("ascii" test_ascii P_exp_TCC12 0 (P_exp_TCC12-1 nil 3780633797 ("" (subtype-tcc) nil nil) ((V_N_b const-decl "nat" arith_expr nil)) nil (P_exp subtype "5" "naturalnumbers.below(arith_expr.V_N_b)")))("ascii" test_ascii P_exp_TCC13 0 (P_exp_TCC1-1 nil 3780633797 ("" (subtype-tcc) nil nil) ((V_N_b const-decl "nat" arith_expr nil)) nil (P_exp subtype "7" "naturalnumbers.below(arith_expr.V_N_b)")))("ascii" test_ascii P_exp_TCC14 0 (P_exp_TCC10-1 nil 3780633797 ("" (subtype-tcc) nil nil) ((V_N_b const-decl "nat" arith_expr nil)) nil (P_exp subtype "6" "naturalnumbers.below(arith_expr.V_N_b)")))("ascii" test_ascii P_exp_TCC15 0 (P_exp_TCC15-1 nil 3780633797 ("" (subtype-tcc) nil nil) ((V_N_b const-decl "nat" arith_expr nil)) nil (P_exp subtype "4" "naturalnumbers.below(arith_expr.V_N_b)")))("ascii" test_ascii P_exp_TCC16 0 (P_exp_TCC8-1 nil 3780633797 ("" (subtype-tcc) nil nil) ((V_N_b const-decl "nat" arith_expr nil)) nil (P_exp subtype "3" "naturalnumbers.below(arith_expr.V_N_b)")))("ascii" test_ascii P_exp_TCC17 0 (P_exp_TCC3-1 nil 3780633797 ("" (subtype-tcc) nil nil) ((V_N_b const-decl "nat" arith_expr nil)) nil (P_exp subtype "1" "naturalnumbers.below(arith_expr.V_N_b)")))("ascii" test_ascii P_exp_TCC18 0 (P_exp_TCC14-1 nil 3780633797 ("" (subtype-tcc) nil nil) ((V_N_b const-decl "nat" arith_expr nil)) nil (P_exp subtype "0" "naturalnumbers.below(arith_expr.V_N_b)")))("ascii" test_ascii P_exp_TCC19 0 (P_exp_TCC19-1 nil 3785834693 ("" (subtype-tcc) nil nil) ((V_N_b const-decl "nat" arith_expr nil)) nil (P_exp subtype "8" "naturalnumbers.below(arith_expr.V_N_b)")))("json" json_parser extractJsonNumber_TCC1 0 (extractJsonNumber_TCC1-1 nil 3797853245 ("" (subtype-tcc) nil nil) ((V_T type-eq-decl nil json_grammar nil) (<= const-decl "bool" json_grammar nil) (V_N_b const-decl "nat" json_grammar nil) (JSON type-decl nil json_object nil) (pre_ast type-decl nil pre_ast nil) (astWellformed? def-decl "bool" ast nil) (ast type-eq-decl nil ast nil)) nil (extractJsonNumber subtype "json_parser.T" "{x: pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].pre_ast | booleans.OR(pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].seq?(x), pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].prior?(x))}")))("json" json_parser extractJsonNumber_TCC2 0 (extractJsonNumber_TCC2-1 nil 3797853245 ("" (subtype-tcc) nil nil) ((V_T type-eq-decl nil json_grammar nil) (<= const-decl "bool" json_grammar nil) (V_N_b const-decl "nat" json_grammar nil) (JSON type-decl nil json_object nil) (pre_ast type-decl nil pre_ast nil) (astWellformed? def-decl "bool" ast nil) (ast type-eq-decl nil ast nil)) nil (extractJsonNumber subtype "pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].T2(json_parser.T)" "{x: pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].pre_ast | booleans.OR(pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].seq?(x), pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].prior?(x))}")))("json" json_parser extractJsonNumber_TCC3 0 (extractJsonNumber_TCC3-1 nil 3797853245 ("" (subtype-tcc) nil nil) ((V_T type-eq-decl nil json_grammar nil) (<= const-decl "bool" json_grammar nil) (V_N_b const-decl "nat" json_grammar nil) (JSON type-decl nil json_object nil) (pre_ast type-decl nil pre_ast nil) (astWellformed? def-decl "bool" ast nil) (ast type-eq-decl nil ast nil)) nil (extractJsonNumber subtype "pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].T2(pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].T2(json_parser.T))" "{x: pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].pre_ast | booleans.OR(pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].seq?(x), pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].prior?(x))}")))("json" json_parser extractJsonNumber_TCC4 0 (extractJsonNumber_TCC4-1 nil 3797853245 ("" (subtype-tcc) nil nil) nil nil (extractJsonNumber subtype "pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].T1(json_parser.T)" "{x: pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].pre_ast | booleans.OR(pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].nonTerminal?(x), booleans.OR(pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].notP?(x), pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].andP?(x)))}")))("json" json_parser extractJsonNumber_TCC5 0 (extractJsonNumber_TCC5-1 nil 3797853245 ("" (subtype-tcc) nil nil) nil nil (extractJsonNumber subtype "json_parser.intAST" "{x: pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].pre_ast | booleans.OR(pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].seq?(x), pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].prior?(x))}")))("json" json_parser extractJsonNumber_TCC6 0 (extractJsonNumber_TCC6-1 nil 3797853245 ("" (subtype-tcc) nil nil) nil nil (extractJsonNumber subtype "pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].T2(json_parser.intAST)" "ast[V_T, <=, V_N_b, 1000, V_S]")))("json" json_parser extractJsonNumber_TCC7 0 (extractJsonNumber_TCC7-1 nil 3797853245 ("" (subtype-tcc) nil nil) nil nil (extractJsonNumber subtype "json_parser.fracAST" "{x: pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].pre_ast | booleans.OR(pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].nonTerminal?(x), booleans.OR(pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].notP?(x), pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].andP?(x)))}")))("json" json_parser extractJsonNumber_TCC8 0 (extractJsonNumber_TCC8-1 nil 3797853245 ("" (subtype-tcc) nil nil) nil nil (extractJsonNumber subtype "pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].T(json_parser.fracAST)" "ast[V_T, <=, V_N_b, 1000, V_S]")))("json" json_parser extractJsonNumber_TCC9 0 (extractJsonNumber_TCC9-1 nil 3797853245 ("" (subtype-tcc) nil nil) nil nil (extractJsonNumber subtype "json_parser.expAST" "{x: pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].pre_ast | booleans.OR(pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].nonTerminal?(x), booleans.OR(pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].notP?(x), pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].andP?(x)))}")))("json" json_parser extractJsonNumber_TCC10 0 (extractJsonNumber_TCC10-1 nil 3797853245 ("" (subtype-tcc) nil nil) nil nil (extractJsonNumber subtype "pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].T(json_parser.expAST)" "ast[V_T, <=, V_N_b, 1000, V_S]")))("semantic_tlparser" semantic_tlparser memoïzed_does_not_change 0 (memoïzed_does_not_change-1 nil 3804503631 ("" (skolem 1 ("P_exp" "P_inp" "_" "_" "inp" "_" "_" "_" "_" "_")) (("" (case "FORALL (A: below(V_N_b)),
                            (G: Δ),
                            (s: upto(bound)),
                            (s_T: upto(bound)):
               subterm(G, P_exp(A)) IMPLIES (s_T <= s AND (s_T = s IMPLIES  g_wf(G, A, P_0c?(P_exp), strong))) IMPLIES forall
                            (cont:
                               [[astTypeOf(parsing(P_exp, A, G, inp, s, s_T)),
                                 sem_result(P_inp, P_exp, A, G, inp, s, s_T),
                                 results(P_exp, P_inp, inp)] ->
                                  [astType, pre_ast]]),
                            (res1, res2: results(P_exp, P_inp, inp)):
			    (FORALL (status: astTypeOf(parsing(P_exp, A, G, inp, s, s_T))),
			    (T: sem_result(P_inp, P_exp, A, G, inp, s, s_T)),
			    (res1, res2: results(P_exp, P_inp, inp)):
			    cont(status, T, res1) = cont(status, T, res2))
			    ⇒
                       semtlpp(P_exp, P_inp, A, G, inp, s, s_T, res1, cont) =
                        semtlpp(P_exp, P_inp, A, G, inp, s, s_T, res2, cont)") (("1" (skeep) (("1" (inst -1 A G s s_T) (("1" (ground) (("1" (inst -1 "cont" "res1" "res2") (("1" (assert) nil nil)) nil) ("2" (typepred "s_T") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (measure-induct+ " lex4(bound - s_T, bound - s,  A, pegMeasure(G))" ("A" "G" "s" "s_T")) (("1" (name-replace "s_T" "x!4") (("1" (name-replace "s" "x!3") (("1" (name-replace "G" "x!2") (("1" (name-replace "A" "x!1") (("1" (skeep) (("1" (assert) (("1" (label "H_Cont" -5) (("1" (case "G = ε") (("1" (replace -1 * LR) (("1" (expand "semtlpp" +) (("1" (inst -6 success " ε(s, s)" res1 res2) nil nil)) nil)) nil) ("2" (case "G = any") (("1" (replace -1 * LR) (("1" (expand "semtlpp" +) (("1" (assert) (("1" (lift-if 2) (("1" (split +) (("1" (flatten) (("1" (assert) (("1" (inst? -7) nil nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (inst? -) (("2" (inst? -) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "terminal?(G)") (("1" (expand "semtlpp" 3) (("1" (assert) (("1" (lift-if) (("1" (split +) (("1" (flatten) (("1" (inst? -8) nil nil)) nil) ("2" (flatten) (("2" (inst? -6) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "range?(G)") (("1" (expand "semtlpp" +) (("1" (assert) (("1" (lift-if) (("1" (split 4) (("1" (flatten) (("1" (assert) (("1" (inst? -) (("1" (inst? -) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst? -) (("2" (inst? -) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "nonTerminal?(G)") (("1" (name "B" "A(G)") (("1" (postpone) nil nil) ("2" (propax) nil nil)) nil) ("2" (case "seq?(G)") (("1" (expand "semtlpp" +) (("1" (assert) (("1" (inst-cp -2 "A" "e1(G)" "s" "s_T") (("1" (split -3) (("1" (inst -1 "cont" "res1" "res2") (("1" (split -1) (("1" (assert) (("1" (postpone) nil nil)) nil) ("2" (postpone) nil nil)) nil) ("2" (postpone) nil nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil) ("4" (postpone) nil nil) ("5" (postpone) nil nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil) ("4" (postpone) nil nil) ("5" (postpone) nil nil) ("6" (postpone) nil nil) ("7" (postpone) nil nil)) nil)) nil)) nil)) nil) nil shostak))("semantic_tlparser" semantic_tlparser results_TCC1 0 (results_TCC1-1 nil 3804395188 ("" (assert) (("" (expand "subterm") (("" (propax) nil nil)) nil)) nil) ((subterm adt-def-decl "boolean" peg nil)) nil (results subtype "semantic_tlparser.P_exp(semantic_tlparser.A)" "{e: wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].Δ | peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].subterm(e, semantic_tlparser.P_exp(semantic_tlparser.A))}")))("semantic_tlparser" semantic_tlparser results_TCC2 0 (results_TCC2-1 nil 3804395188 ("" (subtype-tcc) nil nil) ((NOT const-decl "[bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (V_N type-eq-decl nil nTpred_order nil) (peg type-decl nil peg nil) (interp type-eq-decl nil wf_peg nil) (strong_WF const-decl "bool" wf_peg nil) (WF_nT type-eq-decl nil wf_peg nil) (<= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (bound formal-const-decl "posnat" semantic_tlparser nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil) (> const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil) (total_order? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (V_T formal-nonempty-type-decl nil semantic_tlparser nil) (strong const-decl "bool" wf_peg nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (results subtype "semantic_tlparser.s" "{k: naturalnumbers.upto(semantic_tlparser.s) | booleans.⇒((k = semantic_tlparser.s), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].g_wf(semantic_tlparser.P_exp(semantic_tlparser.A), semantic_tlparser.A, wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].P_0c?(semantic_tlparser.P_exp), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].strong))}")))("json" json_parser IMP_semantic_parser_TCC1 0 (IMP_semantic_parser_TCC2-1 nil 3786377705 ("" (lemma "isTotalOrder") (("" (propax) nil nil)) nil) ((isTotalOrder formula-decl nil json_grammar nil)) nil (IMP_semantic_parser subtype "json_grammar.<=" "(orders[V_T].total_order?)")))("json" json_parser IMP_semantic_parser_TCC2 0 (IMP_semantic_parser_TCC3-1 nil 3786377705 ("" (subtype-tcc) nil nil) ((V_N_b const-decl "nat" json_grammar nil)) nil (IMP_semantic_parser subtype "json_grammar.V_N_b" "{k: naturalnumbers.nat | reals.>(k, 0)}")))("json" json_parser parser_TCC1 0 (parser_TCC1-1 nil 3798639263 ("" (lemma "correct_grammar") (("" (propax) nil nil)) nil) ((correct_grammar formula-decl nil json_grammar nil)) nil (parser subtype "json_grammar.P_exp" "WF_nT[V_T, <=, V_N_b]")))("json" json_parser parser_TCC2 0 (parser_TCC2-1 nil 3798639263 ("" (subtype-tcc) nil nil) nil nil (parser subtype "json_parser.P_inp" "semantic_interp[V_T, <=, V_N_b, 1000, V_S]")))("json" json_parser parser_TCC3 0 (parser_TCC3-1 nil 3798639263 ("" (subtype-tcc) nil nil) ((V_N_b const-decl "nat" json_grammar nil) (entry const-decl "int" json_grammar nil)) nil (parser subtype "json_grammar.entry" "naturalnumbers.below(json_grammar.V_N_b)")))("json" json_parser parser_TCC4 0 (parser_TCC4-1 nil 3798639263 ("" (assert) (("" (expand "subterm") (("" (propax) nil nil)) nil)) nil) ((subterm adt-def-decl "boolean" peg nil)) nil (parser subtype "json_grammar.P_exp(json_grammar.entry)" "{e: wf_peg[V_T, json_grammar.<=, json_grammar.V_N_b].Δ | peg[V_T, json_grammar.<=, json_grammar.V_N_b].subterm(e, json_grammar.P_exp(json_grammar.entry))}")))("json" json_parser parser_TCC5 0 (parser_TCC5-1 nil 3798639263 ("" (subtype-tcc) nil nil) nil nil (parser subtype "(LAMBDA (A: nTpred_order[json_grammar.V_N_b].V_N, s: ast_props[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].inp_bound): semantic_parser[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].unknown)" "semantic_parser[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].results(json_grammar.P_exp, json_parser.P_inp, json_parser.inp)")))("json" json_parser parser_TCC6 0 (parser_TCC6-1 nil 3798639263 ("" (skeep*) (("" (typepred "(sempp[V_T, <=, V_N_b, 1000, V_S]
                (P_exp, P_inp, entry, P_exp(entry), inp, 0, 0,
                 (LAMBDA (A: V_N[V_N_b],
                          s: inp_bound[V_T, <=, V_N_b, 1000, V_S]):
                    unknown[V_T, <=, V_N_b, 1000, V_S]))`1)") (("1" (use "semantic_interp_props") (("1" (assert) nil nil) ("2" (expand "V_N_b") (("2" (assert) nil nil)) nil) ("3" (lemma "isTotalOrder") (("3" (propax) nil nil)) nil) ("4" (expand "entry") (("4" (assert) nil nil)) nil)) nil) ("2" (lemma "isTotalOrder") (("2" (propax) nil nil)) nil) ("3" (skeep 1) (("3" (lemma "isTotalOrder") (("3" (propax) nil nil)) nil)) nil) ("4" (expand "V_N_b") (("4" (assert) nil nil)) nil) ("5" (expand "entry") (("5" (assert) nil nil)) nil)) nil)) nil) ((unknown adt-constructor-decl "(unknown?)" semantic_parser nil) (unknown? adt-recognizer-decl "[saved_result -> boolean]" semantic_parser nil) (entry const-decl "int" json_grammar nil) (P_inp const-decl "[V_N, ast -> V_S]" json_parser nil) (P_exp const-decl "Δ" json_grammar nil) (sempp def-decl "[{T: pre_ast | T = s_inp(P_inp, parsing(P_exp, A, G, inp, s, s_T))},
 results(P_exp, P_inp, inp)]" semantic_parser nil) (results type-eq-decl nil semantic_parser nil) (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}" semantic_interp nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (semanticTree type-eq-decl nil pre_ast nil) (semanticTree? const-decl "bool" pre_ast nil) (semantic adt-constructor-decl "[[below, below, V_N[V_N_b], V_S] -> (semantic?)]" pre_ast nil) (semantic? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil) (fail adt-constructor-decl "[[below, below] -> (fail?)]" pre_ast nil) (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil) (T adt-accessor-decl "[(known?) -> (valuedTree?)]" semantic_parser nil) (valuedTree? const-decl "bool" semantic_interp nil) (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser nil) (output type-eq-decl nil peg_parser nil) (P_fc? const-decl "[Δ -> bool]" wf_peg nil) (failure adt-constructor-decl "(failure?)" ast nil) (failure? adt-recognizer-decl "[astType -> boolean]" ast nil) (P_sc? const-decl "[Δ -> bool]" wf_peg nil) (> const-decl "bool" reals nil) (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil) (success adt-constructor-decl "(success?)" ast nil) (success? adt-recognizer-decl "[astType -> boolean]" ast nil) (trueToInput def-decl "bool" ast_props nil) (trueToGrammar def-decl "bool" ast_props nil) (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil) (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil) (plus? adt-recognizer-decl "[peg -> boolean]" peg nil) (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil) (star? adt-recognizer-decl "[peg -> boolean]" peg nil) (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil) (below type-eq-decl nil pre_ast nil) (ast type-eq-decl nil ast nil) (astWellformed? def-decl "bool" ast nil) (astType? def-decl "astType" ast nil) (astType type-decl nil ast nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (known? adt-recognizer-decl "[saved_result -> boolean]" semantic_parser nil) (saved_result type-decl nil semantic_parser nil) (inp_bound type-eq-decl nil ast_props nil) (strong const-decl "bool" wf_peg nil) (P_0c? const-decl "[Δ -> bool]" wf_peg nil) (g_wf def-decl "bool" wf_peg nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (input type-eq-decl nil ast_props nil) (strong_WF const-decl "bool" wf_peg nil) (interp type-eq-decl nil wf_peg nil) (V_N type-eq-decl nil nTpred_order nil) (< const-decl "bool" reals nil) (subterm adt-def-decl "boolean" peg nil) (peg type-decl nil peg nil) (below type-eq-decl nil naturalnumbers nil) (semantic_interp type-eq-decl nil semantic_interp nil) (WF_nT type-eq-decl nil wf_peg nil) (= const-decl "[T, T -> boolean]" equalities nil) (pre_ast type-decl nil pre_ast nil) (V_S type-eq-decl nil json_parser nil) (JSON type-decl nil json_object nil) (V_N_b const-decl "nat" json_grammar nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (<= const-decl "bool" json_grammar nil) (char type-eq-decl nil strings nil) (V_T type-eq-decl nil json_grammar nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (character type-decl nil character_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (total_order? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (isTotalOrder formula-decl nil json_grammar nil) (semantic_interp_props formula-decl nil semantic_interp nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (parser subtype "(semantic_parser[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].sempp(json_grammar.P_exp, json_parser.P_inp, json_grammar.entry, json_grammar.P_exp(json_grammar.entry), json_parser.inp, 0, 0, (LAMBDA (A: nTpred_order[json_grammar.V_N_b].V_N, s: ast_props[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].inp_bound): semantic_parser[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].unknown))`1)" "ast[V_T, <=, V_N_b, 1000, V_S]")))("json" json_parser strToInp_TCC1 0 (strToInp_TCC1-1 nil 3805351806 ("" (subtype-tcc) nil nil) nil nil (strToInp subtype "LAMBDA (x: naturalnumbers.below(1000)): IF (reals.<(x, json_parser.s`length)) THEN json_parser.s`seq(x) ELSE character_adt.char(0) ENDIF" "input[V_T, <=, V_N_b, 1000, V_S]")))("json" json_grammar quotation_mark_TCC1 0 (quotation_mark_TCC1-1 nil 3786305814 ("" (subtype-tcc) nil nil) ((V_N_b const-decl "nat" json_grammar nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (quotation_mark subtype "24" "naturalnumbers.below(json_grammar.V_N_b)")))("delta" wf_peg Plus_cannot_be_P0_TCC1 0 (Plus_cannot_be_P0_TCC1-1 nil 3813666933 ("" (subtype-tcc) nil nil) nil nil (Plus_cannot_be_P0 subtype "wf_peg.G" "{x: peg[wf_peg.V_T, wf_peg.<=, wf_peg.V_N_b].peg |      peg[wf_peg.V_T, wf_peg.<=, wf_peg.V_N_b].star?(x) OR peg[wf_peg.V_T, wf_peg.<=, wf_peg.V_N_b].plus?(x) OR peg[wf_peg.V_T, wf_peg.<=, wf_peg.V_N_b].opt?(x) OR peg[wf_peg.V_T, wf_peg.<=, wf_peg.V_N_b].notP?(x) OR peg[wf_peg.V_T, wf_peg.<=, wf_peg.V_N_b].andP?(x)}")))("static_analysis" inferred_order_wf_peg nT_properties_reorders 0 (nT_properties_reorders-1 nil 3813656553 ("" (skolem 1 ("P_exp" "s")) (("" (expand "nT_properties") (("" (postpone) nil nil)) nil)) nil) nil shostak))("static_analysis" inferred_order_wf_peg sub_nT_and_wellformedness_TCC1 0 (sub_nT_and_wellformedness_TCC1-1 nil 3813611401 ("" (subtype-tcc) nil nil) nil nil (sub_nT_and_wellformedness subtype "inferred_order_wf_peg.A" "naturalnumbers.upto(inferred_order_wf_peg.V_N_b)")))("static_analysis" inferred_order_wf_peg well_orders_orderly 0 (well_orders_orderly-1 nil 3813604031 ("" (expand "well_orders?") (("" (expand "orderly_WF_nT?") (("" (skeep*) (("" (inst? 1) nil nil)) nil)) nil)) nil) ((orderly_WF_nT? const-decl "bool" inferred_order_wf_peg nil) (nT_Permutation type-eq-decl nil inferred_order_wf_peg nil) (bijective? const-decl "bool" functions nil) (V_N type-eq-decl nil nTpred_order nil) (V_N_b formal-const-decl "posnat" inferred_order_wf_peg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (well_orders? const-decl "bool" inferred_order_wf_peg nil)) shostak))("delta" wf_peg strong_WF_TCC1 0 (strong_WF_TCC1-1 nil 3771171781 ("" (subtype-tcc) nil nil) nil nil (strong_WF subtype "wf_peg.A" "naturalnumbers.upto(wf_peg.V_N_b)")))("parser" peg_parser output_TCC1 0 (output_TCC1-1 nil 3771774354 ("" (subtype-tcc) nil nil) nil nil (output subtype "peg_parser.A" "naturalnumbers.upto(peg_parser.V_N_b)")))("parser_props" parser_props parsing_correctness_ε_TCC1 0 (parsing_correctness_ε_TCC2-1 nil 3785592840 ("" (assert) nil nil) nil nil (parsing_correctness_ε subtype "parser_props.A" "naturalnumbers.upto(parser_props.V_N_b)")))("semantic_tlparser" semantic_tlparser sem_result_TCC1 0 (sem_result_TCC1-1 nil 3804417092 ("" (subtype-tcc) nil nil) nil nil (sem_result subtype "semantic_tlparser.A" "naturalnumbers.upto(semantic_tlparser.V_N_b)")))("parser" peg_parser reference_parser_nonzero 0 (reference_parser_nonzero-1 nil 3847170769 ("" (skolem 1 ("σ" "P_exp" "A" "_" "_" "_" "_")) (("" (induct "G") (("1" (typepred "G!1") (("1" (propax) nil nil)) nil) ("2" (flatten) (("2" (skeep*) (("2" (expand "parsing") (("2" (assert) (("2" (expand "astMeasure") (("2" (expand "reduce_nat") (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (postpone) nil nil) ("4" (postpone) nil nil) ("5" (postpone) nil nil) ("6" (postpone) nil nil) ("7" (postpone) nil nil) ("8" (postpone) nil nil) ("9" (postpone) nil nil) ("10" (postpone) nil nil) ("11" (postpone) nil nil) ("12" (postpone) nil nil) ("13" (postpone) nil nil)) nil)) nil) nil shostak))