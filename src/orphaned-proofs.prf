("ast" ast seq_2_TCC1 0 (seq_2_TCC1-1 nil 3785499487 ("" (subtype-tcc) nil nil) nil nil (seq_2 subtype "ast.T" "{x: pre_ast[ast.V_T, ast.<=, ast.V_N_b, ast.bound, ast.V_S].pre_ast | booleans.OR(pre_ast[ast.V_T, ast.<=, ast.V_N_b, ast.bound, ast.V_S].seq?(x), pre_ast[ast.V_T, ast.<=, ast.V_N_b, ast.bound, ast.V_S].prior?(x))}")))("ast" ast seq_2 0 (seq_2-1 nil 3785499490 ("" (skeep) (("" (typepred "T") (("" (expand "astWellformed?") (("" (assert) (("" (flatten) (("" (assert) (("" (expand "astType?" 2 1) (("" (lift-if 2) (("" (split 2) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ast type-eq-decl nil ast nil) (astWellformed? def-decl "bool" ast nil) (pre_ast type-decl nil pre_ast nil) (V_S formal-type-decl nil ast nil) (bound formal-const-decl "nat" ast nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (V_N_b formal-const-decl "posnat" ast nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (<= formal-const-decl "(total_order?[V_T])" ast nil) (total_order? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (V_T formal-nonempty-type-decl nil ast nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (astType? def-decl "astType" ast nil)) shostak))("json" json_parser extract_number_TCC1 0 (extract_number_TCC1-1 nil 3786428596 ("" (skeep) (("" (ground) nil nil)) nil) ((real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (extract_number disjointness "TABLE
  %---------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------------------------------------------------------++
  |[ json_parser.x = 48 | json_parser.x = 49 | json_parser.x = 50 | json_parser.x = 51 | json_parser.x = 52 | json_parser.x = 53 | json_parser.x = 54 | json_parser.x = 55 | json_parser.x = 56 | json_parser.x = 57 | booleans.∨(reals.<(json_parser.x, 48), reals.>(json_parser.x, 57)) ]|
  %---------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------------------------------------------------------++
  | 0                   | 1                  | 2                  | 3                  | 4                  | 5                  | 6                  | 7                  | 8                  | 9                  | 0                                                                  ||
  %---------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------------------------------------------------------++
ENDTABLE" "nil")))("json" json_parser extract_number_TCC2 0 (extract_number_TCC2-1 nil 3786428596 ("" (skeep) (("" (assert) nil nil)) nil) ((real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (extract_number coverage "TABLE
  %---------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------------------------------------------------------++
  |[ json_parser.x = 48 | json_parser.x = 49 | json_parser.x = 50 | json_parser.x = 51 | json_parser.x = 52 | json_parser.x = 53 | json_parser.x = 54 | json_parser.x = 55 | json_parser.x = 56 | json_parser.x = 57 | booleans.∨(reals.<(json_parser.x, 48), reals.>(json_parser.x, 57)) ]|
  %---------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------------------------------------------------------++
  | 0                   | 1                  | 2                  | 3                  | 4                  | 5                  | 6                  | 7                  | 8                  | 9                  | 0                                                                  ||
  %---------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------+--------------------------------------------------------------------++
ENDTABLE" "nil")))("parser" peg_parser tree_is_parsing_TCC1 0 (tree_is_parsing_TCC1-1 nil 3788207491 ("" (subtype-tcc) nil nil) nil nil (tree_is_parsing subtype "peg_parser.s" "{k: naturalnumbers.upto(peg_parser.s) | booleans.⇒((k = peg_parser.s), wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].g_wf(peg_parser.G, peg_parser.A, wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].P_0c?(peg_parser.P_exp), wf_peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].strong))}")))("parser" peg_parser tree_is_parsing 0 (tree_is_parsing-1 nil 3788207599 ("" (case "Forall (n: nat) : FORALL (T: ast): astMeasure(T) <= n Implies ( 
        EXISTS (P_exp: WF_nT, A: below(V_N_b),
                G: {e: Δ | subterm(e, P_exp(A))}, inp: input, s: inp_bound,
                s_T:
                  {k: upto(s) |
                     (k = s) ⇒ g_wf(G, A, P_0c?(P_exp), strong)}):
          T = parsing(P_exp, A, G, inp, s, s))") (("1" (skeep) (("1" (inst -1 "astMeasure(T)") (("1" (inst -1 "T") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (induct "n") (("1" (postpone) nil nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil)) nil)) nil) ("3" (postpone) nil nil)) nil) nil shostak))("ascii" test_ascii P_exp_TCC1 0 (P_exp_TCC1-1 nil 3785834693 ("" (assert) (("" (inst 1 "0") nil nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (V_T type-eq-decl nil arith_expr nil)) nil (P_exp existence "" "V_T")))("ascii" test_ascii P_exp_TCC2 0 (P_exp_TCC1-1 nil 3780642089 ("" (subtype-tcc) nil nil) ((V_N_b const-decl "nat" arith_expr nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (P_exp subtype "arith_expr.V_N_b" "posnat")))("ascii" test_ascii P_exp_TCC3 0 (P_exp_TCC17-1 nil 3785828602 ("" (subtype-tcc) nil nil) ((V_N_b const-decl "nat" arith_expr nil)) nil (P_exp subtype "8" "naturalnumbers.below(arith_expr.V_N_b)")))("ascii" test_ascii P_exp_TCC4 0 (P_exp_TCC2-1 nil 3780633797 ("" (subtype-tcc) nil nil) ((V_N_b const-decl "nat" arith_expr nil)) nil (P_exp subtype "1" "naturalnumbers.below(arith_expr.V_N_b)")))("ascii" test_ascii P_exp_TCC5 0 (P_exp_TCC7-1 nil 3780633797 ("" (subtype-tcc) nil nil) ((V_N_b const-decl "nat" arith_expr nil)) nil (P_exp subtype "0" "naturalnumbers.below(arith_expr.V_N_b)")))("ascii" test_ascii P_exp_TCC6 0 (P_exp_TCC5-1 nil 3780633797 ("" (subtype-tcc) nil nil) ((V_N_b const-decl "nat" arith_expr nil)) nil (P_exp subtype "2" "naturalnumbers.below(arith_expr.V_N_b)")))("ascii" test_ascii P_exp_TCC7 0 (P_exp_TCC13-1 nil 3780633797 ("" (subtype-tcc) nil nil) ((V_N_b const-decl "nat" arith_expr nil)) nil (P_exp subtype "2" "naturalnumbers.below(arith_expr.V_N_b)")))("ascii" test_ascii P_exp_TCC8 0 (P_exp_TCC6-1 nil 3780633797 ("" (subtype-tcc) nil nil) ((V_N_b const-decl "nat" arith_expr nil)) nil (P_exp subtype "4" "naturalnumbers.below(arith_expr.V_N_b)")))("ascii" test_ascii P_exp_TCC9 0 (P_exp_TCC4-1 nil 3780633797 ("" (subtype-tcc) nil nil) ((V_N_b const-decl "nat" arith_expr nil)) nil (P_exp subtype "3" "naturalnumbers.below(arith_expr.V_N_b)")))("ascii" test_ascii P_exp_TCC10 0 (P_exp_TCC9-1 nil 3780633797 ("" (subtype-tcc) nil nil) ((V_N_b const-decl "nat" arith_expr nil)) nil (P_exp subtype "2" "naturalnumbers.below(arith_expr.V_N_b)")))("ascii" test_ascii P_exp_TCC11 0 (P_exp_TCC11-1 nil 3780633797 ("" (subtype-tcc) nil nil) ((V_N_b const-decl "nat" arith_expr nil)) nil (P_exp subtype "5" "naturalnumbers.below(arith_expr.V_N_b)")))("ascii" test_ascii P_exp_TCC12 0 (P_exp_TCC12-1 nil 3780633797 ("" (subtype-tcc) nil nil) ((V_N_b const-decl "nat" arith_expr nil)) nil (P_exp subtype "5" "naturalnumbers.below(arith_expr.V_N_b)")))("ascii" test_ascii P_exp_TCC13 0 (P_exp_TCC1-1 nil 3780633797 ("" (subtype-tcc) nil nil) ((V_N_b const-decl "nat" arith_expr nil)) nil (P_exp subtype "7" "naturalnumbers.below(arith_expr.V_N_b)")))("ascii" test_ascii P_exp_TCC14 0 (P_exp_TCC10-1 nil 3780633797 ("" (subtype-tcc) nil nil) ((V_N_b const-decl "nat" arith_expr nil)) nil (P_exp subtype "6" "naturalnumbers.below(arith_expr.V_N_b)")))("ascii" test_ascii P_exp_TCC15 0 (P_exp_TCC15-1 nil 3780633797 ("" (subtype-tcc) nil nil) ((V_N_b const-decl "nat" arith_expr nil)) nil (P_exp subtype "4" "naturalnumbers.below(arith_expr.V_N_b)")))("ascii" test_ascii P_exp_TCC16 0 (P_exp_TCC8-1 nil 3780633797 ("" (subtype-tcc) nil nil) ((V_N_b const-decl "nat" arith_expr nil)) nil (P_exp subtype "3" "naturalnumbers.below(arith_expr.V_N_b)")))("ascii" test_ascii P_exp_TCC17 0 (P_exp_TCC3-1 nil 3780633797 ("" (subtype-tcc) nil nil) ((V_N_b const-decl "nat" arith_expr nil)) nil (P_exp subtype "1" "naturalnumbers.below(arith_expr.V_N_b)")))("ascii" test_ascii P_exp_TCC18 0 (P_exp_TCC14-1 nil 3780633797 ("" (subtype-tcc) nil nil) ((V_N_b const-decl "nat" arith_expr nil)) nil (P_exp subtype "0" "naturalnumbers.below(arith_expr.V_N_b)")))("ascii" test_ascii P_exp_TCC19 0 (P_exp_TCC19-1 nil 3785834693 ("" (subtype-tcc) nil nil) ((V_N_b const-decl "nat" arith_expr nil)) nil (P_exp subtype "8" "naturalnumbers.below(arith_expr.V_N_b)")))("json" json_parser extractJsonNumber_TCC1 0 (extractJsonNumber_TCC1-1 nil 3797853245 ("" (subtype-tcc) nil nil) ((V_T type-eq-decl nil json_grammar nil) (<= const-decl "bool" json_grammar nil) (V_N_b const-decl "nat" json_grammar nil) (JSON type-decl nil json_object nil) (pre_ast type-decl nil pre_ast nil) (astWellformed? def-decl "bool" ast nil) (ast type-eq-decl nil ast nil)) nil (extractJsonNumber subtype "json_parser.T" "{x: pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].pre_ast | booleans.OR(pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].seq?(x), pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].prior?(x))}")))("json" json_parser extractJsonNumber_TCC2 0 (extractJsonNumber_TCC2-1 nil 3797853245 ("" (subtype-tcc) nil nil) ((V_T type-eq-decl nil json_grammar nil) (<= const-decl "bool" json_grammar nil) (V_N_b const-decl "nat" json_grammar nil) (JSON type-decl nil json_object nil) (pre_ast type-decl nil pre_ast nil) (astWellformed? def-decl "bool" ast nil) (ast type-eq-decl nil ast nil)) nil (extractJsonNumber subtype "pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].T2(json_parser.T)" "{x: pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].pre_ast | booleans.OR(pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].seq?(x), pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].prior?(x))}")))("json" json_parser extractJsonNumber_TCC3 0 (extractJsonNumber_TCC3-1 nil 3797853245 ("" (subtype-tcc) nil nil) ((V_T type-eq-decl nil json_grammar nil) (<= const-decl "bool" json_grammar nil) (V_N_b const-decl "nat" json_grammar nil) (JSON type-decl nil json_object nil) (pre_ast type-decl nil pre_ast nil) (astWellformed? def-decl "bool" ast nil) (ast type-eq-decl nil ast nil)) nil (extractJsonNumber subtype "pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].T2(pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].T2(json_parser.T))" "{x: pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].pre_ast | booleans.OR(pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].seq?(x), pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].prior?(x))}")))("json" json_parser extractJsonNumber_TCC4 0 (extractJsonNumber_TCC4-1 nil 3797853245 ("" (subtype-tcc) nil nil) nil nil (extractJsonNumber subtype "pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].T1(json_parser.T)" "{x: pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].pre_ast | booleans.OR(pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].nonTerminal?(x), booleans.OR(pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].notP?(x), pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].andP?(x)))}")))("json" json_parser extractJsonNumber_TCC5 0 (extractJsonNumber_TCC5-1 nil 3797853245 ("" (subtype-tcc) nil nil) nil nil (extractJsonNumber subtype "json_parser.intAST" "{x: pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].pre_ast | booleans.OR(pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].seq?(x), pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].prior?(x))}")))("json" json_parser extractJsonNumber_TCC6 0 (extractJsonNumber_TCC6-1 nil 3797853245 ("" (subtype-tcc) nil nil) nil nil (extractJsonNumber subtype "pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].T2(json_parser.intAST)" "ast[V_T, <=, V_N_b, 1000, V_S]")))("json" json_parser extractJsonNumber_TCC7 0 (extractJsonNumber_TCC7-1 nil 3797853245 ("" (subtype-tcc) nil nil) nil nil (extractJsonNumber subtype "json_parser.fracAST" "{x: pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].pre_ast | booleans.OR(pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].nonTerminal?(x), booleans.OR(pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].notP?(x), pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].andP?(x)))}")))("json" json_parser extractJsonNumber_TCC8 0 (extractJsonNumber_TCC8-1 nil 3797853245 ("" (subtype-tcc) nil nil) nil nil (extractJsonNumber subtype "pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].T(json_parser.fracAST)" "ast[V_T, <=, V_N_b, 1000, V_S]")))("json" json_parser extractJsonNumber_TCC9 0 (extractJsonNumber_TCC9-1 nil 3797853245 ("" (subtype-tcc) nil nil) nil nil (extractJsonNumber subtype "json_parser.expAST" "{x: pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].pre_ast | booleans.OR(pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].nonTerminal?(x), booleans.OR(pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].notP?(x), pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].andP?(x)))}")))("json" json_parser extractJsonNumber_TCC10 0 (extractJsonNumber_TCC10-1 nil 3797853245 ("" (subtype-tcc) nil nil) nil nil (extractJsonNumber subtype "pre_ast[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].T(json_parser.expAST)" "ast[V_T, <=, V_N_b, 1000, V_S]")))("semantic_tlparser" semantic_tlparser memoïzed_does_not_change 0 (memoïzed_does_not_change-1 nil 3804503631 ("" (skolem 1 ("P_exp" "P_inp" "_" "_" "inp" "_" "_" "_" "_" "_")) (("" (case "FORALL (A: below(V_N_b)),
                            (G: Δ),
                            (s: upto(bound)),
                            (s_T: upto(bound)):
               subterm(G, P_exp(A)) IMPLIES (s_T <= s AND (s_T = s IMPLIES  g_wf(G, A, P_0c?(P_exp), strong))) IMPLIES forall
                            (cont:
                               [[astTypeOf(parsing(P_exp, A, G, inp, s, s_T)),
                                 sem_result(P_inp, P_exp, A, G, inp, s, s_T),
                                 results(P_exp, P_inp, inp)] ->
                                  [astType, pre_ast]]),
                            (res1, res2: results(P_exp, P_inp, inp)):
			    (FORALL (status: astTypeOf(parsing(P_exp, A, G, inp, s, s_T))),
			    (T: sem_result(P_inp, P_exp, A, G, inp, s, s_T)),
			    (res1, res2: results(P_exp, P_inp, inp)):
			    cont(status, T, res1) = cont(status, T, res2))
			    ⇒
                       semtlpp(P_exp, P_inp, A, G, inp, s, s_T, res1, cont) =
                        semtlpp(P_exp, P_inp, A, G, inp, s, s_T, res2, cont)") (("1" (skeep) (("1" (inst -1 A G s s_T) (("1" (ground) (("1" (inst -1 "cont" "res1" "res2") (("1" (assert) nil nil)) nil) ("2" (typepred "s_T") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (measure-induct+ " lex4(bound - s_T, bound - s,  A, pegMeasure(G))" ("A" "G" "s" "s_T")) (("1" (name-replace "s_T" "x!4") (("1" (name-replace "s" "x!3") (("1" (name-replace "G" "x!2") (("1" (name-replace "A" "x!1") (("1" (skeep) (("1" (assert) (("1" (label "H_Cont" -5) (("1" (case "G = ε") (("1" (replace -1 * LR) (("1" (expand "semtlpp" +) (("1" (inst -6 success " ε(s, s)" res1 res2) nil nil)) nil)) nil) ("2" (case "G = any") (("1" (replace -1 * LR) (("1" (expand "semtlpp" +) (("1" (assert) (("1" (lift-if 2) (("1" (split +) (("1" (flatten) (("1" (assert) (("1" (inst? -7) nil nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (inst? -) (("2" (inst? -) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "terminal?(G)") (("1" (expand "semtlpp" 3) (("1" (assert) (("1" (lift-if) (("1" (split +) (("1" (flatten) (("1" (inst? -8) nil nil)) nil) ("2" (flatten) (("2" (inst? -6) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "range?(G)") (("1" (expand "semtlpp" +) (("1" (assert) (("1" (lift-if) (("1" (split 4) (("1" (flatten) (("1" (assert) (("1" (inst? -) (("1" (inst? -) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst? -) (("2" (inst? -) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "nonTerminal?(G)") (("1" (name "B" "A(G)") (("1" (postpone) nil nil) ("2" (propax) nil nil)) nil) ("2" (case "seq?(G)") (("1" (expand "semtlpp" +) (("1" (assert) (("1" (inst-cp -2 "A" "e1(G)" "s" "s_T") (("1" (split -3) (("1" (inst -1 "cont" "res1" "res2") (("1" (split -1) (("1" (assert) (("1" (postpone) nil nil)) nil) ("2" (postpone) nil nil)) nil) ("2" (postpone) nil nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil) ("4" (postpone) nil nil) ("5" (postpone) nil nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil) ("4" (postpone) nil nil) ("5" (postpone) nil nil) ("6" (postpone) nil nil) ("7" (postpone) nil nil)) nil)) nil)) nil)) nil) nil shostak))("semantic_tlparser" semantic_tlparser results_TCC1 0 (results_TCC1-1 nil 3804395188 ("" (assert) (("" (expand "subterm") (("" (propax) nil nil)) nil)) nil) ((subterm adt-def-decl "boolean" peg nil)) nil (results subtype "semantic_tlparser.P_exp(semantic_tlparser.A)" "{e: wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].Δ | peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].subterm(e, semantic_tlparser.P_exp(semantic_tlparser.A))}")))("semantic_tlparser" semantic_tlparser results_TCC2 0 (results_TCC2-1 nil 3804395188 ("" (subtype-tcc) nil nil) ((NOT const-decl "[bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (V_N type-eq-decl nil nTpred_order nil) (peg type-decl nil peg nil) (interp type-eq-decl nil wf_peg nil) (strong_WF const-decl "bool" wf_peg nil) (WF_nT type-eq-decl nil wf_peg nil) (<= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (bound formal-const-decl "posnat" semantic_tlparser nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_tlparser nil) (> const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (<= formal-const-decl "(total_order?[V_T])" semantic_tlparser nil) (total_order? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (V_T formal-nonempty-type-decl nil semantic_tlparser nil) (strong const-decl "bool" wf_peg nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (results subtype "semantic_tlparser.s" "{k: naturalnumbers.upto(semantic_tlparser.s) | booleans.⇒((k = semantic_tlparser.s), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].g_wf(semantic_tlparser.P_exp(semantic_tlparser.A), semantic_tlparser.A, wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].P_0c?(semantic_tlparser.P_exp), wf_peg[semantic_tlparser.V_T, semantic_tlparser.<=, semantic_tlparser.V_N_b].strong))}")))("json" json_parser IMP_semantic_parser_TCC1 0 (IMP_semantic_parser_TCC2-1 nil 3786377705 ("" (lemma "isTotalOrder") (("" (propax) nil nil)) nil) ((isTotalOrder formula-decl nil json_grammar nil)) nil (IMP_semantic_parser subtype "json_grammar.<=" "(orders[V_T].total_order?)")))("json" json_parser IMP_semantic_parser_TCC2 0 (IMP_semantic_parser_TCC3-1 nil 3786377705 ("" (subtype-tcc) nil nil) ((V_N_b const-decl "nat" json_grammar nil)) nil (IMP_semantic_parser subtype "json_grammar.V_N_b" "{k: naturalnumbers.nat | reals.>(k, 0)}")))("json" json_parser parser_TCC1 0 (parser_TCC1-1 nil 3798639263 ("" (lemma "correct_grammar") (("" (propax) nil nil)) nil) ((correct_grammar formula-decl nil json_grammar nil)) nil (parser subtype "json_grammar.P_exp" "WF_nT[V_T, <=, V_N_b]")))("json" json_parser parser_TCC2 0 (parser_TCC2-1 nil 3798639263 ("" (subtype-tcc) nil nil) nil nil (parser subtype "json_parser.P_inp" "semantic_interp[V_T, <=, V_N_b, 1000, V_S]")))("json" json_parser parser_TCC3 0 (parser_TCC3-1 nil 3798639263 ("" (subtype-tcc) nil nil) ((V_N_b const-decl "nat" json_grammar nil) (entry const-decl "int" json_grammar nil)) nil (parser subtype "json_grammar.entry" "naturalnumbers.below(json_grammar.V_N_b)")))("json" json_parser parser_TCC4 0 (parser_TCC4-1 nil 3798639263 ("" (assert) (("" (expand "subterm") (("" (propax) nil nil)) nil)) nil) ((subterm adt-def-decl "boolean" peg nil)) nil (parser subtype "json_grammar.P_exp(json_grammar.entry)" "{e: wf_peg[V_T, json_grammar.<=, json_grammar.V_N_b].Δ | peg[V_T, json_grammar.<=, json_grammar.V_N_b].subterm(e, json_grammar.P_exp(json_grammar.entry))}")))("json" json_parser parser_TCC5 0 (parser_TCC5-1 nil 3798639263 ("" (subtype-tcc) nil nil) nil nil (parser subtype "(LAMBDA (A: nTpred_order[json_grammar.V_N_b].V_N, s: ast_props[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].inp_bound): semantic_parser[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].unknown)" "semantic_parser[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].results(json_grammar.P_exp, json_parser.P_inp, json_parser.inp)")))("json" json_parser parser_TCC6 0 (parser_TCC6-1 nil 3798639263 ("" (skeep*) (("" (typepred "(sempp[V_T, <=, V_N_b, 1000, V_S]
                (P_exp, P_inp, entry, P_exp(entry), inp, 0, 0,
                 (LAMBDA (A: V_N[V_N_b],
                          s: inp_bound[V_T, <=, V_N_b, 1000, V_S]):
                    unknown[V_T, <=, V_N_b, 1000, V_S]))`1)") (("1" (use "semantic_interp_props") (("1" (assert) nil nil) ("2" (expand "V_N_b") (("2" (assert) nil nil)) nil) ("3" (lemma "isTotalOrder") (("3" (propax) nil nil)) nil) ("4" (expand "entry") (("4" (assert) nil nil)) nil)) nil) ("2" (lemma "isTotalOrder") (("2" (propax) nil nil)) nil) ("3" (skeep 1) (("3" (lemma "isTotalOrder") (("3" (propax) nil nil)) nil)) nil) ("4" (expand "V_N_b") (("4" (assert) nil nil)) nil) ("5" (expand "entry") (("5" (assert) nil nil)) nil)) nil)) nil) ((unknown adt-constructor-decl "(unknown?)" semantic_parser nil) (unknown? adt-recognizer-decl "[saved_result -> boolean]" semantic_parser nil) (entry const-decl "int" json_grammar nil) (P_inp const-decl "[V_N, ast -> V_S]" json_parser nil) (P_exp const-decl "Δ" json_grammar nil) (sempp def-decl "[{T: pre_ast | T = s_inp(P_inp, parsing(P_exp, A, G, inp, s, s_T))},
 results(P_exp, P_inp, inp)]" semantic_parser nil) (results type-eq-decl nil semantic_parser nil) (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}" semantic_interp nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (semanticTree type-eq-decl nil pre_ast nil) (semanticTree? const-decl "bool" pre_ast nil) (semantic adt-constructor-decl "[[below, below, V_N[V_N_b], V_S] -> (semantic?)]" pre_ast nil) (semantic? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil) (fail adt-constructor-decl "[[below, below] -> (fail?)]" pre_ast nil) (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil) (T adt-accessor-decl "[(known?) -> (valuedTree?)]" semantic_parser nil) (valuedTree? const-decl "bool" semantic_interp nil) (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser nil) (output type-eq-decl nil peg_parser nil) (P_fc? const-decl "[Δ -> bool]" wf_peg nil) (failure adt-constructor-decl "(failure?)" ast nil) (failure? adt-recognizer-decl "[astType -> boolean]" ast nil) (P_sc? const-decl "[Δ -> bool]" wf_peg nil) (> const-decl "bool" reals nil) (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil) (success adt-constructor-decl "(success?)" ast nil) (success? adt-recognizer-decl "[astType -> boolean]" ast nil) (trueToInput def-decl "bool" ast_props nil) (trueToGrammar def-decl "bool" ast_props nil) (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil) (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil) (plus? adt-recognizer-decl "[peg -> boolean]" peg nil) (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil) (star? adt-recognizer-decl "[peg -> boolean]" peg nil) (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil) (below type-eq-decl nil pre_ast nil) (ast type-eq-decl nil ast nil) (astWellformed? def-decl "bool" ast nil) (astType? def-decl "astType" ast nil) (astType type-decl nil ast nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (known? adt-recognizer-decl "[saved_result -> boolean]" semantic_parser nil) (saved_result type-decl nil semantic_parser nil) (inp_bound type-eq-decl nil ast_props nil) (strong const-decl "bool" wf_peg nil) (P_0c? const-decl "[Δ -> bool]" wf_peg nil) (g_wf def-decl "bool" wf_peg nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (input type-eq-decl nil ast_props nil) (strong_WF const-decl "bool" wf_peg nil) (interp type-eq-decl nil wf_peg nil) (V_N type-eq-decl nil nTpred_order nil) (< const-decl "bool" reals nil) (subterm adt-def-decl "boolean" peg nil) (peg type-decl nil peg nil) (below type-eq-decl nil naturalnumbers nil) (semantic_interp type-eq-decl nil semantic_interp nil) (WF_nT type-eq-decl nil wf_peg nil) (= const-decl "[T, T -> boolean]" equalities nil) (pre_ast type-decl nil pre_ast nil) (V_S type-eq-decl nil json_parser nil) (JSON type-decl nil json_object nil) (V_N_b const-decl "nat" json_grammar nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (<= const-decl "bool" json_grammar nil) (char type-eq-decl nil strings nil) (V_T type-eq-decl nil json_grammar nil) (char? adt-recognizer-decl "[character -> boolean]" character_adt nil) (character type-decl nil character_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (total_order? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (isTotalOrder formula-decl nil json_grammar nil) (semantic_interp_props formula-decl nil semantic_interp nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (parser subtype "(semantic_parser[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].sempp(json_grammar.P_exp, json_parser.P_inp, json_grammar.entry, json_grammar.P_exp(json_grammar.entry), json_parser.inp, 0, 0, (LAMBDA (A: nTpred_order[json_grammar.V_N_b].V_N, s: ast_props[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].inp_bound): semantic_parser[V_T, json_grammar.<=, json_grammar.V_N_b, 1000, json_parser.V_S].unknown))`1)" "ast[V_T, <=, V_N_b, 1000, V_S]")))("json" json_parser strToInp_TCC1 0 (strToInp_TCC1-1 nil 3805351806 ("" (subtype-tcc) nil nil) nil nil (strToInp subtype "LAMBDA (x: naturalnumbers.below(1000)): IF (reals.<(x, json_parser.s`length)) THEN json_parser.s`seq(x) ELSE character_adt.char(0) ENDIF" "input[V_T, <=, V_N_b, 1000, V_S]")))("json" json_grammar quotation_mark_TCC1 0 (quotation_mark_TCC1-1 nil 3786305814 ("" (subtype-tcc) nil nil) ((V_N_b const-decl "nat" json_grammar nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (quotation_mark subtype "24" "naturalnumbers.below(json_grammar.V_N_b)")))("delta" wf_peg Plus_cannot_be_P0_TCC1 0 (Plus_cannot_be_P0_TCC1-1 nil 3813666933 ("" (subtype-tcc) nil nil) nil nil (Plus_cannot_be_P0 subtype "wf_peg.G" "{x: peg[wf_peg.V_T, wf_peg.<=, wf_peg.V_N_b].peg |      peg[wf_peg.V_T, wf_peg.<=, wf_peg.V_N_b].star?(x) OR peg[wf_peg.V_T, wf_peg.<=, wf_peg.V_N_b].plus?(x) OR peg[wf_peg.V_T, wf_peg.<=, wf_peg.V_N_b].opt?(x) OR peg[wf_peg.V_T, wf_peg.<=, wf_peg.V_N_b].notP?(x) OR peg[wf_peg.V_T, wf_peg.<=, wf_peg.V_N_b].andP?(x)}")))("static_analysis" inferred_order_wf_peg nT_properties_reorders 0 (nT_properties_reorders-1 nil 3813656553 ("" (skolem 1 ("P_exp" "s")) (("" (expand "nT_properties") (("" (postpone) nil nil)) nil)) nil) nil shostak))("static_analysis" inferred_order_wf_peg sub_nT_and_wellformedness_TCC1 0 (sub_nT_and_wellformedness_TCC1-1 nil 3813611401 ("" (subtype-tcc) nil nil) nil nil (sub_nT_and_wellformedness subtype "inferred_order_wf_peg.A" "naturalnumbers.upto(inferred_order_wf_peg.V_N_b)")))("static_analysis" inferred_order_wf_peg well_orders_orderly 0 (well_orders_orderly-1 nil 3813604031 ("" (expand "well_orders?") (("" (expand "orderly_WF_nT?") (("" (skeep*) (("" (inst? 1) nil nil)) nil)) nil)) nil) ((orderly_WF_nT? const-decl "bool" inferred_order_wf_peg nil) (nT_Permutation type-eq-decl nil inferred_order_wf_peg nil) (bijective? const-decl "bool" functions nil) (V_N type-eq-decl nil nTpred_order nil) (V_N_b formal-const-decl "posnat" inferred_order_wf_peg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (well_orders? const-decl "bool" inferred_order_wf_peg nil)) shostak))("delta" wf_peg strong_WF_TCC1 0 (strong_WF_TCC1-1 nil 3771171781 ("" (subtype-tcc) nil nil) nil nil (strong_WF subtype "wf_peg.A" "naturalnumbers.upto(wf_peg.V_N_b)")))("parser" peg_parser output_TCC1 0 (output_TCC1-1 nil 3771774354 ("" (subtype-tcc) nil nil) nil nil (output subtype "peg_parser.A" "naturalnumbers.upto(peg_parser.V_N_b)")))("parser_props" parser_props parsing_correctness_ε_TCC1 0 (parsing_correctness_ε_TCC2-1 nil 3785592840 ("" (assert) nil nil) nil nil (parsing_correctness_ε subtype "parser_props.A" "naturalnumbers.upto(parser_props.V_N_b)")))("semantic_tlparser" semantic_tlparser sem_result_TCC1 0 (sem_result_TCC1-1 nil 3804417092 ("" (subtype-tcc) nil nil) nil nil (sem_result subtype "semantic_tlparser.A" "naturalnumbers.upto(semantic_tlparser.V_N_b)")))("parser" peg_parser reference_parser_nonzero 0 (reference_parser_nonzero-1 nil 3847170769 ("" (skolem 1 ("σ" "P_exp" "A" "_" "_" "_" "_")) (("" (induct "G") (("1" (typepred "G!1") (("1" (propax) nil nil)) nil) ("2" (flatten) (("2" (skeep*) (("2" (expand "parsing") (("2" (assert) (("2" (expand "astMeasure") (("2" (expand "reduce_nat") (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (postpone) nil nil) ("4" (postpone) nil nil) ("5" (postpone) nil nil) ("6" (postpone) nil nil) ("7" (postpone) nil nil) ("8" (postpone) nil nil) ("9" (postpone) nil nil) ("10" (postpone) nil nil) ("11" (postpone) nil nil) ("12" (postpone) nil nil) ("13" (postpone) nil nil)) nil)) nil) nil shostak))("static_analysis" inferred_order_wf_peg inv_TCC1 0 (inv_TCC1-1 nil 3813650237 ("" (lemma "function_inverse_def[V_N,V_N].bijective_inverse_exists") (("" (postpone) nil nil)) nil) nil nil (inv existence "" "[σ: inferred_order_wf_peg.nT_Permutation -> {σ' | function_props[V_N[V_N_b], V_N[V_N_b], V_N[V_N_b]].o(σ, inferred_order_wf_peg.σ') = identity[V_N[V_N_b]].identity}]")))("static_analysis" inferred_order_wf_peg g_wf_perm_TCC1 0 (g_wf_perm_TCC1-1 nil 3813750082 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (V_N_b formal-const-decl "posnat" inferred_order_wf_peg nil) (V_N type-eq-decl nil nTpred_order nil) (bijective? const-decl "bool" functions nil) (nT_Permutation type-eq-decl nil inferred_order_wf_peg nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (reduce_nat adt-def-decl "[peg -> nat]" peg nil) (sum const-decl "nat" peg nil) (surjective? const-decl "bool" functions nil) (injective? const-decl "bool" functions nil) (pegMeasure const-decl "nat" peg nil)) nil (g_wf_perm termination "inferred_order_wf_peg.g_wf_perm(inferred_order_wf_peg.σ)(inferred_order_wf_peg.e1, inferred_order_wf_peg.A, inferred_order_wf_peg.P_0, inferred_order_wf_peg.δ)" "nil")))("static_analysis" inferred_order_wf_peg g_wf_perm_TCC2 0 (g_wf_perm_TCC2-1 nil 3813750082 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (V_N_b formal-const-decl "posnat" inferred_order_wf_peg nil) (V_N type-eq-decl nil nTpred_order nil) (bijective? const-decl "bool" functions nil) (nT_Permutation type-eq-decl nil inferred_order_wf_peg nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (reduce_nat adt-def-decl "[peg -> nat]" peg nil) (sum const-decl "nat" peg nil) (surjective? const-decl "bool" functions nil) (injective? const-decl "bool" functions nil) (pegMeasure const-decl "nat" peg nil)) nil (g_wf_perm termination "inferred_order_wf_peg.g_wf_perm(inferred_order_wf_peg.σ)(inferred_order_wf_peg.e2, inferred_order_wf_peg.A, inferred_order_wf_peg.P_0, booleans.∧(inferred_order_wf_peg.P_0(inferred_order_wf_peg.e1), inferred_order_wf_peg.δ))" "nil")))("static_analysis" inferred_order_wf_peg g_wf_perm_TCC3 0 (g_wf_perm_TCC3-1 nil 3813750082 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (V_N_b formal-const-decl "posnat" inferred_order_wf_peg nil) (V_N type-eq-decl nil nTpred_order nil) (bijective? const-decl "bool" functions nil) (nT_Permutation type-eq-decl nil inferred_order_wf_peg nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (reduce_nat adt-def-decl "[peg -> nat]" peg nil) (sum const-decl "nat" peg nil) (surjective? const-decl "bool" functions nil) (injective? const-decl "bool" functions nil) (pegMeasure const-decl "nat" peg nil)) nil (g_wf_perm termination "inferred_order_wf_peg.g_wf_perm(inferred_order_wf_peg.σ)(inferred_order_wf_peg.e1, inferred_order_wf_peg.A, inferred_order_wf_peg.P_0, inferred_order_wf_peg.δ)" "nil")))("static_analysis" inferred_order_wf_peg g_wf_perm_TCC4 0 (g_wf_perm_TCC4-1 nil 3813750082 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (V_N_b formal-const-decl "posnat" inferred_order_wf_peg nil) (V_N type-eq-decl nil nTpred_order nil) (bijective? const-decl "bool" functions nil) (nT_Permutation type-eq-decl nil inferred_order_wf_peg nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (reduce_nat adt-def-decl "[peg -> nat]" peg nil) (sum const-decl "nat" peg nil) (surjective? const-decl "bool" functions nil) (injective? const-decl "bool" functions nil) (pegMeasure const-decl "nat" peg nil)) nil (g_wf_perm termination "inferred_order_wf_peg.g_wf_perm(inferred_order_wf_peg.σ)(inferred_order_wf_peg.e2, inferred_order_wf_peg.A, inferred_order_wf_peg.P_0, inferred_order_wf_peg.δ)" "nil")))("static_analysis" inferred_order_wf_peg g_wf_perm_TCC5 0 (g_wf_perm_TCC5-1 nil 3813750082 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (V_N_b formal-const-decl "posnat" inferred_order_wf_peg nil) (V_N type-eq-decl nil nTpred_order nil) (bijective? const-decl "bool" functions nil) (nT_Permutation type-eq-decl nil inferred_order_wf_peg nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (reduce_nat adt-def-decl "[peg -> nat]" peg nil) (inc const-decl "nat" peg nil) (surjective? const-decl "bool" functions nil) (injective? const-decl "bool" functions nil) (pegMeasure const-decl "nat" peg nil)) nil (g_wf_perm termination "inferred_order_wf_peg.g_wf_perm(inferred_order_wf_peg.σ)(inferred_order_wf_peg.e, inferred_order_wf_peg.A, inferred_order_wf_peg.P_0, inferred_order_wf_peg.δ)" "nil")))("static_analysis" inferred_order_wf_peg g_wf_perm_TCC6 0 (g_wf_perm_TCC6-1 nil 3813750082 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (V_N_b formal-const-decl "posnat" inferred_order_wf_peg nil) (V_N type-eq-decl nil nTpred_order nil) (bijective? const-decl "bool" functions nil) (nT_Permutation type-eq-decl nil inferred_order_wf_peg nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (reduce_nat adt-def-decl "[peg -> nat]" peg nil) (inc const-decl "nat" peg nil) (surjective? const-decl "bool" functions nil) (injective? const-decl "bool" functions nil) (pegMeasure const-decl "nat" peg nil)) nil (g_wf_perm termination "inferred_order_wf_peg.g_wf_perm(inferred_order_wf_peg.σ)(inferred_order_wf_peg.e, inferred_order_wf_peg.A, inferred_order_wf_peg.P_0, inferred_order_wf_peg.δ)" "nil")))("static_analysis" inferred_order_wf_peg g_wf_perm_TCC7 0 (g_wf_perm_TCC7-1 nil 3813750082 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (V_N_b formal-const-decl "posnat" inferred_order_wf_peg nil) (V_N type-eq-decl nil nTpred_order nil) (bijective? const-decl "bool" functions nil) (nT_Permutation type-eq-decl nil inferred_order_wf_peg nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (reduce_nat adt-def-decl "[peg -> nat]" peg nil) (inc const-decl "nat" peg nil) (surjective? const-decl "bool" functions nil) (injective? const-decl "bool" functions nil) (pegMeasure const-decl "nat" peg nil)) nil (g_wf_perm termination "inferred_order_wf_peg.g_wf_perm(inferred_order_wf_peg.σ)(inferred_order_wf_peg.e, inferred_order_wf_peg.A, inferred_order_wf_peg.P_0, inferred_order_wf_peg.δ)" "nil")))("static_analysis" inferred_order_wf_peg g_wf_perm_TCC8 0 (g_wf_perm_TCC8-1 nil 3813750082 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (V_N_b formal-const-decl "posnat" inferred_order_wf_peg nil) (V_N type-eq-decl nil nTpred_order nil) (bijective? const-decl "bool" functions nil) (nT_Permutation type-eq-decl nil inferred_order_wf_peg nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (reduce_nat adt-def-decl "[peg -> nat]" peg nil) (inc const-decl "nat" peg nil) (surjective? const-decl "bool" functions nil) (injective? const-decl "bool" functions nil) (pegMeasure const-decl "nat" peg nil)) nil (g_wf_perm termination "inferred_order_wf_peg.g_wf_perm(inferred_order_wf_peg.σ)(inferred_order_wf_peg.e, inferred_order_wf_peg.A, inferred_order_wf_peg.P_0, inferred_order_wf_peg.δ)" "nil")))("static_analysis" inferred_order_wf_peg g_wf_perm_TCC9 0 (g_wf_perm_TCC9-1 nil 3813750082 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (V_N_b formal-const-decl "posnat" inferred_order_wf_peg nil) (V_N type-eq-decl nil nTpred_order nil) (bijective? const-decl "bool" functions nil) (nT_Permutation type-eq-decl nil inferred_order_wf_peg nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (reduce_nat adt-def-decl "[peg -> nat]" peg nil) (inc const-decl "nat" peg nil) (surjective? const-decl "bool" functions nil) (injective? const-decl "bool" functions nil) (pegMeasure const-decl "nat" peg nil)) nil (g_wf_perm termination "inferred_order_wf_peg.g_wf_perm(inferred_order_wf_peg.σ)(inferred_order_wf_peg.e, inferred_order_wf_peg.A, inferred_order_wf_peg.P_0, inferred_order_wf_peg.δ)" "nil")))("static_analysis" inferred_order_wf_peg sub_nT_TCC1 0 (sub_nT_TCC1-1 nil 3813611401 ("" (subtype-tcc) nil nil) ((∅ const-decl "set[V_N[V_N_b]]" inferred_order_wf_peg nil) (finite_emptyset name-judgement "finite_set" finite_sets nil)) nil (sub_nT subtype "inferred_order_wf_peg.∅" "finite_set[V_N[V_N_b]]")))("static_analysis" inferred_order_wf_peg sub_nT_TCC2 0 (sub_nT_TCC2-1 nil 3813611401 ("" (subtype-tcc) nil nil) ((∅ const-decl "set[V_N[V_N_b]]" inferred_order_wf_peg nil) (finite_emptyset name-judgement "finite_set" finite_sets nil)) nil (sub_nT subtype "inferred_order_wf_peg.∅" "finite_set[V_N[V_N_b]]")))("static_analysis" inferred_order_wf_peg sub_nT_TCC3 0 (sub_nT_TCC3-1 nil 3813611401 ("" (subtype-tcc) nil nil) ((∅ const-decl "set[V_N[V_N_b]]" inferred_order_wf_peg nil) (finite_emptyset name-judgement "finite_set" finite_sets nil)) nil (sub_nT subtype "inferred_order_wf_peg.∅" "finite_set[V_N[V_N_b]]")))("static_analysis" inferred_order_wf_peg sub_nT_TCC4 0 (sub_nT_TCC4-1 nil 3813611401 ("" (subtype-tcc) nil nil) ((∅ const-decl "set[V_N[V_N_b]]" inferred_order_wf_peg nil) (finite_emptyset name-judgement "finite_set" finite_sets nil)) nil (sub_nT subtype "inferred_order_wf_peg.∅" "finite_set[V_N[V_N_b]]")))("static_analysis" inferred_order_wf_peg sub_nT_TCC5 0 (sub_nT_TCC5-1 nil 3813611401 ("" (termination-tcc) nil nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (reduce_nat adt-def-decl "[peg -> nat]" peg nil) (sum const-decl "nat" peg nil) (pegMeasure const-decl "nat" peg nil)) nil (sub_nT termination "inferred_order_wf_peg.sub_nT(inferred_order_wf_peg.e1, inferred_order_wf_peg.P_0)" "nil")))("static_analysis" inferred_order_wf_peg sub_nT_TCC6 0 (sub_nT_TCC6-1 nil 3813611401 ("" (termination-tcc) nil nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (reduce_nat adt-def-decl "[peg -> nat]" peg nil) (sum const-decl "nat" peg nil) (pegMeasure const-decl "nat" peg nil)) nil (sub_nT termination "inferred_order_wf_peg.sub_nT(inferred_order_wf_peg.e2, inferred_order_wf_peg.P_0)" "nil")))("static_analysis" inferred_order_wf_peg sub_nT_TCC7 0 (sub_nT_TCC7-1 nil 3813611401 ("" (termination-tcc) nil nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (reduce_nat adt-def-decl "[peg -> nat]" peg nil) (sum const-decl "nat" peg nil) (pegMeasure const-decl "nat" peg nil)) nil (sub_nT termination "inferred_order_wf_peg.sub_nT(inferred_order_wf_peg.e1, inferred_order_wf_peg.P_0)" "nil")))("static_analysis" inferred_order_wf_peg sub_nT_TCC8 0 (sub_nT_TCC8-1 nil 3813611401 ("" (termination-tcc) nil nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (reduce_nat adt-def-decl "[peg -> nat]" peg nil) (sum const-decl "nat" peg nil) (pegMeasure const-decl "nat" peg nil)) nil (sub_nT termination "inferred_order_wf_peg.sub_nT(inferred_order_wf_peg.e1, inferred_order_wf_peg.P_0)" "nil")))("static_analysis" inferred_order_wf_peg sub_nT_TCC9 0 (sub_nT_TCC9-1 nil 3813611401 ("" (termination-tcc) nil nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (reduce_nat adt-def-decl "[peg -> nat]" peg nil) (sum const-decl "nat" peg nil) (pegMeasure const-decl "nat" peg nil)) nil (sub_nT termination "inferred_order_wf_peg.sub_nT(inferred_order_wf_peg.e2, inferred_order_wf_peg.P_0)" "nil")))("static_analysis" inferred_order_wf_peg sub_nT_TCC10 0 (sub_nT_TCC10-1 nil 3813611401 ("" (termination-tcc) nil nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (reduce_nat adt-def-decl "[peg -> nat]" peg nil) (inc const-decl "nat" peg nil) (pegMeasure const-decl "nat" peg nil)) nil (sub_nT termination "inferred_order_wf_peg.sub_nT(inferred_order_wf_peg.e, inferred_order_wf_peg.P_0)" "nil")))("static_analysis" inferred_order_wf_peg sub_nT_TCC11 0 (sub_nT_TCC11-1 nil 3813611401 ("" (termination-tcc) nil nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (reduce_nat adt-def-decl "[peg -> nat]" peg nil) (inc const-decl "nat" peg nil) (pegMeasure const-decl "nat" peg nil)) nil (sub_nT termination "inferred_order_wf_peg.sub_nT(inferred_order_wf_peg.e, inferred_order_wf_peg.P_0)" "nil")))("static_analysis" inferred_order_wf_peg sub_nT_TCC12 0 (sub_nT_TCC12-1 nil 3813611401 ("" (termination-tcc) nil nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (reduce_nat adt-def-decl "[peg -> nat]" peg nil) (inc const-decl "nat" peg nil) (pegMeasure const-decl "nat" peg nil)) nil (sub_nT termination "inferred_order_wf_peg.sub_nT(inferred_order_wf_peg.e, inferred_order_wf_peg.P_0)" "nil")))("static_analysis" inferred_order_wf_peg sub_nT_TCC13 0 (sub_nT_TCC13-1 nil 3813611401 ("" (termination-tcc) nil nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (reduce_nat adt-def-decl "[peg -> nat]" peg nil) (inc const-decl "nat" peg nil) (pegMeasure const-decl "nat" peg nil)) nil (sub_nT termination "inferred_order_wf_peg.sub_nT(inferred_order_wf_peg.e, inferred_order_wf_peg.P_0)" "nil")))("static_analysis" inferred_order_wf_peg sub_nT_TCC14 0 (sub_nT_TCC14-1 nil 3813611401 ("" (termination-tcc) nil nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (reduce_nat adt-def-decl "[peg -> nat]" peg nil) (inc const-decl "nat" peg nil) (pegMeasure const-decl "nat" peg nil)) nil (sub_nT termination "inferred_order_wf_peg.sub_nT(inferred_order_wf_peg.e, inferred_order_wf_peg.P_0)" "nil")))("static_analysis" inferred_order_wf_peg sub_nT_and_wellformedness_TCC1 0 (sub_nT_and_wellformedness_TCC1-1 nil 3813611401 ("" (subtype-tcc) nil nil) nil nil (sub_nT_and_wellformedness subtype "inferred_order_wf_peg.A" "naturalnumbers.upto(inferred_order_wf_peg.V_N_b)")))("static_analysis" inferred_order_wf_peg sub_nT_and_wellformedness 0 (sub_nT_and_wellformedness-1 nil 3813611424 ("" (induct G) (("1" (skeep*) (("1" (assert) (("1" (expand "g_wf") (("1" (expand "sub_nT") (("1" (assert) (("1" (skeep) (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (skolem 1 ("e1" "e2")) (("6" (flatten) (("6" (skeep*) (("6" (expand "g_wf" +) (("6" (assert) (("6" (inst -1 "A" "P_0") (("6" (inst -2 "A" "P_0") (("6" (split 1) (("1" (flatten) (("1" (assert) (("1" (split) (("1" (assert) nil nil) ("2" (flatten) (("2" (assert) (("2" (expand "complete") (("2" (expand "strong") (("2" (assert) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) (("3" (flatten) (("3" (assert) (("3" (skeep*) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "strong") (("2" (expand "complete") (("2" (flatten) (("2" (split) (("1" (assert) (("1" (skeep) (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (ground) (("1" (grind) nil nil) ("2" (skeep*) (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (skolem 1 ("e1" "e2")) (("7" (flatten) (("7" (skeep*) (("7" (inst -1 "A" "P_0") (("7" (inst - "A" "P_0") (("7" (expand "strong") (("7" (expand "complete") (("7" (expand "g_wf" +) (("7" (split 1) (("1" (flatten) (("1" (assert) (("1" (split 1) (("1" (flatten) nil nil) ("2" (assert) nil nil) ("3" (skeep*) (("3" (assert) (("3" (expand "sub_nT" -1) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 1) (("1" (assert) (("1" (skeep) (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (skeep) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("8" (skolem 1 ("e")) (("8" (flatten) (("8" (skeep) (("8" (inst? -) (("8" (inst? -) (("8" (expand "g_wf" +) (("8" (split 1) (("1" (flatten) (("1" (assert) (("1" (split 2) (("1" (assert) nil nil) ("2" (skeep) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (skeep) (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("9" (skolem 1 ("e")) (("9" (flatten) (("9" (skeep) (("9" (inst? -) (("9" (inst? -) (("9" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("10" (skolem 1 ("e")) (("10" (flatten) (("10" (skeep) (("10" (inst? -) (("10" (inst? -) (("10" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("11" (skolem 1 ("e")) (("11" (flatten) (("11" (skeep) (("11" (inst? -) (("11" (inst? -) (("11" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("12" (skolem 1 ("e")) (("12" (flatten) (("12" (skeep) (("12" (inst? -) (("12" (inst? -) (("12" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((finite_union application-judgement "finite_set" finite_sets nil) (member const-decl "bool" sets nil) (union const-decl "set" sets nil) (singleton const-decl "(singleton?)" sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (below type-eq-decl nil naturalnumbers nil) (TRUE const-decl "bool" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (finite_emptyset name-judgement "finite_set" finite_sets nil) (emptyset const-decl "set" sets nil) (∅ const-decl "set[V_N[V_N_b]]" inferred_order_wf_peg nil) (peg_induction formula-decl nil peg nil) (V_T formal-nonempty-type-decl nil inferred_order_wf_peg nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (pred type-eq-decl nil defined_types nil) (total_order? const-decl "bool" orders nil) (<= formal-const-decl "(total_order?[V_T])" inferred_order_wf_peg nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (V_N_b formal-const-decl "posnat" inferred_order_wf_peg nil) (sub_nT def-decl "finite_set[V_N[V_N_b]]" inferred_order_wf_peg nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (complete const-decl "bool" wf_peg nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (strong const-decl "bool" wf_peg nil) (g_wf def-decl "bool" wf_peg nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (V_N type-eq-decl nil nTpred_order nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (peg type-decl nil peg nil)) shostak))("static_analysis" inferred_order_wf_peg sub_nT_and_wellformedness_perm 0 (sub_nT_and_wellformedness_perm-1 nil 3813751386 ("" (skolem 1 ("s" "_" "_" "_")) (("" (expand "strong") (("" (expand "complete") (("" (induct G) (("1" (skeep*) (("1" (expand "g_wf_perm" +) (("1" (ground) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (skeep*) (("2" (expand "g_wf_perm" +) (("2" (ground) (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (skeep*) (("3" (expand "g_wf_perm" +) (("3" (ground) (("3" (grind) nil nil)) nil)) nil)) nil) ("4" (skeep*) (("4" (expand "g_wf_perm" +) (("4" (ground) (("4" (grind) nil nil)) nil)) nil)) nil) ("5" (skeep*) (("5" (expand "g_wf_perm" +) (("5" (ground) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("6" (skeep*) (("6" (expand "g_wf_perm" +) (("6" (ground) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (inst? -4) (("4" (assert) (("4" (skeep) (("4" (grind) nil nil)) nil)) nil)) nil) ("5" (inst? -5) (("5" (assert) (("5" (case "P_0(seq1_var)") (("1" (assert) (("1" (skeep) (("1" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (skeep*) (("7" (expand "g_wf_perm" +) (("7" (assert) (("7" (split 1) (("1" (flatten) (("1" (assert) (("1" (split) (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil) ("3" (expand "sub_nT" 1) (("3" (expand "union" 1) (("3" (skeep) (("3" (assert) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 1) (("1" (inst? -4) (("1" (assert) (("1" (skeep) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (inst? -5) (("2" (assert) (("2" (skeep) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("8" (skeep*) (("8" (expand "g_wf_perm" +) (("8" (ground) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil) ("9" (skeep*) (("9" (expand "g_wf_perm" +) (("9" (ground) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil) ("10" (skeep*) (("10" (expand "g_wf_perm" +) (("10" (ground) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil) ("11" (skeep*) (("11" (expand "g_wf_perm" +) (("11" (ground) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil) ("12" (skeep*) (("12" (expand "g_wf_perm" +) (("12" (ground) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((strong const-decl "bool" wf_peg nil) (union const-decl "set" sets nil) (member const-decl "bool" sets nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (singleton const-decl "(singleton?)" sets nil) (below type-eq-decl nil naturalnumbers nil) (emptyset const-decl "set" sets nil) (∅ const-decl "set[V_N[V_N_b]]" inferred_order_wf_peg nil) (peg_induction formula-decl nil peg nil) (V_T formal-nonempty-type-decl nil inferred_order_wf_peg nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (pred type-eq-decl nil defined_types nil) (total_order? const-decl "bool" orders nil) (<= formal-const-decl "(total_order?[V_T])" inferred_order_wf_peg nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (V_N_b formal-const-decl "posnat" inferred_order_wf_peg nil) (sub_nT def-decl "finite_set[V_N[V_N_b]]" inferred_order_wf_peg nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (FALSE const-decl "bool" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (TRUE const-decl "bool" booleans nil) (g_wf_perm def-decl "bool" inferred_order_wf_peg nil) (nT_Permutation type-eq-decl nil inferred_order_wf_peg nil) (bijective? const-decl "bool" functions nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (V_N type-eq-decl nil nTpred_order nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (peg type-decl nil peg nil) (complete const-decl "bool" wf_peg nil)) shostak))("static_analysis" inferred_order_wf_peg kahns_algorithm_TCC1 0 (kahns_algorithm_TCC1-1 nil 3813648570 ("" (inst 1 "LAMBDA (P_exp: interp[V_T, <=, V_N_b]): None") nil nil) ((None adt-constructor-decl "(None?)" inferred_order_wf_peg nil) (None? adt-recognizer-decl "[option_permutation -> boolean]" inferred_order_wf_peg nil) (σ adt-accessor-decl "[(Some?) -> nT_Permutation]" inferred_order_wf_peg nil) (topologically_sorts? const-decl "bool" inferred_order_wf_peg nil) (nT_Permutation type-eq-decl nil inferred_order_wf_peg nil) (bijective? const-decl "bool" functions nil) (peg type-decl nil peg nil) (V_N type-eq-decl nil nTpred_order nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Some? adt-recognizer-decl "[option_permutation -> boolean]" inferred_order_wf_peg nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (option_permutation type-decl nil inferred_order_wf_peg nil) (interp type-eq-decl nil wf_peg nil) (V_N_b formal-const-decl "posnat" inferred_order_wf_peg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (<= formal-const-decl "(total_order?[V_T])" inferred_order_wf_peg nil) (total_order? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (V_T formal-nonempty-type-decl nil inferred_order_wf_peg nil)) nil (kahns_algorithm existence "" "[P_exp: wf_peg[inferred_order_wf_peg.V_T, inferred_order_wf_peg.<=, inferred_order_wf_peg.V_N_b].interp -> {Σ: inferred_order_wf_peg.option_permutation | (booleans.⇒(inferred_order_wf_peg.Some?(Σ), inferred_order_wf_peg.topologically_sorts?(P_exp, inferred_order_wf_peg.σ(Σ))))}]")))("static_analysis" inferred_order_wf_peg complete_WF_reorders 0 (complete_WF_reorders-2 "Tried to unfold a g_wf in hypothesis, spotted a problem" 3813747419 ("" (skolem 1 ("P_exp" "s")) (("" (flatten) (("" (case "(FORALL (A: V_N[V_N_b]), G: subterm(G, P_exp(A)) IMPLIES g_wf(G, A, P_0c?(P_exp), FALSE)) ⇒
                     FORALL (A: V_N[V_N_b]), G: subterm(G, (P_exp)(A)) IMPLIES g_wf_perm(s)(G, A, P_0c?(P_exp), FALSE)") (("1" (expand "complete_WF_perm") (("1" (split -1) (("1" (grind) nil nil) ("2" (hide 2) (("2" (use "complete_WF_theorem2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (flatten) (("2" (skolem 1 ("A" "_")) (("2" (induct "G") (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (skolem 1 (e1 e2)) (("6" (assert) (("6" (flatten) (("6" (assert) (("6" (expand g_wf_perm 1) (("6" (split 1) (("1" (assert) (("1" (use "peg[V_T, <=, V_N_b].subterm_transitivity" (e1 "seq(e1,e2)")) (("1" (grind) nil nil)) nil)) nil) ("2" (assert) (("2" (use "peg[V_T, <=, V_N_b].subterm_transitivity" (e1 "seq(e1,e2)")) (("2" (assert) (("2" (use "peg[V_T, <=, V_N_b].subterm_transitivity" (e1 "seq(e1,e2)" e e2)) (("2" (assert) (("2" (ground) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (skolem 1 (e1 e2)) (("7" (flatten) (("7" (assert) (("7" (expand g_wf_perm 1) (("7" (split 1) (("1" (assert) (("1" (use "peg[V_T, <=, V_N_b].subterm_transitivity" (e1 "prior(e1,e2)")) (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (use "peg[V_T, <=, V_N_b].subterm_transitivity" (e1 "prior(e1,e2)")) (("2" (use "peg[V_T, <=, V_N_b].subterm_transitivity" (e1 "prior(e1,e2)" e e2)) (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("8" (skolem 1 (e)) (("8" (flatten) (("8" (assert) (("8" (expand g_wf_perm 1) (("8" (split 1) (("1" (assert) (("1" (use "peg[V_T, <=, V_N_b].subterm_transitivity" (e1 "star(e)")) (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (inst -4 "A" "star(e)") (("2" (assert) (("2" (expand "g_wf") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("9" (skolem 1 (e)) (("9" (flatten) (("9" (assert) (("9" (expand g_wf_perm 1) (("9" (split 1) (("1" (assert) (("1" (use "peg[V_T, <=, V_N_b].subterm_transitivity" (e1 "plus(e)")) (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (inst - "A" "plus(e)") (("2" (assert) (("2" (expand "g_wf") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("10" (skolem 1 (e)) (("10" (flatten) (("10" (assert) (("10" (expand g_wf_perm 1) (("10" (assert) (("10" (use "peg[V_T, <=, V_N_b].subterm_transitivity" (e1 "opt(e)")) (("10" (assert) (("10" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("11" (skolem 1 (e)) (("11" (flatten) (("11" (assert) (("11" (expand g_wf_perm 1) (("11" (assert) (("11" (use "peg[V_T, <=, V_N_b].subterm_transitivity" (e1 "notP(e)")) (("11" (assert) (("11" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("12" (skolem 1 (e)) (("12" (flatten) (("12" (assert) (("12" (expand g_wf_perm 1) (("12" (assert) (("12" (use "peg[V_T, <=, V_N_b].subterm_transitivity" (e1 "andP(e)")) (("12" (assert) (("12" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((andP? adt-recognizer-decl "[peg -> boolean]" peg nil) (andP adt-constructor-decl "[peg -> (andP?)]" peg nil) (notP? adt-recognizer-decl "[peg -> boolean]" peg nil) (notP adt-constructor-decl "[peg -> (notP?)]" peg nil) (opt? adt-recognizer-decl "[peg -> boolean]" peg nil) (opt adt-constructor-decl "[peg -> (opt?)]" peg nil) (plus adt-constructor-decl "[peg -> (plus?)]" peg nil) (plus? adt-recognizer-decl "[peg -> boolean]" peg nil) (star adt-constructor-decl "[peg -> (star?)]" peg nil) (star? adt-recognizer-decl "[peg -> boolean]" peg nil) (prior adt-constructor-decl "[[peg, peg] -> (prior?)]" peg nil) (prior? adt-recognizer-decl "[peg -> boolean]" peg nil) (subterm_transitivity formula-decl nil peg nil) (seq? adt-recognizer-decl "[peg -> boolean]" peg nil) (seq adt-constructor-decl "[[peg, peg] -> (seq?)]" peg nil) (peg_induction formula-decl nil peg nil) (complete_WF_perm const-decl "bool" inferred_order_wf_peg nil) (complete_WF_theorem2 formula-decl nil wf_peg nil) (int_minus_int_is_int application-judgement "int" integers nil) (complete const-decl "bool" wf_peg nil) (complete_WF const-decl "bool" wf_peg nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (V_N_b formal-const-decl "posnat" inferred_order_wf_peg nil) (V_N type-eq-decl nil nTpred_order nil) (V_T formal-nonempty-type-decl nil inferred_order_wf_peg nil) (pred type-eq-decl nil defined_types nil) (total_order? const-decl "bool" orders nil) (<= formal-const-decl "(total_order?[V_T])" inferred_order_wf_peg nil) (peg type-decl nil peg nil) (subterm adt-def-decl "boolean" peg nil) (interp type-eq-decl nil wf_peg nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (g_wf def-decl "bool" wf_peg nil) (P_0c? const-decl "[Δ -> bool]" wf_peg nil) (FALSE const-decl "bool" booleans nil) (bijective? const-decl "bool" functions nil) (nT_Permutation type-eq-decl nil inferred_order_wf_peg nil) (g_wf_perm def-decl "bool" inferred_order_wf_peg nil)) shostak) (complete_WF_reorders-1 nil 3813650558 ("" (skolem 1 ("P_exp" "s")) (("" (flatten) (("" (expand "complete_WF" 1) (("" (skeep) (("" (case "(FORALL (A: V_N[V_N_b]), G: subterm(G, P_exp(A)) IMPLIES g_wf(G, A, P_0c?(P_exp), FALSE)) ⇒
              FORALL (A: V_N[V_N_b]), G: subterm(G, (P_exp o s)(A)) IMPLIES g_wf(G, A, P_0c?(P_exp o s), FALSE)") (("1" (split -1) (("1" (inst -1 "A" "(P_exp o s)(A)") (("1" (assert) (("1" (expand "complete") (("1" (assert) (("1" (expand "subterm") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "complete_WF_theorem2") (("2" (inst? -) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (hide 2) (("2" (skolem 1 (B _)) (("2" (induct "G") (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (skolem 1 (e1 e2)) (("6" (flatten) (("6" (expand "g_wf" 1) (("6" (split) (("1" (assert) (("1" (assert) (("1" (use "peg[V_T, <=, V_N_b].subterm_transitivity" (e1 "seq(e1,e2)")) (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (use "peg[V_T, <=, V_N_b].subterm_transitivity" (e1 "seq(e1,e2)")) (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (skolem 1 (e1 e2)) (("7" (flatten) (("7" (expand "g_wf" 1) (("7" (split) (("1" (assert) (("1" (use "peg[V_T, <=, V_N_b].subterm_transitivity" (e1 "prior(e1,e2)")) (("1" (assert) (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (use "peg[V_T, <=, V_N_b].subterm_transitivity" (e1 "prior(e1,e2)")) (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("8" (skolem 1 (e)) (("8" (assert) (("8" (flatten) (("8" (postpone) nil nil)) nil)) nil)) nil) ("9" (skolem 1 (e)) (("9" (flatten) (("9" (assert) (("9" (expand "g_wf" +) (("9" (split 1) (("1" (assert) (("1" (use "peg[V_T, <=, V_N_b].subterm_transitivity" (e1 "plus(e)")) (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("10" (skolem 1 (e)) (("10" (flatten) (("10" (simplify) (("10" (expand "g_wf" +) (("10" (assert) (("10" (use "peg[V_T, <=, V_N_b].subterm_transitivity" (e1 "opt(e)")) (("10" (assert) (("10" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("11" (skolem 1 (e)) (("11" (flatten) (("11" (expand "g_wf" +) (("11" (assert) (("11" (use "peg[V_T, <=, V_N_b].subterm_transitivity" (e1 "notP(e)")) (("11" (assert) (("11" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("12" (skolem 1 (e)) (("12" (flatten) (("12" (expand "g_wf" +) (("12" (assert) (("12" (use "peg[V_T, <=, V_N_b].subterm_transitivity" (e1 "andP(e)")) (("12" (assert) (("12" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("static_analysis" inferred_order_wf_peg topological_sort_well_orders 0 (topological_sort_well_orders-1 nil 3813648698 ("" (skolem 1 (P_exp "s")) (("" (flatten) (("" (typepred "kahns_algorithm(P_exp)") (("" (replace -2 * LR) (("" (assert) (("" (hide -2) (("" (expand "topologically_sorts?") (("" (expand "well_orders?") (("" (expand "strong_WF_perm") (("" (use "complete_WF_reorders") (("" (assert) (("" (lemma "sub_nT_and_wellformedness_perm") (("" (skeep) (("" (inst -1 "s" "P_exp(A)" "A" "P_0c?(P_exp)") (("" (assert) (("" (hide 2) (("" (expand "complete_WF_perm") (("" (split 1) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((well_orders? const-decl "bool" inferred_order_wf_peg nil) (complete_WF_reorders formula-decl nil inferred_order_wf_peg nil) (sub_nT_and_wellformedness_perm formula-decl nil inferred_order_wf_peg nil) (P_0c? const-decl "[Δ -> bool]" wf_peg nil) (complete_WF const-decl "bool" wf_peg nil) (complete const-decl "bool" wf_peg nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (complete_WF_perm const-decl "bool" inferred_order_wf_peg nil) (strong_WF_perm const-decl "bool" inferred_order_wf_peg nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (option_permutation type-decl nil inferred_order_wf_peg nil) (Some? adt-recognizer-decl "[option_permutation -> boolean]" inferred_order_wf_peg nil) (V_T formal-nonempty-type-decl nil inferred_order_wf_peg nil) (pred type-eq-decl nil defined_types nil) (total_order? const-decl "bool" orders nil) (<= formal-const-decl "(total_order?[V_T])" inferred_order_wf_peg nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (V_N_b formal-const-decl "posnat" inferred_order_wf_peg nil) (interp type-eq-decl nil wf_peg nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (V_N type-eq-decl nil nTpred_order nil) (peg type-decl nil peg nil) (bijective? const-decl "bool" functions nil) (nT_Permutation type-eq-decl nil inferred_order_wf_peg nil) (topologically_sorts? const-decl "bool" inferred_order_wf_peg nil) (σ adt-accessor-decl "[(Some?) -> nT_Permutation]" inferred_order_wf_peg nil) (kahns_algorithm const-decl "{Σ: option_permutation | (Some?(Σ) ⇒ topologically_sorts?(P_exp, σ(Σ)))}" inferred_order_wf_peg nil)) shostak))("static_analysis" static_analysis no_repetitions_union 0 (no_repetitions_union-1 nil 3847278310 ("" (induct "l1") (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (skolem 1 ("x" "l")) (("3" (flatten) (("3" (use "no_rep_cdr[V_N]") (("3" (assert) (("3" (flatten) (("3" (assert) (("3" (skeep) (("3" (hide -3) (("3" (inst -2 "l2") (("3" (hide -1) (("3" (expand "union_sl" +) (("3" (typepred "add_sl(x, union_sl(l, l2))") (("3" (hide -1 -2) (("3" (expand "no_repetitions?") (("3" (skeep) (("3" (inst-cp -1 "nth(add_sl(x, union_sl(l, l2)), i)") (("3" (inst -1 "nth(add_sl(x, union_sl(l, l2)), j)") (("3" (flatten) (("3" (assert) (("3" (hide -2 -4) (("3" (split -1 -2) (("1" (split -2) (("1" (postpone) nil nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("static_analysis" static_analysis IMP_c_topological_sort_TCC1 0 (IMP_c_topological_sort_TCC1-1 nil 3847268234 ("" (typepred "V_N_b") (("" (inst 1 0) (("" (assert) nil nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (V_N type-eq-decl nil nTpred_order nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (V_N_b formal-const-decl "posnat" static_analysis nil)) nil (IMP_c_topological_sort existence "" "V_N[V_N_b]")))("static_analysis" static_analysis IMP_c_topological_sort_TCC1 0 (IMP_c_topological_sort_TCC1-1 nil 3847362076 ("" (inst 1 0) (("" (assert) nil nil)) nil) ((V_N type-eq-decl nil nTpred_order nil) (V_N_b formal-const-decl "posnat" static_analysis nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (IMP_c_topological_sort existence "" "V_N[V_N_b]")))("static_analysis" static_analysis IMP_c_topological_sort_TCC1 0 (IMP_c_topological_sort_TCC1-1 nil 3847444706 ("" (grind) (("" (inst 1 0) (("" (grind) nil nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (V_N_b formal-const-decl "posnat" static_analysis nil) (V_N type-eq-decl nil nTpred_order nil)) nil (IMP_c_topological_sort existence "" "V_N[V_N_b]")))("static_analysis" static_analysis IMP_c_topological_sort_TCC1 0 (IMP_c_topological_sort_TCC1-1 nil 3847453131 ("" (existence-tcc) nil nil) nil nil (IMP_c_topological_sort existence "" "V_N[V_N_b]")))("static_analysis" static_analysis IMP_c_topological_sort_TCC1 0 (IMP_c_topological_sort_TCC1-1 nil 3847455549 ("" (existence-tcc) nil nil) nil nil (IMP_c_topological_sort existence "" "V_N[V_N_b]")))("static_analysis" static_analysis IMP_c_topological_sort_TCC1 0 (IMP_c_topological_sort_TCC1-1 nil 3847455549 ("" (inst 1 0) (("" (grind) nil nil)) nil) ((V_N type-eq-decl nil nTpred_order nil) (V_N_b formal-const-decl "posnat" static_analysis nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (IMP_c_topological_sort existence "" "V_N[V_N_b]")))("static_analysis" static_analysis IMP_c_topological_sort_TCC1 0 (IMP_c_topological_sort_TCC1-1 nil 3847461392 ("" (inst 1 0) (("" (grind) nil nil)) nil) ((V_N type-eq-decl nil nTpred_order nil) (V_N_b formal-const-decl "posnat" static_analysis nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (IMP_c_topological_sort existence "" "V_N[V_N_b]")))("static_analysis" static_analysis IMP_c_topological_sort_TCC1 0 (IMP_c_topological_sort_TCC1-1 nil 3847461898 ("" (existence-tcc) nil nil) nil nil (IMP_c_topological_sort existence "" "V_N[V_N_b]")))("subrange_list" interval_list interval_list_rec_TCC1 0 (interval_list_rec_TCC1-1 nil 3847474782 ("" (subtype-tcc) nil nil) nil nil (interval_list_rec subtype "(number_fields.-)(interval_list.j, interval_list.i)" "naturalnumber")))("subrange_list" interval_list interval_list_rec_TCC2 0 (interval_list_rec_TCC2-1 nil 3847474782 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (upfrom nonempty-type-eq-decl nil integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (interval_list_rec subtype "interval_list.j" "integers.upfrom((number_fields.+)(1, interval_list.i))")))("subrange_list" interval_list interval_list_rec_TCC3 0 (interval_list_rec_TCC3-1 nil 3847474782 ("" (termination-tcc) nil nil) ((int_minus_int_is_int application-judgement "int" integers nil)) nil (interval_list_rec termination "interval_list.interval_list_rec((number_fields.+)(interval_list.i, 1), interval_list.j)" "nil")))("subrange_list" interval_list interval_list_TCC1 0 (interval_list_TCC1-1 nil 3847474782 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (interval_list subtype "interval_list.j" "integers.upfrom(interval_list.i)")))("subrange_list" interval_list interval_list_length 0 (interval_list_length-1 nil 3847474795 ("" (skeep) (("" (expand "interval_list") (("" (case "forall (i:below(n+1)) : length(interval_list_rec((n-i),n)) = i +1") (("1" (inst -1 n) (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (induct i) (("1" (grind) nil nil) ("2" (skolem 1 "i") (("2" (ground) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((interval_list const-decl "list[nat]" interval_list nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (even_plus_odd_is_odd application-judgement "odd_int" integers nil) (below_induction formula-decl nil bounded_nat_inductions nil) (pred type-eq-decl nil defined_types nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (length def-decl "nat" list_props nil) (upfrom nonempty-type-eq-decl nil integers nil) (interval_list_rec def-decl "list[nat]" interval_list nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil)) shostak))("subrange_list" interval_list interval_list_idx_TCC1 0 (interval_list_idx_TCC1-1 nil 3847474782 ("" (subtype-tcc) nil nil) nil nil (interval_list_idx subtype "interval_list.j" "{a: numbers.number | list_props[numbers.number].member(a, interval_list.interval_list(0, interval_list.n))}")))("static_analysis" static_analysis IMP_c_topological_sort_TCC1 0 (IMP_c_topological_sort_TCC1-1 nil 3847472036 ("" (existence-tcc) nil nil) nil nil (IMP_c_topological_sort existence "" "V_N[V_N_b]")))("static_analysis" static_analysis make_srl_length 0 (make_srl_length-1 nil 3847362913 ("" (skeep) (("" (expand "make_srl") (("" (lift-if) (("" (assert) (("" (case "forall (i:below(n+1)) : length(make_srl_rec((n-i),n)) = i +1") (("1" (inst -1 n) (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (induct i) (("1" (grind) nil nil) ("2" (skolem 1 "i") (("2" (ground) (("2" (expand "make_srl_rec" +) (("2" (expand "length" +) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((make_srl const-decl "subrange_list(i, j)" subrange_list structures) (int_plus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (even_plus_odd_is_odd application-judgement "odd_int" integers nil) (below_induction formula-decl nil bounded_nat_inductions nil) (pred type-eq-decl nil defined_types nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (length def-decl "nat" list_props nil) (upfrom nonempty-type-eq-decl nil integers nil) (subrange_list? const-decl "bool" subrange_list structures) (subrange_list type-eq-decl nil subrange_list structures) (make_srl_rec def-decl "subrange_list(i, j)" subrange_list structures) (- const-decl "[numfield, numfield -> numfield]" number_fields nil)) shostak))("static_analysis" static_analysis make_srl_idx_TCC1 0 (make_srl_idx_TCC1-1 nil 3847454216 ("" (skeep) (("" (typepred "make_srl(0, n)") (("" (rewrite "every_iff_member[number]") (("" (grind) nil nil)) nil)) nil)) nil) ((nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (make_srl const-decl "subrange_list(i, j)" subrange_list structures) (subrange_list type-eq-decl nil subrange_list structures) (subrange_list? const-decl "bool" subrange_list structures) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (/= const-decl "boolean" notequal nil) (no_repetitions? const-decl "bool" more_list_props structures) (every_iff_member formula-decl nil static_analysis nil)) nil (make_srl_idx subtype "static_analysis.j" "{a: numbers.number | list_props[numbers.number].member(a, subrange_list.make_srl(0, static_analysis.n))}")))("static_analysis" static_analysis make_srl_idx 0 (make_srl_idx-1 nil 3847454221 ("" (skolem 1 ("n" "_")) (("" (case "FORALL (k : upto(n), j: nat) : (n-k) <= j <= n IMPLIES idx(make_srl(n-k, n), j) = j-(n-k)") (("1" (skeep) (("1" (inst -1 "n" j) (("1" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (induct "k") (("1" (skeep) (("1" (assert) (("1" (expand "make_srl") (("1" (expand "make_srl_rec") (("1" (case-replace "j=n") (("1" (assert) (("1" (expand "idx") (("1" (propax) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 "i") (("2" (flatten) (("2" (skeep) (("2" (expand "make_srl") (("2" (expand "make_srl_rec" +) (("2" (assert) (("2" (expand "idx" +) (("2" (lift-if) (("2" (assert) (("2" (inst -2 j) (("2" (assert) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (typepred "make_srl(n-k, n)") (("3" (expand "subrange_list?") (("3" (flatten) (("3" (inst -2 j) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (typepred "make_srl(n-k, n)") (("3" (expand "subrange_list?") (("3" (flatten) (("3" (inst -2 j) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((make_srl const-decl "subrange_list(i, j)" subrange_list structures) (subrange_list type-eq-decl nil subrange_list structures) (subrange_list? const-decl "bool" subrange_list structures) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (idx def-decl "{i: below(length(l)) | nth(l, i) = a}" more_list_props structures) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (member def-decl "bool" list_props nil) (list type-decl nil list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (n skolem-const-decl "nat" static_analysis nil) (pred type-eq-decl nil defined_types nil) (upto_induction formula-decl nil bounded_nat_inductions nil) (make_srl_rec def-decl "subrange_list(i, j)" subrange_list structures) (int_plus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil)) shostak))("static_analysis" static_analysis IMP_c_topological_sort_TCC1 0 (IMP_c_topological_sort_TCC1-1 nil 3847517706 ("" (existence-tcc) nil nil) nil nil (IMP_c_topological_sort existence "" "V_N[V_N_b]")))("static_analysis" static_analysis strong_WF_path 0 (strong_WF_path-1 nil 3847451834 ("" (skeep*) (("" (expand "strong_WF") (("" (inst -1 "A") (("" (case "member(B, sub_nT(P_exp(A), P_0c?(P_exp)))") (("1" (hide -3) (("1" (name-replace "G" "P_exp(A)") (("1" (case "subterm(G, P_exp(A))") (("1" (generalize "G" "G") (("1" (induct "G") (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (skolem 1 ("e1" "e2")) (("6" (flatten) (("6" (use "subterm_seq[V_T, <=, V_N_b]") (("6" (expand "sub_nT" -5) (("6" (expand "g_wf" -6) (("6" (flatten) (("6" (assert) (("6" (flatten) (("6" (lift-if) (("6" (typepred "union_sl(sub_nT(e1, P_0c?(P_exp)), sub_nT(e2, P_0c?(P_exp)))") (("6" (hide -1) (("6" (inst -1 B) (("6" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (skolem 1 ("e1" "e2")) (("7" (flatten) (("7" (use "subterm_prior[V_T, <=, V_N_b]") (("7" (expand "sub_nT" -5) (("7" (expand "g_wf" -6) (("7" (flatten) (("7" (assert) (("7" (flatten) (("7" (typepred "union_sl(sub_nT(e1, P_0c?(P_exp)), sub_nT(e2, P_0c?(P_exp)))") (("7" (hide -1) (("7" (inst -1 B) (("7" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("8" (skolem 1 ("e")) (("8" (flatten) (("8" (use "subterm_star[V_T, <=, V_N_b]") (("8" (grind) nil nil)) nil)) nil)) nil) ("9" (skolem 1 ("e")) (("9" (flatten) (("9" (use "subterm_plus[V_T, <=, V_N_b]") (("9" (grind) nil nil)) nil)) nil)) nil) ("10" (skolem 1 ("e")) (("10" (flatten) (("10" (use "subterm_opt[V_T, <=, V_N_b]") (("10" (grind) nil nil)) nil)) nil)) nil) ("11" (skolem 1 ("e")) (("11" (flatten) (("11" (use "subterm_notP[V_T, <=, V_N_b]") (("11" (grind) nil nil)) nil)) nil)) nil) ("12" (skolem 1 ("e")) (("12" (flatten) (("12" (use "subterm_andP[V_T, <=, V_N_b]") (("12" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind :exclude "subterm") (("2" (expand "G") (("2" (expand "subterm") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (expand "restrict") (("2" (expand "edges") (("2" (flatten) (("2" (expand "dependency_graph" -3) (("2" (expand "nodes" -3 1) (("2" (lemma "interval_list_idx") (("2" (inst -1 "0" "V_N_b - 1" "B") (("2" (assert) (("2" (replace -1 * LR) (("2" (expand "nodes" -4 2) (("2" (lemma "interval_list_idx") (("2" (inst -1 0 "V_N_b-1" "A") (("2" (assert) (("2" (replace -1 * LR) (("2" (case-replace "nth(map(adjacents(P_exp))(nodes(P_exp)), A) = adjacents(P_exp)(nth(nodes(P_exp),A))") (("1" (expand "adjacents") (("1" (expand "nodes") (("1" (rewrite "interval_list_nth") nil nil)) nil)) nil) ("2" (hide - 2) (("2" (lemma "map_nth_rw[V_N, {l : list[V_N] | no_repetitions?(l)}]") (("2" (inst -1 "adjacents(P_exp)" "nodes(P_exp)" "A") nil nil)) nil)) nil) ("3" (typepred "A") (("3" (expand "nodes") (("3" (rewrite "interval_list_length") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((strong_WF const-decl "bool" wf_peg nil) (P_0c? const-decl "[Δ -> bool]" wf_peg nil) (interp type-eq-decl nil wf_peg nil) (sub_nT def-decl "(no_repetitions?[V_N])" static_analysis nil) (no_repetitions? const-decl "bool" more_list_props structures) (peg type-decl nil peg nil) (<= formal-const-decl "(total_order?[V_T])" static_analysis nil) (total_order? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (V_T formal-nonempty-type-decl nil static_analysis nil) (member def-decl "bool" list_props nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (G skolem-const-decl "peg[V_T, <=, V_N_b]" static_analysis nil) (strong const-decl "bool" wf_peg nil) (g_wf def-decl "bool" wf_peg nil) (order type-eq-decl nil wf_peg nil) (bijective? const-decl "bool" functions nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (subterm_andP formula-decl nil peg nil) (subterm_notP formula-decl nil peg nil) (subterm_opt formula-decl nil peg nil) (subterm_plus formula-decl nil peg nil) (subterm_star formula-decl nil peg nil) (subterm_prior formula-decl nil peg nil) (subterm_seq formula-decl nil peg nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nT_properties const-decl "F(P_exp)" wf_peg nil) (array_sum const-decl "upto(3 * V_N_b)" array_sum nil) (r const-decl "C(P_exp)" wf_peg nil) (union_sl def-decl "{ll: list[T] | FORALL x: member(x, ll) IFF (member(x, l1) OR member(x, l2))}" set_as_list structures) (OR const-decl "[bool, bool -> bool]" booleans nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (below type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (peg_induction formula-decl nil peg nil) (subterm adt-def-decl "boolean" peg nil) (restrict const-decl "R" restrict nil) (nodes const-decl "list[V_N]" static_analysis nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (map adt-def-decl "list[T1]" list_adt_map nil) (adjacents const-decl "{l: list[V_N] | no_repetitions?(l)}" static_analysis nil) (interval_list_nth formula-decl nil interval_list nil) (map_nth_rw formula-decl nil more_map_props nil) (interval_list_length formula-decl nil interval_list nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (interval_list_idx formula-decl nil interval_list nil) (dependency_graph const-decl "c_digraph[nat]" static_analysis nil) (edges const-decl "bool" c_digraphs_def digraphs) (V_N type-eq-decl nil nTpred_order nil) (V_N_b formal-const-decl "posnat" static_analysis nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak))("static_analysis" static_analysis IMP_c_topological_sort_TCC1 0 (IMP_c_topological_sort_TCC1-1 nil 3847523273 ("" (existence-tcc) nil nil) nil nil (IMP_c_topological_sort existence "" "V_N[V_N_b]")))("static_analysis" static_analysis V_N_subtype_nat 0 (V_N_subtype_nat-1 nil 3847461585 ("" (judgement-tcc) nil nil) nil nil (V_N_subtype_nat_ subtype "nTpred_order[static_analysis.V_N_b].V_N" "naturalnumbers.nat")))("static_analysis" static_analysis V_N_subtype_int 0 (V_N_subtype_int-1 nil 3847470924 ("" (judgement-tcc) nil nil) nil nil (V_N_subtype_int_ subtype "nTpred_order[static_analysis.V_N_b].V_N" "integers.int")))("delta" wf_peg structural_wf_TCC1 0 (structural_wf_TCC1-1 nil 3847691722 ("" (termination-tcc) nil nil) nil nil (structural_wf termination "wf_peg.structural_wf(wf_peg.e2, wf_peg.P_0)" "nil")))("delta" wf_peg structural_wf_TCC2 0 (structural_wf_TCC2-1 nil 3847691722 ("" (termination-tcc) nil nil) nil nil (structural_wf termination "wf_peg.structural_wf(wf_peg.e2, wf_peg.P_0)" "nil")))("delta" wf_peg pattern_wf_TCC1 0 (pattern_wf_TCC1-1 nil 3847691722 ("" (termination-tcc) nil nil) nil nil (pattern_wf termination "wf_peg.pattern_wf(wf_peg.e2, wf_peg.A, wf_peg.σ, wf_peg.P_0)" "nil")))("delta" wf_peg pattern_wf_TCC2 0 (pattern_wf_TCC2-1 nil 3847691722 ("" (termination-tcc) nil nil) nil nil (pattern_wf termination "wf_peg.pattern_wf(wf_peg.e2, wf_peg.A, wf_peg.σ, wf_peg.P_0)" "nil")))("delta" wf_peg g_wf_TCC1 0 (g_wf_TCC1-1 nil 3784647385 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (V_N_b formal-const-decl "posnat" wf_peg nil) (V_N type-eq-decl nil nTpred_order nil) (bijective? const-decl "bool" functions nil) (order type-eq-decl nil wf_peg nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (injective? const-decl "bool" functions nil) (surjective? const-decl "bool" functions nil) (sum const-decl "nat" peg nil) (reduce_nat adt-def-decl "[peg -> nat]" peg nil) (< def-decl "bool" ordinals nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (pegMeasure const-decl "nat" peg nil) (lex2 const-decl "ordinal" lex2 nil)) nil (g_wf termination "wf_peg.g_wf(wf_peg.σ, wf_peg.e1, wf_peg.A, wf_peg.P_0, wf_peg.δ)" "nil")))("delta" wf_peg g_wf_TCC2 0 (g_wf_TCC2-1 nil 3784647385 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (V_N_b formal-const-decl "posnat" wf_peg nil) (V_N type-eq-decl nil nTpred_order nil) (bijective? const-decl "bool" functions nil) (order type-eq-decl nil wf_peg nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (injective? const-decl "bool" functions nil) (surjective? const-decl "bool" functions nil) (sum const-decl "nat" peg nil) (reduce_nat adt-def-decl "[peg -> nat]" peg nil) (< def-decl "bool" ordinals nil) (int_minus_int_is_int application-judgement "int" integers nil) (pegMeasure const-decl "nat" peg nil) (lex2 const-decl "ordinal" lex2 nil)) nil (g_wf termination "wf_peg.g_wf(wf_peg.σ, wf_peg.e2, wf_peg.A, wf_peg.P_0, booleans.∧(wf_peg.P_0(wf_peg.e1), wf_peg.δ))" "nil")))("delta" wf_peg g_wf_TCC3 0 (g_wf_TCC3-1 nil 3784647385 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (V_N_b formal-const-decl "posnat" wf_peg nil) (V_N type-eq-decl nil nTpred_order nil) (bijective? const-decl "bool" functions nil) (order type-eq-decl nil wf_peg nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (injective? const-decl "bool" functions nil) (surjective? const-decl "bool" functions nil) (sum const-decl "nat" peg nil) (reduce_nat adt-def-decl "[peg -> nat]" peg nil) (< def-decl "bool" ordinals nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (pegMeasure const-decl "nat" peg nil) (lex2 const-decl "ordinal" lex2 nil)) nil (g_wf termination "wf_peg.g_wf(wf_peg.σ, wf_peg.e1, wf_peg.A, wf_peg.P_0, wf_peg.δ)" "nil")))("delta" wf_peg g_wf_TCC4 0 (g_wf_TCC4-1 nil 3784647385 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (V_N_b formal-const-decl "posnat" wf_peg nil) (V_N type-eq-decl nil nTpred_order nil) (bijective? const-decl "bool" functions nil) (order type-eq-decl nil wf_peg nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (injective? const-decl "bool" functions nil) (surjective? const-decl "bool" functions nil) (sum const-decl "nat" peg nil) (reduce_nat adt-def-decl "[peg -> nat]" peg nil) (< def-decl "bool" ordinals nil) (int_minus_int_is_int application-judgement "int" integers nil) (pegMeasure const-decl "nat" peg nil) (lex2 const-decl "ordinal" lex2 nil)) nil (g_wf termination "wf_peg.g_wf(wf_peg.σ, wf_peg.e2, wf_peg.A, wf_peg.P_0, wf_peg.δ)" "nil")))("delta" wf_peg g_wf_TCC5 0 (g_wf_TCC5-1 nil 3784647385 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (V_N_b formal-const-decl "posnat" wf_peg nil) (V_N type-eq-decl nil nTpred_order nil) (bijective? const-decl "bool" functions nil) (order type-eq-decl nil wf_peg nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (injective? const-decl "bool" functions nil) (surjective? const-decl "bool" functions nil) (inc const-decl "nat" peg nil) (reduce_nat adt-def-decl "[peg -> nat]" peg nil) (< def-decl "bool" ordinals nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (pegMeasure const-decl "nat" peg nil) (lex2 const-decl "ordinal" lex2 nil)) nil (g_wf termination "wf_peg.g_wf(wf_peg.σ, wf_peg.e, wf_peg.A, wf_peg.P_0, wf_peg.δ)" "nil")))("delta" wf_peg g_wf_TCC6 0 (g_wf_TCC6-1 nil 3784647385 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (V_N_b formal-const-decl "posnat" wf_peg nil) (V_N type-eq-decl nil nTpred_order nil) (bijective? const-decl "bool" functions nil) (order type-eq-decl nil wf_peg nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (injective? const-decl "bool" functions nil) (surjective? const-decl "bool" functions nil) (inc const-decl "nat" peg nil) (reduce_nat adt-def-decl "[peg -> nat]" peg nil) (< def-decl "bool" ordinals nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (pegMeasure const-decl "nat" peg nil) (lex2 const-decl "ordinal" lex2 nil)) nil (g_wf termination "wf_peg.g_wf(wf_peg.σ, wf_peg.e, wf_peg.A, wf_peg.P_0, wf_peg.δ)" "nil")))("delta" wf_peg g_wf_TCC7 0 (g_wf_TCC7-1 nil 3784647385 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (V_N_b formal-const-decl "posnat" wf_peg nil) (V_N type-eq-decl nil nTpred_order nil) (bijective? const-decl "bool" functions nil) (order type-eq-decl nil wf_peg nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (injective? const-decl "bool" functions nil) (surjective? const-decl "bool" functions nil) (inc const-decl "nat" peg nil) (reduce_nat adt-def-decl "[peg -> nat]" peg nil) (< def-decl "bool" ordinals nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (pegMeasure const-decl "nat" peg nil) (lex2 const-decl "ordinal" lex2 nil)) nil (g_wf termination "wf_peg.g_wf(wf_peg.σ, wf_peg.e, wf_peg.A, wf_peg.P_0, wf_peg.δ)" "nil")))("delta" wf_peg g_wf_TCC8 0 (g_wf_TCC8-1 nil 3784647385 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (V_N_b formal-const-decl "posnat" wf_peg nil) (V_N type-eq-decl nil nTpred_order nil) (bijective? const-decl "bool" functions nil) (order type-eq-decl nil wf_peg nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (injective? const-decl "bool" functions nil) (surjective? const-decl "bool" functions nil) (inc const-decl "nat" peg nil) (reduce_nat adt-def-decl "[peg -> nat]" peg nil) (< def-decl "bool" ordinals nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (pegMeasure const-decl "nat" peg nil) (lex2 const-decl "ordinal" lex2 nil)) nil (g_wf termination "wf_peg.g_wf(wf_peg.σ, wf_peg.e, wf_peg.A, wf_peg.P_0, wf_peg.δ)" "nil")))("delta" wf_peg g_wf_TCC9 0 (g_wf_TCC9-1 nil 3784647385 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (V_N_b formal-const-decl "posnat" wf_peg nil) (V_N type-eq-decl nil nTpred_order nil) (bijective? const-decl "bool" functions nil) (order type-eq-decl nil wf_peg nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (injective? const-decl "bool" functions nil) (surjective? const-decl "bool" functions nil) (inc const-decl "nat" peg nil) (reduce_nat adt-def-decl "[peg -> nat]" peg nil) (< def-decl "bool" ordinals nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (pegMeasure const-decl "nat" peg nil) (lex2 const-decl "ordinal" lex2 nil)) nil (g_wf termination "wf_peg.g_wf(wf_peg.σ, wf_peg.e, wf_peg.A, wf_peg.P_0, wf_peg.δ)" "nil")))("delta" wf_peg complete_WF_no_order 0 (complete_WF_no_order-1 nil 3847607482 ("" (skeep) (("" (expand "complete_WF") (("" (expand "complete") (("" (iff 1) (("" (case "FORALL A, G: g_wf(σ, G, A, P_0c?(P_exp), FALSE) = g_wf(σ_p, G, A, P_0c?(P_exp), FALSE)") (("1" (grind) nil nil) ("2" (hide 2) (("2" (skolem 1 ("A" "_")) (("2" (induct "G") (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (grind) nil nil) ("7" (grind) nil nil) ("8" (grind) nil nil) ("9" (grind) nil nil) ("10" (grind) nil nil) ("11" (grind) nil nil) ("12" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((complete_WF const-decl "bool" wf_peg nil) (peg_induction formula-decl nil peg nil) (nT_properties const-decl "F(P_exp)" wf_peg nil) (array_sum const-decl "upto(3 * V_N_b)" array_sum nil) (r const-decl "C(P_exp)" wf_peg nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (V_N_b formal-const-decl "posnat" wf_peg nil) (V_N type-eq-decl nil nTpred_order nil) (V_T formal-nonempty-type-decl nil wf_peg nil) (pred type-eq-decl nil defined_types nil) (total_order? const-decl "bool" orders nil) (<= formal-const-decl "(total_order?[V_T])" wf_peg nil) (peg type-decl nil peg nil) (Δ type-eq-decl nil wf_peg nil) (= const-decl "[T, T -> boolean]" equalities nil) (bijective? const-decl "bool" functions nil) (order type-eq-decl nil wf_peg nil) (g_wf def-decl "bool" wf_peg nil) (interp type-eq-decl nil wf_peg nil) (P_0c? const-decl "[Δ -> bool]" wf_peg nil) (FALSE const-decl "bool" booleans nil) (complete const-decl "bool" wf_peg nil)) shostak))("delta" wf_peg sanity_check 0 (sanity_check-1 nil 3847691724 ("" (skolem 1 ("σ" "P_exp" "A" "P_0" "_" "_")) (("" (induct G) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (skolem 1 ("e1" "e2")) (("6" (ground) (("6" (skolem 1 d) (("6" (expand "g_wf" +) (("6" (expand "structural_wf" +) (("6" (expand "pattern_wf" +) (("6" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (skolem 1 ("e1" "e2")) (("7" (flatten) (("7" (skolem 1 d) (("7" (expand "g_wf" +) (("7" (expand "structural_wf" +) (("7" (expand "pattern_wf" +) (("7" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("8" (skolem 1 "e") (("8" (flatten) (("8" (skolem 1 d) (("8" (expand "g_wf" +) (("8" (expand "structural_wf" +) (("8" (expand "pattern_wf" +) (("8" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("9" (skolem 1 "e") (("9" (flatten) (("9" (skolem 1 d) (("9" (expand "g_wf" +) (("9" (expand "structural_wf" +) (("9" (expand "pattern_wf" +) (("9" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("10" (skolem 1 "e") (("10" (flatten) (("10" (skolem 1 d) (("10" (expand "g_wf" +) (("10" (expand "structural_wf" +) (("10" (expand "pattern_wf" +) (("10" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("11" (skolem 1 "e") (("11" (flatten) (("11" (skolem 1 d) (("11" (expand "g_wf" +) (("11" (expand "structural_wf" +) (("11" (expand "pattern_wf" +) (("11" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("12" (skolem 1 "e") (("12" (flatten) (("12" (skolem 1 d) (("12" (expand "g_wf" +) (("12" (expand "structural_wf" +) (("12" (expand "pattern_wf" +) (("12" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((peg type-decl nil peg nil) (Δ type-eq-decl nil wf_peg nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (V_N type-eq-decl nil nTpred_order nil) (bijective? const-decl "bool" functions nil) (order type-eq-decl nil wf_peg nil) (g_wf def-decl "bool" wf_peg nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (structural_wf def-decl "bool" wf_peg nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (pattern_wf def-decl "bool" wf_peg nil) (V_N_b formal-const-decl "posnat" wf_peg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (<= formal-const-decl "(total_order?[V_T])" wf_peg nil) (total_order? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (V_T formal-nonempty-type-decl nil wf_peg nil) (peg_induction formula-decl nil peg nil) (FALSE const-decl "bool" booleans nil) (TRUE const-decl "bool" booleans nil)) shostak))("delta" wf_peg strong_is_complete_WF 0 (strong_is_complete_WF-1 nil 3771171785 ("" (skeep) (("" (expand "complete_WF") (("" (expand "strong_WF") (("" (skeep) (("" (inst -1 "A") (("" (case "FORALL G : g_wf(σ, G, A, P_0c?(P_exp), strong) IMPLIES g_wf(σ, G, A, P_0c?(P_exp), complete)") (("1" (inst -1 "P_exp(A)") (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (hide -1) (("2" (induct "G") (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (skeep) (("6" (expand "g_wf" -3) (("6" (grind) nil nil)) nil)) nil) ("7" (grind) nil nil) ("8" (grind) nil nil) ("9" (grind) nil nil) ("10" (grind) nil nil) ("11" (grind) nil nil) ("12" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((complete_WF const-decl "bool" wf_peg nil) (complete const-decl "bool" wf_peg nil) (strong const-decl "bool" wf_peg nil) (P_0c? const-decl "[Δ -> bool]" wf_peg nil) (interp type-eq-decl nil wf_peg nil) (g_wf def-decl "bool" wf_peg nil) (order type-eq-decl nil wf_peg nil) (bijective? const-decl "bool" functions nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Δ type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil) (<= formal-const-decl "(total_order?[V_T])" wf_peg nil) (total_order? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (V_T formal-nonempty-type-decl nil wf_peg nil) (nT_properties const-decl "F(P_exp)" wf_peg nil) (array_sum const-decl "upto(3 * V_N_b)" array_sum nil) (r const-decl "C(P_exp)" wf_peg nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (peg_induction formula-decl nil peg nil) (V_N type-eq-decl nil nTpred_order nil) (V_N_b formal-const-decl "posnat" wf_peg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (strong_WF const-decl "bool" wf_peg nil)) shostak))("delta" wf_peg complete_WF_theorem 0 (complete_WF_theorem-1 nil 3771183719 ("" (skeep) (("" (case "FORALL (j :nat) : FORALL (i : upto(j), G' : Δ) : (subterm(G,G') AND (pegMeasure(G') = pegMeasure(G) +i)) IMPLIES ((NOT g_wf(σ, G, A, P_0c?(P_exp), complete)) IMPLIES (NOT g_wf(σ, G', A, P_0c?(P_exp), complete)))") (("1" (inst -1 "pegMeasure(P_exp(A)) - pegMeasure(G)") (("1" (inst -1 "pegMeasure(P_exp(A)) - pegMeasure(G)" " P_exp(A)") (("1" (assert) (("1" (typepred "P_exp") (("1" (use "strong_is_complete_WF") (("1" (expand "complete_WF") (("1" (inst -1 "A") (("1" (use "peg[V_T, <=, V_N_b].subterm_lq") (("1" (assert) (("1" (use "peg[V_T, <=,  V_N_b].subterm_lq") (("1" (assert) (("1" (expand "complete") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "peg[V_T, <=,  V_N_b].subterm_lq") (("2" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (use "peg[V_T, <=, V_N_b].subterm_lq") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "complete") (("2" (hide 2) (("2" (induct "j") (("1" (skeep) (("1" (case-replace "i=0") (("1" (use "peg[V_T, <=, V_N_b].subterm_eq") (("1" (grind) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (skolem 1 "i") (("2" (flatten) (("2" (skolem 1 ("k" "_")) (("2" (induct "G'") (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (skeep) (("6" (expand "subterm" -3) (("6" (split -3) (("1" (replace -1 * LR) (("1" (propax) nil nil)) nil) ("2" (inst -6 "pegMeasure(seq1_var) - pegMeasure(G)" "seq1_var") (("1" (assert) (("1" (expand "g_wf" -5) (("1" (propax) nil nil)) nil)) nil) ("2" (use "peg[V_T, <=, V_N_b].subterm_lq") (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (expand "g_wf" -5) (("3" (flatten) (("3" (use "peg[V_T, <=, V_N_b].subterm_lq") (("3" (inst - "pegMeasure(seq2_var) - pegMeasure(G)" "seq2_var") (("1" (grind) nil nil) ("2" (use "peg[V_T, <=, V_N_b].subterm_lq") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (skeep) (("7" (copy -5) (("7" (expand "g_wf" -1) (("7" (flatten) (("7" (expand "subterm" -5) (("7" (split -5) (("1" (replace -1 * LR) (("1" (propax) nil nil)) nil) ("2" (assert) (("2" (inst -6 "pegMeasure(prior1_var) - pegMeasure(G)" "prior1_var") (("1" (grind) nil nil) ("2" (use "peg[V_T, <=, V_N_b].subterm_lq") (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (assert) (("3" (inst -6 "pegMeasure(prior2_var) - pegMeasure(G)" "prior2_var") (("1" (grind) nil nil) ("2" (use "peg[V_T, <=, V_N_b].subterm_lq") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("8" (skeep) (("8" (copy -4) (("8" (expand "g_wf" -1) (("8" (expand "subterm" -3) (("8" (split -3) (("1" (grind) nil nil) ("2" (inst -6 "pegMeasure(star1_var) - pegMeasure(G)" "star1_var") (("1" (grind) nil nil) ("2" (use "peg[V_T, <=, V_N_b].subterm_lq") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("9" (skeep) (("9" (copy -4) (("9" (expand "g_wf" -1) (("9" (expand "subterm" -3) (("9" (split -3) (("1" (grind) nil nil) ("2" (inst -6 "pegMeasure(plus1_var) - pegMeasure(G)" "plus1_var") (("1" (grind) nil nil) ("2" (use "peg[V_T, <=, V_N_b].subterm_lq") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("10" (skeep) (("10" (copy -4) (("10" (expand "g_wf" -1) (("10" (expand "subterm" -3) (("10" (split -3) (("1" (grind) nil nil) ("2" (inst -6 "pegMeasure(opt1_var) - pegMeasure(G)" "opt1_var") (("1" (grind) nil nil) ("2" (use "peg[V_T, <=, V_N_b].subterm_lq") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("11" (skeep) (("11" (copy -4) (("11" (expand "g_wf" -1) (("11" (expand "subterm" -3) (("11" (split -3) (("1" (grind) nil nil) ("2" (inst -6 "pegMeasure(notP1_var) - pegMeasure(G)" "notP1_var") (("1" (grind) nil nil) ("2" (use "peg[V_T, <=, V_N_b].subterm_lq") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("12" (skeep) (("12" (copy -4) (("12" (expand "g_wf" -1) (("12" (expand "subterm" -3) (("12" (split -3) (("1" (grind) nil nil) ("2" (inst -6 "pegMeasure(andP1_var) - pegMeasure(G)" "andP1_var") (("1" (grind) nil nil) ("2" (use "peg[V_T, <=, V_N_b].subterm_lq") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((complete const-decl "bool" wf_peg nil) (WF_nT type-eq-decl nil wf_peg nil) (strong_WF const-decl "bool" wf_peg nil) (P_0c? const-decl "[Δ -> bool]" wf_peg nil) (interp type-eq-decl nil wf_peg nil) (g_wf def-decl "bool" wf_peg nil) (order type-eq-decl nil wf_peg nil) (bijective? const-decl "bool" functions nil) (V_N type-eq-decl nil nTpred_order nil) (< const-decl "bool" reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (pegMeasure const-decl "nat" peg nil) (= const-decl "[T, T -> boolean]" equalities nil) (subterm adt-def-decl "boolean" peg nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Δ type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil) (V_N_b formal-const-decl "posnat" wf_peg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (<= formal-const-decl "(total_order?[V_T])" wf_peg nil) (total_order? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (V_T formal-nonempty-type-decl nil wf_peg nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (complete_WF const-decl "bool" wf_peg nil) (subterm_lq formula-decl nil peg nil) (strong_is_complete_WF formula-decl nil wf_peg nil) (int_plus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (r const-decl "C(P_exp)" wf_peg nil) (array_sum const-decl "upto(3 * V_N_b)" array_sum nil) (nT_properties const-decl "F(P_exp)" wf_peg nil) (inc const-decl "nat" peg nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (sum const-decl "nat" peg nil) (below type-eq-decl nil naturalnumbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (reduce_nat adt-def-decl "[peg -> nat]" peg nil) (peg_induction formula-decl nil peg nil) (subterm_eq formula-decl nil peg nil) (nat_induction formula-decl nil naturalnumbers nil) (FALSE const-decl "bool" booleans nil)) shostak))("delta" wf_peg complete_WF_theorem2 0 (complete_WF_theorem2-1 nil 3813664218 ("" (skeep) (("" (skeep) (("" (case "FORALL (j :nat) : FORALL (i : upto(j), G' : Δ) : (subterm(G,G') AND (pegMeasure(G') = pegMeasure(G) +i)) IMPLIES ((NOT g_wf(σ, G, A, P_0c?(P_exp), complete)) IMPLIES (NOT g_wf(σ, G', A, P_0c?(P_exp), complete)))") (("1" (inst -1 "pegMeasure(P_exp(A)) - pegMeasure(G)") (("1" (inst -1 "pegMeasure(P_exp(A)) - pegMeasure(G)" " P_exp(A)") (("1" (grind) nil nil) ("2" (use "peg[V_T, <=,  V_N_b].subterm_lq") (("2" (assert) nil nil)) nil)) nil) ("2" (use "peg[V_T, <=, V_N_b].subterm_lq") (("2" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (induct "j") (("1" (skeep) (("1" (typepred "i") (("1" (assert) (("1" (case-replace "i=0") (("1" (expand "complete") (("1" (use "peg[V_T, <=, V_N_b].subterm_eq") (("1" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 "i") (("2" (flatten) (("2" (skolem 1 ("k" "_")) (("2" (induct "G'") (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (skolem 1 ("e1" "e2")) (("6" (assert) (("6" (flatten) (("6" (expand "subterm" -3) (("6" (split -3) (("1" (assert) nil nil) ("2" (expand "complete") (("2" (inst -6 "pegMeasure(e1) - pegMeasure(G)" "e1") (("1" (assert) (("1" (expand "g_wf" -5) (("1" (propax) nil nil)) nil)) nil) ("2" (use "peg[V_T, <=, V_N_b].subterm_lq") (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("3" (expand "g_wf" -5) (("3" (use "peg[V_T, <=, V_N_b].subterm_lq") (("3" (inst -7 "pegMeasure(e2) - pegMeasure(G)" "e2") (("1" (grind) nil nil) ("2" (use "peg[V_T, <=, V_N_b].subterm_lq") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (skeep) (("7" (copy -5) (("7" (expand "g_wf" -1) (("7" (flatten) (("7" (expand "subterm" -5) (("7" (split -5) (("1" (assert) nil nil) ("2" (assert) (("2" (inst -6 "pegMeasure(prior1_var) - pegMeasure(G)" "prior1_var") (("1" (grind) nil nil) ("2" (use "peg[V_T, <=, V_N_b].subterm_lq") (("2" (expand "complete") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("3" (assert) (("3" (inst -6 "pegMeasure(prior2_var) - pegMeasure(G)" "prior2_var") (("1" (grind) nil nil) ("2" (use "peg[V_T, <=, V_N_b].subterm_lq") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("8" (skeep) (("8" (copy -4) (("8" (expand "g_wf" -1) (("8" (expand "subterm" -3) (("8" (split -3) (("1" (grind) nil nil) ("2" (inst -6 "pegMeasure(star1_var) - pegMeasure(G)" "star1_var") (("1" (grind) nil nil) ("2" (use "peg[V_T, <=, V_N_b].subterm_lq") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("9" (skeep) (("9" (copy -4) (("9" (expand "g_wf" -1) (("9" (expand "subterm" -3) (("9" (split -3) (("1" (grind) nil nil) ("2" (inst -6 "pegMeasure(plus1_var) - pegMeasure(G)" "plus1_var") (("1" (grind) nil nil) ("2" (use "peg[V_T, <=, V_N_b].subterm_lq") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("10" (skeep) (("10" (copy -4) (("10" (expand "g_wf" -1) (("10" (expand "subterm" -3) (("10" (split -3) (("1" (grind) nil nil) ("2" (inst -6 "pegMeasure(opt1_var) - pegMeasure(G)" "opt1_var") (("1" (grind) nil nil) ("2" (use "peg[V_T, <=, V_N_b].subterm_lq") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("11" (skeep) (("11" (copy -4) (("11" (expand "g_wf" -1) (("11" (expand "subterm" -3) (("11" (split -3) (("1" (grind) nil nil) ("2" (inst -6 "pegMeasure(notP1_var) - pegMeasure(G)" "notP1_var") (("1" (grind) nil nil) ("2" (use "peg[V_T, <=, V_N_b].subterm_lq") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("12" (skeep) (("12" (copy -4) (("12" (expand "g_wf" -1) (("12" (expand "subterm" -3) (("12" (split -3) (("1" (grind) nil nil) ("2" (inst -6 "pegMeasure(andP1_var) - pegMeasure(G)" "andP1_var") (("1" (grind) nil nil) ("2" (use "peg[V_T, <=, V_N_b].subterm_lq") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((inc const-decl "nat" peg nil) (sum const-decl "nat" peg nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nT_properties const-decl "F(P_exp)" wf_peg nil) (array_sum const-decl "upto(3 * V_N_b)" array_sum nil) (r const-decl "C(P_exp)" wf_peg nil) (below type-eq-decl nil naturalnumbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (reduce_nat adt-def-decl "[peg -> nat]" peg nil) (peg_induction formula-decl nil peg nil) (subterm_eq formula-decl nil peg nil) (nat_induction formula-decl nil naturalnumbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (subterm_lq formula-decl nil peg nil) (complete_WF const-decl "bool" wf_peg nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (V_T formal-nonempty-type-decl nil wf_peg nil) (pred type-eq-decl nil defined_types nil) (total_order? const-decl "bool" orders nil) (<= formal-const-decl "(total_order?[V_T])" wf_peg nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (V_N_b formal-const-decl "posnat" wf_peg nil) (peg type-decl nil peg nil) (Δ type-eq-decl nil wf_peg nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (subterm adt-def-decl "boolean" peg nil) (= const-decl "[T, T -> boolean]" equalities nil) (pegMeasure const-decl "nat" peg nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (NOT const-decl "[bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (V_N type-eq-decl nil nTpred_order nil) (bijective? const-decl "bool" functions nil) (order type-eq-decl nil wf_peg nil) (g_wf def-decl "bool" wf_peg nil) (interp type-eq-decl nil wf_peg nil) (P_0c? const-decl "[Δ -> bool]" wf_peg nil) (complete const-decl "bool" wf_peg nil)) shostak))("delta" wf_peg Star_cannot_be_P0_TCC1 0 (Star_cannot_be_P0_TCC1-1 nil 3770412224 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (V_N_b formal-const-decl "posnat" wf_peg nil) (V_N type-eq-decl nil nTpred_order nil) (bijective? const-decl "bool" functions nil) (order type-eq-decl nil wf_peg nil) (V_T formal-nonempty-type-decl nil wf_peg nil) (pred type-eq-decl nil defined_types nil) (total_order? const-decl "bool" orders nil) (<= formal-const-decl "(total_order?[V_T])" wf_peg nil) (peg type-decl nil peg nil) (Δ type-eq-decl nil wf_peg nil) (interp type-eq-decl nil wf_peg nil) (strong_WF const-decl "bool" wf_peg nil) (WF_nT type-eq-decl nil wf_peg nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (Star_cannot_be_P0 subtype "wf_peg.G" "{x: peg[wf_peg.V_T, wf_peg.<=, wf_peg.V_N_b].peg |      peg[wf_peg.V_T, wf_peg.<=, wf_peg.V_N_b].star?(x) OR peg[wf_peg.V_T, wf_peg.<=, wf_peg.V_N_b].plus?(x) OR peg[wf_peg.V_T, wf_peg.<=, wf_peg.V_N_b].opt?(x) OR peg[wf_peg.V_T, wf_peg.<=, wf_peg.V_N_b].notP?(x) OR peg[wf_peg.V_T, wf_peg.<=, wf_peg.V_N_b].andP?(x)}")))("delta" wf_peg Star_cannot_be_P0 0 (Star_cannot_be_P0-1 nil 3770493280 ("" (skeep) (("" (typepred "P_exp") (("" (use "strong_is_complete_WF") (("" (use "complete_WF_theorem") (("" (grind) nil nil)) nil)) nil)) nil)) nil) (nil nil (interp type-eq-decl nil wf_peg nil) (Δ type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil) (<= formal-const-decl "(total_order?[V_T])" wf_peg nil) (total_order? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (V_T formal-nonempty-type-decl nil wf_peg nil) (order type-eq-decl nil wf_peg nil) (bijective? const-decl "bool" functions nil) (V_N type-eq-decl nil nTpred_order nil) (V_N_b formal-const-decl "posnat" wf_peg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) nil (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (subterm adt-def-decl "boolean" peg nil) (strong const-decl "bool" wf_peg nil) (complete const-decl "bool" wf_peg nil) nil (r const-decl "C(P_exp)" wf_peg nil) (array_sum const-decl "upto(3 * V_N_b)" array_sum nil) (nT_properties const-decl "F(P_exp)" wf_peg nil) nil nil (int_minus_int_is_int application-judgement "int" integers nil) nil) shostak))("delta" wf_peg star_cannot_be_P0 0 (star_cannot_be_P0-1 nil 3847711612 ("" (skeep) (("" (typepred "P_exp") (("" (expand "wf_nT?") (("" (flatten) (("" (lemma "wf_nT_subterm") (("" (inst -2 "A") (("" (inst -1 "P_exp(A)" "star(e)" "P_0c(P_exp)") (("" (assert) (("" (expand "structural_wf?") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((wf_nT type-eq-decl nil wf_peg nil) (wf_nT? const-decl "bool" wf_peg nil) (interp type-eq-decl nil wf_peg nil) (Δ type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil) (<= formal-const-decl "(total_order?[V_T])" wf_peg nil) (total_order? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (V_T formal-nonempty-type-decl nil wf_peg nil) (V_N type-eq-decl nil nTpred_order nil) (V_N_b formal-const-decl "posnat" wf_peg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (structural_wf? def-decl "bool" wf_peg nil) (P_0c const-decl "[Δ -> bool]" wf_peg nil) (star adt-constructor-decl "[peg -> (star?)]" peg nil) (star? adt-recognizer-decl "[peg -> boolean]" peg nil) (wf_nT_subterm formula-decl nil wf_peg nil)) shostak))("static_analysis" static_analysis σ_id_TCC1 0 (σ_id_TCC1-1 nil 3847609484 ("" (subtype-tcc) nil nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (V_N type-eq-decl nil nTpred_order nil) (V_N_b formal-const-decl "posnat" static_analysis nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (injective? const-decl "bool" functions nil) (surjective? const-decl "bool" functions nil) (bijective? const-decl "bool" functions nil)) nil (σ_id subtype "LAMBDA (A: nTpred_order[static_analysis.V_N_b].V_N): A" "order[V_T, <=, V_N_b]")))("static_analysis" static_analysis IMP_c_topological_sort_TCC1 0 (IMP_c_topological_sort_TCC1-1 nil 3847609484 ("" (inst 1 0) (("" (assert) nil nil)) nil) ((V_N type-eq-decl nil nTpred_order nil) (V_N_b formal-const-decl "posnat" static_analysis nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (IMP_c_topological_sort existence "" "V_N[V_N_b]")))("static_analysis" static_analysis strong_WF_edge 0 (strong_WF_edge-1 nil 3847520131 ("" (skeep*) (("" (expand "restrict") (("" (expand "strong_WF") (("" (inst -1 "A") (("" (case "member(B, sub_nT(P_exp(A), P_0c?(P_exp)))") (("1" (hide -3) (("1" (name-replace "G" "P_exp(A)") (("1" (case "subterm(G, P_exp(A))") (("1" (generalize "G" "G") (("1" (induct "G") (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (skolem 1 ("e1" "e2")) (("6" (flatten) (("6" (use "subterm_seq[V_T, <=, V_N_b]") (("6" (expand "sub_nT" -5) (("6" (expand "g_wf" -6) (("6" (flatten) (("6" (assert) (("6" (flatten) (("6" (lift-if) (("6" (typepred "union_sl(sub_nT(e1, P_0c?(P_exp)), sub_nT(e2, P_0c?(P_exp)))") (("6" (hide -1) (("6" (inst -1 B) (("6" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (skolem 1 ("e1" "e2")) (("7" (flatten) (("7" (use "subterm_prior[V_T, <=, V_N_b]") (("7" (expand "sub_nT" -5) (("7" (expand "g_wf" -6) (("7" (flatten) (("7" (assert) (("7" (flatten) (("7" (typepred "union_sl(sub_nT(e1, P_0c?(P_exp)), sub_nT(e2, P_0c?(P_exp)))") (("7" (hide -1) (("7" (inst -1 B) (("7" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("8" (skolem 1 ("e")) (("8" (flatten) (("8" (use "subterm_star[V_T, <=, V_N_b]") (("8" (grind) nil nil)) nil)) nil)) nil) ("9" (skolem 1 ("e")) (("9" (flatten) (("9" (use "subterm_plus[V_T, <=, V_N_b]") (("9" (grind) nil nil)) nil)) nil)) nil) ("10" (skolem 1 ("e")) (("10" (flatten) (("10" (use "subterm_opt[V_T, <=, V_N_b]") (("10" (grind) nil nil)) nil)) nil)) nil) ("11" (skolem 1 ("e")) (("11" (flatten) (("11" (use "subterm_notP[V_T, <=, V_N_b]") (("11" (grind) nil nil)) nil)) nil)) nil) ("12" (skolem 1 ("e")) (("12" (flatten) (("12" (use "subterm_andP[V_T, <=, V_N_b]") (("12" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind :exclude "subterm") (("2" (expand "G") (("2" (expand "subterm") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (expand "edges") (("2" (flatten) (("2" (expand "dependency_graph" -3) (("2" (expand "nodes" -3 1) (("2" (lemma "interval_list_idx") (("2" (inst -1 "0" "V_N_b - 1" "B") (("2" (assert) (("2" (replace -1 * LR) (("2" (expand "nodes" -4 2) (("2" (lemma "interval_list_idx") (("2" (inst -1 0 "V_N_b-1" "A") (("2" (assert) (("2" (replace -1 * LR) (("2" (case-replace "nth(map(adjacents(P_exp))(nodes(P_exp)), A) = adjacents(P_exp)(nth(nodes(P_exp),A))") (("1" (expand "adjacents") (("1" (assert) (("1" (expand "nodes") (("1" (rewrite "interval_list_nth") nil nil)) nil)) nil)) nil) ("2" (hide - 2) (("2" (lemma "map_nth_rw[V_N, node_ls]") (("2" (inst -1 "adjacents(P_exp)" "nodes(P_exp)" "A") nil nil)) nil)) nil) ("3" (typepred "A") (("3" (expand "nodes") (("3" (rewrite "interval_list_nth") nil nil)) nil)) nil) ("4" (assert) (("4" (typepred "A") (("4" (expand "nodes") (("4" (rewrite "interval_list_length") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((restrict const-decl "R" restrict nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (V_N_b formal-const-decl "posnat" static_analysis nil) (V_N type-eq-decl nil nTpred_order nil) (nodes const-decl "node_ls" static_analysis nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (adjacents const-decl "node_ls" static_analysis nil) (map adt-def-decl "list[T1]" list_adt_map nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (length def-decl "nat" list_props nil) (interval_list_nth formula-decl nil interval_list nil) (map_nth_rw formula-decl nil more_map_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (interval_list_length formula-decl nil interval_list nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (interval_list_idx formula-decl nil interval_list nil) (dependency_graph const-decl "c_digraph[nat]" static_analysis nil) (edges const-decl "bool" c_digraphs_def digraphs) (subterm adt-def-decl "boolean" peg nil) (peg_induction formula-decl nil peg nil) (int_minus_int_is_int application-judgement "int" integers nil) (below type-eq-decl nil naturalnumbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (union_sl def-decl "{ll: list[T] | FORALL x: member(x, ll) IFF (member(x, l1) OR member(x, l2))}" set_as_list structures) (r const-decl "C(P_exp)" wf_peg nil) (array_sum const-decl "upto(3 * V_N_b)" array_sum nil) (nT_properties const-decl "F(P_exp)" wf_peg nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (subterm_seq formula-decl nil peg nil) (subterm_prior formula-decl nil peg nil) (subterm_star formula-decl nil peg nil) (subterm_plus formula-decl nil peg nil) (subterm_opt formula-decl nil peg nil) (subterm_notP formula-decl nil peg nil) (subterm_andP formula-decl nil peg nil) (bijective? const-decl "bool" functions nil) (order type-eq-decl nil wf_peg nil) (g_wf def-decl "bool" wf_peg nil) (strong const-decl "bool" wf_peg nil) (G skolem-const-decl "peg[V_T, <=, V_N_b]" static_analysis nil) (= const-decl "[T, T -> boolean]" equalities nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (member def-decl "bool" list_props nil) (V_T formal-nonempty-type-decl nil static_analysis nil) (pred type-eq-decl nil defined_types nil) (total_order? const-decl "bool" orders nil) (<= formal-const-decl "(total_order?[V_T])" static_analysis nil) (peg type-decl nil peg nil) (no_repetitions? const-decl "bool" more_list_props structures) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (node_ls type-eq-decl nil static_analysis nil) (sub_nT def-decl "node_ls" static_analysis nil) (interp type-eq-decl nil wf_peg nil) (P_0c? const-decl "[Δ -> bool]" wf_peg nil) (strong_WF const-decl "bool" wf_peg nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak))("static_analysis" static_analysis strong_WF_path 0 (strong_WF_path-1 nil 3847523274 ("" (skeep) (("" (induct n) (("1" (skeep*) (("1" (assert) (("1" (replace -1 * RL) (("1" (typepred "w") (("1" (expand "walk?") (("1" (flatten) (("1" (expand "finseq_appl") (("1" (inst -3 i) (("1" (assert) (("1" (use "strong_WF_edge") (("1" (assert) (("1" (inst -1 "w`seq(i)" "w`seq(i+1)") (("1" (expand "restrict") (("1" (expand "edge?") (("1" (expand "digraph_edges") (("1" (expand "edges") (("1" (flatten) (("1" (ground) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (rewrite "idx_V_N_nat") (("3" (assert) (("3" (rewrite "idx_V_N_nat") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 "n") (("2" (flatten) (("2" (skeep) (("2" (inst -1 w "i+1" "j") (("1" (assert) (("1" (lemma "strong_WF_edge") (("1" (inst -1 "P_exp" σ) (("1" (assert) (("1" (expand "restrict") (("1" (inst -1 "w`seq(i)" "w`seq(i+1)") (("1" (assert) (("1" (typepred "w") (("1" (expand "walk?") (("1" (flatten) (("1" (inst -3 "i") (("1" (assert) (("1" (expand "finseq_appl") (("1" (expand "edge?") (("1" (expand "digraph_edges") (("1" (expand "edges") (("1" (ground) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (rewrite "idx_V_N_nat") (("3" (rewrite "idx_V_N_nat") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (V_N_b formal-const-decl "posnat" static_analysis nil) (V_N type-eq-decl nil nTpred_order nil) (finseq type-eq-decl nil finite_sequences nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (prewalk type-eq-decl nil walks_ digraphs) (walk? const-decl "bool" walks_ digraphs) (V_T formal-nonempty-type-decl nil static_analysis nil) (total_order? const-decl "bool" orders nil) (<= formal-const-decl "(total_order?[V_T])" static_analysis nil) (peg type-decl nil peg nil) (interp type-eq-decl nil wf_peg nil) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (dependency_graph const-decl "c_digraph[nat]" static_analysis nil) (Walk type-eq-decl nil walks_ digraphs) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (bijective? const-decl "bool" functions nil) (order type-eq-decl nil wf_peg nil) (nat_induction formula-decl nil naturalnumbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (strong_WF_edge formula-decl nil static_analysis nil) (edge? const-decl "bool" digraphs_ digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (verts_in? const-decl "bool" walks_ digraphs) (vert const-decl "bool" c_digraphs_def digraphs) (nodes const-decl "node_ls" static_analysis nil) (interval_list const-decl "list[nat]" interval_list nil) (strong_WF const-decl "bool" wf_peg nil) (strong const-decl "bool" wf_peg nil) (member def-decl "bool" list_props nil) (map adt-def-decl "list[T1]" list_adt_map nil) (adjacents const-decl "node_ls" static_analysis nil) (interval_list_rec def-decl "{l: list[nat] | FORALL k: i <= k <= j ⇔ member(k, l)}" interval_list nil) (idx_V_N_nat formula-decl nil static_analysis nil) (restrict const-decl "R" restrict nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (TRUE const-decl "bool" booleans nil) (P_exp skolem-const-decl "interp[V_T, <=, V_N_b]" static_analysis nil) (w skolem-const-decl "Walk[V_N[V_N_b], digraph_type[V_N[V_N_b]], digraph_verts, digraph_edges,
     digraph_size, digraph_make](dependency_graph(P_exp))" static_analysis nil) (i skolem-const-decl "below(length(w))" static_analysis nil)) shostak))("static_analysis" static_analysis IMP_c_topological_sort_TCC1 0 (IMP_c_topological_sort_TCC1-1 nil 3847732155 ("" (existence-tcc) nil nil) nil nil (IMP_c_topological_sort existence "" "V_N[V_N_b]")))("static_analysis" static_analysis pattern_WF_path_TCC1 0 (pattern_WF_path_TCC1-1 nil 3847733547 ("" (assuming-tcc) nil nil) nil nil (pattern_WF_path assuming "digraphs@walks_[V_N[V_N_b], digraph_type[V_N[V_N_b]], c_digraphs_imp[V_N[V_N_b]].digraph_verts, c_digraphs_imp[V_N[V_N_b]].digraph_edges, c_digraphs_imp[V_N[V_N_b]].digraph_size, c_digraphs_imp[V_N[V_N_b]].digraph_make].walks_" "concretedigraph_implements_abstractdigraph: ASSUMPTION digraphs_abs[walks_.T, walks_.ConcreteDigraph, walks_.vert, walks_.edges, walks_.size, walks_.make].correct_implementation")))("static_analysis" static_analysis IMP_c_topological_sort_TCC1 0 (IMP_c_topological_sort_TCC1-1 nil 3847736082 ("" (existence-tcc) nil nil) nil nil (IMP_c_topological_sort existence "" "V_N[V_N_b]")))("static_analysis" static_analysis IMP_c_topological_sort_TCC1 0 (IMP_c_topological_sort_TCC1-1 nil 3847792504 ("" (existence-tcc) nil nil) nil nil (IMP_c_topological_sort existence "" "V_N[V_N_b]")))("static_analysis" static_analysis dependency_graph_wf_iff_dag_TCC1 0 (dependency_graph_wf_iff_dag_TCC1-1 nil 3847472036 ("" (skeep) (("" (assert) (("" (typepred "dependency_graph(P_exp)") (("" (split) (("1" (expand "dependency_graph") (("1" (expand "nodes") (("1" (expand "interval_list") (("1" (assert) (("1" (assert) (("1" (typepred "interval_list_rec(0, V_N_b - 1)") (("1" (assert) (("1" (rewrite "every_iff_member[number]") (("1" (rewrite "every_iff_member[number]") (("1" (skolem 1 "x") (("1" (inst -1 x) (("1" (flatten) (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (inst? -) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "cdigraph") (("2" (assert) (("2" (flatten) (("2" (ground) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nodes const-decl "node_ls" static_analysis nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (upfrom nonempty-type-eq-decl nil integers nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (member def-decl "bool" list_props nil) (interval_list_rec def-decl "{l: list[nat] | FORALL k: i <= k <= j ⇔ member(k, l)}" interval_list nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (every_iff_member formula-decl nil static_analysis nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (interval_list const-decl "list[nat]" interval_list nil) (list_of_idxs const-decl "bool" c_digraphs_def digraphs) (size const-decl "nat" c_digraphs_def digraphs) (no_repetitions? const-decl "bool" more_list_props structures) (/= const-decl "boolean" notequal nil) (length def-decl "nat" list_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (V_N_b formal-const-decl "posnat" static_analysis nil) (V_N type-eq-decl nil nTpred_order nil) (V_T formal-nonempty-type-decl nil static_analysis nil) (pred type-eq-decl nil defined_types nil) (total_order? const-decl "bool" orders nil) (<= formal-const-decl "(total_order?[V_T])" static_analysis nil) (peg type-decl nil peg nil) (interp type-eq-decl nil wf_peg nil) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (dependency_graph const-decl "c_digraph[nat]" static_analysis nil)) nil (dependency_graph_wf_iff_dag subtype "static_analysis.dependency_graph(static_analysis.P_exp)" "c_digraph[V_N[V_N_b]]")))("static_analysis" static_analysis IMP_c_topological_sort_TCC1 0 (IMP_c_topological_sort_TCC1-1 nil 3847797031 ("" (existence-tcc) nil nil) nil nil (IMP_c_topological_sort existence "" "V_N[V_N_b]")))("parser" peg_parser reference_parser_theorem_TCC1 0 (reference_parser_theorem_TCC1-1 nil 3847856701 ("" (subtype-tcc) nil nil) ((subterm_of? const-decl "bool" peg nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (reference_parser_theorem subtype "peg_parser.G" "peg[peg_parser.V_T, peg_parser.<=, peg_parser.V_N_b].subterm_of(peg_parser.P_exp(peg_parser.A))")))("static_analysis" static_analysis pattern_WF_edge 0 (pattern_WF_edge-1 nil 3847732287 ("" (skeep*) (("" (expand "restrict") (("" (assert) (("" (expand "dependency_graph") (("" (expand "nodes") (("" (assert) (("" (expand "pattern_WF?") (("" (ground) (("1" (skeep) (("1" (inst -1 "A") (("1" (name-replace "G" "P_exp(A)") (("1" (generalize "G" "G") (("1" (induct "G") (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (skolem 1 ("e1" "e2")) (("6" (grind) nil nil)) nil) ("7" (grind) nil nil) ("8" (grind) nil nil) ("9" (grind) nil nil) ("10" (grind) nil nil) ("11" (grind) nil nil) ("12" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst -1 "A" "_") (("2" (name-replace "G" "P_exp(A)") (("2" (generalize "G" "G") (("2" (induct "G") (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (skolem 1 ("e1" "e2")) (("6" (ground) (("1" (skeep*) (("1" (inst - B) (("1" (assert) nil nil)) nil)) nil) ("2" (skeep*) (("2" (inst - B) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (skeep*) (("3" (inst-cp -3 B) (("3" (inst -3 B!1) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("7" (skolem 1 ("e1" "e2")) (("7" (ground) (("1" (skeep*) (("1" (inst - B) (("1" (assert) nil nil)) nil)) nil) ("2" (skeep*) (("2" (inst - B) (("2" (assert) nil nil)) nil)) nil) ("3" (skeep*) (("3" (inst - B) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("8" (grind) nil nil) ("9" (grind) nil nil) ("10" (grind) nil nil) ("11" (grind) nil nil) ("12" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((restrict const-decl "R" restrict nil) (dependency_graph const-decl "c_digraph[nat]" static_analysis nil) (int_minus_int_is_int application-judgement "int" integers nil) (interval_list_member formula-decl nil interval_list nil) (interval_list_idx formula-decl nil interval_list nil) (map_adjacents_nth formula-decl nil static_analysis nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (V_N_b formal-const-decl "posnat" static_analysis nil) (V_N type-eq-decl nil nTpred_order nil) (sub_nT def-decl "node_ls" static_analysis nil) (node_ls type-eq-decl nil static_analysis nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (<= const-decl "bool" reals nil) (no_repetitions? const-decl "bool" more_list_props structures) (member def-decl "bool" list_props nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (P_0c const-decl "[Δ -> bool]" wf_peg nil) (pattern_wf? def-decl "bool" wf_peg nil) (order type-eq-decl nil wf_peg nil) (bijective? const-decl "bool" functions nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (r const-decl "C(P_exp)" wf_peg nil) (array_sum const-decl "upto(3 * V_N_b)" array_sum nil) (nT_properties const-decl "F(P_exp)" wf_peg nil) (union_sl_member_or formula-decl nil static_analysis nil) (NOT const-decl "[bool -> bool]" booleans nil) (below type-eq-decl nil naturalnumbers nil) (peg_induction formula-decl nil peg nil) (V_T formal-nonempty-type-decl nil static_analysis nil) (pred type-eq-decl nil defined_types nil) (total_order? const-decl "bool" orders nil) (<= formal-const-decl "(total_order?[V_T])" static_analysis nil) (peg type-decl nil peg nil) (= const-decl "[T, T -> boolean]" equalities nil) (interp type-eq-decl nil wf_peg nil) (pattern_WF? const-decl "bool" wf_peg nil) (nodes const-decl "node_ls" static_analysis nil) (edges const-decl "bool" c_digraphs_def digraphs) (vert const-decl "bool" c_digraphs_def digraphs) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak))("static_analysis" static_analysis pattern_WF_path 0 (pattern_WF_path-1 nil 3847738092 ("" (skeep) (("" (auto-rewrite "walk?" "finseq_appl" "verts_in?" "edge?" "diagraph_edges" "edges" "restrict") (("" (stop-rewrite "pattern_WF?") (("" (induct n) (("1" (skeep*) (("1" (typepred "w") (("1" (assert) (("1" (flatten) (("1" (inst -3 i) (("1" (use "pattern_WF_edge") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 "n") (("2" (flatten) (("2" (skeep) (("2" (inst -1 w "i+1" "j") (("1" (assert) (("1" (use "pattern_WF_edge") (("1" (assert) (("1" (inst -1 "w`seq(i)" "w`seq(i+1)") (("1" (typepred "w") (("1" (assert) (("1" (flatten) (("1" (inst -3 "i") (("1" (assert) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((i skolem-const-decl "below(length(w))" static_analysis nil) (w skolem-const-decl "Walk[V_N[V_N_b], digraph_type[V_N[V_N_b]], digraph_verts, digraph_edges, digraph_size, digraph_make](dependency_graph(P_exp))" static_analysis nil) (P_exp skolem-const-decl "interp[V_T, <=, V_N_b]" static_analysis nil) (TRUE const-decl "bool" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (vert const-decl "bool" c_digraphs_def digraphs) (verts_in? const-decl "bool" walks_ digraphs) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (edges const-decl "bool" c_digraphs_def digraphs) (edge? const-decl "bool" digraphs_ digraphs) (int_minus_int_is_int application-judgement "int" integers nil) (idx_V_N_nat formula-decl nil static_analysis nil) (restrict const-decl "R" restrict nil) (nodes const-decl "node_ls" static_analysis nil) (interval_list const-decl "list[nat]" interval_list nil) (pattern_WF? const-decl "bool" wf_peg nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (pattern_WF_edge formula-decl nil static_analysis nil) (NOT const-decl "[bool -> bool]" booleans nil) (nat_induction formula-decl nil naturalnumbers nil) (order type-eq-decl nil wf_peg nil) (bijective? const-decl "bool" functions nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil naturalnumbers nil) (Walk type-eq-decl nil walks_ digraphs) (dependency_graph const-decl "c_digraph[nat]" static_analysis nil) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil) (<= formal-const-decl "(total_order?[V_T])" static_analysis nil) (total_order? const-decl "bool" orders nil) (V_T formal-nonempty-type-decl nil static_analysis nil) (walk? const-decl "bool" walks_ digraphs) (prewalk type-eq-decl nil walks_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (finseq type-eq-decl nil finite_sequences nil) (V_N type-eq-decl nil nTpred_order nil) (V_N_b formal-const-decl "posnat" static_analysis nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak))("static_analysis" static_analysis WF_nT?_TCC1 0 (WF_nT?_TCC1-1 nil 3847815911 ("" (expand "wf_nT?") (("" (assert) (("" (skeep*) (("" (ground) (("" (postpone) nil nil)) nil)) nil)) nil)) nil) nil nil (WF_nT? subtype "static_analysis.P_exp" "wf_nT[V_T, <=, V_N_b]")))("static_analysis" static_analysis WF_wf_nT_equivalent 0 (WF_wf_nT_equivalent-1 nil 3847815919 ("" (skeep) (("" (split) (("1" (flatten) (("1" (lemma "dependency_graph_wf_iff_dag") (("1" (inst -1 "P_exp") (("1" (assert) (("1" (ground) (("1" (hide -1 -2 -4 -5 -6) (("1" (lemma "sub_nT_and_wellformedness") (("1" (expand "pattern_WF?") (("1" (skeep) (("1" (inst - "σ(P_exp)" "A" "P_0c(P_exp)" "P_exp(A)") (("1" (assert) (("1" (hide 2) (("1" (skeep) (("1" (typepred "topological_sort[V_N[V_N_b]](dependency_graph(P_exp))") (("1" (assert) (("1" (expand "σ") (("1" (typepred "OUT_2(topological_sort[V_N[V_N_b]](dependency_graph(P_exp)))") (("1" (name-replace "res" "topological_sort[V_N[V_N_b]]
                           (dependency_graph(P_exp))") (("1" (name-replace "σ_ts" "OUT_2(res)") (("1" (expand "topological_ordering?") (("1" (flatten) (("1" (inst - A B) (("1" (assert) (("1" (expand "edge?") (("1" (assert) (("1" (expand "dependency_graph") (("1" (assert) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "dependency_graph") (("2" (assert) nil nil)) nil) ("3" (expand "dependency_graph") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) (("2" (ground) (("2" (inst 1 "σ(P_exp)") nil nil)) nil)) nil)) nil)) nil) ((dependency_graph_wf_iff_dag formula-decl nil static_analysis nil) (WF_nT? const-decl "bool" static_analysis nil) (wf_nT? const-decl "bool" wf_peg nil) (structural_WF? const-decl "bool" wf_peg nil) (pattern_WF? const-decl "bool" wf_peg nil) (bijective? const-decl "bool" functions nil) (order type-eq-decl nil wf_peg nil) (wf_nT type-eq-decl nil wf_peg nil) (σ const-decl "order" static_analysis nil) (P_0c const-decl "[Δ -> bool]" wf_peg nil) (dependency_graph const-decl "c_digraph[nat]" static_analysis nil) (topological_sort const-decl "{res: [loop(G) + (topological_ordering?(G))] | IN?_2(res) ⇔ is_dag(G)}" c_topological_sort digraphs) (is_dag const-decl "bool" c_topological_sort digraphs) (IFF const-decl "[bool, bool -> bool]" booleans nil) (topological_ordering? const-decl "bool" c_topological_sort digraphs) (below type-eq-decl nil naturalnumbers nil) (size const-decl "nat" c_digraphs_def digraphs) (vert type-eq-decl nil digraphs_ digraphs) (vert? const-decl "bool" digraphs_ digraphs) (loop type-eq-decl nil c_topological_sort digraphs) (path? const-decl "bool" paths_ digraphs) (Walk type-eq-decl nil walks_ digraphs) (walk? const-decl "bool" walks_ digraphs) (prewalk type-eq-decl nil walks_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (member def-decl "bool" list_props nil) (A skolem-const-decl "V_N[V_N_b]" static_analysis nil) (P_exp skolem-const-decl "interp[V_T, <=, V_N_b]" static_analysis nil) (B skolem-const-decl "V_N[V_N_b]" static_analysis nil) (vert const-decl "bool" c_digraphs_def digraphs) (edge? const-decl "bool" digraphs_ digraphs) (interval_list_idx formula-decl nil interval_list nil) (idx_V_N_nat formula-decl nil static_analysis nil) (map_adjacents_nth formula-decl nil static_analysis nil) (interval_list_member formula-decl nil interval_list nil) (nodes const-decl "node_ls" static_analysis nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (edges const-decl "bool" c_digraphs_def digraphs) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (sub_nT_and_wellformedness formula-decl nil static_analysis nil) (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil) (<= formal-const-decl "(total_order?[V_T])" static_analysis nil) (total_order? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (V_T formal-nonempty-type-decl nil static_analysis nil) (V_N type-eq-decl nil nTpred_order nil) (V_N_b formal-const-decl "posnat" static_analysis nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak))("static_analysis" static_analysis IMP_c_topological_sort_TCC1 0 (IMP_c_topological_sort_TCC1-1 nil 3847815911 ("" (existence-tcc) nil nil) nil nil (IMP_c_topological_sort existence "" "V_N[V_N_b]")))("static_analysis" static_analysis WF_wf_nT_subtype 0 (WF_wf_nT_subtype-1 nil 3848058817 ("" (skolem-typepred) (("" (use "dependency_graph_wf_iff_dag") (("" (assert) nil nil)) nil)) nil) ((dependency_graph_wf_iff_dag formula-decl nil static_analysis nil) (structural_WF? const-decl "bool" wf_peg nil) (loop_free? const-decl "bool" static_analysis nil) (wf_nT? const-decl "bool" wf_peg nil) (WF_nT type-eq-decl nil static_analysis nil) (WF_nT? const-decl "bool" static_analysis nil) (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil) (<= formal-const-decl "(total_order?[V_T])" static_analysis nil) (total_order? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (V_T formal-nonempty-type-decl nil static_analysis nil) (V_N type-eq-decl nil nTpred_order nil) (V_N_b formal-const-decl "posnat" static_analysis nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil (WF_wf_nT_subtype subtype "static_analysis.x" "wf_nT[V_T, <=, V_N_b]")))("ast_props" ast_props destruct_ast_TCC1 0 (destruct_ast_TCC1-1 nil 3848146776 ("" (subtype-tcc) nil nil) nil nil (destruct_ast subtype "ast_props.Tp" "{T: pre_ast[ast_props.V_T, ast_props.<=, ast_props.V_N_b, ast_props.bound, ast_props.V_S].pre_ast | (booleans.¬)(pre_ast[ast_props.V_T, ast_props.<=, ast_props.V_N_b, ast_props.bound, ast_props.V_S].skip?(T))}")))("ast_props" ast_props destruct_ast_TCC2 0 (destruct_ast_TCC2-1 nil 3848146776 ("" (subtype-tcc) nil nil) nil nil (destruct_ast subtype "ast_props.T1" "{T: pre_ast[ast_props.V_T, ast_props.<=, ast_props.V_N_b, ast_props.bound, ast_props.V_S].pre_ast | (booleans.¬)(pre_ast[ast_props.V_T, ast_props.<=, ast_props.V_N_b, ast_props.bound, ast_props.V_S].skip?(T))}")))("ast_props" ast_props destruct_ast_TCC3 0 (destruct_ast_TCC3-1 nil 3848146776 ("" (subtype-tcc) nil nil) nil nil (destruct_ast subtype "ast_props.Ts" "{T: pre_ast[ast_props.V_T, ast_props.<=, ast_props.V_N_b, ast_props.bound, ast_props.V_S].pre_ast | booleans.OR(pre_ast[ast_props.V_T, ast_props.<=, ast_props.V_N_b, ast_props.bound, ast_props.V_S].skip?(T), pre_ast[ast_props.V_T, ast_props.<=, ast_props.V_N_b, ast_props.bound, ast_props.V_S].star?(T))}")))("ast_props" ast_props destruct_ast_TCC4 0 (destruct_ast_TCC4-1 nil 3848146776 ("" (subtype-tcc) nil nil) nil nil (destruct_ast subtype "ast_props.Ts" "{T: pre_ast[ast_props.V_T, ast_props.<=, ast_props.V_N_b, ast_props.bound, ast_props.V_S].pre_ast | booleans.OR(pre_ast[ast_props.V_T, ast_props.<=, ast_props.V_N_b, ast_props.bound, ast_props.V_S].skip?(T), booleans.OR(pre_ast[ast_props.V_T, ast_props.<=, ast_props.V_N_b, ast_props.bound, ast_props.V_S].plus?(T), pre_ast[ast_props.V_T, ast_props.<=, ast_props.V_N_b, ast_props.bound, ast_props.V_S].fail?(T)))}")))("ast_props" ast_props destruct_ast 0 (destruct_ast-1 nil 3848146780 ("" (skeep*) (("" (inst 1 "e(T)" "s(T)") (("" (flatten) (("" (case "skip?(T)") (("1" (assert) (("1" (inst 1 "G(T)") (("1" (assert) (("1" (apply-extensionality 1) nil nil)) nil)) nil)) nil) ("2" (case "fail?(T)") (("1" (apply-extensionality +) nil nil) ("2" (case "ε?(T)") (("1" (apply-extensionality +) (("1" (case "ε?(T)") (("1" (apply-extensionality +) (("1" (case "ε?(T)") (("1" (apply-extensionality 4) (("1" (case "ε?(T)") (("1" (apply-extensionality 5) nil nil) ("2" (propax) nil nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil) ("2" (case "any?(T)") (("1" (inst 7 "x(T)") (("1" (apply-extensionality 7) nil nil) ("2" (assert) nil nil)) nil) ("2" (case "terminal?(T)") (("1" (inst 9 "a(T)" "x(T)") (("1" (apply-extensionality 9) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil) ("2" (case "range?(T)") (("1" (inst 11 "a(T)" "b(T)" "x(T)") (("1" (apply-extensionality 11) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil) ("2" (case "nonTerminal?(T)") (("1" (inst 13 "A(T)" "T(T)") (("1" (apply-extensionality 13) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil) ("2" (case "semantic?(T)") (("1" (inst 15 "A(T)" "S(T)") (("1" (apply-extensionality 15) nil nil) ("2" (assert) nil nil)) nil) ("2" (assert) (("2" (case "seq?(T)") (("1" (inst 17 "T1(T)" "T2(T)") (("1" (apply-extensionality 17) nil nil) ("2" (assert) nil nil)) nil) ("2" (assert) (("2" (case "prior?(T)") (("1" (inst 19 "T1(T)" "T2(T)") (("1" (apply-extensionality 19) nil nil)) nil) ("2" (assert) (("2" (case "star?(T)") (("1" (inst 21 "T0(T)" "Ts(T)") (("1" (apply-extensionality 21) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil) ("2" (case "plus?(T)") (("1" (inst 23 "T0(T)" "Ts(T)") (("1" (apply-extensionality 23) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil) ("2" (case "opt?(T)") (("1" (inst 25 "T0(T)") (("1" (apply-extensionality 25) nil nil) ("2" (assert) nil nil)) nil) ("2" (assert) (("2" (case "notP?(T)") (("1" (inst 27 "T(T)") (("1" (apply-extensionality 27) nil nil) ("2" (assert) nil nil)) nil) ("2" (assert) (("2" (case "andP?(T)") (("1" (inst 29 "T(T)") (("1" (apply-extensionality 29) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (bound formal-const-decl "nat" ast_props nil) (V_T formal-nonempty-type-decl nil ast_props nil) (pred type-eq-decl nil defined_types nil) (total_order? const-decl "bool" orders nil) (<= formal-const-decl "(total_order?[V_T])" ast_props nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (V_N_b formal-const-decl "posnat" ast_props nil) (V_S formal-type-decl nil ast_props nil) (below type-eq-decl nil pre_ast nil) (pre_ast type-decl nil pre_ast nil) (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil) (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil) (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil) (peg type-decl nil peg nil) (G adt-accessor-decl "[(skip?) -> peg[V_T, <=, V_N_b]]" pre_ast nil) (pre_ast_skip_extensionality formula-decl nil pre_ast nil) (skip adt-constructor-decl "[[below, below, peg[V_T, <=, V_N_b]] -> (skip?)]" pre_ast nil) (ε? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil) (ε adt-constructor-decl "[[below, below] -> (ε?)]" pre_ast nil) (pre_ast_ε_extensionality formula-decl nil pre_ast nil) (terminal adt-constructor-decl "[[below, below, V_T, V_T] -> (terminal?)]" pre_ast nil) (pre_ast_terminal_extensionality formula-decl nil pre_ast nil) (a shared-adt-accessor-decl "[{x: pre_ast | terminal?(x) OR range?(x)} -> V_T]" pre_ast nil) (nonTerminal? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil) (nonTerminal adt-constructor-decl "[[below, below, V_N[V_N_b], {T: pre_ast | ¬skip?(T)}] -> (nonTerminal?)]" pre_ast nil) (pre_ast_nonTerminal_extensionality formula-decl nil pre_ast nil) (< const-decl "bool" reals nil) (V_N type-eq-decl nil nTpred_order nil) (A shared-adt-accessor-decl "[{x: pre_ast | nonTerminal?(x) OR semantic?(x)} -> V_N[V_N_b]]" pre_ast nil) (¬ const-decl "[bool -> bool]" booleans nil) (T shared-adt-accessor-decl "[{x: pre_ast | nonTerminal?(x) OR notP?(x) OR andP?(x)} ->
   {T: pre_ast | ¬skip?(T)}]" pre_ast nil) (andP? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil) (notP? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil) (semantic? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil) (plus adt-constructor-decl "[[below, below, {T: pre_ast | ¬skip?(T)},
  {T: pre_ast | skip?(T) OR plus?(T) OR fail?(T)}] ->
   (plus?)]" pre_ast nil) (pre_ast_plus_extensionality formula-decl nil pre_ast nil) (pre_ast_andP_extensionality formula-decl nil pre_ast nil) (andP adt-constructor-decl "[[below, below, {T: pre_ast | ¬skip?(T)}] -> (andP?)]" pre_ast nil) (pre_ast_notP_extensionality formula-decl nil pre_ast nil) (notP adt-constructor-decl "[[below, below, {T: pre_ast | ¬skip?(T)}] -> (notP?)]" pre_ast nil) (pre_ast_opt_extensionality formula-decl nil pre_ast nil) (opt adt-constructor-decl "[[below, below, {T: pre_ast | ¬skip?(T)}] -> (opt?)]" pre_ast nil) (opt? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil) (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil) (T0 shared-adt-accessor-decl "[{x: pre_ast | star?(x) OR plus?(x) OR opt?(x)} -> {T: pre_ast | ¬skip?(T)}]" pre_ast nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (Ts adt-accessor-decl "[d: {x: pre_ast | star?(x) OR plus?(x)} ->
   {x1: pre_ast |
      IF star?(d) THEN skip?(x1) OR star?(x1)
      ELSE skip?(x1) OR plus?(x1) OR fail?(x1)
      ENDIF}]" pre_ast nil) (pre_ast_star_extensionality formula-decl nil pre_ast nil) (star adt-constructor-decl "[[below, below, {T: pre_ast | ¬skip?(T)},
  {T: pre_ast | skip?(T) OR star?(T)}] ->
   (star?)]" pre_ast nil) (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil) (pre_ast_prior_extensionality formula-decl nil pre_ast nil) (prior adt-constructor-decl "[[below, below, {T: pre_ast | ¬skip?(T)}, pre_ast] -> (prior?)]" pre_ast nil) (prior? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil) (T1 shared-adt-accessor-decl "[{x: pre_ast | seq?(x) OR prior?(x)} -> {T: pre_ast | ¬skip?(T)}]" pre_ast nil) (T2 shared-adt-accessor-decl "[{x: pre_ast | seq?(x) OR prior?(x)} -> pre_ast]" pre_ast nil) (pre_ast_seq_extensionality formula-decl nil pre_ast nil) (seq adt-constructor-decl "[[below, below, {T: pre_ast | ¬skip?(T)}, pre_ast] -> (seq?)]" pre_ast nil) (seq? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil) (S adt-accessor-decl "[(semantic?) -> V_S]" pre_ast nil) (pre_ast_semantic_extensionality formula-decl nil pre_ast nil) (semantic adt-constructor-decl "[[below, below, V_N[V_N_b], V_S] -> (semantic?)]" pre_ast nil) (b adt-accessor-decl "[(range?) -> V_T]" pre_ast nil) (pre_ast_range_extensionality formula-decl nil pre_ast nil) (range adt-constructor-decl "[[below, below, V_T, V_T, V_T] -> (range?)]" pre_ast nil) (range? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil) (terminal? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (x shared-adt-accessor-decl "[{x: pre_ast | any?(x) OR terminal?(x) OR range?(x)} -> V_T]" pre_ast nil) (pre_ast_any_extensionality formula-decl nil pre_ast nil) (any adt-constructor-decl "[[below, below, V_T] -> (any?)]" pre_ast nil) (any? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil) (T skolem-const-decl "pre_ast[V_T, <=, V_N_b, bound, V_S]" ast_props nil) (fail adt-constructor-decl "[[below, below] -> (fail?)]" pre_ast nil) (pre_ast_fail_extensionality formula-decl nil pre_ast nil) (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak))