(semantic_interp
 (s_inp_TCC1 0
  (s_inp_TCC1-1 nil 3774421781
   ("" (skeep)
    (("" (assert)
      (("" (grind)
        (("" (lemma "Wellformed_theorem")
          (("" (inst -1 "T") (("" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((Wellformed_theorem formula-decl nil ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (astWellformed? def-decl "bool" ast nil)
    (astType? def-decl "astType" ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (subterm adt-def-decl "boolean" pre_ast nil)
    (V_T formal-nonempty-type-decl nil semantic_interp nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_interp nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_interp nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_interp nil)
    (V_S formal-type-decl nil semantic_interp nil))
   nil
   (s_inp subtype
    "pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].fail(pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].s(semantic_interp.T), pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].e(semantic_interp.T))"
    "{T_p: pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].semanticTree | booleans.∧((booleans.∧((booleans.⇔(pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].skip?(semantic_interp.T), pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].skip?(T_p))), booleans.∧((booleans.⇔(pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].star?(semantic_interp.T), pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].star?(T_p))), booleans.∧((booleans.⇔((ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astType?(semantic_interp.T) = ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].failure), pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].fail?(T_p))), ((booleans.⇒(pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].plus?(semantic_interp.T), (booleans.∨(pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].plus?(T_p), pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].fail?(T_p)))))))))), booleans.∧((pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].s(T_p) = pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].s(semantic_interp.T)), booleans.∧((pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].e(T_p) = pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].e(semantic_interp.T)), (booleans.⇒(ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astWellformed?(semantic_interp.T), (booleans.∧(ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astWellformed?(T_p), (ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astType?(T_p) = ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astType?(semantic_interp.T)))))))))}")))
 (s_inp_TCC2 0
  (s_inp_TCC2-1 nil 3774421781
   ("" (skeep*) (("" (assert) (("" (grind) nil nil)) nil)) nil)
   ((semanticTree? const-decl "bool" pre_ast nil)
    (subterm adt-def-decl "boolean" pre_ast nil)
    (astType? def-decl "astType" ast nil)
    (V_T formal-nonempty-type-decl nil semantic_interp nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_interp nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_interp nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_interp nil)
    (V_S formal-type-decl nil semantic_interp nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (s_inp subtype "semantic_interp.T"
    "{T_p: pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].semanticTree | booleans.∧((booleans.∧((booleans.⇔(pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].skip?(semantic_interp.T), pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].skip?(T_p))), booleans.∧((booleans.⇔(pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].star?(semantic_interp.T), pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].star?(T_p))), booleans.∧((booleans.⇔((ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astType?(semantic_interp.T) = ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].failure), pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].fail?(T_p))), ((booleans.⇒(pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].plus?(semantic_interp.T), (booleans.∨(pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].plus?(T_p), pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].fail?(T_p)))))))))), booleans.∧((pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].s(T_p) = pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].s(semantic_interp.T)), booleans.∧((pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].e(T_p) = pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].e(semantic_interp.T)), (booleans.⇒(ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astWellformed?(semantic_interp.T), (booleans.∧(ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astWellformed?(T_p), (ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astType?(T_p) = ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astType?(semantic_interp.T)))))))))}")))
 (s_inp_TCC3 0
  (s_inp_TCC3-1 nil 3774421781
   ("" (skeep*) (("" (assert) (("" (grind) nil nil)) nil)) nil)
   ((nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (subterm adt-def-decl "boolean" pre_ast nil)
    (astType? def-decl "astType" ast nil)
    (V_T formal-nonempty-type-decl nil semantic_interp nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_interp nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_interp nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_interp nil)
    (V_S formal-type-decl nil semantic_interp nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (s_inp subtype "semantic_interp.T"
    "{T_p: pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].semanticTree | booleans.∧((booleans.∧((booleans.⇔(pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].skip?(semantic_interp.T), pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].skip?(T_p))), booleans.∧((booleans.⇔(pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].star?(semantic_interp.T), pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].star?(T_p))), booleans.∧((booleans.⇔((ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astType?(semantic_interp.T) = ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].failure), pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].fail?(T_p))), ((booleans.⇒(pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].plus?(semantic_interp.T), (booleans.∨(pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].plus?(T_p), pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].fail?(T_p)))))))))), booleans.∧((pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].s(T_p) = pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].s(semantic_interp.T)), booleans.∧((pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].e(T_p) = pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].e(semantic_interp.T)), (booleans.⇒(ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astWellformed?(semantic_interp.T), (booleans.∧(ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astWellformed?(T_p), (ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astType?(T_p) = ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astType?(semantic_interp.T)))))))))}")))
 (s_inp_TCC4 0
  (s_inp_TCC4-1 nil 3774421781
   ("" (skeep*) (("" (assert) (("" (grind) nil nil)) nil)) nil)
   ((nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (subterm adt-def-decl "boolean" pre_ast nil)
    (astType? def-decl "astType" ast nil)
    (V_T formal-nonempty-type-decl nil semantic_interp nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_interp nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_interp nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_interp nil)
    (V_S formal-type-decl nil semantic_interp nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (s_inp subtype "semantic_interp.T"
    "{T_p: pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].semanticTree | booleans.∧((booleans.∧((booleans.⇔(pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].skip?(semantic_interp.T), pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].skip?(T_p))), booleans.∧((booleans.⇔(pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].star?(semantic_interp.T), pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].star?(T_p))), booleans.∧((booleans.⇔((ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astType?(semantic_interp.T) = ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].failure), pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].fail?(T_p))), ((booleans.⇒(pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].plus?(semantic_interp.T), (booleans.∨(pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].plus?(T_p), pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].fail?(T_p)))))))))), booleans.∧((pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].s(T_p) = pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].s(semantic_interp.T)), booleans.∧((pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].e(T_p) = pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].e(semantic_interp.T)), (booleans.⇒(ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astWellformed?(semantic_interp.T), (booleans.∧(ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astWellformed?(T_p), (ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astType?(T_p) = ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astType?(semantic_interp.T)))))))))}")))
 (s_inp_TCC5 0
  (s_inp_TCC5-1 nil 3774421781
   ("" (skeep*) (("" (assert) (("" (grind) nil nil)) nil)) nil)
   ((nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (subterm adt-def-decl "boolean" pre_ast nil)
    (astType? def-decl "astType" ast nil)
    (in_range const-decl "bool" ast nil)
    (V_T formal-nonempty-type-decl nil semantic_interp nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_interp nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_interp nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_interp nil)
    (V_S formal-type-decl nil semantic_interp nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (s_inp subtype "semantic_interp.T"
    "{T_p: pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].semanticTree | booleans.∧((booleans.∧((booleans.⇔(pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].skip?(semantic_interp.T), pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].skip?(T_p))), booleans.∧((booleans.⇔(pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].star?(semantic_interp.T), pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].star?(T_p))), booleans.∧((booleans.⇔((ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astType?(semantic_interp.T) = ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].failure), pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].fail?(T_p))), ((booleans.⇒(pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].plus?(semantic_interp.T), (booleans.∨(pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].plus?(T_p), pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].fail?(T_p)))))))))), booleans.∧((pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].s(T_p) = pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].s(semantic_interp.T)), booleans.∧((pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].e(T_p) = pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].e(semantic_interp.T)), (booleans.⇒(ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astWellformed?(semantic_interp.T), (booleans.∧(ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astWellformed?(T_p), (ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astType?(T_p) = ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astType?(semantic_interp.T)))))))))}")))
 (s_inp_TCC6 0
  (s_inp_TCC6-1 nil 3774421781 ("" (termination-tcc) nil nil)
   ((astType? def-decl "astType" ast nil)
    (reduce_nat adt-def-decl "[pre_ast -> nat]" pre_ast nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (¬ const-decl "[bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (V_S formal-type-decl nil semantic_interp nil)
    (bound formal-const-decl "posnat" semantic_interp nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_interp nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_interp nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_interp nil)
    (astMeasure const-decl "nat" pre_ast nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (s_inp termination
    "semantic_interp.s_inp(semantic_interp.P_inp, semantic_interp.T)"
    "nil")))
 (s_inp_TCC7 0
  (s_inp_TCC7-1 nil 3774421781
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (assert)
        (("" (split 2)
          (("1" (grind) nil nil)
           ("2" (flatten)
            (("2" (expand "astWellformed?")
              (("2" (flatten)
                (("2" (expand "astMeaningful?")
                  (("2" (assert)
                    (("2" (expand "astType?")
                      (("2" (lemma "Wellformed_theorem")
                        (("2" (inst -1 "T1")
                          (("2" (assert)
                            (("2" (flatten) (("2" (assert) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (subterm adt-def-decl "boolean" pre_ast nil)
    (V_T formal-nonempty-type-decl nil semantic_interp nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_interp nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_interp nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_interp nil)
    (V_S formal-type-decl nil semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (astMeaningful? const-decl "bool" ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (¬ const-decl "[bool -> bool]" booleans nil)
    (pre_ast type-decl nil pre_ast nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (s_inp subtype
    "pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].semantic(semantic_interp.s, semantic_interp.e, semantic_interp.A, semantic_interp.P_inp(semantic_interp.A, semantic_interp.s_inp(semantic_interp.P_inp, semantic_interp.T)))"
    "{T_p: pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].semanticTree | booleans.∧((booleans.∧((booleans.⇔(pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].skip?(semantic_interp.T), pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].skip?(T_p))), booleans.∧((booleans.⇔(pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].star?(semantic_interp.T), pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].star?(T_p))), booleans.∧((booleans.⇔((ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astType?(semantic_interp.T) = ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].failure), pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].fail?(T_p))), ((booleans.⇒(pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].plus?(semantic_interp.T), (booleans.∨(pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].plus?(T_p), pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].fail?(T_p)))))))))), booleans.∧((pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].s(T_p) = pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].s(semantic_interp.T)), booleans.∧((pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].e(T_p) = pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].e(semantic_interp.T)), (booleans.⇒(ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astWellformed?(semantic_interp.T), (booleans.∧(ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astWellformed?(T_p), (ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astType?(T_p) = ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astType?(semantic_interp.T)))))))))}")))
 (s_inp_TCC8 0
  (s_inp_TCC8-1 nil 3774421781
   ("" (skeep)
    (("" (skeep)
      (("" (replace -1 * LR) (("" (assert) (("" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (subterm adt-def-decl "boolean" pre_ast nil)
    (astType? def-decl "astType" ast nil)
    (V_T formal-nonempty-type-decl nil semantic_interp nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_interp nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_interp nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_interp nil)
    (V_S formal-type-decl nil semantic_interp nil))
   nil
   (s_inp subtype "semantic_interp.T"
    "{T_p: pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].semanticTree | booleans.∧((booleans.∧((booleans.⇔(pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].skip?(semantic_interp.T), pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].skip?(T_p))), booleans.∧((booleans.⇔(pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].star?(semantic_interp.T), pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].star?(T_p))), booleans.∧((booleans.⇔((ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astType?(semantic_interp.T) = ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].failure), pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].fail?(T_p))), ((booleans.⇒(pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].plus?(semantic_interp.T), (booleans.∨(pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].plus?(T_p), pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].fail?(T_p)))))))))), booleans.∧((pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].s(T_p) = pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].s(semantic_interp.T)), booleans.∧((pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].e(T_p) = pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].e(semantic_interp.T)), (booleans.⇒(ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astWellformed?(semantic_interp.T), (booleans.∧(ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astWellformed?(T_p), (ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astType?(T_p) = ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astType?(semantic_interp.T)))))))))}")))
 (s_inp_TCC9 0
  (s_inp_TCC9-1 nil 3774421781 ("" (termination-tcc) nil nil)
   ((astType? def-decl "astType" ast nil)
    (reduce_nat adt-def-decl "[pre_ast -> nat]" pre_ast nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (¬ const-decl "[bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (V_S formal-type-decl nil semantic_interp nil)
    (bound formal-const-decl "posnat" semantic_interp nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_interp nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_interp nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_interp nil)
    (astMeasure const-decl "nat" pre_ast nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (s_inp termination
    "semantic_interp.s_inp(semantic_interp.P_inp, semantic_interp.T1)"
    "nil")))
 (s_inp_TCC10 0
  (s_inp_TCC10-1 nil 3774421781
   ("" (skeep*)
    (("" (typepred "T")
      (("" (lemma "Wellformed_theorem")
        (("" (inst - "T")
          (("" (assert)
            (("" (flatten)
              (("" (expand "astWellformed?" -)
                (("" (flatten)
                  (("" (replace -12 * LR)
                    (("" (assert)
                      (("" (assert)
                        (("" (expand "astType?" 1)
                          (("" (lift-if 1)
                            (("" (typepred "v(P_inp, T1)")
                              (("" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((V_S formal-type-decl nil semantic_interp nil)
    (bound formal-const-decl "posnat" semantic_interp nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_interp nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_interp nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_interp nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (astMeasure const-decl "nat" pre_ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (astType type-decl nil ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (¬ const-decl "[bool -> bool]" booleans nil)
    (astType? def-decl "astType" ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (s_inp subtype
    "semantic_interp.s_inp(semantic_interp.P_inp, semantic_interp.T1)"
    "{T: pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].pre_ast | (booleans.¬)(pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].skip?(T))}")))
 (s_inp_TCC11 0
  (s_inp_TCC11-1 nil 3774421781 ("" (termination-tcc) nil nil)
   ((astType? def-decl "astType" ast nil)
    (reduce_nat adt-def-decl "[pre_ast -> nat]" pre_ast nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (¬ const-decl "[bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (V_S formal-type-decl nil semantic_interp nil)
    (bound formal-const-decl "posnat" semantic_interp nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_interp nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_interp nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_interp nil)
    (astMeasure const-decl "nat" pre_ast nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (s_inp termination
    "semantic_interp.s_inp(semantic_interp.P_inp, semantic_interp.T2)"
    "nil")))
 (s_inp_TCC12 0
  (s_inp_TCC12-1 nil 3774421781
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (assert)
        (("" (typepred "v(P_inp, T1)")
          (("1" (typepred "v(P_inp, T2)")
            (("1" (assert)
              (("1" (split 3)
                (("1" (expand "semanticTree?")
                  (("1" (skeep)
                    (("1" (inst - "T_p")
                      (("1" (inst - "T_p")
                        (("1" (assert)
                          (("1" (expand "subterm" -1)
                            (("1" (propax) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (expand "astWellformed?" 1)
                  (("2" (flatten)
                    (("2" (assert)
                      (("2" (flatten)
                        (("2" (assert)
                          (("2" (split 1)
                            (("1" (flatten) (("1" (assert) nil nil))
                              nil)
                             ("2" (flatten) (("2" (assert) nil nil))
                              nil)
                             ("3" (flatten) (("3" (assert) nil nil))
                              nil)
                             ("4" (flatten) (("4" (assert) nil nil))
                              nil)
                             ("5" (flatten)
                              (("5"
                                (assert)
                                (("5"
                                  (assert)
                                  (("5"
                                    (expand "astType?" 4)
                                    (("5"
                                      (lift-if 4)
                                      (("5"
                                        (split 4)
                                        (("1" (propax) nil nil)
                                         ("2"
                                          (assert)
                                          (("2"
                                            (assert)
                                            (("2"
                                              (lemma
                                               "Wellformed_theorem")
                                              (("2"
                                                (inst -1 "T1")
                                                (("2"
                                                  (assert)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("6" (expand "astType?" 1)
                              (("6"
                                (lift-if 1)
                                (("6"
                                  (split 1)
                                  (("1"
                                    (flatten)
                                    (("1"
                                      (lift-if 1)
                                      (("1"
                                        (split 1)
                                        (("1" (propax) nil nil)
                                         ("2"
                                          (flatten)
                                          (("2" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (flatten)
                                    (("2"
                                      (split 2)
                                      (("1"
                                        (flatten)
                                        (("1"
                                          (lift-if 1)
                                          (("1"
                                            (split 1)
                                            (("1"
                                              (flatten)
                                              (("1" (assert) nil nil))
                                              nil)
                                             ("2"
                                              (flatten)
                                              (("2"
                                                (assert)
                                                (("2"
                                                  (split 2)
                                                  (("1"
                                                    (propax)
                                                    nil
                                                    nil)
                                                   ("2"
                                                    (flatten)
                                                    (("2"
                                                      (assert)
                                                      (("2"
                                                        (flatten)
                                                        (("2"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (flatten)
                                        (("2"
                                          (lift-if 3)
                                          (("2"
                                            (split 3)
                                            (("1"
                                              (flatten)
                                              (("1" (assert) nil nil))
                                              nil)
                                             ("2"
                                              (flatten)
                                              (("2"
                                                (assert)
                                                (("2"
                                                  (assert)
                                                  (("2"
                                                    (split 2)
                                                    (("1"
                                                      (flatten)
                                                      (("1"
                                                        (assert)
                                                        nil
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (propax)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (replace -12 * LR)
              (("2" (hide - 2 3) (("2" (grind) nil nil)) nil)) nil))
            nil)
           ("2" (replace -1 * LR)
            (("2" (hide - 2 3) (("2" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((¬ const-decl "[bool -> bool]" booleans nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (astMeasure const-decl "nat" pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_interp nil)
    (bound formal-const-decl "posnat" semantic_interp nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_interp nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_interp nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_interp nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (reduce_nat adt-def-decl "[pre_ast -> nat]" pre_ast nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (subterm adt-def-decl "boolean" pre_ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (s_inp subtype
    "pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].seq(semantic_interp.s, semantic_interp.e, semantic_interp.s_inp(semantic_interp.P_inp, semantic_interp.T1), semantic_interp.s_inp(semantic_interp.P_inp, semantic_interp.T2))"
    "{T_p: pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].semanticTree | booleans.∧((booleans.∧((booleans.⇔(pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].skip?(semantic_interp.T), pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].skip?(T_p))), booleans.∧((booleans.⇔(pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].star?(semantic_interp.T), pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].star?(T_p))), booleans.∧((booleans.⇔((ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astType?(semantic_interp.T) = ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].failure), pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].fail?(T_p))), ((booleans.⇒(pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].plus?(semantic_interp.T), (booleans.∨(pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].plus?(T_p), pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].fail?(T_p)))))))))), booleans.∧((pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].s(T_p) = pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].s(semantic_interp.T)), booleans.∧((pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].e(T_p) = pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].e(semantic_interp.T)), (booleans.⇒(ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astWellformed?(semantic_interp.T), (booleans.∧(ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astWellformed?(T_p), (ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astType?(T_p) = ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astType?(semantic_interp.T)))))))))}")))
 (s_inp_TCC13 0
  (s_inp_TCC13-1 nil 3774421781 ("" (termination-tcc) nil nil)
   ((astType? def-decl "astType" ast nil)
    (reduce_nat adt-def-decl "[pre_ast -> nat]" pre_ast nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (¬ const-decl "[bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (V_S formal-type-decl nil semantic_interp nil)
    (bound formal-const-decl "posnat" semantic_interp nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_interp nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_interp nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_interp nil)
    (astMeasure const-decl "nat" pre_ast nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (s_inp termination
    "semantic_interp.s_inp(semantic_interp.P_inp, semantic_interp.T1)"
    "nil")))
 (s_inp_TCC14 0
  (s_inp_TCC14-1 nil 3774421781
   ("" (skeep*)
    (("" (assert)
      (("" (typepred ("T1" "v(P_inp, T1)"))
        (("1" (assert) nil nil)
         ("2" (typepred "T")
          (("2" (expand "astWellformed?" -)
            (("2" (flatten)
              (("2" (replace -6 * LR) (("2" (assert) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((V_T formal-nonempty-type-decl nil semantic_interp nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_interp nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_interp nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_interp nil)
    (V_S formal-type-decl nil semantic_interp nil)
    (pre_ast type-decl nil pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (¬ const-decl "[bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (astMeasure const-decl "nat" pre_ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (astType type-decl nil ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (astType? def-decl "astType" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (s_inp subtype
    "semantic_interp.s_inp(semantic_interp.P_inp, semantic_interp.T1)"
    "{T: pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].pre_ast | (booleans.¬)(pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].skip?(T))}")))
 (s_inp_TCC15 0
  (s_inp_TCC15-1 nil 3774421781 ("" (termination-tcc) nil nil)
   ((astType? def-decl "astType" ast nil)
    (reduce_nat adt-def-decl "[pre_ast -> nat]" pre_ast nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (¬ const-decl "[bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (V_S formal-type-decl nil semantic_interp nil)
    (bound formal-const-decl "posnat" semantic_interp nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_interp nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_interp nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_interp nil)
    (astMeasure const-decl "nat" pre_ast nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (s_inp termination
    "semantic_interp.s_inp(semantic_interp.P_inp, semantic_interp.T2)"
    "nil")))
 (s_inp_TCC16 0
  (s_inp_TCC16-1 nil 3774421781
   ("" (skeep*)
    (("" (assert)
      (("" (typepred ("v(P_inp, T1)" "v(P_inp, T2)"))
        (("1" (replace -23 * LR)
          (("1" (assert)
            (("1" (assert)
              (("1" (split 3)
                (("1" (expand "semanticTree?")
                  (("1" (skeep)
                    (("1" (inst - "T_p")
                      (("1" (inst - "T_p")
                        (("1" (expand "subterm" -1)
                          (("1" (assert) (("1" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (expand "astWellformed?" 1)
                  (("2" (flatten)
                    (("2" (assert)
                      (("2" (replace -27 * LR)
                        (("2" (split 1)
                          (("1" (assert) nil nil)
                           ("2" (flatten)
                            (("2" (assert)
                              (("2"
                                (expand "astType?" 3)
                                (("2"
                                  (lift-if 3)
                                  (("2"
                                    (lemma "Wellformed_theorem")
                                    (("2"
                                      (inst -1 "T1")
                                      (("2"
                                        (assert)
                                        (("2"
                                          (assert)
                                          (("2"
                                            (flatten)
                                            (("2" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("3" (flatten)
                            (("3" (assert)
                              (("3"
                                (flatten)
                                (("3" (assert) nil nil))
                                nil))
                              nil))
                            nil)
                           ("4" (flatten)
                            (("4" (assert)
                              (("4"
                                (lemma "Wellformed_theorem")
                                (("4"
                                  (inst -1 "T1")
                                  (("4"
                                    (assert)
                                    (("4"
                                      (assert)
                                      (("4"
                                        (flatten)
                                        (("4"
                                          (assert)
                                          (("4"
                                            (expand "astType?" 1)
                                            (("4"
                                              (lift-if 1)
                                              (("4"
                                                (split -6)
                                                (("1"
                                                  (assert)
                                                  (("1"
                                                    (flatten)
                                                    (("1"
                                                      (assert)
                                                      (("1"
                                                        (flatten)
                                                        (("1"
                                                          (assert)
                                                          (("1"
                                                            (lemma
                                                             "Wellformed_theorem")
                                                            (("1"
                                                              (inst
                                                               -1
                                                               "T1")
                                                              (("1"
                                                                (assert)
                                                                (("1"
                                                                  (lemma
                                                                   "Wellformed_theorem")
                                                                  (("1"
                                                                    (inst
                                                                     -1
                                                                     "T2")
                                                                    (("1"
                                                                      (assert)
                                                                      (("1"
                                                                        (flatten)
                                                                        (("1"
                                                                          (assert)
                                                                          (("1"
                                                                            (split
                                                                             1)
                                                                            (("1"
                                                                              (flatten)
                                                                              (("1"
                                                                                (lift-if
                                                                                 1)
                                                                                (("1"
                                                                                  (split
                                                                                   1)
                                                                                  (("1"
                                                                                    (propax)
                                                                                    nil
                                                                                    nil)
                                                                                   ("2"
                                                                                    (flatten)
                                                                                    (("2"
                                                                                      (assert)
                                                                                      (("2"
                                                                                        (flatten)
                                                                                        (("2"
                                                                                          (assert)
                                                                                          nil
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil)
                                                                             ("2"
                                                                              (flatten)
                                                                              (("2"
                                                                                (assert)
                                                                                (("2"
                                                                                  (assert)
                                                                                  nil
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (assert)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (hide 2 3)
          (("2" (replace -1 * LR) (("2" (grind) nil nil)) nil)) nil)
         ("3" (hide 2 3)
          (("3" (replace -1 * LR) (("3" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((reduce_nat adt-def-decl "[pre_ast -> nat]" pre_ast nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (subterm adt-def-decl "boolean" pre_ast nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_interp nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_interp nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_interp nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_interp nil)
    (V_S formal-type-decl nil semantic_interp nil)
    (pre_ast type-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (astMeasure const-decl "nat" pre_ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (astType type-decl nil ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (astType? def-decl "astType" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (¬ const-decl "[bool -> bool]" booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (s_inp subtype
    "pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].prior(semantic_interp.s, semantic_interp.e, semantic_interp.s_inp(semantic_interp.P_inp, semantic_interp.T1), semantic_interp.s_inp(semantic_interp.P_inp, semantic_interp.T2))"
    "{T_p: pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].semanticTree | booleans.∧((booleans.∧((booleans.⇔(pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].skip?(semantic_interp.T), pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].skip?(T_p))), booleans.∧((booleans.⇔(pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].star?(semantic_interp.T), pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].star?(T_p))), booleans.∧((booleans.⇔((ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astType?(semantic_interp.T) = ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].failure), pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].fail?(T_p))), ((booleans.⇒(pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].plus?(semantic_interp.T), (booleans.∨(pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].plus?(T_p), pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].fail?(T_p)))))))))), booleans.∧((pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].s(T_p) = pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].s(semantic_interp.T)), booleans.∧((pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].e(T_p) = pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].e(semantic_interp.T)), (booleans.⇒(ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astWellformed?(semantic_interp.T), (booleans.∧(ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astWellformed?(T_p), (ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astType?(T_p) = ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astType?(semantic_interp.T)))))))))}")))
 (s_inp_TCC17 0
  (s_inp_TCC17-1 nil 3774421781 ("" (termination-tcc) nil nil)
   ((astType? def-decl "astType" ast nil)
    (reduce_nat adt-def-decl "[pre_ast -> nat]" pre_ast nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (¬ const-decl "[bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (V_S formal-type-decl nil semantic_interp nil)
    (bound formal-const-decl "posnat" semantic_interp nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_interp nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_interp nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_interp nil)
    (astMeasure const-decl "nat" pre_ast nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (s_inp termination
    "semantic_interp.s_inp(semantic_interp.P_inp, semantic_interp.T0)"
    "nil")))
 (s_inp_TCC18 0
  (s_inp_TCC18-1 nil 3774421781
   ("" (skeep*)
    (("" (assert)
      (("" (typepred ("T0" "v(P_inp, T0)")) (("" (assert) nil nil))
        nil))
      nil))
    nil)
   ((V_T formal-nonempty-type-decl nil semantic_interp nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_interp nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_interp nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_interp nil)
    (V_S formal-type-decl nil semantic_interp nil)
    (pre_ast type-decl nil pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (¬ const-decl "[bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (astMeasure const-decl "nat" pre_ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (astType type-decl nil ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (astType? def-decl "astType" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (s_inp subtype
    "semantic_interp.s_inp(semantic_interp.P_inp, semantic_interp.T0)"
    "{T: pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].pre_ast | (booleans.¬)(pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].skip?(T))}")))
 (s_inp_TCC19 0
  (s_inp_TCC19-1 nil 3774421781 ("" (termination-tcc) nil nil)
   ((astType? def-decl "astType" ast nil)
    (reduce_nat adt-def-decl "[pre_ast -> nat]" pre_ast nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (¬ const-decl "[bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (V_S formal-type-decl nil semantic_interp nil)
    (bound formal-const-decl "posnat" semantic_interp nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_interp nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_interp nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_interp nil)
    (astMeasure const-decl "nat" pre_ast nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (s_inp termination
    "semantic_interp.s_inp(semantic_interp.P_inp, semantic_interp.Ts)"
    "nil")))
 (s_inp_TCC20 0
  (s_inp_TCC20-1 nil 3774421781
   ("" (skeep*)
    (("" (assert)
      (("" (typepred ("Ts" "v(P_inp, Ts)"))
        (("" (assert) (("" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_interp nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_interp nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_interp nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_interp nil)
    (V_S formal-type-decl nil semantic_interp nil)
    (pre_ast type-decl nil pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (astMeasure const-decl "nat" pre_ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (astType type-decl nil ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (astType? def-decl "astType" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (s_inp subtype
    "semantic_interp.s_inp(semantic_interp.P_inp, semantic_interp.Ts)"
    "{T: pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].pre_ast | booleans.OR(pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].skip?(T), pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].star?(T))}")))
 (s_inp_TCC21 0
  (s_inp_TCC21-1 nil 3774421781
   ("" (skeep*)
    (("" (assert)
      (("" (typepred ("v(P_inp, T0)" "v(P_inp, Ts)"))
        (("1" (split 2)
          (("1" (expand "semanticTree?")
            (("1" (skeep)
              (("1" (inst - "T_p")
                (("1" (inst - "T_p")
                  (("1" (expand "subterm" -1)
                    (("1" (assert) (("1" (assert) nil nil)) nil)) nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (assert)
            (("2" (assert)
              (("2" (replace -22 * LR) (("2" (assert) nil nil)) nil))
              nil))
            nil)
           ("3" (replace -23 * LR) (("3" (assert) nil nil)) nil)
           ("4" (expand "astWellformed?" 1)
            (("4" (replace -23 * LR)
              (("4" (assert)
                (("4" (flatten)
                  (("4" (assert)
                    (("4" (flatten)
                      (("4" (assert)
                        (("4" (split 1)
                          (("1" (flatten)
                            (("1" (assert)
                              (("1"
                                (flatten)
                                (("1" (assert) nil nil))
                                nil))
                              nil))
                            nil)
                           ("2" (flatten)
                            (("2" (assert)
                              (("2"
                                (flatten)
                                (("2" (assert) nil nil))
                                nil))
                              nil))
                            nil)
                           ("3" (assert)
                            (("3" (expand "astType?" 1)
                              (("3"
                                (lemma "Wellformed_theorem")
                                (("3"
                                  (inst -1 "T0")
                                  (("3"
                                    (assert)
                                    (("3"
                                      (flatten)
                                      (("3"
                                        (split -2)
                                        (("1" (assert) nil nil)
                                         ("2"
                                          (assert)
                                          (("2"
                                            (lift-if 1)
                                            (("2"
                                              (lift-if 1)
                                              (("2"
                                                (split 1)
                                                (("1"
                                                  (assert)
                                                  (("1"
                                                    (flatten)
                                                    (("1"
                                                      (assert)
                                                      (("1"
                                                        (split 1)
                                                        (("1"
                                                          (propax)
                                                          nil
                                                          nil)
                                                         ("2"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (assert)
                                                  (("2"
                                                    (flatten)
                                                    (("2"
                                                      (lift-if 2)
                                                      (("2"
                                                        (assert)
                                                        (("2"
                                                          (split 2)
                                                          (("1"
                                                            (assert)
                                                            nil
                                                            nil)
                                                           ("2"
                                                            (propax)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (replace -1 * LR)
          (("2" (hide - 2 3) (("2" (grind) nil nil)) nil)) nil)
         ("3" (replace -1 * LR)
          (("3" (hide - 2 3) (("3" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((reduce_nat adt-def-decl "[pre_ast -> nat]" pre_ast nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (subterm adt-def-decl "boolean" pre_ast nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_interp nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_interp nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_interp nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_interp nil)
    (V_S formal-type-decl nil semantic_interp nil)
    (pre_ast type-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (astMeasure const-decl "nat" pre_ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (astType type-decl nil ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (astType? def-decl "astType" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (¬ const-decl "[bool -> bool]" booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (s_inp subtype
    "pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].star(semantic_interp.s, semantic_interp.e, semantic_interp.s_inp(semantic_interp.P_inp, semantic_interp.T0), semantic_interp.s_inp(semantic_interp.P_inp, semantic_interp.Ts))"
    "{T_p: pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].semanticTree | booleans.∧((booleans.∧((booleans.⇔(pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].skip?(semantic_interp.T), pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].skip?(T_p))), booleans.∧((booleans.⇔(pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].star?(semantic_interp.T), pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].star?(T_p))), booleans.∧((booleans.⇔((ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astType?(semantic_interp.T) = ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].failure), pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].fail?(T_p))), ((booleans.⇒(pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].plus?(semantic_interp.T), (booleans.∨(pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].plus?(T_p), pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].fail?(T_p)))))))))), booleans.∧((pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].s(T_p) = pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].s(semantic_interp.T)), booleans.∧((pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].e(T_p) = pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].e(semantic_interp.T)), (booleans.⇒(ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astWellformed?(semantic_interp.T), (booleans.∧(ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astWellformed?(T_p), (ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astType?(T_p) = ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astType?(semantic_interp.T)))))))))}")))
 (s_inp_TCC22 0
  (s_inp_TCC22-1 nil 3774421781 ("" (termination-tcc) nil nil)
   ((astType? def-decl "astType" ast nil)
    (reduce_nat adt-def-decl "[pre_ast -> nat]" pre_ast nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (¬ const-decl "[bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (V_S formal-type-decl nil semantic_interp nil)
    (bound formal-const-decl "posnat" semantic_interp nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_interp nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_interp nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_interp nil)
    (astMeasure const-decl "nat" pre_ast nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (s_inp termination
    "semantic_interp.s_inp(semantic_interp.P_inp, semantic_interp.T0)"
    "nil")))
 (s_inp_TCC23 0
  (s_inp_TCC23-1 nil 3774421781
   ("" (skeep*)
    (("" (assert)
      (("" (typepred ("T0" "v(P_inp, T0)")) (("" (assert) nil nil))
        nil))
      nil))
    nil)
   ((V_T formal-nonempty-type-decl nil semantic_interp nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_interp nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_interp nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_interp nil)
    (V_S formal-type-decl nil semantic_interp nil)
    (pre_ast type-decl nil pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (¬ const-decl "[bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (astMeasure const-decl "nat" pre_ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (astType type-decl nil ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (astType? def-decl "astType" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (s_inp subtype
    "semantic_interp.s_inp(semantic_interp.P_inp, semantic_interp.T0)"
    "{T: pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].pre_ast | (booleans.¬)(pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].skip?(T))}")))
 (s_inp_TCC24 0
  (s_inp_TCC24-1 nil 3774421781 ("" (termination-tcc) nil nil)
   ((astType? def-decl "astType" ast nil)
    (reduce_nat adt-def-decl "[pre_ast -> nat]" pre_ast nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (¬ const-decl "[bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (V_S formal-type-decl nil semantic_interp nil)
    (bound formal-const-decl "posnat" semantic_interp nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_interp nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_interp nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_interp nil)
    (astMeasure const-decl "nat" pre_ast nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (s_inp termination
    "semantic_interp.s_inp(semantic_interp.P_inp, semantic_interp.Ts)"
    "nil")))
 (s_inp_TCC25 0
  (s_inp_TCC25-1 nil 3774421781
   ("" (skeep*)
    (("" (assert)
      (("" (typepred ("Ts" "v(P_inp, Ts)"))
        (("" (assert)
          (("" (assert) (("" (assert) (("" (grind) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((subterm adt-def-decl "boolean" pre_ast nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_interp nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_interp nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_interp nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_interp nil)
    (V_S formal-type-decl nil semantic_interp nil)
    (pre_ast type-decl nil pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (astMeasure const-decl "nat" pre_ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (astType type-decl nil ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (astType? def-decl "astType" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (s_inp subtype
    "semantic_interp.s_inp(semantic_interp.P_inp, semantic_interp.Ts)"
    "{T: pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].pre_ast | booleans.OR(pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].skip?(T), booleans.OR(pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].plus?(T), pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].fail?(T)))}")))
 (s_inp_TCC26 0
  (s_inp_TCC26-1 nil 3774421781
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (assert)
        (("" (typepred ("v(P_inp, T0)" "v(P_inp, Ts)"))
          (("1" (split 2)
            (("1" (expand "semanticTree?")
              (("1" (skeep)
                (("1" (inst - "T_p")
                  (("1" (inst - "T_p")
                    (("1" (expand "subterm" -1)
                      (("1" (split -1)
                        (("1" (assert) nil nil) ("2" (assert) nil nil)
                         ("3" (assert) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (expand "astWellformed?" 1)
              (("2" (flatten)
                (("2" (assert)
                  (("2" (flatten)
                    (("2" (lemma "Wellformed_theorem")
                      (("2" (inst -1 "v(P_inp, T0)")
                        (("2" (assert)
                          (("2" (flatten)
                            (("2" (split 1)
                              (("1"
                                (flatten)
                                (("1"
                                  (assert)
                                  (("1"
                                    (flatten)
                                    (("1" (assert) nil nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (flatten)
                                (("2"
                                  (assert)
                                  (("2"
                                    (flatten)
                                    (("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil)
                               ("3"
                                (expand "astType?" 1)
                                (("3"
                                  (assert)
                                  (("3"
                                    (split -2)
                                    (("1" (assert) nil nil)
                                     ("2"
                                      (assert)
                                      (("2"
                                        (lift-if 1)
                                        (("2"
                                          (lift-if 1)
                                          (("2"
                                            (lift-if 1)
                                            (("2"
                                              (split 1)
                                              (("1"
                                                (assert)
                                                (("1"
                                                  (flatten)
                                                  (("1"
                                                    (assert)
                                                    (("1"
                                                      (split 1)
                                                      (("1"
                                                        (propax)
                                                        nil
                                                        nil)
                                                       ("2"
                                                        (flatten)
                                                        (("2"
                                                          (split)
                                                          (("1"
                                                            (propax)
                                                            nil
                                                            nil)
                                                           ("2"
                                                            (assert)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (flatten)
                                                (("2"
                                                  (split)
                                                  (("1"
                                                    (split)
                                                    (("1"
                                                      (split)
                                                      (("1"
                                                        (propax)
                                                        nil
                                                        nil)
                                                       ("2"
                                                        (flatten)
                                                        (("2"
                                                          (split 1)
                                                          (("1"
                                                            (propax)
                                                            nil
                                                            nil)
                                                           ("2"
                                                            (flatten)
                                                            (("2"
                                                              (split 2)
                                                              (("1"
                                                                (propax)
                                                                nil
                                                                nil)
                                                               ("2"
                                                                (flatten)
                                                                (("2"
                                                                  (assert)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (flatten)
                                                      (("2"
                                                        (split 1)
                                                        (("1"
                                                          (propax)
                                                          nil
                                                          nil)
                                                         ("2"
                                                          (flatten)
                                                          (("2"
                                                            (assert)
                                                            (("2"
                                                              (split 2)
                                                              (("1"
                                                                (propax)
                                                                nil
                                                                nil)
                                                               ("2"
                                                                (assert)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (ground)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (replace -1 * LR)
            (("2" (hide - 2 3) (("2" (grind) nil nil)) nil)) nil)
           ("3" (replace -1 * LR)
            (("3" (hide - 2 3) (("3" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((¬ const-decl "[bool -> bool]" booleans nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (astMeasure const-decl "nat" pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_interp nil)
    (bound formal-const-decl "posnat" semantic_interp nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_interp nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_interp nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_interp nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (subterm adt-def-decl "boolean" pre_ast nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[pre_ast -> nat]" pre_ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (s_inp subtype
    "pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].plus(semantic_interp.s, semantic_interp.e, semantic_interp.s_inp(semantic_interp.P_inp, semantic_interp.T0), semantic_interp.s_inp(semantic_interp.P_inp, semantic_interp.Ts))"
    "{T_p: pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].semanticTree | booleans.∧((booleans.∧((booleans.⇔(pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].skip?(semantic_interp.T), pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].skip?(T_p))), booleans.∧((booleans.⇔(pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].star?(semantic_interp.T), pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].star?(T_p))), booleans.∧((booleans.⇔((ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astType?(semantic_interp.T) = ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].failure), pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].fail?(T_p))), ((booleans.⇒(pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].plus?(semantic_interp.T), (booleans.∨(pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].plus?(T_p), pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].fail?(T_p)))))))))), booleans.∧((pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].s(T_p) = pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].s(semantic_interp.T)), booleans.∧((pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].e(T_p) = pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].e(semantic_interp.T)), (booleans.⇒(ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astWellformed?(semantic_interp.T), (booleans.∧(ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astWellformed?(T_p), (ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astType?(T_p) = ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astType?(semantic_interp.T)))))))))}")))
 (s_inp_TCC27 0
  (s_inp_TCC27-1 nil 3774421781 ("" (termination-tcc) nil nil)
   ((/= const-decl "boolean" notequal nil)
    (astType? def-decl "astType" ast nil)
    (reduce_nat adt-def-decl "[pre_ast -> nat]" pre_ast nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (¬ const-decl "[bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (V_S formal-type-decl nil semantic_interp nil)
    (bound formal-const-decl "posnat" semantic_interp nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_interp nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_interp nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_interp nil)
    (astMeasure const-decl "nat" pre_ast nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (s_inp termination
    "semantic_interp.s_inp(semantic_interp.P_inp, semantic_interp.T0)"
    "nil")))
 (s_inp_TCC28 0
  (s_inp_TCC28-1 nil 3774421781
   ("" (skeep*)
    (("" (assert)
      (("" (typepred ("T0" "v(P_inp, T0)")) (("" (assert) nil nil))
        nil))
      nil))
    nil)
   ((V_T formal-nonempty-type-decl nil semantic_interp nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_interp nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_interp nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_interp nil)
    (V_S formal-type-decl nil semantic_interp nil)
    (pre_ast type-decl nil pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (¬ const-decl "[bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (astMeasure const-decl "nat" pre_ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (astType type-decl nil ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (astType? def-decl "astType" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (s_inp subtype
    "semantic_interp.s_inp(semantic_interp.P_inp, semantic_interp.T0)"
    "{T: pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].pre_ast | (booleans.¬)(pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].skip?(T))}")))
 (s_inp_TCC29 0
  (s_inp_TCC29-1 nil 3774421781
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (assert)
        (("" (typepred "v(P_inp, T0)")
          (("1" (split 2)
            (("1" (expand "semanticTree?")
              (("1" (skeep)
                (("1" (inst - "T_p")
                  (("1" (expand "subterm" -1) (("1" (assert) nil nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (expand "astWellformed?" 1)
              (("2" (flatten)
                (("2" (lemma "Wellformed_theorem")
                  (("2" (inst - "T0")
                    (("2" (assert)
                      (("2" (flatten)
                        (("2" (split 1)
                          (("1" (propax) nil nil)
                           ("2" (assert)
                            (("2" (flatten) (("2" (assert) nil nil))
                              nil))
                            nil)
                           ("3" (flatten) (("3" (assert) nil nil)) nil)
                           ("4" (expand "astType?" 1)
                            (("4" (assert)
                              (("4"
                                (lift-if 1)
                                (("4"
                                  (split 1)
                                  (("1"
                                    (flatten)
                                    (("1" (assert) nil nil))
                                    nil)
                                   ("2"
                                    (flatten)
                                    (("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (replace -1 * LR)
            (("2" (hide - 2 3) (("2" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((¬ const-decl "[bool -> bool]" booleans nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (astMeasure const-decl "nat" pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_interp nil)
    (bound formal-const-decl "posnat" semantic_interp nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_interp nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_interp nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_interp nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (subterm adt-def-decl "boolean" pre_ast nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[pre_ast -> nat]" pre_ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (s_inp subtype
    "pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].opt(semantic_interp.s, semantic_interp.e, semantic_interp.s_inp(semantic_interp.P_inp, semantic_interp.T0))"
    "{T_p: pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].semanticTree | booleans.∧((booleans.∧((booleans.⇔(pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].skip?(semantic_interp.T), pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].skip?(T_p))), booleans.∧((booleans.⇔(pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].star?(semantic_interp.T), pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].star?(T_p))), booleans.∧((booleans.⇔((ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astType?(semantic_interp.T) = ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].failure), pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].fail?(T_p))), ((booleans.⇒(pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].plus?(semantic_interp.T), (booleans.∨(pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].plus?(T_p), pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].fail?(T_p)))))))))), booleans.∧((pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].s(T_p) = pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].s(semantic_interp.T)), booleans.∧((pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].e(T_p) = pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].e(semantic_interp.T)), (booleans.⇒(ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astWellformed?(semantic_interp.T), (booleans.∧(ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astWellformed?(T_p), (ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astType?(T_p) = ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astType?(semantic_interp.T)))))))))}")))
 (s_inp_TCC30 0
  (s_inp_TCC30-1 nil 3774421781 ("" (termination-tcc) nil nil)
   ((astType? def-decl "astType" ast nil)
    (reduce_nat adt-def-decl "[pre_ast -> nat]" pre_ast nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (¬ const-decl "[bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (V_S formal-type-decl nil semantic_interp nil)
    (bound formal-const-decl "posnat" semantic_interp nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_interp nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_interp nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_interp nil)
    (astMeasure const-decl "nat" pre_ast nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (s_inp termination
    "semantic_interp.s_inp(semantic_interp.P_inp, semantic_interp.T)"
    "nil")))
 (s_inp_TCC31 0
  (s_inp_TCC31-1 nil 3774421781
   ("" (skeep*)
    (("" (assert)
      (("" (typepred ("T1" "v(P_inp, T1)")) (("" (assert) nil nil))
        nil))
      nil))
    nil)
   ((V_T formal-nonempty-type-decl nil semantic_interp nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_interp nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_interp nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_interp nil)
    (V_S formal-type-decl nil semantic_interp nil)
    (pre_ast type-decl nil pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (¬ const-decl "[bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (astMeasure const-decl "nat" pre_ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (astType type-decl nil ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (astType? def-decl "astType" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (s_inp subtype
    "semantic_interp.s_inp(semantic_interp.P_inp, semantic_interp.T)"
    "{T: pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].pre_ast | (booleans.¬)(pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].skip?(T))}")))
 (s_inp_TCC32 0
  (s_inp_TCC32-1 nil 3774421781
   ("" (skeep*)
    (("" (assert)
      (("" (replace -1 * LR)
        (("" (typepred "v(P_inp, T1)")
          (("1" (split 2)
            (("1" (expand "semanticTree?")
              (("1" (skeep)
                (("1" (inst - "T_p")
                  (("1" (expand "subterm" -1) (("1" (assert) nil nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (assert) nil nil) ("3" (assert) nil nil)
             ("4" (expand "astWellformed?" 1)
              (("4" (flatten)
                (("4" (assert)
                  (("4" (lemma "Wellformed_theorem")
                    (("4" (inst -1 "T1")
                      (("4" (assert)
                        (("4" (flatten)
                          (("4" (assert)
                            (("4" (expand "astType?" 1)
                              (("4" (ground) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (replace -1 * LR)
            (("2" (hide - 2 3) (("2" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((¬ const-decl "[bool -> bool]" booleans nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (astMeasure const-decl "nat" pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_interp nil)
    (bound formal-const-decl "posnat" semantic_interp nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_interp nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_interp nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_interp nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (subterm adt-def-decl "boolean" pre_ast nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[pre_ast -> nat]" pre_ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (s_inp subtype
    "pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].notP(semantic_interp.s, semantic_interp.e, semantic_interp.s_inp(semantic_interp.P_inp, semantic_interp.T))"
    "{T_p: pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].semanticTree | booleans.∧((booleans.∧((booleans.⇔(pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].skip?(semantic_interp.T), pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].skip?(T_p))), booleans.∧((booleans.⇔(pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].star?(semantic_interp.T), pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].star?(T_p))), booleans.∧((booleans.⇔((ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astType?(semantic_interp.T) = ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].failure), pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].fail?(T_p))), ((booleans.⇒(pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].plus?(semantic_interp.T), (booleans.∨(pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].plus?(T_p), pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].fail?(T_p)))))))))), booleans.∧((pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].s(T_p) = pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].s(semantic_interp.T)), booleans.∧((pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].e(T_p) = pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].e(semantic_interp.T)), (booleans.⇒(ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astWellformed?(semantic_interp.T), (booleans.∧(ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astWellformed?(T_p), (ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astType?(T_p) = ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astType?(semantic_interp.T)))))))))}")))
 (s_inp_TCC33 0
  (s_inp_TCC33-1 nil 3774421781 ("" (termination-tcc) nil nil)
   ((astType? def-decl "astType" ast nil)
    (reduce_nat adt-def-decl "[pre_ast -> nat]" pre_ast nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (¬ const-decl "[bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (V_S formal-type-decl nil semantic_interp nil)
    (bound formal-const-decl "posnat" semantic_interp nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_interp nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_interp nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_interp nil)
    (astMeasure const-decl "nat" pre_ast nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (s_inp termination
    "semantic_interp.s_inp(semantic_interp.P_inp, semantic_interp.T)"
    "nil")))
 (s_inp_TCC34 0
  (s_inp_TCC34-1 nil 3774421781
   ("" (skeep*)
    (("" (assert)
      (("" (typepred ("T1" "v(P_inp, T1)")) (("" (assert) nil nil))
        nil))
      nil))
    nil)
   ((V_T formal-nonempty-type-decl nil semantic_interp nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_interp nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_interp nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_interp nil)
    (V_S formal-type-decl nil semantic_interp nil)
    (pre_ast type-decl nil pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (¬ const-decl "[bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (astMeasure const-decl "nat" pre_ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (astType type-decl nil ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (astType? def-decl "astType" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (s_inp subtype
    "semantic_interp.s_inp(semantic_interp.P_inp, semantic_interp.T)"
    "{T: pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].pre_ast | (booleans.¬)(pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].skip?(T))}")))
 (s_inp_TCC35 0
  (s_inp_TCC35-1 nil 3774421781
   ("" (skeep*)
    (("" (assert)
      (("" (replace -1 * LR)
        (("" (assert)
          (("" (typepred "v(P_inp, T1)")
            (("1" (split 2)
              (("1" (expand "semanticTree?")
                (("1" (skeep)
                  (("1" (inst - "T_p")
                    (("1" (expand "subterm" -1)
                      (("1" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil)
               ("2" (expand "astWellformed?" 1)
                (("2" (flatten)
                  (("2" (assert)
                    (("2" (lemma "Wellformed_theorem")
                      (("2" (inst -1 "T1")
                        (("2" (assert)
                          (("2" (assert)
                            (("2" (flatten)
                              (("2"
                                (assert)
                                (("2"
                                  (expand "astType?" 1)
                                  (("2" (propax) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (replace -1 * LR)
              (("2" (hide - 2 3) (("2" (grind) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((reduce_nat adt-def-decl "[pre_ast -> nat]" pre_ast nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (subterm adt-def-decl "boolean" pre_ast nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_interp nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_interp nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_interp nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_interp nil)
    (V_S formal-type-decl nil semantic_interp nil)
    (pre_ast type-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (astMeasure const-decl "nat" pre_ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (astType type-decl nil ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (astType? def-decl "astType" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (¬ const-decl "[bool -> bool]" booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (s_inp subtype
    "pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].andP(semantic_interp.s, semantic_interp.e, semantic_interp.s_inp(semantic_interp.P_inp, semantic_interp.T))"
    "{T_p: pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].semanticTree | booleans.∧((booleans.∧((booleans.⇔(pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].skip?(semantic_interp.T), pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].skip?(T_p))), booleans.∧((booleans.⇔(pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].star?(semantic_interp.T), pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].star?(T_p))), booleans.∧((booleans.⇔((ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astType?(semantic_interp.T) = ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].failure), pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].fail?(T_p))), ((booleans.⇒(pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].plus?(semantic_interp.T), (booleans.∨(pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].plus?(T_p), pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].fail?(T_p)))))))))), booleans.∧((pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].s(T_p) = pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].s(semantic_interp.T)), booleans.∧((pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].e(T_p) = pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].e(semantic_interp.T)), (booleans.⇒(ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astWellformed?(semantic_interp.T), (booleans.∧(ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astWellformed?(T_p), (ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astType?(T_p) = ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astType?(semantic_interp.T)))))))))}")))
 (s_inp_TCC36 0
  (s_inp_TCC36-1 nil 3774421781
   ("" (skeep*) (("" (assert) (("" (grind) nil nil)) nil)) nil)
   ((semanticTree? const-decl "bool" pre_ast nil)
    (subterm adt-def-decl "boolean" pre_ast nil)
    (astType? def-decl "astType" ast nil)
    (V_T formal-nonempty-type-decl nil semantic_interp nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_interp nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_interp nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_interp nil)
    (V_S formal-type-decl nil semantic_interp nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (s_inp subtype "semantic_interp.T"
    "{T_p: pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].semanticTree | booleans.∧((booleans.∧((booleans.⇔(pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].skip?(semantic_interp.T), pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].skip?(T_p))), booleans.∧((booleans.⇔(pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].star?(semantic_interp.T), pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].star?(T_p))), booleans.∧((booleans.⇔((ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astType?(semantic_interp.T) = ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].failure), pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].fail?(T_p))), ((booleans.⇒(pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].plus?(semantic_interp.T), (booleans.∨(pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].plus?(T_p), pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].fail?(T_p)))))))))), booleans.∧((pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].s(T_p) = pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].s(semantic_interp.T)), booleans.∧((pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].e(T_p) = pre_ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].e(semantic_interp.T)), (booleans.⇒(ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astWellformed?(semantic_interp.T), (booleans.∧(ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astWellformed?(T_p), (ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astType?(T_p) = ast[semantic_interp.V_T, semantic_interp.<=, semantic_interp.V_N_b, semantic_interp.bound, semantic_interp.V_S].astType?(semantic_interp.T)))))))))}")))
 (s_inp_TCC37 0
  (s_inp_TCC37-1 nil 3774421781
   ("" (skeep*) (("" (assert) (("" (grind) nil nil)) nil)) nil)
   ((astType? def-decl "astType" ast nil)
    (V_T formal-nonempty-type-decl nil semantic_interp nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_interp nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_interp nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_interp nil)
    (V_S formal-type-decl nil semantic_interp nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (s_inp cases "semantic_interp.T" "pre_ast: DATATYPE
 BEGIN
  skip(s, e: below, G: Δ): skip?
  fail(s, e: below): fail?
  ε(s, e: below): ε?
  any(s, e: below, x: V_T): any?
  terminal(s, e: below, a: V_T, x: V_T): terminal?
  range(s, e: below, a, b: V_T, x: V_T): range?
  nonTerminal(s, e: below, A: V_N, T: {T: pre_ast | ¬skip?(T)}): nonTerminal?
  semantic(s, e: below, A: V_N, S: V_S): semantic?
  seq(s, e: below, T1: {T: pre_ast | ¬skip?(T)}, T2: pre_ast): seq?
  prior(s, e: below, T1: {T: pre_ast | ¬skip?(T)}, T2: pre_ast): prior?
  star(s, e: below, T0: {T: pre_ast | ¬skip?(T)}, Ts: {T: pre_ast | skip?(T) OR star?(T)}): star?
  plus(s, e: below, T0: {T: pre_ast | ¬skip?(T)}, Ts: {T: pre_ast | skip?(T) OR plus?(T) OR fail?(T)}): plus?
  opt(s, e: below, T0: {T: pre_ast | ¬skip?(T)}): opt?
  notP(s, e: below, T: {T: pre_ast | ¬skip?(T)}): notP?
  andP(s, e: below, T: {T: pre_ast | ¬skip?(T)}): andP?
 END pre_ast")))
 (semantic_interp_bounds 0
  (semantic_interp_bounds-1 nil 3774442770
   ("" (skeep)
    (("" (typepred "s_inp(P_inp, T)") (("" (assert) nil nil)) nil))
    nil)
   ((ast type-eq-decl nil ast nil)
    (s_inp def-decl "{T_p: semanticTree |
   ((skip?(T) ⇔ skip?(T_p)) ∧
     (star?(T) ⇔ star?(T_p)) ∧
      ((astType?(T) = failure) ⇔ fail?(T_p)) ∧
       ((plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p)))))
    ∧
    (s(T_p) = s(T)) ∧
     (e(T_p) = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_interp nil)
    (bound formal-const-decl "posnat" semantic_interp nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_interp nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_interp nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_interp nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak))
 (semantic_interp_type 0
  (semantic_interp_type-1 nil 3774442901
   ("" (skeep)
    (("" (typepred "s_inp(P_inp, T)") (("" (assert) nil nil)) nil))
    nil)
   ((ast type-eq-decl nil ast nil)
    (s_inp def-decl "{T_p: semanticTree |
   ((skip?(T) ⇔ skip?(T_p)) ∧
     (star?(T) ⇔ star?(T_p)) ∧
      ((astType?(T) = failure) ⇔ fail?(T_p)) ∧
       ((plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p)))))
    ∧
    (s(T_p) = s(T)) ∧
     (e(T_p) = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_interp nil)
    (bound formal-const-decl "posnat" semantic_interp nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_interp nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_interp nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_interp nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak))
 (semantic_interp_theorem 0
  (semantic_interp_theorem-1 nil 3774443023
   ("" (skeep)
    (("" (typepred "s_inp(P_inp, T)") (("" (propax) nil nil)) nil))
    nil)
   ((ast type-eq-decl nil ast nil)
    (s_inp def-decl "{T_p: semanticTree |
   ((skip?(T) ⇔ skip?(T_p)) ∧
     (star?(T) ⇔ star?(T_p)) ∧
      ((astType?(T) = failure) ⇔ fail?(T_p)) ∧
       ((plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p)))))
    ∧
    (s(T_p) = s(T)) ∧
     (e(T_p) = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_interp nil)
    (bound formal-const-decl "posnat" semantic_interp nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_interp nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_interp nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_interp nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak))
 (semantic_interp_props 0
  (semantic_interp_props-1 nil 3776088442
   ("" (skeep)
    (("" (lemma "semantic_interp_bounds")
      (("" (inst -1 "T" "P_inp")
        (("" (assert)
          (("" (flatten)
            (("" (assert)
              (("" (lemma "semantic_interp_type")
                (("" (inst -1 "T" "P_inp")
                  (("" (assert)
                    (("" (lemma "semantic_interp_theorem")
                      (("" (inst -1 "T" "P_inp") nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((semantic_interp_bounds formula-decl nil semantic_interp nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_interp nil)
    (bound formal-const-decl "posnat" semantic_interp nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_interp nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_interp nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_interp nil))
   shostak)))
