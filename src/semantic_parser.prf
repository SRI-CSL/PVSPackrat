(semantic_parser
 (results_TCC1 0
  (results_TCC1-1 nil 3774443161
   ("" (assert) (("" (expand "subterm") (("" (propax) nil nil)) nil))
    nil)
   ((subterm adt-def-decl "boolean" peg nil)
    (subterm_of? const-decl "bool" peg nil))
   shostak
   (results subtype "semantic_parser.P_exp(semantic_parser.A)"
    "peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].subterm_of(semantic_parser.P_exp(semantic_parser.A))")))
 (results_TCC2 0
  (results_TCC2-1 nil 3774443161
   ("" (skeep*)
    (("" (assert)
      (("" (typepred "P_exp")
        (("" (use "WF_nT_rewrite")
          (("" (flatten)
            (("" (expand "pattern_WF?") (("" (inst - A) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (WF_nT_rewrite formula-decl nil static_analysis nil)
    (pattern_WF? const-decl "bool" wf_peg nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (peg type-decl nil peg nil) (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak
   (results subtype "semantic_parser.s"
    "{k: naturalnumbers.upto(semantic_parser.s) | booleans.IMPLIES((k = semantic_parser.s), wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].pattern_wf?(semantic_parser.P_exp(semantic_parser.A), semantic_parser.A, static_analysis[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].σ(semantic_parser.P_exp), wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].P_0c(semantic_parser.P_exp)))}")))
 (sempp_TCC1 0
  (sempp_TCC4-1 nil 3774443162
   ("" (skeep)
    (("" (assert) (("" (expand "subterm") (("" (propax) nil nil)) nil))
      nil))
    nil)
   ((subterm_of? const-decl "bool" peg nil)
    (subterm adt-def-decl "boolean" peg nil))
   shostak
   (sempp subtype "semantic_parser.P_exp(semantic_parser.A)"
    "peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].subterm_of(semantic_parser.P_exp(semantic_parser.A))")))
 (sempp_TCC2 0
  (sempp_TCC5-1 nil 3774443162
   ("" (skeep)
    (("" (assert)
      (("" (use "WF_nT_rewrite")
        (("" (flatten)
          (("" (expand "pattern_WF?") (("" (inst - A) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (pattern_WF? const-decl "bool" wf_peg nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil) (peg type-decl nil peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (WF_nT_rewrite formula-decl nil static_analysis nil))
   shostak
   (sempp subtype "semantic_parser.s"
    "{k: naturalnumbers.upto(semantic_parser.s) | booleans.IMPLIES((k = semantic_parser.s), wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].pattern_wf?(semantic_parser.P_exp(semantic_parser.A), semantic_parser.A, static_analysis[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].σ(semantic_parser.P_exp), wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].P_0c(semantic_parser.P_exp)))}")))
 (sempp_TCC3 0
  (sempp_TCC1-1 nil 3774443161 ("" (skeep) (("" (assert) nil nil)) nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   shostak
   (sempp subtype
    "(number_fields.-)(semantic_parser.bound, semantic_parser.s_T)"
    "nat")))
 (sempp_TCC4 0
  (sempp_TCC2-1 nil 3774443161 ("" (skeep) (("" (assert) nil nil)) nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   shostak
   (sempp subtype
    "(number_fields.-)(semantic_parser.bound, semantic_parser.s)"
    "nat")))
 (sempp_TCC5 0
  (sempp_TCC7-1 nil 3774443162
   ("" (skeep)
    (("" (assert) (("" (typepred "z`7") (("" (assert) nil nil)) nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (below type-eq-decl nil naturalnumbers nil)
    (subterm_of type-eq-decl nil peg nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil) (peg type-decl nil peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (saved_result type-decl nil semantic_parser nil)
    (known? adt-recognizer-decl "[saved_result -> boolean]"
     semantic_parser nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (astType type-decl nil ast nil) (pre_ast type-decl nil pre_ast nil)
    (astType? def-decl "astType" ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil) (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (status adt-accessor-decl
            "[(known?) -> astType[V_T, <=, V_N_b, bound, V_S]]"
            semantic_parser nil)
    (T adt-accessor-decl
     "[(known?) -> pre_ast[V_T, <=, V_N_b, bound, V_S]]"
     semantic_parser nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail adt-constructor-decl "[[below, below] -> (fail?)]" pre_ast
     nil)
    (semantic? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (semantic adt-constructor-decl
     "[[below, below, V_N[V_N_b], V_S] -> (semantic?)]" pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (results type-eq-decl nil semantic_parser nil))
   shostak
   (sempp subtype
    "(number_fields.-)(semantic_parser.bound, semantic_parser.z`7)"
    "nat")))
 (sempp_TCC6 0
  (sempp_TCC3-1 nil 3774443162 ("" (skeep) (("" (assert) nil nil)) nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   shostak
   (sempp subtype
    "(number_fields.-)(semantic_parser.bound, semantic_parser.z`6)"
    "nat")))
 (sempp_TCC7 0
  (sempp_TCC8-1 nil 3774443162 ("" (skeep) (("" (assert) nil nil)) nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   shostak
   (sempp subtype
    "(number_fields.-)(semantic_parser.bound, semantic_parser.s_T)"
    "nat")))
 (sempp_TCC8 0
  (sempp_TCC9-1 nil 3774443162 ("" (skeep) (("" (assert) nil nil)) nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   shostak
   (sempp subtype
    "(number_fields.-)(semantic_parser.bound, semantic_parser.s)"
    "nat")))
 (sempp_TCC9 0
  (sempp_TCC11-1 nil 3774443163
   ("" (skeep*)
    (("" (replace -1 * LR) (("" (assert) (("" (grind) nil nil)) nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (astType? def-decl "astType" ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak
   (sempp subtype
    "ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].success"
    "semantic_parser.astTypeOf(peg_parser[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].parsing(semantic_parser.P_exp, semantic_parser.A, semantic_parser.G, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T))")))
 (sempp_TCC10 0
  (sempp_TCC6-1 nil 3774443162
   ("" (skeep)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (expand "s_inp")
          (("" (assert)
            (("" (lift-if)
              (("" (ground)
                (("1" (lift-if 1)
                  (("1" (assert)
                    (("1" (split)
                      (("1" (flatten)
                        (("1" (assert) (("1" (grind) nil nil)) nil))
                        nil)
                       ("2" (grind) nil nil))
                      nil))
                    nil))
                  nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   shostak
   (sempp subtype
    "pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].ε(semantic_parser.s, semantic_parser.s)"
    "semantic_parser.equalTo(semantic_interp[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].s_inp(semantic_parser.P_inp, peg_parser[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].parsing(semantic_parser.P_exp, semantic_parser.A, semantic_parser.G, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T)))")))
 (sempp_TCC11 0
  (sempp_TCC10-1 nil 3774443162
   ("" (skeep*) (("" (grind) nil nil)) nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (astType? def-decl "astType" ast nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (posint_min application-judgement "{k: posint | k <= i AND k <= j}"
     real_defs nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak
   (sempp subtype
    "ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].failure"
    "semantic_parser.astTypeOf(peg_parser[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].parsing(semantic_parser.P_exp, semantic_parser.A, semantic_parser.G, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T))")))
 (sempp_TCC12 0
  (sempp_TCC81-1 nil 3775125996
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (expand "s_inp")
          (("" (expand "astType?")
            (("" (expand "min") (("" (assert) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype
    "pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].fail(semantic_parser.s, semantic_parser.s)"
    "semantic_parser.equalTo(semantic_interp[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].s_inp(semantic_parser.P_inp, peg_parser[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].parsing(semantic_parser.P_exp, semantic_parser.A, semantic_parser.G, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T)))")))
 (sempp_TCC13 0
  (sempp_TCC12-1 nil 3774443168
   ("" (skeep*)
    (("" (replace -1 * LR) (("" (hide -1) (("" (grind) nil nil)) nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (astType? def-decl "astType" ast nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (posint_min application-judgement "{k: posint | k <= i AND k <= j}"
     real_defs nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak
   (sempp subtype
    "ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].success"
    "semantic_parser.astTypeOf(peg_parser[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].parsing(semantic_parser.P_exp, semantic_parser.A, semantic_parser.G, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T))")))
 (sempp_TCC14 0
  (sempp_TCC21-1 nil 3774443187
   ("" (skeep)
    (("" (typepred "res")
      (("" (inst -1 "B" "s")
        (("" (assert)
          (("" (name "T_p" "parsing(P_exp, B, P_exp(B), inp, s, s)")
            (("" (replace -1 * LR)
              (("" (flatten)
                (("" (assert)
                  (("" (split -4)
                    (("1" (grind) nil nil)
                     ("2" (typepred "T_p")
                      (("2" (use "Wellformedness_is_meaningfulness")
                        (("2" (expand "astMeaningful?")
                          (("2" (assert)
                            (("2" (replace -12 * LR)
                              (("2"
                                (expand "parsing" +)
                                (("2"
                                  (replace -12 * LR)
                                  (("2"
                                    (assert)
                                    (("2"
                                      (replace -9 * LR)
                                      (("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((results type-eq-decl nil semantic_parser nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semantic adt-constructor-decl
     "[[below, below, V_N[V_N_b], V_S] -> (semantic?)]" pre_ast nil)
    (semantic? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail adt-constructor-decl "[[below, below] -> (fail?)]" pre_ast
     nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (T adt-accessor-decl
     "[(known?) -> pre_ast[V_T, <=, V_N_b, bound, V_S]]"
     semantic_parser nil)
    (status adt-accessor-decl
            "[(known?) -> astType[V_T, <=, V_N_b, bound, V_S]]"
            semantic_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil) (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (input type-eq-decl nil ast_props nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (subterm_of type-eq-decl nil peg nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (astType? def-decl "astType" ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (astType type-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (known? adt-recognizer-decl "[saved_result -> boolean]"
     semantic_parser nil)
    (saved_result type-decl nil semantic_parser nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (<= const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil) (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   shostak
   (sempp subtype "(number_fields.+)(semantic_parser.s, 1)"
    "below[V_T, <=, V_N_b, bound, V_S]")))
 (sempp_TCC15 0
  (sempp_TCC26-1 nil 3774443196
   ("" (skeep)
    (("" (replace -1 * LR)
      (("" (expand "parsing" +)
        (("" (expand "s_inp" +)
          (("" (expand "astType?" +) (("" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (posint_min application-judgement "{k: posint | k <= i AND k <= j}"
     real_defs nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   shostak
   (sempp subtype
    "pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].any(semantic_parser.s, (number_fields.+)(semantic_parser.s, 1), semantic_parser.inp(semantic_parser.s))"
    "semantic_parser.equalTo(semantic_interp[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].s_inp(semantic_parser.P_inp, peg_parser[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].parsing(semantic_parser.P_exp, semantic_parser.A, semantic_parser.G, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T)))")))
 (sempp_TCC16 0
  (sempp_TCC27-1 nil 3774443216
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing" +)
        (("" (expand "astType?" +) (("" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_min application-judgement "{k: posint | k <= i AND k <= j}"
     real_defs nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak
   (sempp subtype
    "ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].success"
    "semantic_parser.astTypeOf(peg_parser[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].parsing(semantic_parser.P_exp, semantic_parser.A, semantic_parser.G, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T))")))
 (sempp_TCC17 0
  (sempp_TCC28-1 nil 3774443217
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing" +)
        (("" (expand "s_inp" +)
          (("" (expand "astType?" +) (("" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_min application-judgement "{k: posint | k <= i AND k <= j}"
     real_defs nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak
   (sempp subtype
    "pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].terminal(semantic_parser.s, (number_fields.+)(semantic_parser.s, 1), semantic_parser.a, semantic_parser.a)"
    "semantic_parser.equalTo(semantic_interp[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].s_inp(semantic_parser.P_inp, peg_parser[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].parsing(semantic_parser.P_exp, semantic_parser.A, semantic_parser.G, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T)))")))
 (sempp_TCC18 0
  (sempp_TCC31-1 nil 3774450009
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (expand "astType?")
          (("" (expand "min")
            (("" (assert)
              (("" (lift-if)
                (("" (assert)
                  (("" (split)
                    (("1" (split)
                      (("1" (propax) nil nil) ("2" (assert) nil nil))
                      nil)
                     ("2" (assert) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak
   (sempp subtype
    "ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].failure"
    "semantic_parser.astTypeOf(peg_parser[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].parsing(semantic_parser.P_exp, semantic_parser.A, semantic_parser.G, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T))")))
 (sempp_TCC19 0
  (sempp_TCC32-1 nil 3774450010
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing" +)
        (("" (expand "s_inp" +)
          (("" (expand "astType?" +)
            (("" (ground) (("1" (grind) nil nil) ("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (posint_min application-judgement "{k: posint | k <= i AND k <= j}"
     real_defs nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (/= const-decl "boolean" notequal nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak
   (sempp subtype
    "pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].fail(semantic_parser.s, real_defs.min((number_fields.+)(semantic_parser.s, 1), semantic_parser.bound))"
    "semantic_parser.equalTo(semantic_interp[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].s_inp(semantic_parser.P_inp, peg_parser[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].parsing(semantic_parser.P_exp, semantic_parser.A, semantic_parser.G, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T)))")))
 (sempp_TCC20 0
  (sempp_TCC34-1 nil 3774450059
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing" +)
        (("" (expand "astType?" +) (("" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_min application-judgement "{k: posint | k <= i AND k <= j}"
     real_defs nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (in_range const-decl "bool" ast nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak
   (sempp subtype
    "ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].success"
    "semantic_parser.astTypeOf(peg_parser[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].parsing(semantic_parser.P_exp, semantic_parser.A, semantic_parser.G, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T))")))
 (sempp_TCC21 0
  (sempp_TCC35-1 nil 3774450090
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing" +)
        (("" (expand "s_inp" +)
          (("" (expand "astType?" +) (("" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_min application-judgement "{k: posint | k <= i AND k <= j}"
     real_defs nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (in_range const-decl "bool" ast nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak
   (sempp subtype
    "pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].range(semantic_parser.s, (number_fields.+)(semantic_parser.s, 1), semantic_parser.a, semantic_parser.b, semantic_parser.inp(semantic_parser.s))"
    "semantic_parser.equalTo(semantic_interp[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].s_inp(semantic_parser.P_inp, peg_parser[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].parsing(semantic_parser.P_exp, semantic_parser.A, semantic_parser.G, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T)))")))
 (sempp_TCC22 0
  (sempp_TCC36-1 nil 3774450090
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (expand "astType?")
          (("" (expand "min")
            (("" (assert)
              (("" (split)
                (("1" (assert) nil nil)
                 ("2" (assert)
                  (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak
   (sempp subtype
    "ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].failure"
    "semantic_parser.astTypeOf(peg_parser[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].parsing(semantic_parser.P_exp, semantic_parser.A, semantic_parser.G, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T))")))
 (sempp_TCC23 0
  (sempp_TCC53-1 nil 3777620320
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (expand "s_inp")
          (("" (expand "astType?")
            (("" (expand "min")
              (("" (assert)
                (("" (split)
                  (("1" (lift-if) (("1" (assert) nil nil)) nil)
                   ("2" (lift-if) (("2" (assert) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype
    "pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].fail(semantic_parser.s, real_defs.min((number_fields.+)(semantic_parser.s, 1), semantic_parser.bound))"
    "semantic_parser.equalTo(semantic_interp[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].s_inp(semantic_parser.P_inp, peg_parser[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].parsing(semantic_parser.P_exp, semantic_parser.A, semantic_parser.G, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T)))")))
 (sempp_TCC24 0
  (sempp_TCC61-1 nil 3775125996
   ("" (skolem-typepred) (("" (inst? -) (("" (grind) nil nil)) nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (structural_WF? const-decl "bool" wf_peg nil)
    (interval_list const-decl "list[nat]" interval_list nil)
    (nodes const-decl "node_ls" static_analysis nil)
    (dependency_graph const-decl "c_digraph[nat]" static_analysis nil)
    (size const-decl "nat" c_digraphs_def digraphs)
    (node const-decl "{v: T | member(v, data(cd))}" c_digraphs_def
     digraphs)
    (empty_marking const-decl "marking" c_topological_sort digraphs)
    (gen_seq1 const-decl "Seq(G)" walks_ digraphs)
    (topological_sort_aux def-decl
     "{res: [loop(G) + [non_temporary_marking, list[Vert(G)]]] |
   CASES res
     OF IN_1(loop): TRUE,
        IN_2(res):
          LET (mp, lp) = res IN
            topperm_list(G, mp)(lp) ∧
             greater_marking(mp, m) ∧
              suffix?(l, lp) ∧ FORALL (i: upto(n)): member(node(G)(i), lp)
     ENDCASES}" c_topological_sort digraphs)
    (topological_sort const-decl
     "{res: [loop(G) + (topological_ordering?(G))] | IN?_2(res) ⇔ is_dag(G)}"
     c_topological_sort digraphs)
    (subterm adt-def-decl "boolean" peg nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (results type-eq-decl nil semantic_parser nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semantic adt-constructor-decl
     "[[below, below, V_N[V_N_b], V_S] -> (semantic?)]" pre_ast nil)
    (semantic? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail adt-constructor-decl "[[below, below] -> (fail?)]" pre_ast
     nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (T adt-accessor-decl
     "[(known?) -> pre_ast[V_T, <=, V_N_b, bound, V_S]]"
     semantic_parser nil)
    (status adt-accessor-decl
            "[(known?) -> astType[V_T, <=, V_N_b, bound, V_S]]"
            semantic_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil) (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (input type-eq-decl nil ast_props nil)
    (astType? def-decl "astType" ast nil)
    (pre_ast type-decl nil pre_ast nil) (astType type-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (known? adt-recognizer-decl "[saved_result -> boolean]"
     semantic_parser nil)
    (saved_result type-decl nil semantic_parser nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (<= const-decl "bool" reals nil)
    (subterm_of type-eq-decl nil peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil) (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil
   (sempp subtype "semantic_parser.status"
    "semantic_parser.astTypeOf(peg_parser[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].parsing(semantic_parser.P_exp, semantic_parser.A, semantic_parser.G, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T))")))
 (sempp_TCC25 0
  (sempp_TCC30-1 nil 3776062507
   ("" (skolem-typepred)
    (("" (inst? -)
      (("" (flatten)
        (("" (assert)
          (("" (split -7)
            (("1" (grind) nil nil)
             ("2" (assert)
              (("2" (flatten)
                (("2" (replaces)
                  (("2" (expand ("parsing" "s_inp") +)
                    (("2" (expand "astType?" +)
                      (("2" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (TRUE const-decl "bool" booleans nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (subterm adt-def-decl "boolean" peg nil)
    (topological_sort const-decl
     "{res: [loop(G) + (topological_ordering?(G))] | IN?_2(res) ⇔ is_dag(G)}"
     c_topological_sort digraphs)
    (topological_sort_aux def-decl
     "{res: [loop(G) + [non_temporary_marking, list[Vert(G)]]] |
   CASES res
     OF IN_1(loop): TRUE,
        IN_2(res):
          LET (mp, lp) = res IN
            topperm_list(G, mp)(lp) ∧
             greater_marking(mp, m) ∧
              suffix?(l, lp) ∧ FORALL (i: upto(n)): member(node(G)(i), lp)
     ENDCASES}" c_topological_sort digraphs)
    (gen_seq1 const-decl "Seq(G)" walks_ digraphs)
    (empty_marking const-decl "marking" c_topological_sort digraphs)
    (node const-decl "{v: T | member(v, data(cd))}" c_digraphs_def
     digraphs)
    (size const-decl "nat" c_digraphs_def digraphs)
    (dependency_graph const-decl "c_digraph[nat]" static_analysis nil)
    (nodes const-decl "node_ls" static_analysis nil)
    (interval_list const-decl "list[nat]" interval_list nil)
    (structural_WF? const-decl "bool" wf_peg nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (results type-eq-decl nil semantic_parser nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semantic adt-constructor-decl
     "[[below, below, V_N[V_N_b], V_S] -> (semantic?)]" pre_ast nil)
    (semantic? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail adt-constructor-decl "[[below, below] -> (fail?)]" pre_ast
     nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (T adt-accessor-decl
     "[(known?) -> pre_ast[V_T, <=, V_N_b, bound, V_S]]"
     semantic_parser nil)
    (status adt-accessor-decl
            "[(known?) -> astType[V_T, <=, V_N_b, bound, V_S]]"
            semantic_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil) (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (input type-eq-decl nil ast_props nil)
    (astType? def-decl "astType" ast nil)
    (pre_ast type-decl nil pre_ast nil) (astType type-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (known? adt-recognizer-decl "[saved_result -> boolean]"
     semantic_parser nil)
    (saved_result type-decl nil semantic_parser nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (<= const-decl "bool" reals nil)
    (subterm_of type-eq-decl nil peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil) (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil
   (sempp subtype "semantic_parser.T_B"
    "semantic_parser.equalTo(semantic_interp[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].s_inp(semantic_parser.P_inp, peg_parser[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].parsing(semantic_parser.P_exp, semantic_parser.A, semantic_parser.G, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T)))")))
 (sempp_TCC26 0
  (sempp_TCC22-1 nil 3774443191
   ("" (skeep)
    (("" (assert) (("" (expand "subterm") (("" (propax) nil nil)) nil))
      nil))
    nil)
   ((subterm_of? const-decl "bool" peg nil)
    (subterm adt-def-decl "boolean" peg nil))
   shostak
   (sempp subtype "semantic_parser.P_exp(semantic_parser.B)"
    "peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].subterm_of(semantic_parser.P_exp(semantic_parser.B))")))
 (sempp_TCC27 0
  (sempp_TCC23-1 nil 3774443191
   ("" (skeep*)
    (("" (assert)
      (("" (use "WF_nT_rewrite")
        (("" (flatten)
          (("" (expand "pattern_WF?") (("" (inst - B) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (pattern_WF? const-decl "bool" wf_peg nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil) (peg type-decl nil peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (WF_nT_rewrite formula-decl nil static_analysis nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak
   (sempp subtype "semantic_parser.s"
    "{k: naturalnumbers.upto(semantic_parser.s) | booleans.⇒((k = semantic_parser.s), wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].pattern_wf?(semantic_parser.P_exp(semantic_parser.B), semantic_parser.B, static_analysis[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].σ(semantic_parser.P_exp), wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].P_0c(semantic_parser.P_exp)))}")))
 (sempp_TCC28 0
  (sempp_TCC24-1 nil 3774443191
   ("" (skeep*)
    (("" (assert)
      (("" (assert)
        (("" (flatten)
          (("" (assert)
            (("" (typepred "s_T")
              (("" (assert)
                (("" (replace -3 * LR) (("" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (lex4_lt formula-decl nil lex4 nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of type-eq-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (lex3_lt formula-decl nil lex3 nil)
    (lex2_lt formula-decl nil lex2 nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak
   (sempp termination
    "semantic_parser.sempp(semantic_parser.P_exp, semantic_parser.P_inp, semantic_parser.B, semantic_parser.P_exp(semantic_parser.B), semantic_parser.inp, semantic_parser.s, semantic_parser.s, semantic_parser.res)"
    "nil")))
 (sempp_TCC29 0
  (sempp_TCC35-1 nil 3776062507
   ("" (skeep*)
    (("" (typepred "T_B")
      (("" (name "T_p" " parsing(P_exp, B, P_exp(B), inp, s, s)")
        (("" (replace -1 * LR)
          (("" (lemma "semantic_interp_props")
            (("" (inst -1 "T_p" "P_inp")
              (("" (flatten)
                (("" (replace -6 * RL)
                  (("" (use "Wellformedness_is_meaningfulness")
                    (("" (expand "astMeaningful?")
                      (("" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((equalTo type-eq-decl nil semantic_parser nil)
    (below type-eq-decl nil naturalnumbers nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (ast type-eq-decl nil ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (subterm_of type-eq-decl nil peg nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (astMeaningful? const-decl "bool" ast nil)
    (Wellformedness_is_meaningfulness formula-decl nil ast nil)
    (semantic_interp_props formula-decl nil semantic_interp nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype "semantic_parser.T_B"
    "semanticTree[V_T, <=, V_N_b, bound, V_S]")))
 (sempp_TCC30 0
  (sempp_TCC65-1 nil 3777620320
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (assert)
        (("" (expand ("parsing") +)
          (("" (expand "astType?" +)
            (("" (typepred "status!1") (("" (assert) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (astTypeOf type-eq-decl nil semantic_parser nil)
    (below type-eq-decl nil naturalnumbers nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (<= const-decl "bool" reals nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (< const-decl "bool" reals nil)
    (subterm_of type-eq-decl nil peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (astType type-decl nil ast nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (astType? def-decl "astType" ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype
    "ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].success"
    "semantic_parser.astTypeOf(peg_parser[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].parsing(semantic_parser.P_exp, semantic_parser.A, semantic_parser.G, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T))")))
 (sempp_TCC31 0
  (sempp_TCC30-1 nil 3774449978
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand ("parsing") +)
        (("" (expand "s_inp" +)
          (("" (expand "astType?" +)
            (("" (typepred "status!1") (("" (assert) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (astTypeOf type-eq-decl nil semantic_parser nil)
    (below type-eq-decl nil naturalnumbers nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (<= const-decl "bool" reals nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (< const-decl "bool" reals nil)
    (subterm_of type-eq-decl nil peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (astType type-decl nil ast nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak
   (sempp subtype "semantic_parser.sem_T"
    "semantic_parser.equalTo(semantic_interp[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].s_inp(semantic_parser.P_inp, peg_parser[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].parsing(semantic_parser.P_exp, semantic_parser.A, semantic_parser.G, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T)))")))
 (sempp_TCC32 0
  (sempp_TCC107-1 nil 3777620320
   ("" (skeep*)
    (("" (lift-if -)
      (("" (assert)
        (("" (split -)
          (("1" (flatten)
            (("1" (assert)
              (("1" (replace -9 * LR) (("1" (assert) nil nil)) nil))
              nil))
            nil)
           ("2" (typepred "res1")
            (("2" (inst - "A!1" "s_1")
              (("2" (lift-if)
                (("2" (assert) (("2" (ground) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (<= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (saved_result type-decl nil semantic_parser nil)
    (known? adt-recognizer-decl "[saved_result -> boolean]"
     semantic_parser nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (astType type-decl nil ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (astType? def-decl "astType" ast nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (subterm_of type-eq-decl nil peg nil) (peg type-decl nil peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (input type-eq-decl nil ast_props nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil) (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (status adt-accessor-decl
            "[(known?) -> astType[V_T, <=, V_N_b, bound, V_S]]"
            semantic_parser nil)
    (T adt-accessor-decl
     "[(known?) -> pre_ast[V_T, <=, V_N_b, bound, V_S]]"
     semantic_parser nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail adt-constructor-decl "[[below, below] -> (fail?)]" pre_ast
     nil)
    (semantic? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (semantic adt-constructor-decl
     "[[below, below, V_N[V_N_b], V_S] -> (semantic?)]" pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (results type-eq-decl nil semantic_parser nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype
    "semantic_parser.res WITH [(semantic_parser.B, semantic_parser.s) := semantic_parser.known(ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].success, semantic_parser.sem_T)]"
    "semantic_parser.results(semantic_parser.P_exp, semantic_parser.P_inp, semantic_parser.inp)")))
 (sempp_TCC33 0
  (sempp_TCC113-1 nil 3777620320
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand ("parsing" "s_inp") +)
        (("" (expand "astType?")
          (("" (typepred "status!1")
            (("" (assert)
              ((""
                (lemma "Wellformed_theorem"
                 (T "parsing(P_exp, B, P_exp(B), inp, s, s)"))
                (("" (assert) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (astType type-decl nil ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (subterm_of type-eq-decl nil peg nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (<= const-decl "bool" reals nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (below type-eq-decl nil naturalnumbers nil)
    (astTypeOf type-eq-decl nil semantic_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype
    "ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].failure"
    "semantic_parser.astTypeOf(peg_parser[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].parsing(semantic_parser.P_exp, semantic_parser.A, semantic_parser.G, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T))")))
 (sempp_TCC34 0
  (sempp_TCC37-1 nil 3774450138
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (expand "s_inp")
          (("" (expand "astType?")
            (("" (typepred "status!1")
              (("" (assert)
                ((""
                  (lemma "Wellformed_theorem"
                   (T "parsing(P_exp, B, P_exp(B), inp, s, s)"))
                  (("" (assert)
                    (("" (flatten)
                      (("" (assert)
                        ((""
                          (lemma "semantic_interp_props"
                           (T "parsing(P_exp, B, P_exp(B), inp, s, s)"
                            P_inp P_inp))
                          (("" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (astTypeOf type-eq-decl nil semantic_parser nil)
    (below type-eq-decl nil naturalnumbers nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (<= const-decl "bool" reals nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (< const-decl "bool" reals nil)
    (subterm_of type-eq-decl nil peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (astType type-decl nil ast nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (semantic_interp_props formula-decl nil semantic_interp nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak
   (sempp subtype "semantic_parser.fail_T"
    "semantic_parser.equalTo(semantic_interp[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].s_inp(semantic_parser.P_inp, peg_parser[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].parsing(semantic_parser.P_exp, semantic_parser.A, semantic_parser.G, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T)))")))
 (sempp_TCC35 0
  (sempp_TCC38-1 nil 3774450139
   ("" (skeep*)
    (("" (lift-if -)
      (("" (split -)
        (("1" (flatten)
          (("1" (assert)
            (("1" (flatten)
              (("1" (decompose-equality -)
                (("1" (assert)
                  (("1" (typepred "T_B")
                    (("1" (typepred "status!1")
                      (("1" (assert)
                        (("1" (use "Wellformed_theorem")
                          (("1" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (flatten)
          (("2" (assert)
            (("2" (typepred "T_B")
              (("2" (typepred "status!1")
                (("2" (typepred "res1")
                  (("2" (inst - "A!1" "s_1")
                    (("2" (assert)
                      (("2" (split -1)
                        (("1" (flatten)
                          (("1" (assert)
                            (("1" (hide 4)
                              (("1"
                                (lift-if)
                                (("1" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (flatten) (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((results type-eq-decl nil semantic_parser nil)
    (semantic adt-constructor-decl
     "[[below, below, V_N[V_N_b], V_S] -> (semantic?)]" pre_ast nil)
    (semantic? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail adt-constructor-decl "[[below, below] -> (fail?)]" pre_ast
     nil)
    (T adt-accessor-decl
     "[(known?) -> pre_ast[V_T, <=, V_N_b, bound, V_S]]"
     semantic_parser nil)
    (status adt-accessor-decl
            "[(known?) -> astType[V_T, <=, V_N_b, bound, V_S]]"
            semantic_parser nil)
    (known? adt-recognizer-decl "[saved_result -> boolean]"
     semantic_parser nil)
    (saved_result type-decl nil semantic_parser nil)
    (astTypeOf type-eq-decl nil semantic_parser nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (pre_ast type-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (ast type-eq-decl nil ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (equalTo type-eq-decl nil semantic_parser nil)
    (nonTerminal adt-constructor-decl
     "[below(V_N_b) -> (nonTerminal?)]" peg nil)
    (A adt-accessor-decl "[(nonTerminal?) -> below(V_N_b)]" peg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (subterm_of type-eq-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (subterm_of? const-decl "bool" peg nil)
    (nonTerminal? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (peg type-decl nil peg nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak
   (sempp subtype
    "semantic_parser.res WITH [(semantic_parser.B, semantic_parser.s) := semantic_parser.known(ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].failure, semantic_parser.fail_T)]"
    "semantic_parser.results(semantic_parser.P_exp, semantic_parser.P_inp, semantic_parser.inp)")))
 (sempp_TCC36 0
  (sempp_TCC39-1 nil 3774450152
   ("" (skeep*)
    (("" (assert)
      (("" (use "subterm_seq" (G "P_exp(A)"))
        (("" (assert) (("" (typepred "G") (("" (assert) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((subterm_of? const-decl "bool" peg nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (subterm_of type-eq-decl nil peg nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (subterm_seq formula-decl nil peg nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak
   (sempp subtype "semantic_parser.e1"
    "peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].subterm_of(semantic_parser.P_exp(semantic_parser.A))")))
 (sempp_TCC37 0
  (sempp_TCC40-1 nil 3774450155
   ("" (skeep*)
    (("" (typepred "s_T")
      (("" (assert)
        (("" (expand "g_wf" -)
          (("" (flatten)
            (("" (replace -4 * LR) (("" (assert) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of type-eq-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak
   (sempp subtype "semantic_parser.s_T"
    "{k: naturalnumbers.upto(semantic_parser.s) | booleans.⇒((k = semantic_parser.s), wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].pattern_wf?(semantic_parser.e1, semantic_parser.A, static_analysis[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].σ(semantic_parser.P_exp), wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].P_0c(semantic_parser.P_exp)))}")))
 (sempp_TCC38 0
  (sempp_TCC41-1 nil 3774450157
   ("" (skeep*)
    (("" (rewrite "lex4_lt")
      (("" (rewrite "lex3_lt")
        (("" (rewrite "lex2_lt")
          (("" (replace -1 * LR) (("" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (lex4_lt formula-decl nil lex4 nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (<= const-decl "bool" reals nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (peg type-decl nil peg nil) (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (below type-eq-decl nil naturalnumbers nil)
    (subterm_of type-eq-decl nil peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (pegMeasure const-decl "nat" peg nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lex2_lt formula-decl nil lex2 nil)
    (lex3_lt formula-decl nil lex3 nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (sum_inc const-decl "nat" peg nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak
   (sempp termination
    "semantic_parser.sempp(semantic_parser.P_exp, semantic_parser.P_inp, semantic_parser.A, semantic_parser.e1, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T, semantic_parser.res)"
    "nil")))
 (sempp_TCC39 0
  (sempp_TCC40-1 nil 3804941352
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing" +)
        (("" (typepred "status1")
          (("" (assert)
            (("" (expand "astType?" +) (("" (propax) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astTypeOf type-eq-decl nil semantic_parser nil)
    (below type-eq-decl nil naturalnumbers nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (<= const-decl "bool" reals nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (< const-decl "bool" reals nil)
    (subterm_of type-eq-decl nil peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (astType? def-decl "astType" ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (astType type-decl nil ast nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype
    "ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].failure"
    "semantic_parser.astTypeOf(peg_parser[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].parsing(semantic_parser.P_exp, semantic_parser.A, semantic_parser.G, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T))")))
 (sempp_TCC40 0
  (sempp_TCC43-1 nil 3774450232
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (assert)
        (("" (expand "parsing" 1)
          (("" (assert)
            (("" (typepred "T1")
              ((""
                (typepred
                 " s_inp(P_inp, parsing(P_exp, A, e1, inp, s, s_T))")
                (("" (assert)
                  (("" (assert)
                    (("" (expand "s_inp" 3)
                      (("" (expand "astType?" 3)
                        (("" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (equalTo type-eq-decl nil semantic_parser nil)
    (below type-eq-decl nil naturalnumbers nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (ast type-eq-decl nil ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (subterm_of type-eq-decl nil peg nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak
   (sempp subtype
    "pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].fail(semantic_parser.s, pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].e(semantic_parser.T1))"
    "semantic_parser.equalTo(semantic_interp[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].s_inp(semantic_parser.P_inp, peg_parser[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].parsing(semantic_parser.P_exp, semantic_parser.A, semantic_parser.G, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T)))")))
 (sempp_TCC41 0
  (sempp_TCC44-1 nil 3774457949
   ("" (skeep*)
    (("" (use "subterm_seq" (G "P_exp(A)"))
      (("" (assert) (("" (typepred "G") (("" (assert) nil nil)) nil))
        nil))
      nil))
    nil)
   ((subterm_seq formula-decl nil peg nil) (peg type-decl nil peg nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (below type-eq-decl nil naturalnumbers nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (subterm_of type-eq-decl nil peg nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (subterm_of? const-decl "bool" peg nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak
   (sempp subtype "semantic_parser.e2"
    "peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].subterm_of(semantic_parser.P_exp(semantic_parser.A))")))
 (sempp_TCC42 0
  (sempp_TCC46-1 nil 3774591301
   ("" (skeep*)
    (("" (typepred "T1")
      ((""
        (typepred "s_inp(P_inp, parsing(P_exp, A, e1, inp, s, s_T))")
        (("" (assert)
          (("" (assert)
            (("" (typepred "s_T")
              (("" (use "Wellformed_theorem")
                (("" (assert)
                  (("" (flatten)
                    (("" (assert)
                      (("" (flatten)
                        (("" (assert)
                          (("" (flatten)
                            (("" (assert)
                              ((""
                                (replace -18 * LR)
                                ((""
                                  (assert)
                                  ((""
                                    (g_props)
                                    ((""
                                      (typepred
                                       "parsing(P_exp, A, e1, inp, s, s_T)")
                                      (("" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((equalTo type-eq-decl nil semantic_parser nil)
    (below type-eq-decl nil naturalnumbers nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (ast type-eq-decl nil ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (subterm_of type-eq-decl nil peg nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak
   (sempp subtype "semantic_parser.s_T"
    "{k: naturalnumbers.upto(pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].e(semantic_parser.T1)) | booleans.⇒((k = pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].e(semantic_parser.T1)), wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].pattern_wf?(semantic_parser.e2, semantic_parser.A, static_analysis[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].σ(semantic_parser.P_exp), wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].P_0c(semantic_parser.P_exp)))}")))
 (sempp_TCC43 0
  (sempp_TCC47-1 nil 3774591327
   ("" (skeep*)
    (("" (rewrite "lex4_lt")
      (("" (rewrite "lex3_lt")
        (("" (rewrite "lex2_lt")
          (("" (flatten)
            (("" (typepred "T1")
              (("" (name "T1_p" "parsing(P_exp, A, e1, inp, s, s_T)")
                (("" (lemma "semantic_interp_props")
                  (("" (inst -1 "T1_p" "P_inp")
                    (("" (replace -2 * LR)
                      (("" (replace -3 * RL)
                        (("" (flatten)
                          (("" (use "Consumption_growth")
                            (("" (assert)
                              ((""
                                (replace -8 * LR)
                                ((""
                                  (hide - 1 2)
                                  (("" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (lex4_lt formula-decl nil lex4 nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (<= const-decl "bool" reals nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (peg type-decl nil peg nil) (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (below type-eq-decl nil naturalnumbers nil)
    (subterm_of type-eq-decl nil peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (pre_ast type-decl nil pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (input type-eq-decl nil ast_props nil)
    (ast type-eq-decl nil ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (equalTo type-eq-decl nil semantic_parser nil)
    (pegMeasure const-decl "nat" peg nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (Consumption_growth formula-decl nil ast nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (sum_inc const-decl "nat" peg nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (semantic_interp_props formula-decl nil semantic_interp nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (lex2_lt formula-decl nil lex2 nil)
    (lex3_lt formula-decl nil lex3 nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak
   (sempp termination
    "semantic_parser.sempp(semantic_parser.P_exp, semantic_parser.P_inp, semantic_parser.A, semantic_parser.e2, semantic_parser.inp, pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].e(semantic_parser.T1), semantic_parser.s_T, semantic_parser.res)"
    "nil")))
 (sempp_TCC44 0
  (sempp_TCC45-1 nil 3804941352
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing" +)
        (("" (typepred "status1")
          (("" (typepred "status2")
            (("" (assert)
              (("" (lift-if)
                (("" (assert)
                  ((""
                    (lemma "Wellformed_theorem"
                     (T "parsing(P_exp, A, e1, inp, s, s_T)"))
                    (("" (assert)
                      (("" (flatten)
                        (("" (assert)
                          ((""
                            (lemma "Wellformed_theorem"
                             (T
                              "parsing(P_exp, A, e2, inp, e(T1), s_T)"))
                            (("" (assert)
                              ((""
                                (assert)
                                ((""
                                  (typepred "T1")
                                  ((""
                                    (lemma
                                     "semantic_interp_props"
                                     (T T1 P_inp P_inp))
                                    (("1" (assert) nil nil)
                                     ("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astTypeOf type-eq-decl nil semantic_parser nil)
    (below type-eq-decl nil naturalnumbers nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (<= const-decl "bool" reals nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (< const-decl "bool" reals nil)
    (subterm_of type-eq-decl nil peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (astType? def-decl "astType" ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (astType type-decl nil ast nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (semantic_interp_props formula-decl nil semantic_interp nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (equalTo type-eq-decl nil semantic_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype
    "ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].failure"
    "semantic_parser.astTypeOf(peg_parser[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].parsing(semantic_parser.P_exp, semantic_parser.A, semantic_parser.G, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T))")))
 (sempp_TCC45 0
  (sempp_TCC46-1 nil 3804941352
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (typepred "status1")
          (("" (assert)
            (("" (expand "s_inp")
              (("" (expand "astType?" +)
                (("" (assert)
                  (("" (typepred "status2")
                    (("" (assert)
                      (("" (lift-if)
                        (("" (assert)
                          (("" (split)
                            (("1" (flatten)
                              (("1"
                                (assert)
                                (("1"
                                  (typepred "T1")
                                  (("1" (assert) nil nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (flatten)
                              (("2"
                                (typepred "T1")
                                (("2"
                                  (assert)
                                  (("2"
                                    (split)
                                    (("1"
                                      (split)
                                      (("1" (flatten) nil nil)
                                       ("2"
                                        (assert)
                                        (("2"
                                          (typepred "T1")
                                          (("2"
                                            (use "Wellformed_theorem")
                                            (("2" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (split)
                                      (("1"
                                        (flatten)
                                        (("1"
                                          (typepred "T1")
                                          (("1"
                                            (use
                                             "semantic_interp_props")
                                            (("1"
                                              (flatten)
                                              (("1"
                                                (assert)
                                                (("1"
                                                  (replace -4 * RL)
                                                  (("1"
                                                    (typepred "T2")
                                                    (("1"
                                                      (assert)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (assert)
                                        (("2"
                                          (typepred "T1")
                                          (("2"
                                            (typepred "T2")
                                            (("2"
                                              (assert)
                                              (("2"
                                                (lemma
                                                 "semantic_interp_props")
                                                (("2"
                                                  (inst
                                                   -
                                                   " parsing(P_exp, A, e2, inp, e(T1), s_T)"
                                                   "P_inp")
                                                  (("2"
                                                    (flatten)
                                                    (("2"
                                                      (assert)
                                                      (("2"
                                                        (replace
                                                         -5
                                                         *
                                                         RL)
                                                        (("2"
                                                          (lemma
                                                           "semantic_interp_props")
                                                          (("2"
                                                            (inst
                                                             -
                                                             " parsing(P_exp, A, e1, inp, s, s_T)"
                                                             "P_inp")
                                                            (("2"
                                                              (flatten)
                                                              (("2"
                                                                (replace
                                                                 -10
                                                                 *
                                                                 RL)
                                                                (("2"
                                                                  (typepred
                                                                   "status1")
                                                                  (("2"
                                                                    (typepred
                                                                     "status2")
                                                                    (("2"
                                                                      (lemma
                                                                       "Wellformed_theorem")
                                                                      (("2"
                                                                        (inst
                                                                         -1
                                                                         "T1")
                                                                        (("2"
                                                                          (assert)
                                                                          nil
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astTypeOf type-eq-decl nil semantic_parser nil)
    (below type-eq-decl nil naturalnumbers nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (<= const-decl "bool" reals nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (< const-decl "bool" reals nil)
    (subterm_of type-eq-decl nil peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (astType? def-decl "astType" ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (astType type-decl nil ast nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (equalTo type-eq-decl nil semantic_parser nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (semantic_interp_props formula-decl nil semantic_interp nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype
    "pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].fail(semantic_parser.s, pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].e(semantic_parser.T2))"
    "semantic_parser.equalTo(semantic_interp[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].s_inp(semantic_parser.P_inp, peg_parser[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].parsing(semantic_parser.P_exp, semantic_parser.A, semantic_parser.G, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T)))")))
 (sempp_TCC46 0
  (sempp_TCC47-1 nil 3804941352
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (expand "astType?" + 2)
          (("" (expand "astType?" + 2)
            (("" (assert)
              (("" (lift-if)
                (("" (typepred "status1")
                  (("" (typepred "status2")
                    (("" (typepred "T1")
                      (("" (typepred "T2")
                        (("" (lemma "Wellformed_theorem" (T T1))
                          (("" (lemma "Wellformed_theorem" (T T2))
                            (("" (assert)
                              ((""
                                (assert)
                                ((""
                                  (flatten)
                                  (("" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (astTypeOf type-eq-decl nil semantic_parser nil)
    (below type-eq-decl nil naturalnumbers nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (<= const-decl "bool" reals nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (< const-decl "bool" reals nil)
    (subterm_of type-eq-decl nil peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (astType type-decl nil ast nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (equalTo type-eq-decl nil semantic_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype
    "ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].success"
    "semantic_parser.astTypeOf(peg_parser[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].parsing(semantic_parser.P_exp, semantic_parser.A, semantic_parser.G, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T))")))
 (sempp_TCC47 0
  (sempp_TCC49-1 nil 3774591350
   ("" (skeep*)
    (("" (typepred "T1")
      (("" (name "T1_p" "parsing(P_exp, A, e1, inp, s, s_T)")
        (("" (replace -1 * LR)
          (("" (typepred "T1_p")
            (("" (typepred "s_inp(P_inp, T1_p)")
              (("" (assert) (("" (assert) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((equalTo type-eq-decl nil semantic_parser nil)
    (below type-eq-decl nil naturalnumbers nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (ast type-eq-decl nil ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (subterm_of type-eq-decl nil peg nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak
   (sempp subtype "semantic_parser.T1"
    "{T: pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].pre_ast | (booleans.¬)(pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].skip?(T))}")))
 (sempp_TCC48 0
  (sempp_TCC49-1 nil 3804941352
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (typepred "status1")
        (("" (typepred "status2")
          (("" (typepred "T1")
            (("" (typepred "T2")
              (("" (lemma "Wellformed_theorem" (T T1))
                (("" (lemma "Wellformed_theorem" (T T2))
                  (("" (assert)
                    (("" (flatten)
                      (("" (expand "parsing" +)
                        (("" (expand "s_inp" +)
                          (("" (expand "astType?" +)
                            (("" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((equalTo type-eq-decl nil semantic_parser nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (astType type-decl nil ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (astType? def-decl "astType" ast nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (subterm_of type-eq-decl nil peg nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (<= const-decl "bool" reals nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (below type-eq-decl nil naturalnumbers nil)
    (astTypeOf type-eq-decl nil semantic_parser nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype
    "pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].seq(semantic_parser.s, pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].e(semantic_parser.T2), semantic_parser.T1, semantic_parser.T2)"
    "semantic_parser.equalTo(semantic_interp[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].s_inp(semantic_parser.P_inp, peg_parser[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].parsing(semantic_parser.P_exp, semantic_parser.A, semantic_parser.G, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T)))")))
 (sempp_TCC49 0
  (sempp_TCC51-1 nil 3774869098
   ("" (skeep*)
    (("" (use "subterm_prior" (G "P_exp(A)"))
      (("" (assert) (("" (typepred "G") (("" (assert) nil nil)) nil))
        nil))
      nil))
    nil)
   ((subterm_prior formula-decl nil peg nil)
    (peg type-decl nil peg nil) (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (below type-eq-decl nil naturalnumbers nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (subterm_of type-eq-decl nil peg nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (subterm_of? const-decl "bool" peg nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak
   (sempp subtype "semantic_parser.e1"
    "peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].subterm_of(semantic_parser.P_exp(semantic_parser.A))")))
 (sempp_TCC50 0
  (sempp_TCC52-1 nil 3774869141
   ("" (skeep*)
    (("" (typepred "s_T")
      (("" (expand "g_wf" -)
        (("" (replace -3 * LR) (("" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of type-eq-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak
   (sempp subtype "semantic_parser.s_T"
    "{k: naturalnumbers.upto(semantic_parser.s) | booleans.⇒((k = semantic_parser.s), wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].pattern_wf?(semantic_parser.e1, semantic_parser.A, static_analysis[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].σ(semantic_parser.P_exp), wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].P_0c(semantic_parser.P_exp)))}")))
 (sempp_TCC51 0
  (sempp_TCC53-1 nil 3774869172
   ("" (skeep*)
    (("" (rewrite "lex4_lt")
      (("" (rewrite "lex3_lt")
        (("" (rewrite "lex2_lt") (("" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (lex4_lt formula-decl nil lex4 nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (<= const-decl "bool" reals nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (peg type-decl nil peg nil) (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (below type-eq-decl nil naturalnumbers nil)
    (subterm_of type-eq-decl nil peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (pegMeasure const-decl "nat" peg nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lex2_lt formula-decl nil lex2 nil)
    (lex3_lt formula-decl nil lex3 nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (sum_inc const-decl "nat" peg nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak
   (sempp termination
    "semantic_parser.sempp(semantic_parser.P_exp, semantic_parser.P_inp, semantic_parser.A, semantic_parser.e1, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T, semantic_parser.res)"
    "nil")))
 (sempp_TCC52 0
  (sempp_TCC53-1 nil 3804941352
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (typepred "status1")
        (("" (typepred "T1")
          (("" (lemma "Wellformed_theorem" (T T1))
            (("" (assert)
              (("" (expand "parsing" +)
                (("" (expand "astType?" +) (("" (propax) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((equalTo type-eq-decl nil semantic_parser nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (astType type-decl nil ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (astType? def-decl "astType" ast nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (subterm_of type-eq-decl nil peg nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (<= const-decl "bool" reals nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (below type-eq-decl nil naturalnumbers nil)
    (astTypeOf type-eq-decl nil semantic_parser nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype
    "ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].success"
    "semantic_parser.astTypeOf(peg_parser[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].parsing(semantic_parser.P_exp, semantic_parser.A, semantic_parser.G, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T))")))
 (sempp_TCC53 0
  (sempp_TCC55-1 nil 3774869248
   ("" (skeep*)
    (("" (typepred "status1")
      (("" (typepred "T1")
        (("" (lemma "Wellformed_theorem" (T T1))
          (("" (assert)
            (("" (assert)
              (("" (typepred "T1")
                (("" (expand "s_inp" -1)
                  (("" (lift-if -1) (("" (ground) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astTypeOf type-eq-decl nil semantic_parser nil)
    (below type-eq-decl nil naturalnumbers nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (<= const-decl "bool" reals nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (< const-decl "bool" reals nil)
    (subterm_of type-eq-decl nil peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (astType? def-decl "astType" ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (astType type-decl nil ast nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (equalTo type-eq-decl nil semantic_parser nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak
   (sempp subtype "semantic_parser.T1"
    "{T: pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].pre_ast | (booleans.¬)(pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].skip?(T))}")))
 (sempp_TCC54 0
  (sempp_TCC59-1 nil 3777620320
   ("" (skeep*)
    (("" (typepred "T1")
      ((""
        (typepred "s_inp(P_inp, parsing(P_exp, A, e1, inp, s, s_T))")
        (("" (typepred "parsing(P_exp, A, e1, inp, s, s_T)")
          (("" (assert)
            (("" (replace -20 * LR)
              (("" (expand "parsing" 2)
                (("" (expand "s_inp" 2)
                  (("" (assert)
                    (("" (decompose-equality 2)
                      (("" (expand "s_inp" 1) (("" (assert) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((equalTo type-eq-decl nil semantic_parser nil)
    (below type-eq-decl nil naturalnumbers nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (ast type-eq-decl nil ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (subterm_of type-eq-decl nil peg nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (¬ const-decl "[bool -> bool]" booleans nil)
    (prior adt-constructor-decl
     "[[below, below, {T: pre_ast | ¬skip?(T)}, pre_ast] -> (prior?)]"
     pre_ast nil)
    (skip adt-constructor-decl
          "[[below, below, peg[V_T, <=, V_N_b]] -> (skip?)]" pre_ast
          nil)
    (prior? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (pre_ast_prior_extensionality formula-decl nil pre_ast nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype
    "pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].prior(semantic_parser.s, pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].e(semantic_parser.T1), semantic_parser.T1, pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].skip(semantic_parser.s, semantic_parser.s, semantic_parser.e2))"
    "semantic_parser.equalTo(semantic_interp[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].s_inp(semantic_parser.P_inp, peg_parser[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].parsing(semantic_parser.P_exp, semantic_parser.A, semantic_parser.G, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T)))")))
 (sempp_TCC55 0
  (sempp_TCC57-1 nil 3775125996
   ("" (skeep*)
    (("" (use "subterm_prior" (G "P_exp(A)"))
      (("" (assert) (("" (typepred "G") (("" (assert) nil nil)) nil))
        nil))
      nil))
    nil)
   ((subterm_prior formula-decl nil peg nil)
    (peg type-decl nil peg nil) (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (below type-eq-decl nil naturalnumbers nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (subterm_of type-eq-decl nil peg nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (subterm_of? const-decl "bool" peg nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype "semantic_parser.e2"
    "peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].subterm_of(semantic_parser.P_exp(semantic_parser.A))")))
 (sempp_TCC56 0
  (sempp_TCC58-1 nil 3775125996
   ("" (skeep*)
    (("" (typepred "s_T")
      (("" (assert)
        (("" (expand "g_wf" -2)
          (("" (replace -3 * LR) (("" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of type-eq-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype "semantic_parser.s_T"
    "{k: naturalnumbers.upto(semantic_parser.s) | booleans.⇒((k = semantic_parser.s), wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].pattern_wf?(semantic_parser.e2, semantic_parser.A, static_analysis[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].σ(semantic_parser.P_exp), wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].P_0c(semantic_parser.P_exp)))}")))
 (sempp_TCC57 0
  (sempp_TCC59-1 nil 3775125996
   ("" (skeep*)
    (("" (rewrite "lex4_lt")
      (("" (rewrite "lex3_lt")
        (("" (rewrite "lex2_lt")
          (("" (replace -1 * LR) (("" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (lex4_lt formula-decl nil lex4 nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (<= const-decl "bool" reals nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (peg type-decl nil peg nil) (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (below type-eq-decl nil naturalnumbers nil)
    (subterm_of type-eq-decl nil peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (pegMeasure const-decl "nat" peg nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lex2_lt formula-decl nil lex2 nil)
    (lex3_lt formula-decl nil lex3 nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (sum_inc const-decl "nat" peg nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp termination
    "semantic_parser.sempp(semantic_parser.P_exp, semantic_parser.P_inp, semantic_parser.A, semantic_parser.e2, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T, semantic_parser.res)"
    "nil")))
 (sempp_TCC58 0
  (sempp_TCC59-1 nil 3804941352
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (expand "astType?" + 2)
          (("" (expand "astType?" + 2)
            (("" (assert)
              (("" (typepred "T1")
                ((""
                  (lemma "Wellformed_theorem"
                   (T "parsing(P_exp, A, e1, inp, s, s_T)"))
                  (("" (assert)
                    (("" (flatten) (("" (assert) nil nil)) nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (astType type-decl nil ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (subterm_of type-eq-decl nil peg nil) (peg type-decl nil peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (ast type-eq-decl nil ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (below type-eq-decl nil naturalnumbers nil)
    (equalTo type-eq-decl nil semantic_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype
    "ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].success"
    "semantic_parser.astTypeOf(peg_parser[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].parsing(semantic_parser.P_exp, semantic_parser.A, semantic_parser.G, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T))")))
 (sempp_TCC59 0
  (sempp_TCC60-1 nil 3804941352
   ("" (skeep*)
    (("" (typepred "T1")
      (("" (expand "s_inp")
        (("" (lift-if)
          (("" (assert)
            (("" (ground)
              (("" (typepred "parsing(P_exp, A, e1, inp, s, s_T)")
                (("" (assert) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((equalTo type-eq-decl nil semantic_parser nil)
    (below type-eq-decl nil naturalnumbers nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (ast type-eq-decl nil ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (subterm_of type-eq-decl nil peg nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype "semantic_parser.T1"
    "{T: pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].pre_ast | (booleans.¬)(pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].skip?(T))}")))
 (sempp_TCC60 0
  (sempp_TCC61-1 nil 3804941352
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (assert)
        (("" (expand "parsing")
          (("" (assert)
            (("" (expand "s_inp" 2 1)
              (("" (assert)
                (("" (assert)
                  (("" (lift-if)
                    (("" (assert)
                      ((""
                        (lemma "Wellformed_theorem"
                         (T "parsing(P_exp, A, e1, inp, s, s_T)"))
                        (("" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (subterm_of type-eq-decl nil peg nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (<= const-decl "bool" reals nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (astType type-decl nil ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (below type-eq-decl nil naturalnumbers nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (astType? def-decl "astType" ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype
    "pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].prior(semantic_parser.s, pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].e(semantic_parser.T2), semantic_parser.T1, semantic_parser.T2)"
    "semantic_parser.equalTo(semantic_interp[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].s_inp(semantic_parser.P_inp, peg_parser[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].parsing(semantic_parser.P_exp, semantic_parser.A, semantic_parser.G, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T)))")))
 (sempp_TCC61 0
  (sempp_TCC62-1 nil 3804941352
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (typepred "T1")
        (("" (typepred "T2")
          ((""
            (lemma "Wellformed_theorem"
             (T " parsing(P_exp, A, e1, inp, s, s_T)"))
            ((""
              (lemma "Wellformed_theorem"
               (T " parsing(P_exp, A, e2, inp, s, s_T)"))
              (("" (assert)
                (("" (flatten)
                  (("" (expand "parsing" +)
                    (("" (expand "astType?" +) (("" (assert) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (subterm_of type-eq-decl nil peg nil) (peg type-decl nil peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (ast type-eq-decl nil ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (below type-eq-decl nil naturalnumbers nil)
    (equalTo type-eq-decl nil semantic_parser nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype
    "ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].failure"
    "semantic_parser.astTypeOf(peg_parser[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].parsing(semantic_parser.P_exp, semantic_parser.A, semantic_parser.G, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T))")))
 (sempp_TCC62 0
  (sempp_TCC63-1 nil 3804941352
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (typepred "T1")
        (("" (typepred "T2")
          ((""
            (lemma "Wellformed_theorem"
             (T " parsing(P_exp, A, e1, inp, s, s_T)"))
            ((""
              (lemma "Wellformed_theorem"
               (T " parsing(P_exp, A, e2, inp, s, s_T)"))
              (("" (assert)
                (("" (flatten)
                  (("" (expand "parsing" +)
                    (("" (expand "s_inp" +)
                      (("" (expand "astType?" +)
                        (("" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (subterm_of type-eq-decl nil peg nil) (peg type-decl nil peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (ast type-eq-decl nil ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (below type-eq-decl nil naturalnumbers nil)
    (equalTo type-eq-decl nil semantic_parser nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype
    "pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].fail(semantic_parser.s, pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].e(semantic_parser.T2))"
    "semantic_parser.equalTo(semantic_interp[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].s_inp(semantic_parser.P_inp, peg_parser[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].parsing(semantic_parser.P_exp, semantic_parser.A, semantic_parser.G, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T)))")))
 (sempp_TCC63 0
  (sempp_TCC63-1 nil 3775125996
   ("" (skeep)
    (("" (use "subterm_star" (G "P_exp(A)"))
      (("" (assert) (("" (typepred "G") (("" (assert) nil nil)) nil))
        nil))
      nil))
    nil)
   ((subterm_star formula-decl nil peg nil) (peg type-decl nil peg nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (below type-eq-decl nil naturalnumbers nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (subterm_of type-eq-decl nil peg nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (subterm_of? const-decl "bool" peg nil))
   nil
   (sempp subtype "semantic_parser.e"
    "peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].subterm_of(semantic_parser.P_exp(semantic_parser.A))")))
 (sempp_TCC64 0
  (sempp_TCC64-1 nil 3775125996
   ("" (skeep)
    (("" (typepred "s_T")
      (("" (replace -3 * LR)
        (("" (expand "g_wf" -2) (("" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of type-eq-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (sempp subtype "semantic_parser.s_T"
    "{k: naturalnumbers.upto(semantic_parser.s) | booleans.⇒((k = semantic_parser.s), wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].pattern_wf?(semantic_parser.e, semantic_parser.A, static_analysis[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].σ(semantic_parser.P_exp), wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].P_0c(semantic_parser.P_exp)))}")))
 (sempp_TCC65 0
  (sempp_TCC65-1 nil 3775125996
   ("" (skeep*)
    (("" (rewrite "lex4_lt")
      (("" (replace -1 * LR) (("" (hide -) (("" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (lex4_lt formula-decl nil lex4 nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (<= const-decl "bool" reals nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (peg type-decl nil peg nil) (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (below type-eq-decl nil naturalnumbers nil)
    (subterm_of type-eq-decl nil peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (pegMeasure const-decl "nat" peg nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lex2_lt formula-decl nil lex2 nil)
    (lex3_lt formula-decl nil lex3 nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (inc const-decl "nat" peg nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp termination
    "semantic_parser.sempp(semantic_parser.P_exp, semantic_parser.P_inp, semantic_parser.A, semantic_parser.e, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T, semantic_parser.res)"
    "nil")))
 (sempp_TCC66 0
  (sempp_TCC67-1 nil 3804941352
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (assert)
          (("" (assert)
            (("" (expand "astType?") (("" (propax) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype
    "ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].success"
    "semantic_parser.astTypeOf(peg_parser[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].parsing(semantic_parser.P_exp, semantic_parser.A, semantic_parser.G, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T))")))
 (sempp_TCC67 0
  (sempp_TCC67-1 nil 3775125996
   ("" (skeep*)
    (("" (typepred "T0")
      (("" (assert)
        (("" (expand "sem_output?")
          (("" (assert) (("" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((equalTo type-eq-decl nil semantic_parser nil)
    (below type-eq-decl nil naturalnumbers nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (ast type-eq-decl nil ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (subterm_of type-eq-decl nil peg nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype "semantic_parser.T0"
    "{T: pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].pre_ast | (booleans.¬)(pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].skip?(T))}")))
 (sempp_TCC68 0
  (sempp_TCC71-1 nil 3777620320
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (assert)
        (("" (auto-rewrite! "parsing")
          (("" (auto-rewrite! "s_inp")
            (("" (assert)
              (("" (wf-ast "parsing(P_exp, A, e, inp, s, s_T)")
                (("" (assert)
                  (("" (assert)
                    (("" (decompose-equality 1)
                      (("" (typepred "T0") (("" (assert) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (¬ const-decl "[bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (star adt-constructor-decl
     "[[below, below, {T: pre_ast | ¬skip?(T)},
  {T: pre_ast | skip?(T) OR star?(T)}] ->
   (star?)]" pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (equalTo type-eq-decl nil semantic_parser nil)
    (skip adt-constructor-decl
          "[[below, below, peg[V_T, <=, V_N_b]] -> (skip?)]" pre_ast
          nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star adt-constructor-decl "[peg -> (star?)]" peg nil)
    (fail adt-constructor-decl "[[below, below] -> (fail?)]" pre_ast
     nil)
    (pre_ast_star_extensionality formula-decl nil pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (below type-eq-decl nil naturalnumbers nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType type-decl nil ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ast type-eq-decl nil ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (<= const-decl "bool" reals nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (< const-decl "bool" reals nil)
    (subterm_of type-eq-decl nil peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (astWellformed? def-decl "bool" ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype
    "pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].star(semantic_parser.s, semantic_parser.s, semantic_parser.T0, pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].skip(pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].e(semantic_parser.T0), pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].e(semantic_parser.T0), peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].star(semantic_parser.e)))"
    "semantic_parser.equalTo(semantic_interp[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].s_inp(semantic_parser.P_inp, peg_parser[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].parsing(semantic_parser.P_exp, semantic_parser.A, semantic_parser.G, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T)))")))
 (sempp_TCC69 0
  (sempp_TCC69-1 nil 3775125996
   ("" (skeep)
    (("" (lemma "peg[V_T, <=, V_N_b].subterm_transitivity")
      (("" (inst -1 "e" "G" "P_exp(A)") (("" (assert) nil nil)) nil))
      nil))
    nil)
   ((V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (subterm_transitivity formula-decl nil peg nil)
    (subterm_of type-eq-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (subterm_of? const-decl "bool" peg nil)
    (peg type-decl nil peg nil))
   nil
   (sempp subtype
    "peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].star(semantic_parser.e)"
    "peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].subterm_of(semantic_parser.P_exp(semantic_parser.A))")))
 (sempp_TCC70 0
  (sempp_TCC71-1 nil 3775125996
   ("" (skeep*)
    (("" (typepred "s_T")
      (("" (assert)
        (("" (wf-ast T0)
          (("" (assert)
            (("" (flatten)
              (("" (assert)
                (("" (typepred "parsing(P_exp, A, e, inp, s, s_T)")
                  (("" (assert)
                    (("" (flatten)
                      (("" (assert)
                        ((""
                          (typepred
                           " s_inp(P_inp, parsing(P_exp, A, e, inp, s, s_T))")
                          (("" (assert)
                            (("" (assert)
                              ((""
                                (replace -24 * LR)
                                (("" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of type-eq-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (pre_ast type-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (input type-eq-decl nil ast_props nil)
    (ast type-eq-decl nil ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (equalTo type-eq-decl nil semantic_parser nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype "semantic_parser.s_T"
    "{k: naturalnumbers.upto(pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].e(semantic_parser.T0)) | booleans.⇒((k = pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].e(semantic_parser.T0)), wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].pattern_wf?(peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].star(semantic_parser.e), semantic_parser.A, static_analysis[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].σ(semantic_parser.P_exp), wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].P_0c(semantic_parser.P_exp)))}")))
 (sempp_TCC71 0
  (sempp_TCC72-1 nil 3775125996
   ("" (skeep*)
    (("" (assert)
      (("" (assert)
        (("" (assert)
          (("" (flatten)
            (("" (assert)
              (("" (typepred "T0")
                (("" (typepred "parsing(P_exp, A, e, inp, s, s_T)")
                  (("" (assert)
                    (("" (typepred "status0")
                      ((""
                        (lemma "Wellformed_theorem"
                         (T "parsing(P_exp, A, e, inp, s, s_T)"))
                        (("" (assert)
                          (("" (flatten)
                            (("" (assert)
                              ((""
                                (use "star_cannot_be_P_0")
                                ((""
                                  (typepred "G")
                                  (("" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (pegMeasure_star formula-decl nil peg nil)
    (lex2_lt formula-decl nil lex2 nil)
    (lex3_lt formula-decl nil lex3 nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (astTypeOf type-eq-decl nil semantic_parser nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (wf_nT? const-decl "bool" wf_peg nil)
    (wf_nT type-eq-decl nil wf_peg nil)
    (star_cannot_be_P_0 formula-decl nil wf_peg nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (subterm_of type-eq-decl nil peg nil) (peg type-decl nil peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (ast type-eq-decl nil ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (below type-eq-decl nil naturalnumbers nil)
    (equalTo type-eq-decl nil semantic_parser nil)
    (lex4_lt formula-decl nil lex4 nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp termination
    "semantic_parser.sempp(semantic_parser.P_exp, semantic_parser.P_inp, semantic_parser.A, peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].star(semantic_parser.e), semantic_parser.inp, pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].e(semantic_parser.T0), semantic_parser.s_T, semantic_parser.res)"
    "nil")))
 (sempp_TCC72 0
  (sempp_TCC73-1 nil 3804941352
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (assert)
        (("" (expand "parsing")
          (("" (assert)
            (("" (lift-if)
              (("" (assert)
                (("" (typepred "T0")
                  (("" (assert)
                    (("" (wf-ast T0)
                      (("" (assert)
                        (("" (flatten)
                          (("" (assert)
                            (("" (hide -3)
                              ((""
                                (typepred "status!1")
                                ((""
                                  (typepred
                                   "parsing(P_exp, A, star(e), inp, e(T0), s_T)")
                                  ((""
                                    (assert)
                                    ((""
                                      (replace -8 * RL)
                                      ((""
                                        (split 2)
                                        (("1" (propax) nil nil)
                                         ("2"
                                          (wf-ast
                                           "parsing(P_exp, A, star(e), inp, e(T0), s_T)")
                                          (("2"
                                            (assert)
                                            (("2"
                                              (flatten)
                                              (("2"
                                                (expand
                                                 "trueToGrammar")
                                                (("2"
                                                  (lift-if)
                                                  (("2"
                                                    (assert)
                                                    (("2"
                                                      (hide -5)
                                                      (("2"
                                                        (name-replace
                                                         "T_s"
                                                         "parsing(P_exp, A, star(e), inp, e(T0), s_T)")
                                                        (("2"
                                                          (ground)
                                                          (("2"
                                                            (flatten)
                                                            (("2"
                                                              (assert)
                                                              (("2"
                                                                (lift-if)
                                                                (("2"
                                                                  (assert)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (equalTo type-eq-decl nil semantic_parser nil)
    (below type-eq-decl nil naturalnumbers nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (ast type-eq-decl nil ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (subterm_of type-eq-decl nil peg nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star adt-constructor-decl "[peg -> (star?)]" peg nil)
    (astTypeOf type-eq-decl nil semantic_parser nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (astType? def-decl "astType" ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype
    "ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].success"
    "semantic_parser.astTypeOf(peg_parser[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].parsing(semantic_parser.P_exp, semantic_parser.A, semantic_parser.G, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T))")))
 (sempp_TCC73 0
  (sempp_TCC74-1 nil 3775125996
   ("" (skeep*)
    (("" (name-replace "T1" "T0")
      (("" (typepred "T1")
        (("" (name "T1_p" "parsing(P_exp, A, e, inp, s, s_T)")
          (("" (replace -1 * LR)
            (("" (lemma "semantic_interp_props")
              (("" (inst -1 "T1_p" "P_inp")
                (("" (replace -3 * RL)
                  (("" (flatten)
                    (("" (expand "astWellformed?")
                      (("" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((V_T formal-nonempty-type-decl nil semantic_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (subterm_of type-eq-decl nil peg nil) (peg type-decl nil peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (ast type-eq-decl nil ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (below type-eq-decl nil naturalnumbers nil)
    (equalTo type-eq-decl nil semantic_parser nil)
    (semantic_interp_props formula-decl nil semantic_interp nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype "semantic_parser.T0"
    "{T: pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].pre_ast | (booleans.¬)(pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].skip?(T))}")))
 (sempp_TCC74 0
  (sempp_TCC78-1 nil 3777620320
   ("" (skeep*)
    (("" (typepred "Ts")
      ((""
        (typepred
         "s_inp(P_inp, parsing(P_exp, A, star(e), inp, e(T0), s_T))")
        (("" (assert)
          (("" (hide - 1 3 4 5)
            (("" (expand "parsing")
              (("" (lift-if) (("" (assert) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((equalTo type-eq-decl nil semantic_parser nil)
    (star adt-constructor-decl "[peg -> (star?)]" peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (ast type-eq-decl nil ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (subterm_of type-eq-decl nil peg nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype "semantic_parser.Ts"
    "{T: pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].pre_ast | booleans.OR(pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].skip?(T), pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].star?(T))}")))
 (sempp_TCC75 0
  (sempp_TCC79-1 nil 3777620320
   ("" (skeep*)
    (("" (typepred "T0")
      ((""
        (typepred " s_inp(P_inp, parsing(P_exp, A, e, inp, s, s_T))")
        (("" (typepred "parsing(P_exp, A, e, inp, s, s_T)")
          (("" (use "Wellformed_theorem" ("T" "T0"))
            (("" (assert)
              (("" (flatten)
                (("" (assert)
                  (("" (typepred "Ts")
                    ((""
                      (typepred
                       " s_inp(P_inp, parsing(P_exp, A, star(e), inp, e(T0), s_T))")
                      ((""
                        (typepred
                         "parsing(P_exp, A, star(e), inp, e(T0), s_T)")
                        (("" (use "Wellformed_theorem" ("T" "Ts"))
                          (("" (assert)
                            (("" (flatten)
                              ((""
                                (assert)
                                ((""
                                  (replace -44 * LR)
                                  ((""
                                    (expand "parsing" 3)
                                    ((""
                                      (expand "s_inp" 3)
                                      ((""
                                        (lift-if)
                                        ((""
                                          (assert)
                                          ((""
                                            (lift-if)
                                            (("" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((equalTo type-eq-decl nil semantic_parser nil)
    (below type-eq-decl nil naturalnumbers nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (ast type-eq-decl nil ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (subterm_of type-eq-decl nil peg nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (star adt-constructor-decl "[peg -> (star?)]" peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype
    "pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].star(semantic_parser.s, pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].e(semantic_parser.Ts), semantic_parser.T0, semantic_parser.Ts)"
    "semantic_parser.equalTo(semantic_interp[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].s_inp(semantic_parser.P_inp, peg_parser[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].parsing(semantic_parser.P_exp, semantic_parser.A, semantic_parser.G, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T)))")))
 (sempp_TCC76 0
  (sempp_TCC77-1 nil 3775125996
   ("" (skeep*)
    (("" (use "subterm_plus" (G "P_exp(A)"))
      (("" (assert) (("" (typepred "G") (("" (assert) nil nil)) nil))
        nil))
      nil))
    nil)
   ((subterm_plus formula-decl nil peg nil) (peg type-decl nil peg nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (below type-eq-decl nil naturalnumbers nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (subterm_of type-eq-decl nil peg nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (subterm_of? const-decl "bool" peg nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype "semantic_parser.e"
    "peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].subterm_of(semantic_parser.P_exp(semantic_parser.A))")))
 (sempp_TCC77 0
  (sempp_TCC78-1 nil 3775125996
   ("" (skeep*)
    (("" (typepred "s_T")
      (("" (replace -3 * LR)
        (("" (expand "g_wf" -) (("" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of type-eq-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype "semantic_parser.s_T"
    "{k: naturalnumbers.upto(semantic_parser.s) | booleans.⇒((k = semantic_parser.s), wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].pattern_wf?(semantic_parser.e, semantic_parser.A, static_analysis[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].σ(semantic_parser.P_exp), wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].P_0c(semantic_parser.P_exp)))}")))
 (sempp_TCC78 0
  (sempp_TCC79-1 nil 3775125996
   ("" (skeep*)
    (("" (rewrite "lex4_lt")
      (("" (rewrite "lex3_lt")
        (("" (rewrite "lex2_lt")
          (("" (replace -1 * LR) (("" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (lex4_lt formula-decl nil lex4 nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (<= const-decl "bool" reals nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (peg type-decl nil peg nil) (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (below type-eq-decl nil naturalnumbers nil)
    (subterm_of type-eq-decl nil peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (pegMeasure const-decl "nat" peg nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lex2_lt formula-decl nil lex2 nil)
    (lex3_lt formula-decl nil lex3 nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (inc const-decl "nat" peg nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp termination
    "semantic_parser.sempp(semantic_parser.P_exp, semantic_parser.P_inp, semantic_parser.A, semantic_parser.e, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T, semantic_parser.res)"
    "nil")))
 (sempp_TCC79 0
  (sempp_TCC80-1 nil 3804941352
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing" +)
        (("" (assert)
          (("" (expand "astType?" +) (("" (propax) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype
    "ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].failure"
    "semantic_parser.astTypeOf(peg_parser[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].parsing(semantic_parser.P_exp, semantic_parser.A, semantic_parser.G, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T))")))
 (sempp_TCC80 0
  (sempp_TCC81-1 nil 3804941352
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "s_inp")
            (("" (assert)
              (("" (expand "astType?") (("" (propax) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype
    "pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].fail(semantic_parser.s, semantic_parser.s)"
    "semantic_parser.equalTo(semantic_interp[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].s_inp(semantic_parser.P_inp, peg_parser[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].parsing(semantic_parser.P_exp, semantic_parser.A, semantic_parser.G, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T)))")))
 (sempp_TCC81 0
  (sempp_TCC82-1 nil 3775125996
   ("" (skeep)
    (("" (lemma "peg[V_T, <=, V_N_b].subterm_transitivity")
      (("" (inst -1 "e" "G" "P_exp(A)") (("" (assert) nil nil)) nil))
      nil))
    nil)
   ((V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (subterm_transitivity formula-decl nil peg nil)
    (subterm_of type-eq-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (subterm_of? const-decl "bool" peg nil)
    (peg type-decl nil peg nil))
   nil
   (sempp subtype
    "peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].plus(semantic_parser.e)"
    "peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].subterm_of(semantic_parser.P_exp(semantic_parser.A))")))
 (sempp_TCC82 0
  (sempp_TCC84-1 nil 3775125996
   ("" (skeep*)
    (("" (typepred "T0")
      ((""
        (typepred " s_inp(P_inp, parsing(P_exp, A, e, inp, s, s_T))")
        (("" (typepred "parsing(P_exp, A, e, inp, s, s_T)")
          (("" (use "Wellformed_theorem" ("T" "T0"))
            (("" (assert)
              (("" (flatten)
                (("" (assert)
                  (("" (typepred "s_T")
                    (("" (replace -24 * LR)
                      (("" (flatten) (("" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((equalTo type-eq-decl nil semantic_parser nil)
    (below type-eq-decl nil naturalnumbers nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (ast type-eq-decl nil ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (subterm_of type-eq-decl nil peg nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype "semantic_parser.s_T"
    "{k: naturalnumbers.upto(pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].e(semantic_parser.T0)) | booleans.⇒((k = pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].e(semantic_parser.T0)), wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].pattern_wf?(peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].plus(semantic_parser.e), semantic_parser.A, static_analysis[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].σ(semantic_parser.P_exp), wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].P_0c(semantic_parser.P_exp)))}")))
 (sempp_TCC83 0
  (sempp_TCC85-1 nil 3775125996
   ("" (skeep*)
    (("" (assert)
      (("" (assert)
        (("" (assert)
          (("" (flatten)
            (("" (assert)
              (("" (typepred "s_T")
                (("" (assert)
                  (("" (wf-ast T0)
                    (("" (assert)
                      (("" (flatten)
                        (("" (assert)
                          (("" (replace -6 * LR)
                            (("" (assert)
                              ((""
                                (typepred
                                 "parsing(P_exp, A, e, inp, s, s_T)")
                                ((""
                                  (assert)
                                  ((""
                                    (use "plus_cannot_be_P_0")
                                    ((""
                                      (assert)
                                      ((""
                                        (typepred "G")
                                        (("" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (pegMeasure_plus formula-decl nil peg nil)
    (lex2_lt formula-decl nil lex2 nil)
    (lex3_lt formula-decl nil lex3 nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (wf_nT type-eq-decl nil wf_peg nil)
    (wf_nT? const-decl "bool" wf_peg nil)
    (plus_cannot_be_P_0 formula-decl nil wf_peg nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (equalTo type-eq-decl nil semantic_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (ast type-eq-decl nil ast nil)
    (input type-eq-decl nil ast_props nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (peg type-decl nil peg nil) (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (below type-eq-decl nil naturalnumbers nil)
    (subterm_of type-eq-decl nil peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (lex4_lt formula-decl nil lex4 nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp termination
    "semantic_parser.sempp(semantic_parser.P_exp, semantic_parser.P_inp, semantic_parser.A, peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].plus(semantic_parser.e), semantic_parser.inp, pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].e(semantic_parser.T0), semantic_parser.s_T, semantic_parser.res)"
    "nil")))
 (sempp_TCC84 0
  (sempp_TCC85-1 nil 3804941352
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (assert)
          (("" (lift-if)
            (("" (assert)
              (("" (wf-ast T0)
                (("" (assert)
                  (("" (flatten)
                    (("" (assert)
                      (("" (typepred "Ts")
                        (("" (assert)
                          (("" (ground)
                            (("" (assert)
                              ((""
                                (wf-ast
                                 "parsing(P_exp, A, plus(e), inp,
                       e(parsing(P_exp, A, e, inp, s, s_T)), s_T)")
                                (("" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (plus adt-constructor-decl "[peg -> (plus?)]" peg nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (equalTo type-eq-decl nil semantic_parser nil)
    (below type-eq-decl nil naturalnumbers nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (ast type-eq-decl nil ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (subterm_of type-eq-decl nil peg nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype
    "ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].success"
    "semantic_parser.astTypeOf(peg_parser[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].parsing(semantic_parser.P_exp, semantic_parser.A, semantic_parser.G, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T))")))
 (sempp_TCC85 0
  (sempp_TCC87-1 nil 3775125996
   ("" (skeep*)
    (("" (typepred "T0")
      ((""
        (typepred " s_inp(P_inp, parsing(P_exp, A, e, inp, s, s_T))")
        (("" (typepred "parsing(P_exp, A, e, inp, s, s_T)")
          (("" (use "Wellformed_theorem" ("T" "T0"))
            (("" (assert) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((equalTo type-eq-decl nil semantic_parser nil)
    (below type-eq-decl nil naturalnumbers nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (ast type-eq-decl nil ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (subterm_of type-eq-decl nil peg nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype "semantic_parser.T0"
    "{T: pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].pre_ast | (booleans.¬)(pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].skip?(T))}")))
 (sempp_TCC86 0
  (sempp_TCC91-1 nil 3777620320
   ("" (skeep*)
    (("" (typepred "T0")
      ((""
        (typepred " s_inp(P_inp, parsing(P_exp, A, e, inp, s, s_T))")
        (("" (typepred "parsing(P_exp, A, e, inp, s, s_T)")
          (("" (use "Wellformed_theorem" ("T" "T0"))
            (("" (assert)
              (("" (flatten)
                (("" (assert)
                  (("" (typepred "Ts")
                    ((""
                      (typepred
                       " s_inp(P_inp, parsing(P_exp, A, plus(e), inp, e(T0), s_T))")
                      ((""
                        (typepred
                         "parsing(P_exp, A, plus(e), inp, e(T0), s_T)")
                        (("" (use "Wellformed_theorem" ("T" "Ts"))
                          (("" (assert)
                            (("" (flatten)
                              ((""
                                (hide - 1 2 4 5 6 7 8)
                                ((""
                                  (expand "parsing")
                                  ((""
                                    (lift-if)
                                    (("" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((equalTo type-eq-decl nil semantic_parser nil)
    (below type-eq-decl nil naturalnumbers nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (ast type-eq-decl nil ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (subterm_of type-eq-decl nil peg nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (plus adt-constructor-decl "[peg -> (plus?)]" peg nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype "semantic_parser.Ts"
    "{T: pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].pre_ast | booleans.OR(pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].skip?(T), booleans.OR(pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].plus?(T), pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].fail?(T)))}")))
 (sempp_TCC87 0
  (sempp_TCC92-1 nil 3777620320
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "s_inp")
            (("" (assert)
              (("" (lift-if)
                (("" (assert)
                  (("" (typepred "Ts")
                    ((""
                      (typepred
                       " s_inp(P_inp, parsing(P_exp, A, plus(e), inp, e(T0), s_T))")
                      (("" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (astType type-decl nil ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (subterm_of type-eq-decl nil peg nil) (peg type-decl nil peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (ast type-eq-decl nil ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (below type-eq-decl nil naturalnumbers nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus adt-constructor-decl "[peg -> (plus?)]" peg nil)
    (equalTo type-eq-decl nil semantic_parser nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype
    "pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].plus(semantic_parser.s, pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].e(semantic_parser.Ts), semantic_parser.T0, semantic_parser.Ts)"
    "semantic_parser.equalTo(semantic_interp[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].s_inp(semantic_parser.P_inp, peg_parser[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].parsing(semantic_parser.P_exp, semantic_parser.A, semantic_parser.G, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T)))")))
 (sempp_TCC88 0
  (sempp_TCC90-1 nil 3775125996
   ("" (skeep)
    (("" (assert)
      (("" (use "subterm_opt" (G "P_exp(A)"))
        (("" (assert) (("" (typepred "G") (("" (assert) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((subterm_of? const-decl "bool" peg nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (subterm_of type-eq-decl nil peg nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (subterm_opt formula-decl nil peg nil))
   nil
   (sempp subtype "semantic_parser.e"
    "peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].subterm_of(semantic_parser.P_exp(semantic_parser.A))")))
 (sempp_TCC89 0
  (sempp_TCC91-1 nil 3775125996
   ("" (skeep*)
    (("" (typepred "s_T")
      (("" (assert)
        (("" (expand "g_wf" -)
          (("" (replace -4 * LR)
            (("" (assert)
              (("" (replace -3 * LR) (("" (assert) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of type-eq-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype "semantic_parser.s_T"
    "{k: naturalnumbers.upto(semantic_parser.s) | booleans.⇒((k = semantic_parser.s), wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].pattern_wf?(semantic_parser.e, semantic_parser.A, static_analysis[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].σ(semantic_parser.P_exp), wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].P_0c(semantic_parser.P_exp)))}")))
 (sempp_TCC90 0
  (sempp_TCC92-1 nil 3775125996
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (rewrite "lex4_lt")
        (("" (rewrite "lex3_lt")
          (("" (rewrite "lex2_lt")
            (("" (assert) (("" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((opt adt-constructor-decl "[peg -> (opt?)]" peg nil)
    (opt? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (pegMeasure const-decl "nat" peg nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of type-eq-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (<= const-decl "bool" reals nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (lex4_lt formula-decl nil lex4 nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (pegMeasure_opt formula-decl nil peg nil)
    (lex2_lt formula-decl nil lex2 nil)
    (lex3_lt formula-decl nil lex3 nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp termination
    "semantic_parser.sempp(semantic_parser.P_exp, semantic_parser.P_inp, semantic_parser.A, semantic_parser.e, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T, semantic_parser.res)"
    "nil")))
 (sempp_TCC91 0
  (sempp_TCC92-1 nil 3804941352
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (assert)
          (("" (assert)
            (("" (expand "astType?") (("" (propax) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype
    "ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].success"
    "semantic_parser.astTypeOf(peg_parser[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].parsing(semantic_parser.P_exp, semantic_parser.A, semantic_parser.G, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T))")))
 (sempp_TCC92 0
  (sempp_TCC94-1 nil 3775125996
   ("" (skeep*)
    (("" (name-replace "T0" "T!1")
      (("" (typepred "T0")
        ((""
          (typepred " s_inp(P_inp, parsing(P_exp, A, e, inp, s, s_T))")
          (("" (typepred "parsing(P_exp, A, e, inp, s, s_T)")
            (("" (use "Wellformed_theorem" ("T" "T0"))
              (("" (assert) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((V_T formal-nonempty-type-decl nil semantic_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (subterm_of type-eq-decl nil peg nil) (peg type-decl nil peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (ast type-eq-decl nil ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (below type-eq-decl nil naturalnumbers nil)
    (equalTo type-eq-decl nil semantic_parser nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype "semantic_parser.T"
    "{T: pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].pre_ast | (booleans.¬)(pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].skip?(T))}")))
 (sempp_TCC93 0
  (sempp_TCC98-1 nil 3777620320
   ("" (skeep*)
    (("" (name-replace "T0" "T!1")
      (("" (replace -1 * LR)
        (("" (expand "parsing")
          (("" (assert)
            (("" (expand "s_inp") (("" (assert) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((V_T formal-nonempty-type-decl nil semantic_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (subterm_of type-eq-decl nil peg nil) (peg type-decl nil peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (ast type-eq-decl nil ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (below type-eq-decl nil naturalnumbers nil)
    (equalTo type-eq-decl nil semantic_parser nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype
    "pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].opt(semantic_parser.s, semantic_parser.s, semantic_parser.T)"
    "semantic_parser.equalTo(semantic_interp[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].s_inp(semantic_parser.P_inp, peg_parser[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].parsing(semantic_parser.P_exp, semantic_parser.A, semantic_parser.G, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T)))")))
 (sempp_TCC94 0
  (sempp_TCC95-1 nil 3804941352
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (assert)
          (("" (typepred "T!1")
            (("" (lemma "Wellformed_theorem" (T "T!1"))
              (("" (assert)
                (("" (flatten) (("" (ground) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (astType type-decl nil ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (subterm_of type-eq-decl nil peg nil) (peg type-decl nil peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (ast type-eq-decl nil ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (below type-eq-decl nil naturalnumbers nil)
    (equalTo type-eq-decl nil semantic_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype
    "ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].success"
    "semantic_parser.astTypeOf(peg_parser[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].parsing(semantic_parser.P_exp, semantic_parser.A, semantic_parser.G, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T))")))
 (sempp_TCC95 0
  (sempp_TCC97-1 nil 3775125996
   ("" (skeep*)
    (("" (name-replace "T1" "T!1")
      (("" (typepred "T1")
        (("" (name "T1_p" "parsing(P_exp, A, e, inp, s, s_T)")
          (("" (replace -1 * LR)
            (("" (lemma "semantic_interp_props")
              (("" (inst -1 "T1_p" "P_inp")
                (("" (replace -3 * RL)
                  (("" (flatten)
                    (("" (expand "astWellformed?")
                      (("" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((V_T formal-nonempty-type-decl nil semantic_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (subterm_of type-eq-decl nil peg nil) (peg type-decl nil peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (ast type-eq-decl nil ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (below type-eq-decl nil naturalnumbers nil)
    (equalTo type-eq-decl nil semantic_parser nil)
    (semantic_interp_props formula-decl nil semantic_interp nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype "semantic_parser.T"
    "{T: pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].pre_ast | (booleans.¬)(pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].skip?(T))}")))
 (sempp_TCC96 0
  (sempp_TCC101-1 nil 3777620320
   ("" (skeep*)
    (("" (name-replace "T0" "T!1")
      (("" (replace -1 * LR)
        (("" (expand "parsing")
          (("" (assert)
            (("" (expand "s_inp")
              (("" (assert)
                (("" (lift-if)
                  (("" (assert)
                    (("" (typepred "T0")
                      ((""
                        (typepred
                         " s_inp(P_inp, parsing(P_exp, A, e, inp, s, s_T))")
                        ((""
                          (typepred
                           "parsing(P_exp, A, e, inp, s, s_T)")
                          (("" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((V_T formal-nonempty-type-decl nil semantic_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (subterm_of type-eq-decl nil peg nil) (peg type-decl nil peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (ast type-eq-decl nil ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (below type-eq-decl nil naturalnumbers nil)
    (equalTo type-eq-decl nil semantic_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype
    "pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].opt(semantic_parser.s, pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].e(semantic_parser.T), semantic_parser.T)"
    "semantic_parser.equalTo(semantic_interp[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].s_inp(semantic_parser.P_inp, peg_parser[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].parsing(semantic_parser.P_exp, semantic_parser.A, semantic_parser.G, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T)))")))
 (sempp_TCC97 0
  (sempp_TCC99-1 nil 3775125996
   ("" (skeep)
    (("" (assert)
      (("" (use "subterm_notP" (G "P_exp(A)"))
        (("" (assert) (("" (typepred "G") (("" (assert) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((subterm_of? const-decl "bool" peg nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (subterm_of type-eq-decl nil peg nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (subterm_notP formula-decl nil peg nil))
   nil
   (sempp subtype "semantic_parser.e"
    "peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].subterm_of(semantic_parser.P_exp(semantic_parser.A))")))
 (sempp_TCC98 0
  (sempp_TCC100-1 nil 3775125996
   ("" (skeep*)
    (("" (typepred "s_T")
      (("" (assert)
        (("" (expand "g_wf" -)
          (("" (replace -3 * LR) (("" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of type-eq-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype "semantic_parser.s_T"
    "{k: naturalnumbers.upto(semantic_parser.s) | booleans.⇒((k = semantic_parser.s), wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].pattern_wf?(semantic_parser.e, semantic_parser.A, static_analysis[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].σ(semantic_parser.P_exp), wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].P_0c(semantic_parser.P_exp)))}")))
 (sempp_TCC99 0
  (sempp_TCC101-1 nil 3775125996
   ("" (assert)
    (("" (assert)
      (("" (skeep*)
        (("" (replace -1 * LR) (("" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((lex3_lt formula-decl nil lex3 nil)
    (lex2_lt formula-decl nil lex2 nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (pegMeasure_notP formula-decl nil peg nil)
    (TRUE const-decl "bool" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (lex4_lt formula-decl nil lex4 nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (sempp termination
    "semantic_parser.sempp(semantic_parser.P_exp, semantic_parser.P_inp, semantic_parser.A, semantic_parser.e, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T, semantic_parser.res)"
    "nil")))
 (sempp_TCC100 0
  (sempp_TCC101-1 nil 3804941352
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (assert)
          (("" (assert)
            (("" (expand "astType?") (("" (propax) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype
    "ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].success"
    "semantic_parser.astTypeOf(peg_parser[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].parsing(semantic_parser.P_exp, semantic_parser.A, semantic_parser.G, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T))")))
 (sempp_TCC101 0
  (sempp_TCC103-1 nil 3775125996
   ("" (skeep)
    (("" (skeep)
      (("" (name-replace "T1" "T!1")
        (("" (typepred "T1")
          (("" (name "T1_p" "parsing(P_exp, A, e, inp, s, s_T)")
            (("" (replace -1 * LR)
              (("" (lemma "semantic_interp_props")
                (("" (inst -1 "T1_p" "P_inp")
                  (("" (replace -3 * RL)
                    (("" (flatten)
                      (("" (expand "astWellformed?")
                        (("" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (semantic_interp_props formula-decl nil semantic_interp nil)
    (equalTo type-eq-decl nil semantic_parser nil)
    (below type-eq-decl nil naturalnumbers nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (ast type-eq-decl nil ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (subterm_of type-eq-decl nil peg nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil))
   nil
   (sempp subtype "semantic_parser.T"
    "{T: pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].pre_ast | (booleans.¬)(pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].skip?(T))}")))
 (sempp_TCC102 0
  (sempp_TCC103-1 nil 3804941352
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "s_inp")
            (("" (assert)
              (("" (expand "astType?") (("" (assert) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype
    "pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].notP(semantic_parser.s, semantic_parser.s, semantic_parser.T)"
    "semantic_parser.equalTo(semantic_interp[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].s_inp(semantic_parser.P_inp, peg_parser[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].parsing(semantic_parser.P_exp, semantic_parser.A, semantic_parser.G, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T)))")))
 (sempp_TCC103 0
  (sempp_TCC104-1 nil 3804941352
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing" +)
        (("" (assert)
          (("" (typepred "status!1")
            ((""
              (lemma "Wellformed_theorem"
               (T "parsing(P_exp, A, e, inp, s, s_T)"))
              (("" (assert)
                (("" (flatten) (("" (assert) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (astType type-decl nil ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (subterm_of type-eq-decl nil peg nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (<= const-decl "bool" reals nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (below type-eq-decl nil naturalnumbers nil)
    (astTypeOf type-eq-decl nil semantic_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype
    "ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].failure"
    "semantic_parser.astTypeOf(peg_parser[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].parsing(semantic_parser.P_exp, semantic_parser.A, semantic_parser.G, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T))")))
 (sempp_TCC104 0
  (sempp_TCC106-1 nil 3804941352
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (assert)
          (("" (expand "s_inp")
            (("" (expand "astType?")
              (("" (assert)
                (("" (lift-if)
                  (("" (ground)
                    (("" (typepred "T!1")
                      (("" (typepred "status!1")
                        (("" (lemma "Wellformed_theorem" (T "T!1"))
                          (("" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (astTypeOf type-eq-decl nil semantic_parser nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (astType type-decl nil ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (subterm_of type-eq-decl nil peg nil) (peg type-decl nil peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (ast type-eq-decl nil ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (below type-eq-decl nil naturalnumbers nil)
    (equalTo type-eq-decl nil semantic_parser nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype
    "pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].fail(semantic_parser.s, semantic_parser.s)"
    "semantic_parser.equalTo(semantic_interp[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].s_inp(semantic_parser.P_inp, peg_parser[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].parsing(semantic_parser.P_exp, semantic_parser.A, semantic_parser.G, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T)))")))
 (sempp_TCC105 0
  (sempp_TCC105-1 nil 3775125996
   ("" (skeep)
    (("" (use "subterm_andP" (G "P_exp(A)"))
      (("" (assert) (("" (typepred "G") (("" (assert) nil nil)) nil))
        nil))
      nil))
    nil)
   ((subterm_andP formula-decl nil peg nil) (peg type-decl nil peg nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (below type-eq-decl nil naturalnumbers nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (subterm_of type-eq-decl nil peg nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (subterm_of? const-decl "bool" peg nil))
   nil
   (sempp subtype "semantic_parser.e"
    "peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].subterm_of(semantic_parser.P_exp(semantic_parser.A))")))
 (sempp_TCC106 0
  (sempp_TCC106-1 nil 3775125996
   ("" (skeep*)
    (("" (typepred "s_T")
      (("" (assert)
        (("" (expand "g_wf" -)
          (("" (replace -3 * LR) (("" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of type-eq-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype "semantic_parser.s_T"
    "{k: naturalnumbers.upto(semantic_parser.s) | booleans.⇒((k = semantic_parser.s), wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].pattern_wf?(semantic_parser.e, semantic_parser.A, static_analysis[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].σ(semantic_parser.P_exp), wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].P_0c(semantic_parser.P_exp)))}")))
 (sempp_TCC107 0
  (sempp_TCC107-1 nil 3775125996
   ("" (assert)
    (("" (assert)
      (("" (skeep*)
        (("" (replace -1 * LR) (("" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((lex3_lt formula-decl nil lex3 nil)
    (lex2_lt formula-decl nil lex2 nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (pegMeasure_andP formula-decl nil peg nil)
    (TRUE const-decl "bool" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (lex4_lt formula-decl nil lex4 nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (sempp termination
    "semantic_parser.sempp(semantic_parser.P_exp, semantic_parser.P_inp, semantic_parser.A, semantic_parser.e, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T, semantic_parser.res)"
    "nil")))
 (sempp_TCC108 0
  (sempp_TCC110-1 nil 3804941352
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (expand "astType?") (("" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype
    "ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].success"
    "semantic_parser.astTypeOf(peg_parser[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].parsing(semantic_parser.P_exp, semantic_parser.A, semantic_parser.G, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T))")))
 (sempp_TCC109 0
  (sempp_TCC109-1 nil 3775125996
   ("" (skeep*)
    (("" (typepred "T!1")
      (("" (name-replace "T1" "T!1")
        (("" (name "T1_p" "parsing(P_exp, A, e, inp, s, s_T)")
          (("" (replace -1 * LR)
            (("" (lemma "semantic_interp_props")
              (("" (inst -1 "T1_p" "P_inp")
                (("" (replace -3 * RL)
                  (("" (flatten)
                    (("" (expand "astWellformed?")
                      (("" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((equalTo type-eq-decl nil semantic_parser nil)
    (below type-eq-decl nil naturalnumbers nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (ast type-eq-decl nil ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (subterm_of type-eq-decl nil peg nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semantic_interp_props formula-decl nil semantic_interp nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype "semantic_parser.T"
    "{T: pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].pre_ast | (booleans.¬)(pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].skip?(T))}")))
 (sempp_TCC110 0
  (sempp_TCC111-1 nil 3804941352
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (expand "s_inp")
          (("" (assert)
            (("" (lift-if)
              (("" (assert)
                (("" (ground)
                  (("" (expand "astType?") (("" (propax) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype
    "pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].andP(semantic_parser.s, semantic_parser.s, semantic_parser.T)"
    "semantic_parser.equalTo(semantic_interp[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].s_inp(semantic_parser.P_inp, peg_parser[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].parsing(semantic_parser.P_exp, semantic_parser.A, semantic_parser.G, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T)))")))
 (sempp_TCC111 0
  (sempp_TCC113-1 nil 3804941352
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing" +)
        (("" (assert)
          (("" (expand "astType?" +)
            (("" (assert)
              ((""
                (lemma "Wellformed_theorem"
                 (T "parsing(P_exp, A, e, inp, s, s_T)"))
                (("" (assert) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((astType? def-decl "astType" ast nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (below type-eq-decl nil naturalnumbers nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType type-decl nil ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (subterm_of? const-decl "bool" peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (order type-eq-decl nil wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (<= const-decl "bool" reals nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (< const-decl "bool" reals nil)
    (subterm_of type-eq-decl nil peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (pre_ast type-decl nil pre_ast nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype
    "ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].failure"
    "semantic_parser.astTypeOf(peg_parser[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].parsing(semantic_parser.P_exp, semantic_parser.A, semantic_parser.G, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T))")))
 (sempp_TCC112 0
  (sempp_TCC112-1 nil 3804941352
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (expand "s_inp")
          (("" (expand "astType?")
            (("" (assert)
              (("" (ground)
                (("" (lift-if)
                  (("" (assert)
                    (("" (ground)
                      (("" (assert)
                        (("" (typepred "status!1")
                          ((""
                            (lemma "Wellformed_theorem"
                             (T "parsing(P_exp, A, e, inp, s, s_T)"))
                            (("" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((s_inp def-decl "{T_p: semanticTree |
      (skip?(T) ⇔ skip?(T_p)) ∧ (star?(T) ⇔ star?(T_p))
    ∧ (astType?(T) = failure ⇔ fail?(T_p))
    ∧ (plus?(T) ⇒ (plus?(T_p) ∨ fail?(T_p))) ∧ (s(T_p) = s(T))
    ∧ (e(T_p) = e(T))
    ∧ (astWellformed?(T) ⇒
        (astWellformed?(T_p) ∧ (astType?(T_p) = astType?(T))))}"
     semantic_interp nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (astType type-decl nil ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (subterm_of type-eq-decl nil peg nil)
    (< const-decl "bool" reals nil) (peg type-decl nil peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (<= const-decl "bool" reals nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (subterm_of? const-decl "bool" peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (below type-eq-decl nil naturalnumbers nil)
    (astTypeOf type-eq-decl nil semantic_parser nil)
    (astType? def-decl "astType" ast nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype
    "pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].fail(semantic_parser.s, semantic_parser.s)"
    "semantic_parser.equalTo(semantic_interp[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].s_inp(semantic_parser.P_inp, peg_parser[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].parsing(semantic_parser.P_exp, semantic_parser.A, semantic_parser.G, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T)))"))))

