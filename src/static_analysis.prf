(inferred_order_wf_peg
 (inv_TCC1 0
  (inv_TCC1-1 nil 3813650237
   ("" (lemma "function_inverse_def[V_N,V_N].bijective_inverse_exists")
    (("" (postpone) nil nil)) nil)
   nil nil
   (inv existence ""
    "[σ: inferred_order_wf_peg.nT_Permutation -> {σ' | function_props[V_N[V_N_b], V_N[V_N_b], V_N[V_N_b]].o(σ, inferred_order_wf_peg.σ') = identity[V_N[V_N_b]].identity}]")))
 (g_wf_perm_TCC1 0
  (g_wf_perm_TCC1-1 nil 3813750082 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" inferred_order_wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (bijective? const-decl "bool" functions nil)
    (nT_Permutation type-eq-decl nil inferred_order_wf_peg nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (sum const-decl "nat" peg nil)
    (surjective? const-decl "bool" functions nil)
    (injective? const-decl "bool" functions nil)
    (pegMeasure const-decl "nat" peg nil))
   nil
   (g_wf_perm termination
    "inferred_order_wf_peg.g_wf_perm(inferred_order_wf_peg.σ)(inferred_order_wf_peg.e1, inferred_order_wf_peg.A, inferred_order_wf_peg.P_0, inferred_order_wf_peg.δ)"
    "nil")))
 (g_wf_perm_TCC2 0
  (g_wf_perm_TCC2-1 nil 3813750082 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" inferred_order_wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (bijective? const-decl "bool" functions nil)
    (nT_Permutation type-eq-decl nil inferred_order_wf_peg nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (sum const-decl "nat" peg nil)
    (surjective? const-decl "bool" functions nil)
    (injective? const-decl "bool" functions nil)
    (pegMeasure const-decl "nat" peg nil))
   nil
   (g_wf_perm termination
    "inferred_order_wf_peg.g_wf_perm(inferred_order_wf_peg.σ)(inferred_order_wf_peg.e2, inferred_order_wf_peg.A, inferred_order_wf_peg.P_0, booleans.∧(inferred_order_wf_peg.P_0(inferred_order_wf_peg.e1), inferred_order_wf_peg.δ))"
    "nil")))
 (g_wf_perm_TCC3 0
  (g_wf_perm_TCC3-1 nil 3813750082 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" inferred_order_wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (bijective? const-decl "bool" functions nil)
    (nT_Permutation type-eq-decl nil inferred_order_wf_peg nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (sum const-decl "nat" peg nil)
    (surjective? const-decl "bool" functions nil)
    (injective? const-decl "bool" functions nil)
    (pegMeasure const-decl "nat" peg nil))
   nil
   (g_wf_perm termination
    "inferred_order_wf_peg.g_wf_perm(inferred_order_wf_peg.σ)(inferred_order_wf_peg.e1, inferred_order_wf_peg.A, inferred_order_wf_peg.P_0, inferred_order_wf_peg.δ)"
    "nil")))
 (g_wf_perm_TCC4 0
  (g_wf_perm_TCC4-1 nil 3813750082 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" inferred_order_wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (bijective? const-decl "bool" functions nil)
    (nT_Permutation type-eq-decl nil inferred_order_wf_peg nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (sum const-decl "nat" peg nil)
    (surjective? const-decl "bool" functions nil)
    (injective? const-decl "bool" functions nil)
    (pegMeasure const-decl "nat" peg nil))
   nil
   (g_wf_perm termination
    "inferred_order_wf_peg.g_wf_perm(inferred_order_wf_peg.σ)(inferred_order_wf_peg.e2, inferred_order_wf_peg.A, inferred_order_wf_peg.P_0, inferred_order_wf_peg.δ)"
    "nil")))
 (g_wf_perm_TCC5 0
  (g_wf_perm_TCC5-1 nil 3813750082 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" inferred_order_wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (bijective? const-decl "bool" functions nil)
    (nT_Permutation type-eq-decl nil inferred_order_wf_peg nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (inc const-decl "nat" peg nil)
    (surjective? const-decl "bool" functions nil)
    (injective? const-decl "bool" functions nil)
    (pegMeasure const-decl "nat" peg nil))
   nil
   (g_wf_perm termination
    "inferred_order_wf_peg.g_wf_perm(inferred_order_wf_peg.σ)(inferred_order_wf_peg.e, inferred_order_wf_peg.A, inferred_order_wf_peg.P_0, inferred_order_wf_peg.δ)"
    "nil")))
 (g_wf_perm_TCC6 0
  (g_wf_perm_TCC6-1 nil 3813750082 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" inferred_order_wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (bijective? const-decl "bool" functions nil)
    (nT_Permutation type-eq-decl nil inferred_order_wf_peg nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (inc const-decl "nat" peg nil)
    (surjective? const-decl "bool" functions nil)
    (injective? const-decl "bool" functions nil)
    (pegMeasure const-decl "nat" peg nil))
   nil
   (g_wf_perm termination
    "inferred_order_wf_peg.g_wf_perm(inferred_order_wf_peg.σ)(inferred_order_wf_peg.e, inferred_order_wf_peg.A, inferred_order_wf_peg.P_0, inferred_order_wf_peg.δ)"
    "nil")))
 (g_wf_perm_TCC7 0
  (g_wf_perm_TCC7-1 nil 3813750082 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" inferred_order_wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (bijective? const-decl "bool" functions nil)
    (nT_Permutation type-eq-decl nil inferred_order_wf_peg nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (inc const-decl "nat" peg nil)
    (surjective? const-decl "bool" functions nil)
    (injective? const-decl "bool" functions nil)
    (pegMeasure const-decl "nat" peg nil))
   nil
   (g_wf_perm termination
    "inferred_order_wf_peg.g_wf_perm(inferred_order_wf_peg.σ)(inferred_order_wf_peg.e, inferred_order_wf_peg.A, inferred_order_wf_peg.P_0, inferred_order_wf_peg.δ)"
    "nil")))
 (g_wf_perm_TCC8 0
  (g_wf_perm_TCC8-1 nil 3813750082 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" inferred_order_wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (bijective? const-decl "bool" functions nil)
    (nT_Permutation type-eq-decl nil inferred_order_wf_peg nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (inc const-decl "nat" peg nil)
    (surjective? const-decl "bool" functions nil)
    (injective? const-decl "bool" functions nil)
    (pegMeasure const-decl "nat" peg nil))
   nil
   (g_wf_perm termination
    "inferred_order_wf_peg.g_wf_perm(inferred_order_wf_peg.σ)(inferred_order_wf_peg.e, inferred_order_wf_peg.A, inferred_order_wf_peg.P_0, inferred_order_wf_peg.δ)"
    "nil")))
 (g_wf_perm_TCC9 0
  (g_wf_perm_TCC9-1 nil 3813750082 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" inferred_order_wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (bijective? const-decl "bool" functions nil)
    (nT_Permutation type-eq-decl nil inferred_order_wf_peg nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (inc const-decl "nat" peg nil)
    (surjective? const-decl "bool" functions nil)
    (injective? const-decl "bool" functions nil)
    (pegMeasure const-decl "nat" peg nil))
   nil
   (g_wf_perm termination
    "inferred_order_wf_peg.g_wf_perm(inferred_order_wf_peg.σ)(inferred_order_wf_peg.e, inferred_order_wf_peg.A, inferred_order_wf_peg.P_0, inferred_order_wf_peg.δ)"
    "nil")))
 (sub_nT_TCC1 0
  (sub_nT_TCC1-1 nil 3813611401 ("" (subtype-tcc) nil nil)
   ((∅ const-decl "set[V_N[V_N_b]]" inferred_order_wf_peg nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil))
   nil
   (sub_nT subtype "inferred_order_wf_peg.∅"
    "finite_set[V_N[V_N_b]]")))
 (sub_nT_TCC2 0
  (sub_nT_TCC2-1 nil 3813611401 ("" (subtype-tcc) nil nil)
   ((∅ const-decl "set[V_N[V_N_b]]" inferred_order_wf_peg nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil))
   nil
   (sub_nT subtype "inferred_order_wf_peg.∅"
    "finite_set[V_N[V_N_b]]")))
 (sub_nT_TCC3 0
  (sub_nT_TCC3-1 nil 3813611401 ("" (subtype-tcc) nil nil)
   ((∅ const-decl "set[V_N[V_N_b]]" inferred_order_wf_peg nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil))
   nil
   (sub_nT subtype "inferred_order_wf_peg.∅"
    "finite_set[V_N[V_N_b]]")))
 (sub_nT_TCC4 0
  (sub_nT_TCC4-1 nil 3813611401 ("" (subtype-tcc) nil nil)
   ((∅ const-decl "set[V_N[V_N_b]]" inferred_order_wf_peg nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil))
   nil
   (sub_nT subtype "inferred_order_wf_peg.∅"
    "finite_set[V_N[V_N_b]]")))
 (sub_nT_TCC5 0
  (sub_nT_TCC5-1 nil 3813611401 ("" (termination-tcc) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (sum const-decl "nat" peg nil)
    (pegMeasure const-decl "nat" peg nil))
   nil
   (sub_nT termination
    "inferred_order_wf_peg.sub_nT(inferred_order_wf_peg.e1, inferred_order_wf_peg.P_0)"
    "nil")))
 (sub_nT_TCC6 0
  (sub_nT_TCC6-1 nil 3813611401 ("" (termination-tcc) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (sum const-decl "nat" peg nil)
    (pegMeasure const-decl "nat" peg nil))
   nil
   (sub_nT termination
    "inferred_order_wf_peg.sub_nT(inferred_order_wf_peg.e2, inferred_order_wf_peg.P_0)"
    "nil")))
 (sub_nT_TCC7 0
  (sub_nT_TCC7-1 nil 3813611401 ("" (termination-tcc) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (sum const-decl "nat" peg nil)
    (pegMeasure const-decl "nat" peg nil))
   nil
   (sub_nT termination
    "inferred_order_wf_peg.sub_nT(inferred_order_wf_peg.e1, inferred_order_wf_peg.P_0)"
    "nil")))
 (sub_nT_TCC8 0
  (sub_nT_TCC8-1 nil 3813611401 ("" (termination-tcc) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (sum const-decl "nat" peg nil)
    (pegMeasure const-decl "nat" peg nil))
   nil
   (sub_nT termination
    "inferred_order_wf_peg.sub_nT(inferred_order_wf_peg.e1, inferred_order_wf_peg.P_0)"
    "nil")))
 (sub_nT_TCC9 0
  (sub_nT_TCC9-1 nil 3813611401 ("" (termination-tcc) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (sum const-decl "nat" peg nil)
    (pegMeasure const-decl "nat" peg nil))
   nil
   (sub_nT termination
    "inferred_order_wf_peg.sub_nT(inferred_order_wf_peg.e2, inferred_order_wf_peg.P_0)"
    "nil")))
 (sub_nT_TCC10 0
  (sub_nT_TCC10-1 nil 3813611401 ("" (termination-tcc) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (inc const-decl "nat" peg nil)
    (pegMeasure const-decl "nat" peg nil))
   nil
   (sub_nT termination
    "inferred_order_wf_peg.sub_nT(inferred_order_wf_peg.e, inferred_order_wf_peg.P_0)"
    "nil")))
 (sub_nT_TCC11 0
  (sub_nT_TCC11-1 nil 3813611401 ("" (termination-tcc) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (inc const-decl "nat" peg nil)
    (pegMeasure const-decl "nat" peg nil))
   nil
   (sub_nT termination
    "inferred_order_wf_peg.sub_nT(inferred_order_wf_peg.e, inferred_order_wf_peg.P_0)"
    "nil")))
 (sub_nT_TCC12 0
  (sub_nT_TCC12-1 nil 3813611401 ("" (termination-tcc) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (inc const-decl "nat" peg nil)
    (pegMeasure const-decl "nat" peg nil))
   nil
   (sub_nT termination
    "inferred_order_wf_peg.sub_nT(inferred_order_wf_peg.e, inferred_order_wf_peg.P_0)"
    "nil")))
 (sub_nT_TCC13 0
  (sub_nT_TCC13-1 nil 3813611401 ("" (termination-tcc) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (inc const-decl "nat" peg nil)
    (pegMeasure const-decl "nat" peg nil))
   nil
   (sub_nT termination
    "inferred_order_wf_peg.sub_nT(inferred_order_wf_peg.e, inferred_order_wf_peg.P_0)"
    "nil")))
 (sub_nT_TCC14 0
  (sub_nT_TCC14-1 nil 3813611401 ("" (termination-tcc) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (inc const-decl "nat" peg nil)
    (pegMeasure const-decl "nat" peg nil))
   nil
   (sub_nT termination
    "inferred_order_wf_peg.sub_nT(inferred_order_wf_peg.e, inferred_order_wf_peg.P_0)"
    "nil")))
 (sub_nT_and_wellformedness_TCC1 0
  (sub_nT_and_wellformedness_TCC1-1 nil 3813611401
   ("" (subtype-tcc) nil nil) nil nil
   (sub_nT_and_wellformedness subtype "inferred_order_wf_peg.A"
    "naturalnumbers.upto(inferred_order_wf_peg.V_N_b)")))
 (sub_nT_and_wellformedness 0
  (sub_nT_and_wellformedness-1 nil 3813611424
   ("" (induct G)
    (("1" (skeep*)
      (("1" (assert)
        (("1" (expand "g_wf")
          (("1" (expand "sub_nT")
            (("1" (assert)
              (("1" (skeep)
                (("1" (assert) (("1" (grind) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil)
     ("5" (grind) nil nil)
     ("6" (skolem 1 ("e1" "e2"))
      (("6" (flatten)
        (("6" (skeep*)
          (("6" (expand "g_wf" +)
            (("6" (assert)
              (("6" (inst -1 "A" "P_0")
                (("6" (inst -2 "A" "P_0")
                  (("6" (split 1)
                    (("1" (flatten)
                      (("1" (assert)
                        (("1" (split)
                          (("1" (assert) nil nil)
                           ("2" (flatten)
                            (("2" (assert)
                              (("2"
                                (expand "complete")
                                (("2"
                                  (expand "strong")
                                  (("2"
                                    (assert)
                                    (("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("3" (assert)
                            (("3" (flatten)
                              (("3"
                                (assert)
                                (("3"
                                  (skeep*)
                                  (("3" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (expand "strong")
                      (("2" (expand "complete")
                        (("2" (flatten)
                          (("2" (split)
                            (("1" (assert)
                              (("1"
                                (skeep)
                                (("1"
                                  (assert)
                                  (("1" (grind) nil nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (assert)
                              (("2"
                                (ground)
                                (("1" (grind) nil nil)
                                 ("2"
                                  (skeep*)
                                  (("2"
                                    (assert)
                                    (("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("7" (skolem 1 ("e1" "e2"))
      (("7" (flatten)
        (("7" (skeep*)
          (("7" (inst -1 "A" "P_0")
            (("7" (inst - "A" "P_0")
              (("7" (expand "strong")
                (("7" (expand "complete")
                  (("7" (expand "g_wf" +)
                    (("7" (split 1)
                      (("1" (flatten)
                        (("1" (assert)
                          (("1" (split 1)
                            (("1" (flatten) nil nil)
                             ("2" (assert) nil nil)
                             ("3" (skeep*)
                              (("3"
                                (assert)
                                (("3"
                                  (expand "sub_nT" -1)
                                  (("3" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (flatten)
                        (("2" (split 1)
                          (("1" (assert)
                            (("1" (skeep)
                              (("1"
                                (assert)
                                (("1" (grind) nil nil))
                                nil))
                              nil))
                            nil)
                           ("2" (assert)
                            (("2" (skeep) (("2" (grind) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("8" (skolem 1 ("e"))
      (("8" (flatten)
        (("8" (skeep)
          (("8" (inst? -)
            (("8" (inst? -)
              (("8" (expand "g_wf" +)
                (("8" (split 1)
                  (("1" (flatten)
                    (("1" (assert)
                      (("1" (split 2)
                        (("1" (assert) nil nil)
                         ("2" (skeep) (("2" (grind) nil nil)) nil))
                        nil))
                      nil))
                    nil)
                   ("2" (flatten)
                    (("2" (assert)
                      (("2" (skeep)
                        (("2" (assert) (("2" (grind) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("9" (skolem 1 ("e"))
      (("9" (flatten)
        (("9" (skeep)
          (("9" (inst? -) (("9" (inst? -) (("9" (grind) nil nil)) nil))
            nil))
          nil))
        nil))
      nil)
     ("10" (skolem 1 ("e"))
      (("10" (flatten)
        (("10" (skeep)
          (("10" (inst? -)
            (("10" (inst? -) (("10" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil)
     ("11" (skolem 1 ("e"))
      (("11" (flatten)
        (("11" (skeep)
          (("11" (inst? -)
            (("11" (inst? -) (("11" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil)
     ("12" (skolem 1 ("e"))
      (("12" (flatten)
        (("12" (skeep)
          (("12" (inst? -)
            (("12" (inst? -) (("12" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((finite_union application-judgement "finite_set" finite_sets nil)
    (member const-decl "bool" sets nil)
    (union const-decl "set" sets nil)
    (singleton const-decl "(singleton?)" sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (below type-eq-decl nil naturalnumbers nil)
    (TRUE const-decl "bool" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (emptyset const-decl "set" sets nil)
    (∅ const-decl "set[V_N[V_N_b]]" inferred_order_wf_peg nil)
    (peg_induction formula-decl nil peg nil)
    (V_T formal-nonempty-type-decl nil inferred_order_wf_peg nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" inferred_order_wf_peg
        nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" inferred_order_wf_peg nil)
    (sub_nT def-decl "finite_set[V_N[V_N_b]]" inferred_order_wf_peg
     nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (complete const-decl "bool" wf_peg nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (strong const-decl "bool" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (peg type-decl nil peg nil))
   shostak))
 (sub_nT_and_wellformedness_perm 0
  (sub_nT_and_wellformedness_perm-1 nil 3813751386
   ("" (skolem 1 ("s" "_" "_" "_"))
    (("" (expand "strong")
      (("" (expand "complete")
        (("" (induct G)
          (("1" (skeep*)
            (("1" (expand "g_wf_perm" +)
              (("1" (ground) (("1" (grind) nil nil)) nil)) nil))
            nil)
           ("2" (skeep*)
            (("2" (expand "g_wf_perm" +)
              (("2" (ground) (("2" (grind) nil nil)) nil)) nil))
            nil)
           ("3" (skeep*)
            (("3" (expand "g_wf_perm" +)
              (("3" (ground) (("3" (grind) nil nil)) nil)) nil))
            nil)
           ("4" (skeep*)
            (("4" (expand "g_wf_perm" +)
              (("4" (ground) (("4" (grind) nil nil)) nil)) nil))
            nil)
           ("5" (skeep*)
            (("5" (expand "g_wf_perm" +)
              (("5" (ground)
                (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
              nil))
            nil)
           ("6" (skeep*)
            (("6" (expand "g_wf_perm" +)
              (("6" (ground)
                (("1" (grind) nil nil) ("2" (grind) nil nil)
                 ("3" (grind) nil nil)
                 ("4" (inst? -4)
                  (("4" (assert)
                    (("4" (skeep) (("4" (grind) nil nil)) nil)) nil))
                  nil)
                 ("5" (inst? -5)
                  (("5" (assert)
                    (("5" (case "P_0(seq1_var)")
                      (("1" (assert)
                        (("1" (skeep) (("1" (grind) nil nil)) nil))
                        nil)
                       ("2" (assert) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("7" (skeep*)
            (("7" (expand "g_wf_perm" +)
              (("7" (assert)
                (("7" (split 1)
                  (("1" (flatten)
                    (("1" (assert)
                      (("1" (split)
                        (("1" (assert) (("1" (grind) nil nil)) nil)
                         ("2" (grind) nil nil)
                         ("3" (expand "sub_nT" 1)
                          (("3" (expand "union" 1)
                            (("3" (skeep)
                              (("3"
                                (assert)
                                (("3" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (flatten)
                    (("2" (split 1)
                      (("1" (inst? -4)
                        (("1" (assert)
                          (("1" (skeep) (("1" (grind) nil nil)) nil))
                          nil))
                        nil)
                       ("2" (inst? -5)
                        (("2" (assert)
                          (("2" (skeep) (("2" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("8" (skeep*)
            (("8" (expand "g_wf_perm" +)
              (("8" (ground)
                (("1" (grind) nil nil) ("2" (grind) nil nil)
                 ("3" (grind) nil nil))
                nil))
              nil))
            nil)
           ("9" (skeep*)
            (("9" (expand "g_wf_perm" +)
              (("9" (ground)
                (("1" (grind) nil nil) ("2" (grind) nil nil)
                 ("3" (grind) nil nil))
                nil))
              nil))
            nil)
           ("10" (skeep*)
            (("10" (expand "g_wf_perm" +)
              (("10" (ground)
                (("1" (grind) nil nil) ("2" (grind) nil nil)
                 ("3" (grind) nil nil))
                nil))
              nil))
            nil)
           ("11" (skeep*)
            (("11" (expand "g_wf_perm" +)
              (("11" (ground)
                (("1" (grind) nil nil) ("2" (grind) nil nil)
                 ("3" (grind) nil nil))
                nil))
              nil))
            nil)
           ("12" (skeep*)
            (("12" (expand "g_wf_perm" +)
              (("12" (ground)
                (("1" (grind) nil nil) ("2" (grind) nil nil)
                 ("3" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((strong const-decl "bool" wf_peg nil)
    (union const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (singleton const-decl "(singleton?)" sets nil)
    (below type-eq-decl nil naturalnumbers nil)
    (emptyset const-decl "set" sets nil)
    (∅ const-decl "set[V_N[V_N_b]]" inferred_order_wf_peg nil)
    (peg_induction formula-decl nil peg nil)
    (V_T formal-nonempty-type-decl nil inferred_order_wf_peg nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" inferred_order_wf_peg
        nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" inferred_order_wf_peg nil)
    (sub_nT def-decl "finite_set[V_N[V_N_b]]" inferred_order_wf_peg
     nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (FALSE const-decl "bool" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (g_wf_perm def-decl "bool" inferred_order_wf_peg nil)
    (nT_Permutation type-eq-decl nil inferred_order_wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (peg type-decl nil peg nil)
    (complete const-decl "bool" wf_peg nil))
   shostak))
 (kahns_algorithm_TCC1 0
  (kahns_algorithm_TCC1-1 nil 3813648570
   ("" (inst 1 "LAMBDA (P_exp: interp[V_T, <=, V_N_b]): None") nil nil)
   ((None adt-constructor-decl "(None?)" inferred_order_wf_peg nil)
    (None? adt-recognizer-decl "[option_permutation -> boolean]"
     inferred_order_wf_peg nil)
    (σ adt-accessor-decl "[(Some?) -> nT_Permutation]"
     inferred_order_wf_peg nil)
    (topologically_sorts? const-decl "bool" inferred_order_wf_peg nil)
    (nT_Permutation type-eq-decl nil inferred_order_wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (peg type-decl nil peg nil) (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Some? adt-recognizer-decl "[option_permutation -> boolean]"
     inferred_order_wf_peg nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (option_permutation type-decl nil inferred_order_wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N_b formal-const-decl "posnat" inferred_order_wf_peg nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" inferred_order_wf_peg
        nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (V_T formal-nonempty-type-decl nil inferred_order_wf_peg nil))
   nil
   (kahns_algorithm existence ""
    "[P_exp: wf_peg[inferred_order_wf_peg.V_T, inferred_order_wf_peg.<=, inferred_order_wf_peg.V_N_b].interp -> {Σ: inferred_order_wf_peg.option_permutation | (booleans.⇒(inferred_order_wf_peg.Some?(Σ), inferred_order_wf_peg.topologically_sorts?(P_exp, inferred_order_wf_peg.σ(Σ))))}]")))
 (complete_WF_reorders 0
  (complete_WF_reorders-2
   "Tried to unfold a g_wf in hypothesis, spotted a problem" 3813747419
   ("" (skolem 1 ("P_exp" "s"))
    (("" (flatten)
      ((""
        (case "(FORALL (A: V_N[V_N_b]), G: subterm(G, P_exp(A)) IMPLIES g_wf(G, A, P_0c?(P_exp), FALSE)) ⇒
                     FORALL (A: V_N[V_N_b]), G: subterm(G, (P_exp)(A)) IMPLIES g_wf_perm(s)(G, A, P_0c?(P_exp), FALSE)")
        (("1" (expand "complete_WF_perm")
          (("1" (split -1)
            (("1" (grind) nil nil)
             ("2" (hide 2)
              (("2" (use "complete_WF_theorem2")
                (("2" (assert) nil nil)) nil))
              nil))
            nil))
          nil)
         ("2" (hide 2)
          (("2" (flatten)
            (("2" (skolem 1 ("A" "_"))
              (("2" (induct "G")
                (("1" (grind) nil nil) ("2" (grind) nil nil)
                 ("3" (grind) nil nil) ("4" (grind) nil nil)
                 ("5" (grind) nil nil)
                 ("6" (skolem 1 (e1 e2))
                  (("6" (assert)
                    (("6" (flatten)
                      (("6" (assert)
                        (("6" (expand g_wf_perm 1)
                          (("6" (split 1)
                            (("1" (assert)
                              (("1"
                                (use
                                 "peg[V_T, <=, V_N_b].subterm_transitivity"
                                 (e1 "seq(e1,e2)"))
                                (("1" (grind) nil nil))
                                nil))
                              nil)
                             ("2" (assert)
                              (("2"
                                (use
                                 "peg[V_T, <=, V_N_b].subterm_transitivity"
                                 (e1 "seq(e1,e2)"))
                                (("2"
                                  (assert)
                                  (("2"
                                    (use
                                     "peg[V_T, <=, V_N_b].subterm_transitivity"
                                     (e1 "seq(e1,e2)" e e2))
                                    (("2"
                                      (assert)
                                      (("2"
                                        (ground)
                                        (("1" (grind) nil nil)
                                         ("2" (grind) nil nil)
                                         ("3" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("7" (skolem 1 (e1 e2))
                  (("7" (flatten)
                    (("7" (assert)
                      (("7" (expand g_wf_perm 1)
                        (("7" (split 1)
                          (("1" (assert)
                            (("1"
                              (use "peg[V_T, <=, V_N_b].subterm_transitivity"
                                   (e1 "prior(e1,e2)"))
                              (("1"
                                (assert)
                                (("1" (grind) nil nil))
                                nil))
                              nil))
                            nil)
                           ("2" (assert)
                            (("2"
                              (use "peg[V_T, <=, V_N_b].subterm_transitivity"
                                   (e1 "prior(e1,e2)"))
                              (("2"
                                (use
                                 "peg[V_T, <=, V_N_b].subterm_transitivity"
                                 (e1 "prior(e1,e2)" e e2))
                                (("2"
                                  (assert)
                                  (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("8" (skolem 1 (e))
                  (("8" (flatten)
                    (("8" (assert)
                      (("8" (expand g_wf_perm 1)
                        (("8" (split 1)
                          (("1" (assert)
                            (("1"
                              (use "peg[V_T, <=, V_N_b].subterm_transitivity"
                                   (e1 "star(e)"))
                              (("1"
                                (assert)
                                (("1" (grind) nil nil))
                                nil))
                              nil))
                            nil)
                           ("2" (inst -4 "A" "star(e)")
                            (("2" (assert)
                              (("2"
                                (expand "g_wf")
                                (("2" (propax) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("9" (skolem 1 (e))
                  (("9" (flatten)
                    (("9" (assert)
                      (("9" (expand g_wf_perm 1)
                        (("9" (split 1)
                          (("1" (assert)
                            (("1"
                              (use "peg[V_T, <=, V_N_b].subterm_transitivity"
                                   (e1 "plus(e)"))
                              (("1"
                                (assert)
                                (("1" (grind) nil nil))
                                nil))
                              nil))
                            nil)
                           ("2" (inst - "A" "plus(e)")
                            (("2" (assert)
                              (("2"
                                (expand "g_wf")
                                (("2" (propax) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("10" (skolem 1 (e))
                  (("10" (flatten)
                    (("10" (assert)
                      (("10" (expand g_wf_perm 1)
                        (("10" (assert)
                          (("10"
                            (use "peg[V_T, <=, V_N_b].subterm_transitivity"
                                 (e1 "opt(e)"))
                            (("10" (assert) (("10" (grind) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("11" (skolem 1 (e))
                  (("11" (flatten)
                    (("11" (assert)
                      (("11" (expand g_wf_perm 1)
                        (("11" (assert)
                          (("11"
                            (use "peg[V_T, <=, V_N_b].subterm_transitivity"
                                 (e1 "notP(e)"))
                            (("11" (assert) (("11" (grind) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("12" (skolem 1 (e))
                  (("12" (flatten)
                    (("12" (assert)
                      (("12" (expand g_wf_perm 1)
                        (("12" (assert)
                          (("12"
                            (use "peg[V_T, <=, V_N_b].subterm_transitivity"
                                 (e1 "andP(e)"))
                            (("12" (assert) (("12" (grind) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((andP? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (andP adt-constructor-decl "[peg -> (andP?)]" peg nil)
    (notP? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (notP adt-constructor-decl "[peg -> (notP?)]" peg nil)
    (opt? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (opt adt-constructor-decl "[peg -> (opt?)]" peg nil)
    (plus adt-constructor-decl "[peg -> (plus?)]" peg nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star adt-constructor-decl "[peg -> (star?)]" peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (prior adt-constructor-decl "[[peg, peg] -> (prior?)]" peg nil)
    (prior? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (subterm_transitivity formula-decl nil peg nil)
    (seq? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (seq adt-constructor-decl "[[peg, peg] -> (seq?)]" peg nil)
    (peg_induction formula-decl nil peg nil)
    (complete_WF_perm const-decl "bool" inferred_order_wf_peg nil)
    (complete_WF_theorem2 formula-decl nil wf_peg nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (complete const-decl "bool" wf_peg nil)
    (complete_WF const-decl "bool" wf_peg nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" inferred_order_wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (V_T formal-nonempty-type-decl nil inferred_order_wf_peg nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" inferred_order_wf_peg
        nil)
    (peg type-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (FALSE const-decl "bool" booleans nil)
    (bijective? const-decl "bool" functions nil)
    (nT_Permutation type-eq-decl nil inferred_order_wf_peg nil)
    (g_wf_perm def-decl "bool" inferred_order_wf_peg nil))
   shostak)
  (complete_WF_reorders-1 nil 3813650558
   ("" (skolem 1 ("P_exp" "s"))
    (("" (flatten)
      (("" (expand "complete_WF" 1)
        (("" (skeep)
          ((""
            (case "(FORALL (A: V_N[V_N_b]), G: subterm(G, P_exp(A)) IMPLIES g_wf(G, A, P_0c?(P_exp), FALSE)) ⇒
              FORALL (A: V_N[V_N_b]), G: subterm(G, (P_exp o s)(A)) IMPLIES g_wf(G, A, P_0c?(P_exp o s), FALSE)")
            (("1" (split -1)
              (("1" (inst -1 "A" "(P_exp o s)(A)")
                (("1" (assert)
                  (("1" (expand "complete")
                    (("1" (assert)
                      (("1" (expand "subterm") (("1" (propax) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (hide 2)
                (("2" (lemma "complete_WF_theorem2")
                  (("2" (inst? -) (("2" (assert) nil nil)) nil)) nil))
                nil))
              nil)
             ("2" (flatten)
              (("2" (hide 2)
                (("2" (skolem 1 (B _))
                  (("2" (induct "G")
                    (("1" (assert) (("1" (grind) nil nil)) nil)
                     ("2" (grind) nil nil) ("3" (grind) nil nil)
                     ("4" (grind) nil nil) ("5" (grind) nil nil)
                     ("6" (skolem 1 (e1 e2))
                      (("6" (flatten)
                        (("6" (expand "g_wf" 1)
                          (("6" (split)
                            (("1" (assert)
                              (("1"
                                (assert)
                                (("1"
                                  (use
                                   "peg[V_T, <=, V_N_b].subterm_transitivity"
                                   (e1 "seq(e1,e2)"))
                                  (("1"
                                    (assert)
                                    (("1" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (assert)
                              (("2"
                                (use
                                 "peg[V_T, <=, V_N_b].subterm_transitivity"
                                 (e1 "seq(e1,e2)"))
                                (("2"
                                  (assert)
                                  (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("7" (skolem 1 (e1 e2))
                      (("7" (flatten)
                        (("7" (expand "g_wf" 1)
                          (("7" (split)
                            (("1" (assert)
                              (("1"
                                (use
                                 "peg[V_T, <=, V_N_b].subterm_transitivity"
                                 (e1 "prior(e1,e2)"))
                                (("1"
                                  (assert)
                                  (("1"
                                    (assert)
                                    (("1" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (assert)
                              (("2"
                                (use
                                 "peg[V_T, <=, V_N_b].subterm_transitivity"
                                 (e1 "prior(e1,e2)"))
                                (("2"
                                  (assert)
                                  (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("8" (skolem 1 (e))
                      (("8" (assert)
                        (("8" (flatten) (("8" (postpone) nil nil))
                          nil))
                        nil))
                      nil)
                     ("9" (skolem 1 (e))
                      (("9" (flatten)
                        (("9" (assert)
                          (("9" (expand "g_wf" +)
                            (("9" (split 1)
                              (("1"
                                (assert)
                                (("1"
                                  (use
                                   "peg[V_T, <=, V_N_b].subterm_transitivity"
                                   (e1 "plus(e)"))
                                  (("1"
                                    (assert)
                                    (("1" (grind) nil nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (assert)
                                (("2" (postpone) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("10" (skolem 1 (e))
                      (("10" (flatten)
                        (("10" (simplify)
                          (("10" (expand "g_wf" +)
                            (("10" (assert)
                              (("10"
                                (use
                                 "peg[V_T, <=, V_N_b].subterm_transitivity"
                                 (e1 "opt(e)"))
                                (("10"
                                  (assert)
                                  (("10" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("11" (skolem 1 (e))
                      (("11" (flatten)
                        (("11" (expand "g_wf" +)
                          (("11" (assert)
                            (("11"
                              (use "peg[V_T, <=, V_N_b].subterm_transitivity"
                                   (e1 "notP(e)"))
                              (("11"
                                (assert)
                                (("11" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("12" (skolem 1 (e))
                      (("12" (flatten)
                        (("12" (expand "g_wf" +)
                          (("12" (assert)
                            (("12"
                              (use "peg[V_T, <=, V_N_b].subterm_transitivity"
                                   (e1 "andP(e)"))
                              (("12"
                                (assert)
                                (("12" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak))
 (topological_sort_well_orders 0
  (topological_sort_well_orders-1 nil 3813648698
   ("" (skolem 1 (P_exp "s"))
    (("" (flatten)
      (("" (typepred "kahns_algorithm(P_exp)")
        (("" (replace -2 * LR)
          (("" (assert)
            (("" (hide -2)
              (("" (expand "topologically_sorts?")
                (("" (expand "well_orders?")
                  (("" (expand "strong_WF_perm")
                    (("" (use "complete_WF_reorders")
                      (("" (assert)
                        (("" (lemma "sub_nT_and_wellformedness_perm")
                          (("" (skeep)
                            ((""
                              (inst -1 "s" "P_exp(A)" "A"
                               "P_0c?(P_exp)")
                              ((""
                                (assert)
                                ((""
                                  (hide 2)
                                  ((""
                                    (expand "complete_WF_perm")
                                    ((""
                                      (split 1)
                                      (("1" (grind) nil nil)
                                       ("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((well_orders? const-decl "bool" inferred_order_wf_peg nil)
    (complete_WF_reorders formula-decl nil inferred_order_wf_peg nil)
    (sub_nT_and_wellformedness_perm formula-decl nil
     inferred_order_wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (complete_WF const-decl "bool" wf_peg nil)
    (complete const-decl "bool" wf_peg nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (complete_WF_perm const-decl "bool" inferred_order_wf_peg nil)
    (strong_WF_perm const-decl "bool" inferred_order_wf_peg nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (option_permutation type-decl nil inferred_order_wf_peg nil)
    (Some? adt-recognizer-decl "[option_permutation -> boolean]"
     inferred_order_wf_peg nil)
    (V_T formal-nonempty-type-decl nil inferred_order_wf_peg nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" inferred_order_wf_peg
        nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" inferred_order_wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil) (peg type-decl nil peg nil)
    (bijective? const-decl "bool" functions nil)
    (nT_Permutation type-eq-decl nil inferred_order_wf_peg nil)
    (topologically_sorts? const-decl "bool" inferred_order_wf_peg nil)
    (σ adt-accessor-decl "[(Some?) -> nT_Permutation]"
     inferred_order_wf_peg nil)
    (kahns_algorithm const-decl
     "{Σ: option_permutation | (Some?(Σ) ⇒ topologically_sorts?(P_exp, σ(Σ)))}"
     inferred_order_wf_peg nil))
   shostak)))

