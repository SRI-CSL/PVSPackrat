(static_analysis
 (V_N_not_empty 0
  (V_N_not_empty-1 nil 3847461586
   ("" (inst 1 0) (("" (grind) nil nil)) nil)
   ((V_N type-eq-decl nil nTpred_order nil)
    (V_N_b formal-const-decl "posnat" static_analysis nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   shostak))
 (every_iff_member 0
  (every_iff_member-1 nil 3847460814
   ("" (skeep)
    (("" (split)
      (("1" (flatten)
        (("1" (rewrite "every_nth")
          (("1" (skeep)
            (("1" (rewrite "member_iff_nth")
              (("1" (skeep)
                (("1" (inst -1 i) (("1" (assert) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (flatten)
        (("2" (rewrite "every_nth")
          (("2" (skeep)
            (("2" (inst -1 "nth(l,i)")
              (("2" (assert)
                (("2" (use "member_iff_nth[T]") (("2" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((every_nth formula-decl nil list_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (T decl-formal-type nil static_analysis nil)
    (member_iff_nth formula-decl nil more_list_props structures)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil))
   shostak))
 (node_ls_list_V_N 0
  (node_ls_list_V_N-1 nil 3847535537
   ("" (skolem 1 "l")
    (("" (typepred "l")
      (("" (rewrite "every_iff_member[number]")
        (("" (rewrite "every_iff_member[number]")
          (("" (skolem 1 "n")
            (("" (inst -1 n)
              (("" (flatten)
                (("" (assert)
                  (("" (flatten)
                    (("" (assert)
                      (("" (inst -7 "n") (("" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((node_ls type-eq-decl nil static_analysis nil)
    (V_N_b formal-const-decl "posnat" static_analysis nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (member def-decl "bool" list_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (no_repetitions? const-decl "bool" more_list_props structures)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (< const-decl "bool" reals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (every_iff_member formula-decl nil static_analysis nil))
   nil
   (node_ls_list_V_N subtype "static_analysis.x" "list[V_N[V_N_b]]")))
 (no_rep_cdr_iff 0
  (no_rep_cdr_iff-1 nil 3847282215
   ("" (skeep*)
    (("" (split)
      (("1" (flatten)
        (("1" (use "no_rep_cdr[nat]") (("1" (assert) nil nil)) nil))
        nil)
       ("2" (flatten)
        (("2" (expand "no_repetitions?")
          (("2" (skeep)
            (("2" (expand "nth" -2)
              (("2" (lift-if)
                (("2" (lift-if)
                  (("2" (assert)
                    (("2" (lift-if)
                      (("2" (ground)
                        (("1" (use "member_iff_nth[nat]")
                          (("1" (grind) nil nil)) nil)
                         ("2" (use "member_iff_nth[nat]")
                          (("2" (grind) nil nil)) nil)
                         ("3" (inst -2 "i-1" "j-1")
                          (("3" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((no_rep_cdr formula-decl nil more_list_props structures)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (no_repetitions? const-decl "bool" more_list_props structures)
    (nth def-decl "T" list_props nil)
    (member_iff_nth formula-decl nil more_list_props structures)
    (/= const-decl "boolean" notequal nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak))
 (no_repetitions_add_ls 0
  (no_repetitions_add_ls-1 nil 3847281851
   ("" (induct "l")
    (("1" (grind) nil nil)
     ("2" (skolem 1 ("x" "l"))
      (("2" (flatten)
        (("2" (skolem 1 y)
          (("2" (lemma "no_rep_cdr" (a x))
            (("2" (inst? -)
              (("2" (assert)
                (("2" (flatten)
                  (("2" (assert)
                    (("2" (flatten)
                      (("2" (inst -2 y)
                        (("2" (expand "add_sl" +)
                          (("2" (assert)
                            (("2" (ground)
                              (("2"
                                (lemma "no_rep_cdr_iff")
                                (("2"
                                  (inst -1 "add_sl(y,l)" x)
                                  (("2"
                                    (assert)
                                    (("2"
                                      (typepred "add_sl(y,l)")
                                      (("2"
                                        (inst -3 x)
                                        (("2" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((no_rep_cdr_iff formula-decl nil static_analysis nil)
    (no_rep_cdr formula-decl nil more_list_props structures)
    (/= const-decl "boolean" notequal nil)
    (below type-eq-decl nil naturalnumbers nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (list_induction formula-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (add_sl def-decl
     "{ll: (nonempty_sl?) | FORALL y: member(y, ll) IFF (x = y OR member(y, l))}"
     set_as_list structures)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (member def-decl "bool" list_props nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (nonempty_sl? const-decl "bool" set_as_list structures)
    (no_repetitions? const-decl "bool" more_list_props structures)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil))
   shostak))
 (no_repetitions_union_ls 0
  (no_repetitions_union_ls-1 nil 3847282749
   ("" (induct "l1")
    (("1" (grind) nil nil)
     ("2" (skolem 1 ("x" "l"))
      (("2" (flatten)
        (("2" (skeep)
          (("2" (expand "union_sl" +)
            (("2" (lift-if)
              (("2" (assert)
                (("2" (lemma "no_repetitions_add_ls")
                  (("2" (inst -1 "union_sl(l,l2)" x)
                    (("2" (assert)
                      (("2" (use "no_rep_cdr[nat]")
                        (("2" (assert)
                          (("2" (flatten)
                            (("2" (assert) (("2" (grind) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((no_repetitions_add_ls formula-decl nil static_analysis nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (< const-decl "bool" reals nil)
    (x skolem-const-decl "nat" static_analysis nil)
    (length def-decl "nat" list_props nil)
    (l skolem-const-decl "list[nat]" static_analysis nil)
    (below type-eq-decl nil naturalnumbers nil)
    (add_sl def-decl
     "{ll: (nonempty_sl?) | FORALL y: member(y, ll) IFF (x = y OR member(y, l))}"
     set_as_list structures)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nonempty_sl? const-decl "bool" set_as_list structures)
    (no_rep_cdr formula-decl nil more_list_props structures)
    (/= const-decl "boolean" notequal nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (list_induction formula-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (union_sl def-decl
     "{ll: list[T] | FORALL x: member(x, ll) IFF (member(x, l1) OR member(x, l2))}"
     set_as_list structures)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (member def-decl "bool" list_props nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (no_repetitions? const-decl "bool" more_list_props structures)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil))
   shostak))
 (V_N_list_subtype_nat_list 0
  (V_N_list_subtype_nat_list-1 nil 3847461392
   ("" (skeep*)
    (("" (typepred "x")
      (("" (rewrite "every_iff_member[number]")
        (("" (rewrite "every_iff_member[number]")
          (("" (skolem 1 "a")
            (("" (inst -1 "a")
              (("" (flatten)
                (("" (assert)
                  (("" (flatten) (("" (assert) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((V_N type-eq-decl nil nTpred_order nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (V_N_b formal-const-decl "posnat" static_analysis nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil) (>= const-decl "bool" reals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (every_iff_member formula-decl nil static_analysis nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (V_N_list_subtype_nat_list_ subtype "list_adt[V_N[V_N_b]].list"
    "list_adt[nat].list")))
 (sub_nT_TCC1 0
  (sub_nT_TCC1-1 nil 3847256679 ("" (grind) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (length def-decl "nat" list_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (/= const-decl "boolean" notequal nil)
    (no_repetitions? const-decl "bool" more_list_props structures)
    (member def-decl "bool" list_props nil))
   nil (sub_nT subtype "list_adt[nat].null" "node_ls")))
 (sub_nT_TCC2 0
  (sub_nT_TCC2-1 nil 3847256679 ("" (grind) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (length def-decl "nat" list_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (/= const-decl "boolean" notequal nil)
    (no_repetitions? const-decl "bool" more_list_props structures)
    (member def-decl "bool" list_props nil))
   nil (sub_nT subtype "list_adt[nat].null" "node_ls")))
 (sub_nT_TCC3 0
  (sub_nT_TCC3-1 nil 3847256679 ("" (grind) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (length def-decl "nat" list_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (/= const-decl "boolean" notequal nil)
    (no_repetitions? const-decl "bool" more_list_props structures)
    (member def-decl "bool" list_props nil))
   nil (sub_nT subtype "list_adt[nat].null" "node_ls")))
 (sub_nT_TCC4 0
  (sub_nT_TCC4-1 nil 3847256679 ("" (grind) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (length def-decl "nat" list_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (/= const-decl "boolean" notequal nil)
    (no_repetitions? const-decl "bool" more_list_props structures)
    (member def-decl "bool" list_props nil))
   nil (sub_nT subtype "list_adt[nat].null" "node_ls")))
 (sub_nT_TCC5 0
  (sub_nT_TCC5-1 nil 3847268234 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" static_analysis nil)
    (below type-eq-decl nil naturalnumbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (length def-decl "nat" list_props nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (/= const-decl "boolean" notequal nil)
    (no_repetitions? const-decl "bool" more_list_props structures)
    (member def-decl "bool" list_props nil))
   nil
   (sub_nT subtype
    "list_adt[nat].cons(static_analysis.B, list_adt[nat].null)"
    "node_ls")))
 (sub_nT_TCC6 0
  (sub_nT_TCC5-1 nil 3847256679 ("" (termination-tcc) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (sum const-decl "nat" peg nil)
    (pegMeasure const-decl "nat" peg nil))
   nil
   (sub_nT termination
    "static_analysis.sub_nT(static_analysis.e1, static_analysis.P_0)"
    "nil")))
 (sub_nT_TCC7 0
  (sub_nT_TCC6-1 nil 3847256679 ("" (termination-tcc) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (sum const-decl "nat" peg nil)
    (pegMeasure const-decl "nat" peg nil))
   nil
   (sub_nT termination
    "static_analysis.sub_nT(static_analysis.e2, static_analysis.P_0)"
    "nil")))
 (sub_nT_TCC8 0
  (sub_nT_TCC6-1 nil 3847268234
   ("" (skeep)
    (("" (split)
      (("1" (use "no_repetitions_union_ls") (("1" (assert) nil nil))
        nil)
       ("2" (skeep)
        (("2" (typepred "union_sl[nat](v(e1, P_0), v(e2, P_0))")
          (("2" (inst -2 n)
            (("2" (assert)
              (("2" (typepred "v(e1, P_0)")
                (("2" (inst -3 n)
                  (("2" (assert)
                    (("2" (typepred "v(e2, P_0)")
                      (("2" (inst -3 n) (("2" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (V_T formal-nonempty-type-decl nil static_analysis nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" static_analysis nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" static_analysis nil)
    (peg type-decl nil peg nil) (< const-decl "bool" reals nil)
    (pegMeasure const-decl "nat" peg nil)
    (no_repetitions? const-decl "bool" more_list_props structures)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (member def-decl "bool" list_props nil)
    (<= const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (node_ls type-eq-decl nil static_analysis nil)
    (no_repetitions_union_ls formula-decl nil static_analysis nil)
    (union_sl def-decl
     "{ll: list[T] | FORALL x: member(x, ll) IFF (member(x, l1) OR member(x, l2))}"
     set_as_list structures)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (sub_nT subtype
    "set_as_list[nat].union_sl(static_analysis.sub_nT(static_analysis.e1, static_analysis.P_0), static_analysis.sub_nT(static_analysis.e2, static_analysis.P_0))"
    "node_ls")))
 (sub_nT_TCC9 0
  (sub_nT_TCC7-1 nil 3847256679 ("" (termination-tcc) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (sum const-decl "nat" peg nil)
    (pegMeasure const-decl "nat" peg nil))
   nil
   (sub_nT termination
    "static_analysis.sub_nT(static_analysis.e1, static_analysis.P_0)"
    "nil")))
 (sub_nT_TCC10 0
  (sub_nT_TCC8-1 nil 3847256679 ("" (termination-tcc) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (sum const-decl "nat" peg nil)
    (pegMeasure const-decl "nat" peg nil))
   nil
   (sub_nT termination
    "static_analysis.sub_nT(static_analysis.e1, static_analysis.P_0)"
    "nil")))
 (sub_nT_TCC11 0
  (sub_nT_TCC9-1 nil 3847256679 ("" (termination-tcc) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (sum const-decl "nat" peg nil)
    (pegMeasure const-decl "nat" peg nil))
   nil
   (sub_nT termination
    "static_analysis.sub_nT(static_analysis.e2, static_analysis.P_0)"
    "nil")))
 (sub_nT_TCC12 0
  (sub_nT_TCC9-1 nil 3847268234
   ("" (skeep*)
    (("" (use "no_repetitions_union_ls")
      (("1" (assert)
        (("1" (skeep)
          (("1" (typepred "union_sl[nat](v(e1, P_0), v(e2, P_0))")
            (("1" (inst -2 n)
              (("1" (assert)
                (("1" (typepred "v(e1, P_0)")
                  (("1" (inst -3 n)
                    (("1" (typepred "v(e2, P_0)")
                      (("1" (inst -3 n) (("1" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (grind) nil nil) ("3" (grind) nil nil))
      nil))
    nil)
   ((no_repetitions_union_ls formula-decl nil static_analysis nil)
    (node_ls type-eq-decl nil static_analysis nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (member def-decl "bool" list_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (no_repetitions? const-decl "bool" more_list_props structures)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (e2 skolem-const-decl "peg[V_T, <=, V_N_b]" static_analysis nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (V_T formal-nonempty-type-decl nil static_analysis nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" static_analysis nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" static_analysis nil)
    (peg type-decl nil peg nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pegMeasure const-decl "nat" peg nil)
    (e1 skolem-const-decl "peg[V_T, <=, V_N_b]" static_analysis nil)
    (G skolem-const-decl "peg[V_T, <=, V_N_b]" static_analysis nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (union_sl def-decl
     "{ll: list[T] | FORALL x: member(x, ll) IFF (member(x, l1) OR member(x, l2))}"
     set_as_list structures)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (/= const-decl "boolean" notequal nil)
    (sum const-decl "nat" peg nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sub_nT subtype
    "set_as_list[nat].union_sl(static_analysis.sub_nT(static_analysis.e1, static_analysis.P_0), static_analysis.sub_nT(static_analysis.e2, static_analysis.P_0))"
    "node_ls")))
 (sub_nT_TCC13 0
  (sub_nT_TCC10-1 nil 3847256679 ("" (termination-tcc) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (inc const-decl "nat" peg nil)
    (pegMeasure const-decl "nat" peg nil))
   nil
   (sub_nT termination
    "static_analysis.sub_nT(static_analysis.e, static_analysis.P_0)"
    "nil")))
 (sub_nT_TCC14 0
  (sub_nT_TCC11-1 nil 3847256679 ("" (termination-tcc) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (inc const-decl "nat" peg nil)
    (pegMeasure const-decl "nat" peg nil))
   nil
   (sub_nT termination
    "static_analysis.sub_nT(static_analysis.e, static_analysis.P_0)"
    "nil")))
 (sub_nT_TCC15 0
  (sub_nT_TCC12-1 nil 3847256679 ("" (termination-tcc) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (inc const-decl "nat" peg nil)
    (pegMeasure const-decl "nat" peg nil))
   nil
   (sub_nT termination
    "static_analysis.sub_nT(static_analysis.e, static_analysis.P_0)"
    "nil")))
 (sub_nT_TCC16 0
  (sub_nT_TCC13-1 nil 3847256679 ("" (termination-tcc) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (inc const-decl "nat" peg nil)
    (pegMeasure const-decl "nat" peg nil))
   nil
   (sub_nT termination
    "static_analysis.sub_nT(static_analysis.e, static_analysis.P_0)"
    "nil")))
 (sub_nT_TCC17 0
  (sub_nT_TCC14-1 nil 3847256679 ("" (termination-tcc) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (inc const-decl "nat" peg nil)
    (pegMeasure const-decl "nat" peg nil))
   nil
   (sub_nT termination
    "static_analysis.sub_nT(static_analysis.e, static_analysis.P_0)"
    "nil")))
 (sub_nT_and_wellformedness 0
  (sub_nT_and_wellformedness-1 nil 3847256683
   ("" (skolem 1 ("Ïƒ" "_" "_" "_"))
    (("" (expand "strong")
      (("" (expand "complete")
        (("" (induct "G")
          (("1" (grind) nil nil) ("2" (grind) nil nil)
           ("3" (grind) nil nil) ("4" (grind) nil nil)
           ("5" (grind) nil nil)
           ("6" (skolem 1 ("e1" "e2"))
            (("6" (flatten)
              (("6" (skeep*)
                (("6" (expand "g_wf" +)
                  (("6" (expand "sub_nT" +)
                    (("6" (inst -1 "A" "P_0")
                      (("6" (inst -2 "A" "P_0")
                        (("6" (split 1)
                          (("1" (flatten)
                            (("1" (assert)
                              (("1"
                                (flatten)
                                (("1"
                                  (split)
                                  (("1" (propax) nil nil)
                                   ("2"
                                    (assert)
                                    (("2"
                                      (case "P_0(e1)")
                                      (("1" (assert) nil nil)
                                       ("2" (assert) nil nil))
                                      nil))
                                    nil)
                                   ("3"
                                    (skeep)
                                    (("3"
                                      (assert)
                                      (("3"
                                        (lift-if)
                                        (("3"
                                          (split -1)
                                          (("1"
                                            (flatten)
                                            (("1"
                                              (typepred
                                               "union_sl(sub_nT(e1, P_0), sub_nT(e2, P_0))")
                                              (("1"
                                                (hide -1)
                                                (("1"
                                                  (inst -1 B)
                                                  (("1"
                                                    (assert)
                                                    (("1"
                                                      (hide -3)
                                                      (("1"
                                                        (grind)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2" (grind) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (flatten)
                            (("2" (case "P_0(e1)")
                              (("1"
                                (ground)
                                (("1"
                                  (skeep)
                                  (("1"
                                    (inst -8 B)
                                    (("1"
                                      (assert)
                                      (("1"
                                        (typepred
                                         "union_sl(sub_nT(e1, P_0), sub_nT(e2, P_0))")
                                        (("1"
                                          (inst -2 "B")
                                          (("1" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (skeep*)
                                  (("2"
                                    (inst-cp -6 "B")
                                    (("2"
                                      (inst-cp -6 "B!1")
                                      (("2"
                                        (grind)
                                        (("2"
                                          (typepred
                                           "union_sl(sub_nT(e1, P_0), sub_nT(e2, P_0))")
                                          (("2"
                                            (inst -2 B)
                                            (("2"
                                              (hide -1)
                                              (("2" (assert) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("3"
                                  (assert)
                                  (("3"
                                    (skeep*)
                                    (("3"
                                      (inst -8 B)
                                      (("3"
                                        (assert)
                                        (("3"
                                          (typepred
                                           "union_sl(sub_nT(e1, P_0), sub_nT(e2, P_0))")
                                          (("3" (grind) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("4"
                                  (assert)
                                  (("4"
                                    (skeep)
                                    (("4"
                                      (inst -5 "B")
                                      (("4"
                                        (assert)
                                        (("4"
                                          (typepred
                                           "union_sl(sub_nT(e1, P_0), sub_nT(e2, P_0))")
                                          (("4" (grind) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (assert) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("7" (skolem 1 ("e1" "e2"))
            (("7" (flatten)
              (("7" (skeep*)
                (("7" (expand "g_wf" +)
                  (("7" (expand "sub_nT" +)
                    (("7" (inst -1 "A" "P_0")
                      (("7" (inst -2 "A" "P_0")
                        (("7" (flatten)
                          (("7" (ground)
                            (("1" (skeep)
                              (("1"
                                (inst - B)
                                (("1"
                                  (inst - B)
                                  (("1"
                                    (typepred
                                     "union_sl(sub_nT(e1, P_0), sub_nT(e2, P_0))")
                                    (("1"
                                      (inst -2 B)
                                      (("1"
                                        (assert)
                                        (("1" (ground) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (skeep)
                              (("2"
                                (inst - B)
                                (("2"
                                  (inst - B)
                                  (("2"
                                    (assert)
                                    (("2"
                                      (typepred
                                       "union_sl(sub_nT(e1, P_0), sub_nT(e2, P_0))")
                                      (("2"
                                        (inst -2 B)
                                        (("2" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("3" (skeep)
                              (("3"
                                (inst - B)
                                (("3"
                                  (inst - B)
                                  (("3"
                                    (assert)
                                    (("3"
                                      (typepred
                                       "union_sl(sub_nT(e1, P_0), sub_nT(e2, P_0))")
                                      (("3"
                                        (inst -2 B)
                                        (("3" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("4" (skeep)
                              (("4"
                                (inst - B)
                                (("4"
                                  (assert)
                                  (("4"
                                    (typepred
                                     "union_sl(sub_nT(e1, P_0), sub_nT(e2, P_0))")
                                    (("4"
                                      (inst -2 B)
                                      (("4" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("5" (skeep)
                              (("5"
                                (inst - B)
                                (("5"
                                  (assert)
                                  (("5"
                                    (typepred
                                     "union_sl(sub_nT(e1, P_0), sub_nT(e2, P_0))")
                                    (("5"
                                      (inst -2 B)
                                      (("5" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("8" (skolem 1 "e")
            (("8" (flatten)
              (("8" (skeep*)
                (("8" (expand "g_wf" +)
                  (("8" (expand "sub_nT" +)
                    (("8" (inst -1 "A" "P_0") (("8" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("9" (skolem 1 "e")
            (("9" (flatten)
              (("9" (skeep*)
                (("9" (expand "g_wf" +)
                  (("9" (expand "sub_nT" +)
                    (("9" (inst -1 "A" "P_0") (("9" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("10" (skolem 1 "e")
            (("10" (flatten)
              (("10" (skeep*)
                (("10" (expand "g_wf" +)
                  (("10" (expand "sub_nT" +)
                    (("10" (inst -1 "A" "P_0") nil nil)) nil))
                  nil))
                nil))
              nil))
            nil)
           ("11" (skolem 1 "e")
            (("11" (flatten)
              (("11" (skeep*)
                (("11" (expand "g_wf" +)
                  (("11" (expand "sub_nT" +)
                    (("11" (inst -1 "A" "P_0") nil nil)) nil))
                  nil))
                nil))
              nil))
            nil)
           ("12" (skolem 1 "e")
            (("12" (flatten)
              (("12" (skeep*)
                (("12" (expand "g_wf" +)
                  (("12" (expand "sub_nT" +)
                    (("12" (inst -1 "A" "P_0") nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((strong const-decl "bool" wf_peg nil) (peg type-decl nil peg nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (TRUE const-decl "bool" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (FALSE const-decl "bool" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (member def-decl "bool" list_props nil)
    (no_repetitions? const-decl "bool" more_list_props structures)
    (<= const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (node_ls type-eq-decl nil static_analysis nil)
    (sub_nT def-decl "node_ls" static_analysis nil)
    (V_N_b formal-const-decl "posnat" static_analysis nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" static_analysis nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (V_T formal-nonempty-type-decl nil static_analysis nil)
    (peg_induction formula-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (union_sl def-decl
     "{ll: list[T] | FORALL x: member(x, ll) IFF (member(x, l1) OR member(x, l2))}"
     set_as_list structures)
    (complete const-decl "bool" wf_peg nil))
   shostak))
 (nodes_TCC1 0
  (nodes_TCC1-1 nil 3847362076
   ("" (grind)
    (("" (typepred "make_srl_rec(0, V_N_b - 1)")
      (("" (rewrite "every_nth")
        (("" (rewrite "every_nth")
          (("" (skeep)
            (("" (inst -1 i)
              (("" (assert)
                (("" (flatten)
                  (("" (ground)
                    (("1"
                      (inst -5 "nth(make_srl_rec(0, V_N_b - 1), i)")
                      (("1" (assert)
                        (("1" (use "member_iff_nth[int]")
                          (("1" (assert) (("1" (inst 1 i) nil nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2"
                      (inst -5 "nth(make_srl_rec(0, V_N_b - 1), i)")
                      (("2" (assert)
                        (("2" (use "member_iff_nth[int]")
                          (("2" (assert) (("2" (inst 1 i) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (nodes subtype "(number_fields.-)(static_analysis.V_N_b, 1)"
    "nat")))
 (nodes_TCC2 0
  (nodes_TCC2-1 nil 3847515139
   ("" (split)
    (("1" (use "interval_list_no_repetitions") (("1" (assert) nil nil))
      nil)
     ("2" (skeep)
      (("2" (expand "interval_list")
        (("2" (assert)
          (("2" (typepred "interval_list_rec(0, V_N_b - 1)")
            (("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (member def-decl "bool" list_props nil)
    (interval_list_rec def-decl
     "{l: list[nat] | FORALL k: i <= k <= j â‡” member(k, l)}"
     interval_list nil)
    (interval_list const-decl "list[nat]" interval_list nil)
    (interval_list_no_repetitions formula-decl nil interval_list nil)
    (V_N_b formal-const-decl "posnat" static_analysis nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (nodes subtype
    "interval_list.interval_list(0, (number_fields.-)(static_analysis.V_N_b, 1))"
    "node_ls")))
 (dependency_graph_TCC1 0
  (dependency_graph_TCC1-1 nil 3847362076
   ("" (skeep)
    (("" (expand "cdigraph")
      (("" (case-replace "length(nodes(P_exp)) = V_N_b")
        (("1" (split)
          (("1" (lemma "map_length[V_N[V_N_b], node_ls]")
            (("1" (grind) nil nil)) nil)
           ("2" (expand "list_of_idxs")
            (("2" (expand "size")
              (("2" (skolem 1 "i")
                (("2" (skolem 1 "j")
                  (("2" (lemma "map_nth_rw[V_N[V_N_b], node_ls]")
                    (("2"
                      (inst - "adjacents(P_exp)" "nodes(P_exp)" "i")
                      (("1" (replaces)
                        (("1" (expand "adjacents")
                          (("1"
                            (typepred
                             "sub_nT(P_exp(nth(nodes(P_exp), i)), P_0c?(P_exp))")
                            (("1"
                              (inst -3
                               " nth(sub_nT(P_exp(nth(nodes(P_exp), i)), P_0c?(P_exp)), j)")
                              (("1"
                                (assert)
                                (("1"
                                  (use "member_iff_nth[nat]")
                                  (("1"
                                    (assert)
                                    (("1" (inst 1 "j") nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (expand "nodes")
                              (("2"
                                (rewrite "interval_list_nth")
                                (("2"
                                  (assert)
                                  (("2"
                                    (typepred "i")
                                    (("2"
                                      (lemma
                                       "map_length[V_N[V_N_b], node_ls]")
                                      (("2"
                                        (inst
                                         -1
                                         "adjacents(P_exp)"
                                         "nodes(P_exp)")
                                        (("2"
                                          (replace -1 * LR)
                                          (("2"
                                            (expand "nodes")
                                            (("2"
                                              (rewrite
                                               "interval_list_length")
                                              nil
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (typepred "i")
                        (("2" (lemma "map_length[V_N[V_N_b], node_ls]")
                          (("2"
                            (inst -1 "adjacents(P_exp)" "nodes(P_exp)")
                            (("2" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("3" (expand "nodes")
            (("3" (skeep)
              (("3"
                (case-replace
                 "nth(map[V_N[V_N_b], node_ls](adjacents(P_exp))(interval_list(0, V_N_b - 1)), i) = adjacents(P_exp)(nth(interval_list(0, V_N_b -1),i))")
                (("1" (assert) nil nil)
                 ("2" (hide -1 2)
                  (("2" (lemma "map_nth_rw[V_N[V_N_b], node_ls]")
                    (("2" (inst -1 "adjacents(P_exp)" "nodes(P_exp)" i)
                      (("1" (assert) (("1" (grind) nil nil)) nil)
                       ("2" (typepred "i")
                        (("2" (lemma "map_length[V_N[V_N_b],node_ls]")
                          (("2"
                            (inst -1 "adjacents(P_exp)" "nodes(P_exp)")
                            (("2" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("3" (rewrite "interval_list_nth")
                  (("1" (typepred "i")
                    (("1" (lemma "map_length[V_N[V_N_b],node_ls]")
                      (("1" (inst -1 "adjacents(P_exp)" "nodes(P_exp)")
                        (("1" (assert)
                          (("1" (expand "nodes")
                            (("1" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (typepred "i")
                    (("2" (lemma "map_length[V_N[V_N_b],node_ls]")
                      (("2" (expand "nodes")
                        (("2" (assert) (("2" (grind) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("4" (typepred "i")
                  (("4" (lemma "map_length[V_N[V_N_b],node_ls]")
                    (("4" (inst -1 "adjacents(P_exp)" "nodes(P_exp)")
                      (("4" (expand "nodes") (("4" (assert) nil nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("5" (assert) nil nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (hide 2)
          (("2" (expand "nodes")
            (("2" (rewrite "interval_list_length") nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((cdigraph const-decl "bool" c_digraphs_def digraphs)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (interval_list const-decl "list[nat]" interval_list nil)
    (map adt-def-decl "list[T1]" list_adt_map nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (interval_list_rec def-decl
     "{l: list[nat] | FORALL k: i <= k <= j â‡” member(k, l)}"
     interval_list nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (adjacents const-decl "node_ls" static_analysis nil)
    (map_length formula-decl nil more_map_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (size const-decl "nat" c_digraphs_def digraphs)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (P_exp skolem-const-decl "interp[V_T, <=, V_N_b]" static_analysis
     nil)
    (below type-eq-decl nil naturalnumbers nil)
    (i skolem-const-decl
       "below(length(map[V_N[V_N_b], node_ls](adjacents(P_exp))(nodes(P_exp))))"
       static_analysis nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (interval_list_length formula-decl nil interval_list nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (interval_list_nth formula-decl nil interval_list nil)
    (member_iff_nth formula-decl nil more_list_props structures)
    (P_0c? const-decl "[Î” -> bool]" wf_peg nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (sub_nT def-decl "node_ls" static_analysis nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (map_nth_rw formula-decl nil more_map_props nil)
    (list_of_idxs const-decl "bool" c_digraphs_def digraphs)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (/= const-decl "boolean" notequal nil)
    (i skolem-const-decl
       "below(length(map[V_N[V_N_b], node_ls](adjacents(P_exp))(nodes(P_exp))))"
       static_analysis nil)
    (nodes const-decl "node_ls" static_analysis nil)
    (node_ls type-eq-decl nil static_analysis nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (member def-decl "bool" list_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (no_repetitions? const-decl "bool" more_list_props structures)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (<= formal-const-decl "(total_order?[V_T])" static_analysis nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil static_analysis nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (V_N_b formal-const-decl "posnat" static_analysis nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   nil
   (dependency_graph subtype
    "(# data := static_analysis.nodes(static_analysis.P_exp), adjs := list_adt_map[V_N[V_N_b], node_ls].map(static_analysis.adjacents(static_analysis.P_exp))(static_analysis.nodes(static_analysis.P_exp)) #)"
    "c_digraph[nat]")))
 (strong_WF_edge 0
  (strong_WF_edge-1 nil 3847520131
   ("" (skeep*)
    (("" (expand "restrict")
      (("" (expand "strong_WF")
        (("" (inst -1 "A")
          (("" (case "member(B, sub_nT(P_exp(A), P_0c?(P_exp)))")
            (("1" (hide -3)
              (("1" (name-replace "G" "P_exp(A)")
                (("1" (case "subterm(G, P_exp(A))")
                  (("1" (generalize "G" "G")
                    (("1" (induct "G")
                      (("1" (grind) nil nil) ("2" (grind) nil nil)
                       ("3" (grind) nil nil) ("4" (grind) nil nil)
                       ("5" (grind) nil nil)
                       ("6" (skolem 1 ("e1" "e2"))
                        (("6" (flatten)
                          (("6" (use "subterm_seq[V_T, <=, V_N_b]")
                            (("6" (expand "sub_nT" -5)
                              (("6"
                                (expand "g_wf" -6)
                                (("6"
                                  (flatten)
                                  (("6"
                                    (assert)
                                    (("6"
                                      (flatten)
                                      (("6"
                                        (lift-if)
                                        (("6"
                                          (typepred
                                           "union_sl(sub_nT(e1, P_0c?(P_exp)), sub_nT(e2, P_0c?(P_exp)))")
                                          (("6"
                                            (hide -1)
                                            (("6"
                                              (inst -1 B)
                                              (("6" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("7" (skolem 1 ("e1" "e2"))
                        (("7" (flatten)
                          (("7" (use "subterm_prior[V_T, <=, V_N_b]")
                            (("7" (expand "sub_nT" -5)
                              (("7"
                                (expand "g_wf" -6)
                                (("7"
                                  (flatten)
                                  (("7"
                                    (assert)
                                    (("7"
                                      (flatten)
                                      (("7"
                                        (typepred
                                         "union_sl(sub_nT(e1, P_0c?(P_exp)), sub_nT(e2, P_0c?(P_exp)))")
                                        (("7"
                                          (hide -1)
                                          (("7"
                                            (inst -1 B)
                                            (("7" (grind) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("8" (skolem 1 ("e"))
                        (("8" (flatten)
                          (("8" (use "subterm_star[V_T, <=, V_N_b]")
                            (("8" (grind) nil nil)) nil))
                          nil))
                        nil)
                       ("9" (skolem 1 ("e"))
                        (("9" (flatten)
                          (("9" (use "subterm_plus[V_T, <=, V_N_b]")
                            (("9" (grind) nil nil)) nil))
                          nil))
                        nil)
                       ("10" (skolem 1 ("e"))
                        (("10" (flatten)
                          (("10" (use "subterm_opt[V_T, <=, V_N_b]")
                            (("10" (grind) nil nil)) nil))
                          nil))
                        nil)
                       ("11" (skolem 1 ("e"))
                        (("11" (flatten)
                          (("11" (use "subterm_notP[V_T, <=, V_N_b]")
                            (("11" (grind) nil nil)) nil))
                          nil))
                        nil)
                       ("12" (skolem 1 ("e"))
                        (("12" (flatten)
                          (("12" (use "subterm_andP[V_T, <=, V_N_b]")
                            (("12" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (grind :exclude "subterm")
                    (("2" (expand "G")
                      (("2" (expand "subterm") (("2" (propax) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (hide -1 2)
              (("2" (expand "edges")
                (("2" (flatten)
                  (("2" (expand "dependency_graph" -3)
                    (("2" (expand "nodes" -3 1)
                      (("2" (lemma "interval_list_idx")
                        (("2" (inst -1 "0" "V_N_b - 1" "B")
                          (("2" (assert)
                            (("2" (replace -1 * LR)
                              (("2"
                                (expand "nodes" -4 2)
                                (("2"
                                  (lemma "interval_list_idx")
                                  (("2"
                                    (inst -1 0 "V_N_b-1" "A")
                                    (("2"
                                      (assert)
                                      (("2"
                                        (replace -1 * LR)
                                        (("2"
                                          (case-replace
                                           "nth(map(adjacents(P_exp))(nodes(P_exp)), A) = adjacents(P_exp)(nth(nodes(P_exp),A))")
                                          (("1"
                                            (expand "adjacents")
                                            (("1"
                                              (assert)
                                              (("1"
                                                (expand "nodes")
                                                (("1"
                                                  (rewrite
                                                   "interval_list_nth")
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (hide - 2)
                                            (("2"
                                              (lemma
                                               "map_nth_rw[V_N, node_ls]")
                                              (("2"
                                                (inst
                                                 -1
                                                 "adjacents(P_exp)"
                                                 "nodes(P_exp)"
                                                 "A")
                                                nil
                                                nil))
                                              nil))
                                            nil)
                                           ("3"
                                            (typepred "A")
                                            (("3"
                                              (expand "nodes")
                                              (("3"
                                                (rewrite
                                                 "interval_list_nth")
                                                nil
                                                nil))
                                              nil))
                                            nil)
                                           ("4"
                                            (assert)
                                            (("4"
                                              (typepred "A")
                                              (("4"
                                                (expand "nodes")
                                                (("4"
                                                  (rewrite
                                                   "interval_list_length")
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((restrict const-decl "R" restrict nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" static_analysis nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (nodes const-decl "node_ls" static_analysis nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (adjacents const-decl "node_ls" static_analysis nil)
    (map adt-def-decl "list[T1]" list_adt_map nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (length def-decl "nat" list_props nil)
    (interval_list_nth formula-decl nil interval_list nil)
    (map_nth_rw formula-decl nil more_map_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (interval_list_length formula-decl nil interval_list nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (interval_list_idx formula-decl nil interval_list nil)
    (dependency_graph const-decl "c_digraph[nat]" static_analysis nil)
    (edges const-decl "bool" c_digraphs_def digraphs)
    (subterm adt-def-decl "boolean" peg nil)
    (peg_induction formula-decl nil peg nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (union_sl def-decl
     "{ll: list[T] | FORALL x: member(x, ll) IFF (member(x, l1) OR member(x, l2))}"
     set_as_list structures)
    (r const-decl "C(P_exp)" wf_peg nil)
    (array_sum const-decl "upto(3 * V_N_b)" array_sum nil)
    (nT_properties const-decl "F(P_exp)" wf_peg nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (subterm_seq formula-decl nil peg nil)
    (subterm_prior formula-decl nil peg nil)
    (subterm_star formula-decl nil peg nil)
    (subterm_plus formula-decl nil peg nil)
    (subterm_opt formula-decl nil peg nil)
    (subterm_notP formula-decl nil peg nil)
    (subterm_andP formula-decl nil peg nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (G skolem-const-decl "peg[V_T, <=, V_N_b]" static_analysis nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (member def-decl "bool" list_props nil)
    (V_T formal-nonempty-type-decl nil static_analysis nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" static_analysis nil)
    (peg type-decl nil peg nil)
    (no_repetitions? const-decl "bool" more_list_props structures)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (node_ls type-eq-decl nil static_analysis nil)
    (sub_nT def-decl "node_ls" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil)
    (P_0c? const-decl "[Î” -> bool]" wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak))
 (strong_WF_path 0
  (strong_WF_path-1 nil 3847523274
   ("" (skeep)
    (("" (induct n)
      (("1" (skeep*)
        (("1" (assert)
          (("1" (replace -1 * RL)
            (("1" (typepred "w")
              (("1" (expand "walk?")
                (("1" (flatten)
                  (("1" (expand "finseq_appl")
                    (("1" (inst -3 i)
                      (("1" (assert)
                        (("1" (use "strong_WF_edge")
                          (("1" (assert)
                            (("1" (inst -1 "w`seq(i)" "w`seq(i+1)")
                              (("1"
                                (expand "restrict")
                                (("1"
                                  (expand "edge?")
                                  (("1"
                                    (expand "digraph_edges")
                                    (("1"
                                      (expand "edges")
                                      (("1"
                                        (flatten)
                                        (("1"
                                          (ground)
                                          (("1" (grind) nil nil)
                                           ("2" (grind) nil nil)
                                           ("3" (postpone) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (postpone) nil nil))
      nil))
    nil)
   nil shostak))
 (dependency_graph_wf_iff_dag_TCC1 0
  (dependency_graph_wf_iff_dag_TCC1-1 nil 3847472036
   ("" (skeep)
    (("" (assert)
      (("" (typepred "dependency_graph(P_exp)")
        (("" (split)
          (("1" (expand "dependency_graph")
            (("1" (expand "nodes")
              (("1" (expand "interval_list")
                (("1" (assert)
                  (("1" (assert)
                    (("1" (typepred "interval_list_rec(0, V_N_b - 1)")
                      (("1" (assert)
                        (("1" (rewrite "every_iff_member[number]")
                          (("1" (rewrite "every_iff_member[number]")
                            (("1" (skolem 1 "x")
                              (("1"
                                (inst -1 x)
                                (("1"
                                  (flatten)
                                  (("1"
                                    (assert)
                                    (("1"
                                      (flatten)
                                      (("1"
                                        (assert)
                                        (("1"
                                          (inst? -)
                                          (("1" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (assert)
            (("2" (expand "cdigraph")
              (("2" (assert)
                (("2" (flatten)
                  (("2" (ground)
                    (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nodes const-decl "node_ls" static_analysis nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (member def-decl "bool" list_props nil)
    (interval_list_rec def-decl
     "{l: list[nat] | FORALL k: i <= k <= j â‡” member(k, l)}"
     interval_list nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (every_iff_member formula-decl nil static_analysis nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (interval_list const-decl "list[nat]" interval_list nil)
    (list_of_idxs const-decl "bool" c_digraphs_def digraphs)
    (size const-decl "nat" c_digraphs_def digraphs)
    (no_repetitions? const-decl "bool" more_list_props structures)
    (/= const-decl "boolean" notequal nil)
    (length def-decl "nat" list_props nil)
    (map adt-def-decl "list[T1]" list_adt_map nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs)
    (cdigraph const-decl "bool" c_digraphs_def digraphs)
    (< const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" static_analysis nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (V_T formal-nonempty-type-decl nil static_analysis nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" static_analysis nil)
    (peg type-decl nil peg nil) (interp type-eq-decl nil wf_peg nil)
    (c_digraph type-eq-decl nil c_digraphs_def digraphs)
    (dependency_graph const-decl "c_digraph[nat]" static_analysis nil))
   nil
   (dependency_graph_wf_iff_dag subtype
    "static_analysis.dependency_graph(static_analysis.P_exp)"
    "c_digraph[V_N[V_N_b]]")))
 (dependency_graph_wf_iff_dag 0
  (dependency_graph_wf_iff_dag-1 nil 3847451200
   ("" (skeep)
    (("" (split)
      (("1" (flatten)
        (("1" (expand "orderly_WF_nT?")
          (("1" (skeep)
            (("1"
              (typepred
               "topological_sort[V_N[V_N_b]](dependency_graph(P_exp))")
              (("1" (assert)
                (("1" (hide -1)
                  (("1" (expand "is_dag")
                    (("1" (hide 2)
                      (("1" (measure-induct+ "w`length" "w")
                        (("1" (name-replace "w" "x!1")
                          (("1" (typepred "w")
                            (("1" (expand "path?")
                              (("1"
                                (assert)
                                (("1"
                                  (expand "finseq_appl")
                                  (("1" (postpone) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (postpone) nil nil))
      nil))
    nil)
   nil shostak)))

