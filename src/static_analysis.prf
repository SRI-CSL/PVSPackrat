(inferred_order_wf_peg
 (inv_TCC1 0
  (inv_TCC1-1 nil 3813650237
   ("" (lemma "function_inverse_def[V_N,V_N].bijective_inverse_exists")
    (("" (postpone) nil nil)) nil)
   nil nil
   (inv existence ""
    "[σ: inferred_order_wf_peg.nT_Permutation -> {σ' | function_props[V_N[V_N_b], V_N[V_N_b], V_N[V_N_b]].o(σ, inferred_order_wf_peg.σ') = identity[V_N[V_N_b]].identity}]")))
 (well_orders_orderly 0
  (well_orders_orderly-1 nil 3813604031
   ("" (expand "well_orders?")
    (("" (expand "orderly_WF_nT?")
      (("" (skeep*) (("" (inst? 1) nil nil)) nil)) nil))
    nil)
   ((orderly_WF_nT? const-decl "bool" inferred_order_wf_peg nil)
    (nT_Permutation type-eq-decl nil inferred_order_wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (V_N_b formal-const-decl "posnat" inferred_order_wf_peg nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (well_orders? const-decl "bool" inferred_order_wf_peg nil))
   shostak))
 (sub_nT_TCC1 0
  (sub_nT_TCC1-1 nil 3813611401 ("" (subtype-tcc) nil nil)
   ((∅ const-decl "set[V_N[V_N_b]]" inferred_order_wf_peg nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil))
   nil
   (sub_nT subtype "inferred_order_wf_peg.∅"
    "finite_set[V_N[V_N_b]]")))
 (sub_nT_TCC2 0
  (sub_nT_TCC2-1 nil 3813611401 ("" (subtype-tcc) nil nil)
   ((∅ const-decl "set[V_N[V_N_b]]" inferred_order_wf_peg nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil))
   nil
   (sub_nT subtype "inferred_order_wf_peg.∅"
    "finite_set[V_N[V_N_b]]")))
 (sub_nT_TCC3 0
  (sub_nT_TCC3-1 nil 3813611401 ("" (subtype-tcc) nil nil)
   ((∅ const-decl "set[V_N[V_N_b]]" inferred_order_wf_peg nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil))
   nil
   (sub_nT subtype "inferred_order_wf_peg.∅"
    "finite_set[V_N[V_N_b]]")))
 (sub_nT_TCC4 0
  (sub_nT_TCC4-1 nil 3813611401 ("" (subtype-tcc) nil nil)
   ((∅ const-decl "set[V_N[V_N_b]]" inferred_order_wf_peg nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil))
   nil
   (sub_nT subtype "inferred_order_wf_peg.∅"
    "finite_set[V_N[V_N_b]]")))
 (sub_nT_TCC5 0
  (sub_nT_TCC5-1 nil 3813611401 ("" (termination-tcc) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (sum const-decl "nat" peg nil)
    (pegMeasure const-decl "nat" peg nil))
   nil
   (sub_nT termination
    "inferred_order_wf_peg.sub_nT(inferred_order_wf_peg.e1, inferred_order_wf_peg.P_0)"
    "nil")))
 (sub_nT_TCC6 0
  (sub_nT_TCC6-1 nil 3813611401 ("" (termination-tcc) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (sum const-decl "nat" peg nil)
    (pegMeasure const-decl "nat" peg nil))
   nil
   (sub_nT termination
    "inferred_order_wf_peg.sub_nT(inferred_order_wf_peg.e2, inferred_order_wf_peg.P_0)"
    "nil")))
 (sub_nT_TCC7 0
  (sub_nT_TCC7-1 nil 3813611401 ("" (termination-tcc) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (sum const-decl "nat" peg nil)
    (pegMeasure const-decl "nat" peg nil))
   nil
   (sub_nT termination
    "inferred_order_wf_peg.sub_nT(inferred_order_wf_peg.e1, inferred_order_wf_peg.P_0)"
    "nil")))
 (sub_nT_TCC8 0
  (sub_nT_TCC8-1 nil 3813611401 ("" (termination-tcc) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (sum const-decl "nat" peg nil)
    (pegMeasure const-decl "nat" peg nil))
   nil
   (sub_nT termination
    "inferred_order_wf_peg.sub_nT(inferred_order_wf_peg.e1, inferred_order_wf_peg.P_0)"
    "nil")))
 (sub_nT_TCC9 0
  (sub_nT_TCC9-1 nil 3813611401 ("" (termination-tcc) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (sum const-decl "nat" peg nil)
    (pegMeasure const-decl "nat" peg nil))
   nil
   (sub_nT termination
    "inferred_order_wf_peg.sub_nT(inferred_order_wf_peg.e2, inferred_order_wf_peg.P_0)"
    "nil")))
 (sub_nT_TCC10 0
  (sub_nT_TCC10-1 nil 3813611401 ("" (termination-tcc) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (inc const-decl "nat" peg nil)
    (pegMeasure const-decl "nat" peg nil))
   nil
   (sub_nT termination
    "inferred_order_wf_peg.sub_nT(inferred_order_wf_peg.e, inferred_order_wf_peg.P_0)"
    "nil")))
 (sub_nT_TCC11 0
  (sub_nT_TCC11-1 nil 3813611401 ("" (termination-tcc) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (inc const-decl "nat" peg nil)
    (pegMeasure const-decl "nat" peg nil))
   nil
   (sub_nT termination
    "inferred_order_wf_peg.sub_nT(inferred_order_wf_peg.e, inferred_order_wf_peg.P_0)"
    "nil")))
 (sub_nT_TCC12 0
  (sub_nT_TCC12-1 nil 3813611401 ("" (termination-tcc) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (inc const-decl "nat" peg nil)
    (pegMeasure const-decl "nat" peg nil))
   nil
   (sub_nT termination
    "inferred_order_wf_peg.sub_nT(inferred_order_wf_peg.e, inferred_order_wf_peg.P_0)"
    "nil")))
 (sub_nT_TCC13 0
  (sub_nT_TCC13-1 nil 3813611401 ("" (termination-tcc) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (inc const-decl "nat" peg nil)
    (pegMeasure const-decl "nat" peg nil))
   nil
   (sub_nT termination
    "inferred_order_wf_peg.sub_nT(inferred_order_wf_peg.e, inferred_order_wf_peg.P_0)"
    "nil")))
 (sub_nT_TCC14 0
  (sub_nT_TCC14-1 nil 3813611401 ("" (termination-tcc) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (inc const-decl "nat" peg nil)
    (pegMeasure const-decl "nat" peg nil))
   nil
   (sub_nT termination
    "inferred_order_wf_peg.sub_nT(inferred_order_wf_peg.e, inferred_order_wf_peg.P_0)"
    "nil")))
 (sub_nT_and_wellformedness_TCC1 0
  (sub_nT_and_wellformedness_TCC1-1 nil 3813611401
   ("" (subtype-tcc) nil nil) nil nil
   (sub_nT_and_wellformedness subtype "inferred_order_wf_peg.A"
    "naturalnumbers.upto(inferred_order_wf_peg.V_N_b)")))
 (sub_nT_and_wellformedness 0
  (sub_nT_and_wellformedness-1 nil 3813611424
   ("" (induct G)
    (("1" (skeep*)
      (("1" (assert)
        (("1" (expand "g_wf")
          (("1" (expand "sub_nT")
            (("1" (assert)
              (("1" (skeep)
                (("1" (assert) (("1" (grind) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil)
     ("5" (grind) nil nil)
     ("6" (skolem 1 ("e1" "e2"))
      (("6" (flatten)
        (("6" (skeep*)
          (("6" (expand "g_wf" +)
            (("6" (assert)
              (("6" (inst -1 "A" "P_0")
                (("6" (inst -2 "A" "P_0")
                  (("6" (split 1)
                    (("1" (flatten)
                      (("1" (assert)
                        (("1" (split)
                          (("1" (assert) nil nil)
                           ("2" (flatten)
                            (("2" (assert)
                              (("2"
                                (expand "complete")
                                (("2"
                                  (expand "strong")
                                  (("2"
                                    (assert)
                                    (("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("3" (assert)
                            (("3" (flatten)
                              (("3"
                                (assert)
                                (("3"
                                  (skeep*)
                                  (("3" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (expand "strong")
                      (("2" (expand "complete")
                        (("2" (flatten)
                          (("2" (split)
                            (("1" (assert)
                              (("1"
                                (skeep)
                                (("1"
                                  (assert)
                                  (("1" (grind) nil nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (assert)
                              (("2"
                                (ground)
                                (("1" (grind) nil nil)
                                 ("2"
                                  (skeep*)
                                  (("2"
                                    (assert)
                                    (("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("7" (skolem 1 ("e1" "e2"))
      (("7" (flatten)
        (("7" (skeep*)
          (("7" (inst -1 "A" "P_0")
            (("7" (inst - "A" "P_0")
              (("7" (expand "strong")
                (("7" (expand "complete")
                  (("7" (expand "g_wf" +)
                    (("7" (split 1)
                      (("1" (flatten)
                        (("1" (assert)
                          (("1" (split 1)
                            (("1" (flatten) nil nil)
                             ("2" (assert) nil nil)
                             ("3" (skeep*)
                              (("3"
                                (assert)
                                (("3"
                                  (expand "sub_nT" -1)
                                  (("3" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (flatten)
                        (("2" (split 1)
                          (("1" (assert)
                            (("1" (skeep)
                              (("1"
                                (assert)
                                (("1" (grind) nil nil))
                                nil))
                              nil))
                            nil)
                           ("2" (assert)
                            (("2" (skeep) (("2" (grind) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("8" (skolem 1 ("e"))
      (("8" (flatten)
        (("8" (skeep)
          (("8" (inst? -)
            (("8" (inst? -)
              (("8" (expand "g_wf" +)
                (("8" (split 1)
                  (("1" (flatten)
                    (("1" (assert)
                      (("1" (split 2)
                        (("1" (assert) nil nil)
                         ("2" (skeep) (("2" (grind) nil nil)) nil))
                        nil))
                      nil))
                    nil)
                   ("2" (flatten)
                    (("2" (assert)
                      (("2" (skeep)
                        (("2" (assert) (("2" (grind) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("9" (skolem 1 ("e"))
      (("9" (flatten)
        (("9" (skeep)
          (("9" (inst? -) (("9" (inst? -) (("9" (grind) nil nil)) nil))
            nil))
          nil))
        nil))
      nil)
     ("10" (skolem 1 ("e"))
      (("10" (flatten)
        (("10" (skeep)
          (("10" (inst? -)
            (("10" (inst? -) (("10" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil)
     ("11" (skolem 1 ("e"))
      (("11" (flatten)
        (("11" (skeep)
          (("11" (inst? -)
            (("11" (inst? -) (("11" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil)
     ("12" (skolem 1 ("e"))
      (("12" (flatten)
        (("12" (skeep)
          (("12" (inst? -)
            (("12" (inst? -) (("12" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((finite_union application-judgement "finite_set" finite_sets nil)
    (member const-decl "bool" sets nil)
    (union const-decl "set" sets nil)
    (singleton const-decl "(singleton?)" sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (below type-eq-decl nil naturalnumbers nil)
    (TRUE const-decl "bool" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (emptyset const-decl "set" sets nil)
    (∅ const-decl "set[V_N[V_N_b]]" inferred_order_wf_peg nil)
    (peg_induction formula-decl nil peg nil)
    (V_T formal-nonempty-type-decl nil inferred_order_wf_peg nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" inferred_order_wf_peg
        nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" inferred_order_wf_peg nil)
    (sub_nT def-decl "finite_set[V_N[V_N_b]]" inferred_order_wf_peg
     nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (complete const-decl "bool" wf_peg nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (strong const-decl "bool" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (peg type-decl nil peg nil))
   shostak))
 (kahns_algorithm_TCC1 0
  (kahns_algorithm_TCC1-1 nil 3813648570
   ("" (inst 1 "LAMBDA (P_exp: interp[V_T, <=, V_N_b]): None") nil nil)
   ((None adt-constructor-decl "(None?)" inferred_order_wf_peg nil)
    (None? adt-recognizer-decl "[option_permutation -> boolean]"
     inferred_order_wf_peg nil)
    (σ adt-accessor-decl "[(Some?) -> nT_Permutation]"
     inferred_order_wf_peg nil)
    (topologically_sorts? const-decl "bool" inferred_order_wf_peg nil)
    (nT_Permutation type-eq-decl nil inferred_order_wf_peg nil)
    (bijective? const-decl "bool" functions nil)
    (peg type-decl nil peg nil) (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Some? adt-recognizer-decl "[option_permutation -> boolean]"
     inferred_order_wf_peg nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (option_permutation type-decl nil inferred_order_wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N_b formal-const-decl "posnat" inferred_order_wf_peg nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" inferred_order_wf_peg
        nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (V_T formal-nonempty-type-decl nil inferred_order_wf_peg nil))
   nil
   (kahns_algorithm existence ""
    "[P_exp: wf_peg[inferred_order_wf_peg.V_T, inferred_order_wf_peg.<=, inferred_order_wf_peg.V_N_b].interp -> {Σ: inferred_order_wf_peg.option_permutation | (booleans.⇒(inferred_order_wf_peg.Some?(Σ), inferred_order_wf_peg.topologically_sorts?(P_exp, inferred_order_wf_peg.σ(Σ))))}]")))
 (nT_properties_reorders 0
  (nT_properties_reorders-1 nil 3813656553
   ("" (skolem 1 ("P_exp" "s"))
    (("" (expand "nT_properties") (("" (postpone) nil nil)) nil)) nil)
   nil shostak))
 (complete_WF_reorders 0
  (complete_WF_reorders-1 nil 3813650558
   ("" (expand "complete_WF")
    (("" (expand "complete")
      (("" (skolem 1 ("P_exp" "s"))
        ((""
          (case "(FORALL (A: V_N[V_N_b]), G: subterm(G, P_exp(A)) IMPLIES g_wf(G, A, P_0c?(P_exp), FALSE)) ⇒
       FORALL (A: V_N[V_N_b]), G: subterm(G, (P_exp o s)(A)) IMPLIES g_wf(G, A, P_0c?(P_exp o s), FALSE)")
          (("1" (flatten)
            (("1" (skeep)
              (("1" (split -1)
                (("1" (inst? -)
                  (("1" (assert)
                    (("1" (expand "subterm") (("1" (propax) nil nil))
                      nil))
                    nil))
                  nil)
                 ("2" (hide 2)
                  (("2" (lemma "complete_WF_theorem")
                    (("2" (postpone) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (postpone) nil nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak))
 (topological_sort_well_orders 0
  (topological_sort_well_orders-1 nil 3813648698
   ("" (skeep*)
    (("" (name-replace "s" "σ!1")
      (("" (typepred "kahns_algorithm(P_exp)")
        (("" (replace -2 * LR)
          (("" (assert)
            (("" (expand "topologically_sorts?")
              (("" (expand "well_orders?")
                (("" (expand "strong_WF")
                  (("" (skeep)
                    (("" (expand "strong")
                      (("" (lemma sub_nT_and_wellformedness)
                        (("" (inst? -1)
                          (("" (assert)
                            (("" (split)
                              (("1"
                                (lemma "complete_WF_theorem2")
                                (("1"
                                  (inst? -)
                                  (("1"
                                    (assert)
                                    (("1"
                                      (use complete_WF_reorders)
                                      (("1"
                                        (assert)
                                        (("1"
                                          (inst? -)
                                          (("1"
                                            (assert)
                                            (("1"
                                              (expand "subterm")
                                              (("1" (propax) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (hide 2)
                                (("2" (postpone) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak)))

