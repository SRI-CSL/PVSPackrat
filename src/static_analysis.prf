(static_analysis
 (IMP_c_topological_sort_TCC1 0
  (IMP_c_topological_sort_TCC1-1 nil 3848133026
   ("" (inst 1 0) (("" (assert) nil nil)) nil)
   ((V_N type-eq-decl nil nTpred_order nil)
    (V_N_b formal-const-decl "posnat" static_analysis nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil (IMP_c_topological_sort existence "" "V_N[V_N_b]")))
 (V_N_not_empty 0
  (V_N_not_empty-1 nil 3847461586
   ("" (inst 1 0) (("" (grind) nil nil)) nil)
   ((V_N type-eq-decl nil nTpred_order nil)
    (V_N_b formal-const-decl "posnat" static_analysis nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   shostak))
 (every_iff_member 0
  (every_iff_member-1 nil 3847460814
   ("" (skeep)
    (("" (split)
      (("1" (flatten)
        (("1" (rewrite "every_nth")
          (("1" (skeep)
            (("1" (rewrite "member_iff_nth")
              (("1" (skeep)
                (("1" (inst -1 i) (("1" (assert) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (flatten)
        (("2" (rewrite "every_nth")
          (("2" (skeep)
            (("2" (inst -1 "nth(l,i)")
              (("2" (assert)
                (("2" (use "member_iff_nth[T]") (("2" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((every_nth formula-decl nil list_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (T decl-formal-type nil static_analysis nil)
    (member_iff_nth formula-decl nil more_list_props structures)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil))
   shostak))
 (node_ls_list_V_N 0
  (node_ls_list_V_N-1 nil 3847535537
   ("" (skolem 1 "l")
    (("" (typepred "l")
      (("" (rewrite "every_iff_member[number]")
        (("" (rewrite "every_iff_member[number]")
          (("" (skolem 1 "n")
            (("" (inst -1 n)
              (("" (flatten)
                (("" (assert)
                  (("" (flatten)
                    (("" (assert)
                      (("" (inst -7 "n") (("" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((node_ls type-eq-decl nil static_analysis nil)
    (V_N_b formal-const-decl "posnat" static_analysis nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (member def-decl "bool" list_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (no_repetitions? const-decl "bool" more_list_props structures)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (< const-decl "bool" reals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (every_iff_member formula-decl nil static_analysis nil))
   nil
   (node_ls_list_V_N subtype "static_analysis.x" "list[V_N[V_N_b]]")))
 (no_rep_cdr_iff 0
  (no_rep_cdr_iff-1 nil 3847282215
   ("" (skeep*)
    (("" (split)
      (("1" (flatten)
        (("1" (use "no_rep_cdr[nat]") (("1" (assert) nil nil)) nil))
        nil)
       ("2" (flatten)
        (("2" (expand "no_repetitions?")
          (("2" (skeep)
            (("2" (expand "nth" -2)
              (("2" (lift-if)
                (("2" (lift-if)
                  (("2" (assert)
                    (("2" (lift-if)
                      (("2" (ground)
                        (("1" (use "member_iff_nth[nat]")
                          (("1" (grind) nil nil)) nil)
                         ("2" (use "member_iff_nth[nat]")
                          (("2" (grind) nil nil)) nil)
                         ("3" (inst -2 "i-1" "j-1")
                          (("3" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((no_rep_cdr formula-decl nil more_list_props structures)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (no_repetitions? const-decl "bool" more_list_props structures)
    (nth def-decl "T" list_props nil)
    (member_iff_nth formula-decl nil more_list_props structures)
    (/= const-decl "boolean" notequal nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak))
 (no_repetitions_add_ls 0
  (no_repetitions_add_ls-1 nil 3847281851
   ("" (induct "l")
    (("1" (grind) nil nil)
     ("2" (skolem 1 ("x" "l"))
      (("2" (flatten)
        (("2" (skolem 1 y)
          (("2" (lemma "no_rep_cdr[nat]" (a x))
            (("2" (inst? -)
              (("2" (assert)
                (("2" (flatten)
                  (("2" (assert)
                    (("2" (flatten)
                      (("2" (inst -2 y)
                        (("2" (assert)
                          (("2" (expand "add_sl" +)
                            (("2" (assert)
                              (("2"
                                (ground)
                                (("2"
                                  (lemma "no_rep_cdr_iff")
                                  (("2"
                                    (inst -1 "add_sl(y,l)" x)
                                    (("2"
                                      (assert)
                                      (("2"
                                        (typepred "add_sl(y,l)")
                                        (("2"
                                          (inst -3 x)
                                          (("2" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((no_rep_cdr_iff formula-decl nil static_analysis nil)
    (no_rep_cdr formula-decl nil more_list_props structures)
    (/= const-decl "boolean" notequal nil)
    (below type-eq-decl nil naturalnumbers nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (list_induction formula-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (add_sl def-decl
     "{ll: (nonempty_sl?) | FORALL y: member(y, ll) IFF (x = y OR member(y, l))}"
     set_as_list structures)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (member def-decl "bool" list_props nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (nonempty_sl? const-decl "bool" set_as_list structures)
    (no_repetitions? const-decl "bool" more_list_props structures)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil))
   shostak))
 (no_repetitions_union_ls 0
  (no_repetitions_union_ls-1 nil 3847282749
   ("" (induct "l1")
    (("1" (grind) nil nil)
     ("2" (skolem 1 ("x" "l"))
      (("2" (flatten)
        (("2" (skeep)
          (("2" (expand "union_sl" +)
            (("2" (lift-if)
              (("2" (assert)
                (("2" (lemma "no_repetitions_add_ls")
                  (("2" (inst -1 "union_sl(l,l2)" x)
                    (("2" (assert)
                      (("2" (use "no_rep_cdr[nat]")
                        (("2" (assert)
                          (("2" (flatten)
                            (("2" (assert) (("2" (grind) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((no_repetitions_add_ls formula-decl nil static_analysis nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (< const-decl "bool" reals nil)
    (x skolem-const-decl "nat" static_analysis nil)
    (length def-decl "nat" list_props nil)
    (l skolem-const-decl "list[nat]" static_analysis nil)
    (below type-eq-decl nil naturalnumbers nil)
    (add_sl def-decl
     "{ll: (nonempty_sl?) | FORALL y: member(y, ll) IFF (x = y OR member(y, l))}"
     set_as_list structures)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nonempty_sl? const-decl "bool" set_as_list structures)
    (no_rep_cdr formula-decl nil more_list_props structures)
    (/= const-decl "boolean" notequal nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (list_induction formula-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (union_sl def-decl
     "{ll: list[T] | FORALL x: member(x, ll) IFF (member(x, l1) OR member(x, l2))}"
     set_as_list structures)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (member def-decl "bool" list_props nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (no_repetitions? const-decl "bool" more_list_props structures)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil))
   shostak))
 (V_N_list_subtype_nat_list 0
  (V_N_list_subtype_nat_list-1 nil 3847461392
   ("" (skeep*)
    (("" (typepred "x")
      (("" (rewrite "every_iff_member[number]")
        (("" (rewrite "every_iff_member[number]")
          (("" (skolem 1 "a")
            (("" (inst -1 "a")
              (("" (flatten)
                (("" (assert)
                  (("" (flatten) (("" (assert) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((V_N type-eq-decl nil nTpred_order nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (V_N_b formal-const-decl "posnat" static_analysis nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil) (>= const-decl "bool" reals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (every_iff_member formula-decl nil static_analysis nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (V_N_list_subtype_nat_list_ subtype "list_adt[V_N[V_N_b]].list"
    "list_adt[nat].list")))
 (idx_V_N_nat 0
  (idx_V_N_nat-1 nil 3847550410
   ("" (induct l)
    (("1" (grind) nil nil)
     ("2" (skolem 1 ("x" "l"))
      (("2" (flatten)
        (("2" (skolem 1 "y")
          (("2" (expand "idx" +)
            (("2" (inst -1 y)
              (("1" (assert)
                (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)
               ("2" (typepred "y")
                (("2" (expand "member" -) (("2" (assert) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (x skolem-const-decl "V_N[V_N_b]" static_analysis nil)
    (l skolem-const-decl "list[V_N[V_N_b]]" static_analysis nil)
    (y skolem-const-decl "{x_1: V_N | member(x_1, cons(x, l))}"
     static_analysis nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (list_induction formula-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" static_analysis nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (idx def-decl "{i: below(length(l)) | nth(l, i) = a}"
     more_list_props structures)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (member def-decl "bool" list_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil))
   shostak))
 (no_repetitions_V_N_nat 0
  (no_repetitions_V_N_nat-1 nil 3847796661
   ("" (skeep)
    (("" (expand "no_repetitions?") (("" (propax) nil nil)) nil)) nil)
   ((no_repetitions? const-decl "bool" more_list_props structures))
   shostak))
 (sub_nT_TCC1 0
  (sub_nT_TCC1-1 nil 3847256679 ("" (grind) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (length def-decl "nat" list_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (/= const-decl "boolean" notequal nil)
    (no_repetitions? const-decl "bool" more_list_props structures)
    (member def-decl "bool" list_props nil))
   nil (sub_nT subtype "list_adt[nat].null" "node_ls")))
 (sub_nT_TCC2 0
  (sub_nT_TCC2-1 nil 3847256679 ("" (grind) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (length def-decl "nat" list_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (/= const-decl "boolean" notequal nil)
    (no_repetitions? const-decl "bool" more_list_props structures)
    (member def-decl "bool" list_props nil))
   nil (sub_nT subtype "list_adt[nat].null" "node_ls")))
 (sub_nT_TCC3 0
  (sub_nT_TCC3-1 nil 3847256679 ("" (grind) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (length def-decl "nat" list_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (/= const-decl "boolean" notequal nil)
    (no_repetitions? const-decl "bool" more_list_props structures)
    (member def-decl "bool" list_props nil))
   nil (sub_nT subtype "list_adt[nat].null" "node_ls")))
 (sub_nT_TCC4 0
  (sub_nT_TCC4-1 nil 3847256679 ("" (grind) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (length def-decl "nat" list_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (/= const-decl "boolean" notequal nil)
    (no_repetitions? const-decl "bool" more_list_props structures)
    (member def-decl "bool" list_props nil))
   nil (sub_nT subtype "list_adt[nat].null" "node_ls")))
 (sub_nT_TCC5 0
  (sub_nT_TCC5-1 nil 3847268234 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" static_analysis nil)
    (below type-eq-decl nil naturalnumbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (length def-decl "nat" list_props nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (/= const-decl "boolean" notequal nil)
    (no_repetitions? const-decl "bool" more_list_props structures)
    (member def-decl "bool" list_props nil))
   nil
   (sub_nT subtype
    "list_adt[nat].cons(static_analysis.B, list_adt[nat].null)"
    "node_ls")))
 (sub_nT_TCC6 0
  (sub_nT_TCC5-1 nil 3847256679 ("" (termination-tcc) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (sum const-decl "nat" peg nil)
    (pegMeasure const-decl "nat" peg nil))
   nil
   (sub_nT termination
    "static_analysis.sub_nT(static_analysis.e1, static_analysis.P_0)"
    "nil")))
 (sub_nT_TCC7 0
  (sub_nT_TCC6-1 nil 3847256679 ("" (termination-tcc) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (sum const-decl "nat" peg nil)
    (pegMeasure const-decl "nat" peg nil))
   nil
   (sub_nT termination
    "static_analysis.sub_nT(static_analysis.e2, static_analysis.P_0)"
    "nil")))
 (sub_nT_TCC8 0
  (sub_nT_TCC6-1 nil 3847268234
   ("" (skeep)
    (("" (split)
      (("1" (use "no_repetitions_union_ls") (("1" (assert) nil nil))
        nil)
       ("2" (skeep)
        (("2" (typepred "union_sl[nat](v(e1, P_0), v(e2, P_0))")
          (("2" (inst -2 n)
            (("2" (assert)
              (("2" (typepred "v(e1, P_0)")
                (("2" (inst -3 n)
                  (("2" (assert)
                    (("2" (typepred "v(e2, P_0)")
                      (("2" (inst -3 n) (("2" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (V_T formal-nonempty-type-decl nil static_analysis nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" static_analysis nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" static_analysis nil)
    (peg type-decl nil peg nil) (< const-decl "bool" reals nil)
    (pegMeasure const-decl "nat" peg nil)
    (no_repetitions? const-decl "bool" more_list_props structures)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (member def-decl "bool" list_props nil)
    (<= const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (node_ls type-eq-decl nil static_analysis nil)
    (no_repetitions_union_ls formula-decl nil static_analysis nil)
    (union_sl def-decl
     "{ll: list[T] | FORALL x: member(x, ll) IFF (member(x, l1) OR member(x, l2))}"
     set_as_list structures)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (sub_nT subtype
    "set_as_list[nat].union_sl(static_analysis.sub_nT(static_analysis.e1, static_analysis.P_0), static_analysis.sub_nT(static_analysis.e2, static_analysis.P_0))"
    "node_ls")))
 (sub_nT_TCC9 0
  (sub_nT_TCC7-1 nil 3847256679 ("" (termination-tcc) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (sum const-decl "nat" peg nil)
    (pegMeasure const-decl "nat" peg nil))
   nil
   (sub_nT termination
    "static_analysis.sub_nT(static_analysis.e1, static_analysis.P_0)"
    "nil")))
 (sub_nT_TCC10 0
  (sub_nT_TCC8-1 nil 3847256679 ("" (termination-tcc) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (sum const-decl "nat" peg nil)
    (pegMeasure const-decl "nat" peg nil))
   nil
   (sub_nT termination
    "static_analysis.sub_nT(static_analysis.e1, static_analysis.P_0)"
    "nil")))
 (sub_nT_TCC11 0
  (sub_nT_TCC9-1 nil 3847256679 ("" (termination-tcc) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (sum const-decl "nat" peg nil)
    (pegMeasure const-decl "nat" peg nil))
   nil
   (sub_nT termination
    "static_analysis.sub_nT(static_analysis.e2, static_analysis.P_0)"
    "nil")))
 (sub_nT_TCC12 0
  (sub_nT_TCC9-1 nil 3847268234
   ("" (skeep*)
    (("" (use "no_repetitions_union_ls")
      (("1" (assert)
        (("1" (skeep)
          (("1" (typepred "union_sl[nat](v(e1, P_0), v(e2, P_0))")
            (("1" (inst -2 n)
              (("1" (assert)
                (("1" (typepred "v(e1, P_0)")
                  (("1" (inst -3 n)
                    (("1" (typepred "v(e2, P_0)")
                      (("1" (inst -3 n) (("1" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (grind) nil nil) ("3" (grind) nil nil))
      nil))
    nil)
   ((no_repetitions_union_ls formula-decl nil static_analysis nil)
    (node_ls type-eq-decl nil static_analysis nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (member def-decl "bool" list_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (no_repetitions? const-decl "bool" more_list_props structures)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (e2 skolem-const-decl "peg[V_T, <=, V_N_b]" static_analysis nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (V_T formal-nonempty-type-decl nil static_analysis nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" static_analysis nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" static_analysis nil)
    (peg type-decl nil peg nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pegMeasure const-decl "nat" peg nil)
    (e1 skolem-const-decl "peg[V_T, <=, V_N_b]" static_analysis nil)
    (G skolem-const-decl "peg[V_T, <=, V_N_b]" static_analysis nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (union_sl def-decl
     "{ll: list[T] | FORALL x: member(x, ll) IFF (member(x, l1) OR member(x, l2))}"
     set_as_list structures)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (/= const-decl "boolean" notequal nil)
    (sum const-decl "nat" peg nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sub_nT subtype
    "set_as_list[nat].union_sl(static_analysis.sub_nT(static_analysis.e1, static_analysis.P_0), static_analysis.sub_nT(static_analysis.e2, static_analysis.P_0))"
    "node_ls")))
 (sub_nT_TCC13 0
  (sub_nT_TCC10-1 nil 3847256679 ("" (termination-tcc) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (inc const-decl "nat" peg nil)
    (pegMeasure const-decl "nat" peg nil))
   nil
   (sub_nT termination
    "static_analysis.sub_nT(static_analysis.e, static_analysis.P_0)"
    "nil")))
 (sub_nT_TCC14 0
  (sub_nT_TCC11-1 nil 3847256679 ("" (termination-tcc) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (inc const-decl "nat" peg nil)
    (pegMeasure const-decl "nat" peg nil))
   nil
   (sub_nT termination
    "static_analysis.sub_nT(static_analysis.e, static_analysis.P_0)"
    "nil")))
 (sub_nT_TCC15 0
  (sub_nT_TCC12-1 nil 3847256679 ("" (termination-tcc) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (inc const-decl "nat" peg nil)
    (pegMeasure const-decl "nat" peg nil))
   nil
   (sub_nT termination
    "static_analysis.sub_nT(static_analysis.e, static_analysis.P_0)"
    "nil")))
 (sub_nT_TCC16 0
  (sub_nT_TCC13-1 nil 3847256679 ("" (termination-tcc) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (inc const-decl "nat" peg nil)
    (pegMeasure const-decl "nat" peg nil))
   nil
   (sub_nT termination
    "static_analysis.sub_nT(static_analysis.e, static_analysis.P_0)"
    "nil")))
 (sub_nT_TCC17 0
  (sub_nT_TCC14-1 nil 3847256679 ("" (termination-tcc) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (inc const-decl "nat" peg nil)
    (pegMeasure const-decl "nat" peg nil))
   nil
   (sub_nT termination
    "static_analysis.sub_nT(static_analysis.e, static_analysis.P_0)"
    "nil")))
 (union_sl_member_or 0
  (union_sl_member_or-1 nil 3847736799
   ("" (skeep*)
    (("" (typepred "union_sl(l1, l2)") (("" (grind) nil nil)) nil))
    nil)
   ((node_ls type-eq-decl nil static_analysis nil)
    (V_N_b formal-const-decl "posnat" static_analysis nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (no_repetitions? const-decl "bool" more_list_props structures)
    (union_sl def-decl
     "{ll: list[T] | FORALL x: member(x, ll) IFF (member(x, l1) OR member(x, l2))}"
     set_as_list structures)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (member def-decl "bool" list_props nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak))
 (sub_nT_and_wellformedness 0
  (sub_nT_and_wellformedness-1 nil 3847256683
   ("" (skolem 1 ("σ" "A" "P_0" "_"))
    (("" (induct "G")
      (("1" (grind) nil nil) ("2" (grind) nil nil)
       ("3" (grind) nil nil) ("4" (grind) nil nil)
       ("5" (grind) nil nil) ("6" (grind) nil nil)
       ("7" (grind) nil nil)
       ("8" (skolem 1 ("e1" "e2"))
        (("8" (flatten)
          (("8" (expand "pattern_wf?" +)
            (("8" (expand "sub_nT" +)
              (("8" (split 1)
                (("1" (flatten)
                  (("1" (assert)
                    (("1" (skeep)
                      (("1" (lift-if)
                        (("1" (assert)
                          (("1" (split -3)
                            (("1" (flatten)
                              (("1"
                                (assert)
                                (("1"
                                  (typepred
                                   "union_sl(sub_nT(e1, P_0), sub_nT(e2, P_0))")
                                  (("1"
                                    (hide -1)
                                    (("1"
                                      (inst - B)
                                      (("1"
                                        (assert)
                                        (("1" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (flatten)
                              (("2"
                                (assert)
                                (("2" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (case "P_0(e1)")
                    (("1" (assert)
                      (("1" (ground)
                        (("1" (skeep)
                          (("1" (inst -5 B)
                            (("1"
                              (typepred
                               "union_sl(sub_nT(e1, P_0), sub_nT(e2, P_0))")
                              (("1"
                                (inst -2 "B")
                                (("1" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (skeep*)
                          (("2" (inst-cp -4 "B")
                            (("2" (inst-cp -4 "B!1")
                              (("2"
                                (grind)
                                (("2"
                                  (typepred
                                   "union_sl(sub_nT(e1, P_0), sub_nT(e2, P_0))")
                                  (("2"
                                    (inst -2 B)
                                    (("2"
                                      (hide -1)
                                      (("2" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("3" (skeep)
                          (("3" (inst -5 B)
                            (("3"
                              (typepred
                               "union_sl(sub_nT(e1, P_0), sub_nT(e2, P_0))")
                              (("3" (grind) nil nil)) nil))
                            nil))
                          nil)
                         ("4" (skeep)
                          (("4" (inst - "B")
                            (("4" (assert)
                              (("4"
                                (typepred
                                 "union_sl(sub_nT(e1, P_0), sub_nT(e2, P_0))")
                                (("4" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (assert) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("9" (skolem 1 ("e1" "e2"))
        (("9" (flatten)
          (("9" (expand "pattern_wf?" +)
            (("9" (expand "sub_nT" +)
              (("9" (ground)
                (("1" (skeep)
                  (("1" (inst - B)
                    (("1" (inst - B)
                      (("1"
                        (typepred
                         "union_sl(sub_nT(e1, P_0), sub_nT(e2, P_0))")
                        (("1" (inst -2 B)
                          (("1" (assert) (("1" (ground) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (skeep)
                  (("2" (inst - B)
                    (("2" (inst - B)
                      (("2" (assert)
                        (("2"
                          (typepred
                           "union_sl(sub_nT(e1, P_0), sub_nT(e2, P_0))")
                          (("2" (inst -2 B) (("2" (assert) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("3" (skeep)
                  (("3" (inst - B)
                    (("3" (inst - B)
                      (("3" (assert)
                        (("3"
                          (typepred
                           "union_sl(sub_nT(e1, P_0), sub_nT(e2, P_0))")
                          (("3" (inst -2 B) (("3" (assert) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("4" (skeep)
                  (("4" (inst - B)
                    (("4" (assert)
                      (("4"
                        (typepred
                         "union_sl(sub_nT(e1, P_0), sub_nT(e2, P_0))")
                        (("4" (inst -2 B) (("4" (assert) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("5" (skeep)
                  (("5" (inst - B)
                    (("5" (assert)
                      (("5"
                        (typepred
                         "union_sl(sub_nT(e1, P_0), sub_nT(e2, P_0))")
                        (("5" (inst -2 B) (("5" (assert) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("10" (skolem 1 "e")
        (("10" (flatten)
          (("10" (expand "pattern_wf?" +)
            (("10" (expand "sub_nT" +) (("10" (grind) nil nil)) nil))
            nil))
          nil))
        nil)
       ("11" (skolem 1 "e")
        (("11" (flatten)
          (("11" (expand "pattern_wf?" +)
            (("11" (expand "sub_nT" +) (("11" (grind) nil nil)) nil))
            nil))
          nil))
        nil)
       ("12" (skolem 1 "e")
        (("12" (flatten)
          (("12" (expand "pattern_wf?" +)
            (("12" (expand "sub_nT" +) (("12" (ground) nil nil)) nil))
            nil))
          nil))
        nil)
       ("13" (skolem 1 "e")
        (("13" (flatten)
          (("13" (expand "pattern_wf?" +)
            (("13" (expand "sub_nT" +) (("13" (ground) nil nil)) nil))
            nil))
          nil))
        nil)
       ("14" (skolem 1 "e")
        (("14" (flatten)
          (("14" (expand "pattern_wf?" +)
            (("14" (expand "sub_nT" +) (("14" (ground) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((peg type-decl nil peg nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (pattern_wf? def-decl "bool" wf_peg nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (member def-decl "bool" list_props nil)
    (no_repetitions? const-decl "bool" more_list_props structures)
    (<= const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (node_ls type-eq-decl nil static_analysis nil)
    (sub_nT def-decl "node_ls" static_analysis nil)
    (V_N_b formal-const-decl "posnat" static_analysis nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" static_analysis nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (V_T formal-nonempty-type-decl nil static_analysis nil)
    (peg_induction formula-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (TRUE const-decl "bool" booleans nil)
    (union_sl_member_or formula-decl nil static_analysis nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (union_sl def-decl
     "{ll: list[T] | FORALL x: member(x, ll) IFF (member(x, l1) OR member(x, l2))}"
     set_as_list structures))
   shostak))
 (nodes_TCC1 0
  (nodes_TCC1-1 nil 3847362076
   ("" (grind)
    (("" (typepred "make_srl_rec(0, V_N_b - 1)")
      (("" (rewrite "every_nth")
        (("" (rewrite "every_nth")
          (("" (skeep)
            (("" (inst -1 i)
              (("" (assert)
                (("" (flatten)
                  (("" (ground)
                    (("1"
                      (inst -5 "nth(make_srl_rec(0, V_N_b - 1), i)")
                      (("1" (assert)
                        (("1" (use "member_iff_nth[int]")
                          (("1" (assert) (("1" (inst 1 i) nil nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2"
                      (inst -5 "nth(make_srl_rec(0, V_N_b - 1), i)")
                      (("2" (assert)
                        (("2" (use "member_iff_nth[int]")
                          (("2" (assert) (("2" (inst 1 i) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (nodes subtype "(number_fields.-)(static_analysis.V_N_b, 1)"
    "nat")))
 (nodes_TCC2 0
  (nodes_TCC2-1 nil 3847515139
   ("" (split)
    (("1" (use "interval_list_no_repetitions") (("1" (assert) nil nil))
      nil)
     ("2" (skeep)
      (("2" (expand "interval_list")
        (("2" (assert)
          (("2" (typepred "interval_list_rec(0, V_N_b - 1)")
            (("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (member def-decl "bool" list_props nil)
    (interval_list_rec def-decl
     "{l: list[nat] | FORALL k: i <= k <= j ⇔ member(k, l)}"
     interval_list nil)
    (interval_list const-decl "list[nat]" interval_list nil)
    (interval_list_no_repetitions formula-decl nil interval_list nil)
    (V_N_b formal-const-decl "posnat" static_analysis nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (nodes subtype
    "interval_list.interval_list(0, (number_fields.-)(static_analysis.V_N_b, 1))"
    "node_ls")))
 (dependency_graph_TCC1 0
  (dependency_graph_TCC1-1 nil 3847362076
   ("" (skeep)
    (("" (expand "cdigraph")
      (("" (case-replace "length(nodes(P_exp)) = V_N_b")
        (("1" (split)
          (("1" (lemma "map_length[V_N[V_N_b], node_ls]")
            (("1" (grind) nil nil)) nil)
           ("2" (expand "list_of_idxs")
            (("2" (expand "size")
              (("2" (skolem 1 "i")
                (("2" (skolem 1 "j")
                  (("2" (lemma "map_nth_rw[V_N[V_N_b], node_ls]")
                    (("2"
                      (inst - "adjacents(P_exp)" "nodes(P_exp)" "i")
                      (("1" (replaces)
                        (("1" (expand "adjacents")
                          (("1"
                            (typepred
                             "sub_nT(P_exp(nth(nodes(P_exp), i)), P_0c(P_exp))")
                            (("1"
                              (inst -3
                               " nth(sub_nT(P_exp(nth(nodes(P_exp), i)), P_0c(P_exp)), j)")
                              (("1"
                                (assert)
                                (("1"
                                  (use "member_iff_nth[nat]")
                                  (("1"
                                    (assert)
                                    (("1" (inst 1 "j") nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (expand "nodes")
                              (("2"
                                (rewrite "interval_list_nth")
                                (("2"
                                  (assert)
                                  (("2"
                                    (typepred "i")
                                    (("2"
                                      (lemma
                                       "map_length[V_N[V_N_b], node_ls]")
                                      (("2"
                                        (inst
                                         -1
                                         "adjacents(P_exp)"
                                         "nodes(P_exp)")
                                        (("2"
                                          (replace -1 * LR)
                                          (("2"
                                            (expand "nodes")
                                            (("2"
                                              (rewrite
                                               "interval_list_length")
                                              nil
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (typepred "i")
                        (("2" (lemma "map_length[V_N[V_N_b], node_ls]")
                          (("2"
                            (inst -1 "adjacents(P_exp)" "nodes(P_exp)")
                            (("2" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("3" (expand "nodes")
            (("3" (skeep)
              (("3"
                (case-replace
                 "nth(map[V_N[V_N_b], node_ls](adjacents(P_exp))(interval_list(0, V_N_b - 1)), i) = adjacents(P_exp)(nth(interval_list(0, V_N_b -1),i))")
                (("1" (assert) nil nil)
                 ("2" (hide -1 2)
                  (("2" (lemma "map_nth_rw[V_N[V_N_b], node_ls]")
                    (("2" (inst -1 "adjacents(P_exp)" "nodes(P_exp)" i)
                      (("1" (assert) (("1" (grind) nil nil)) nil)
                       ("2" (typepred "i")
                        (("2" (lemma "map_length[V_N[V_N_b],node_ls]")
                          (("2"
                            (inst -1 "adjacents(P_exp)" "nodes(P_exp)")
                            (("2" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("3" (rewrite "interval_list_nth")
                  (("1" (typepred "i")
                    (("1" (lemma "map_length[V_N[V_N_b],node_ls]")
                      (("1" (inst -1 "adjacents(P_exp)" "nodes(P_exp)")
                        (("1" (assert)
                          (("1" (expand "nodes")
                            (("1" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (typepred "i")
                    (("2" (lemma "map_length[V_N[V_N_b],node_ls]")
                      (("2" (expand "nodes")
                        (("2"
                          (inst - "adjacents(P_exp)"
                           "interval_list(0,V_N_b-1)")
                          (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("4" (typepred "i")
                  (("4" (lemma "map_length[V_N[V_N_b],node_ls]")
                    (("4" (inst -1 "adjacents(P_exp)" "nodes(P_exp)")
                      (("4" (expand "nodes")
                        (("4" (assert) (("4" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("5" (assert) nil nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (assert)
          (("2" (hide 2)
            (("2" (expand "nodes")
              (("2" (rewrite "interval_list_length") nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((cdigraph const-decl "bool" c_digraphs_def digraphs)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (interval_list const-decl "list[nat]" interval_list nil)
    (map adt-def-decl "list[T1]" list_adt_map nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (interval_list_rec def-decl
     "{l: list[nat] | FORALL k: i <= k <= j ⇔ member(k, l)}"
     interval_list nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (adjacents const-decl "node_ls" static_analysis nil)
    (map_length formula-decl nil more_map_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (size const-decl "nat" c_digraphs_def digraphs)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (P_exp skolem-const-decl "interp[V_T, <=, V_N_b]" static_analysis
     nil)
    (below type-eq-decl nil naturalnumbers nil)
    (i skolem-const-decl
       "below(length(map[V_N[V_N_b], node_ls](adjacents(P_exp))(nodes(P_exp))))"
       static_analysis nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (interval_list_length formula-decl nil interval_list nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (interval_list_nth formula-decl nil interval_list nil)
    (member_iff_nth formula-decl nil more_list_props structures)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (sub_nT def-decl "node_ls" static_analysis nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (map_nth_rw formula-decl nil more_map_props nil)
    (list_of_idxs const-decl "bool" c_digraphs_def digraphs)
    (i skolem-const-decl
       "below(length(map[V_N[V_N_b], node_ls](adjacents(P_exp))(nodes(P_exp))))"
       static_analysis nil)
    (nodes const-decl "node_ls" static_analysis nil)
    (node_ls type-eq-decl nil static_analysis nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (member def-decl "bool" list_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (no_repetitions? const-decl "bool" more_list_props structures)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (<= formal-const-decl "(total_order?[V_T])" static_analysis nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil static_analysis nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (V_N_b formal-const-decl "posnat" static_analysis nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   nil
   (dependency_graph subtype
    "(# data := static_analysis.nodes(static_analysis.P_exp), adjs := list_adt_map[V_N[V_N_b], node_ls].map(static_analysis.adjacents(static_analysis.P_exp))(static_analysis.nodes(static_analysis.P_exp)) #)"
    "c_digraph[nat]")))
 (map_adjacents_nth_TCC1 0
  (map_adjacents_nth_TCC1-1 nil 3847733409
   ("" (assert)
    (("" (grind)
      (("" (typepred "interval_list_rec(0, V_N_b - 1)")
        (("" (assert)
          (("" (use "every_iff_member[number]")
            (("" (assert)
              (("" (hide -2)
                (("" (use "every_iff_member[number]")
                  (("" (assert)
                    (("" (hide 2)
                      (("" (skeep)
                        (("" (inst -2 "x_1")
                          (("" (assert)
                            (("" (flatten)
                              ((""
                                (assert)
                                ((""
                                  (inst -7 x_1)
                                  (("" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((interval_list const-decl "list[nat]" interval_list nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (< const-decl "bool" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (every_iff_member formula-decl nil static_analysis nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (member def-decl "bool" list_props nil)
    (interval_list_rec def-decl
     "{l: list[nat] | FORALL k: i <= k <= j ⇔ member(k, l)}"
     interval_list nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" static_analysis nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (map_adjacents_nth subtype
    "interval_list.interval_list(0, (number_fields.-)(static_analysis.V_N_b, 1))"
    "list[V_N[V_N_b]]")))
 (map_adjacents_nth_TCC2 0
  (map_adjacents_nth_TCC1-1 nil 3847732155
   ("" (skeep)
    (("" (assert)
      (("" (lemma "map_length[V_N[V_N_b],node_ls]")
        (("" (inst -1 "adjacents(P_exp)" "nodes(P_exp)")
          (("" (assert)
            (("" (expand "nodes") (("" (assert) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (V_T formal-nonempty-type-decl nil static_analysis nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" static_analysis nil)
    (peg type-decl nil peg nil) (interp type-eq-decl nil wf_peg nil)
    (adjacents const-decl "node_ls" static_analysis nil)
    (nodes const-decl "node_ls" static_analysis nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (interval_list_length formula-decl nil interval_list nil)
    (map_length formula-decl nil more_map_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" static_analysis nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (no_repetitions? const-decl "bool" more_list_props structures)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (member def-decl "bool" list_props nil)
    (<= const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (node_ls type-eq-decl nil static_analysis nil))
   nil
   (map_adjacents_nth subtype "static_analysis.A"
    "below[length[node_ls](map[V_N[V_N_b], node_ls](adjacents(P_exp))(interval_list(0, V_N_b - 1)))]")))
 (map_adjacents_nth 0
  (map_adjacents_nth-1 nil 3847732156
   ("" (skeep)
    (("" (use "map_nth_rw[V_N, node_ls]")
      (("" (assert)
        (("" (assert)
          (("" (expand "adjacents") (("" (propax) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((interval_list_length formula-decl nil interval_list nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (map_nth_rw formula-decl nil more_map_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" static_analysis nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (no_repetitions? const-decl "bool" more_list_props structures)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (member def-decl "bool" list_props nil)
    (<= const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (node_ls type-eq-decl nil static_analysis nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (interval_list const-decl "list[nat]" interval_list nil)
    (adjacents const-decl "node_ls" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (<= formal-const-decl "(total_order?[V_T])" static_analysis nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil static_analysis nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (interval_list_nth formula-decl nil interval_list nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (node_dependency_graph_TCC1 0
  (node_dependency_graph_TCC1-1 nil 3847797031
   ("" (expand "size")
    (("" (skeep)
      (("" (expand "dependency_graph")
        (("" (assert)
          (("" (expand "nodes") (("" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (interval_list_length formula-decl nil interval_list nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nodes const-decl "node_ls" static_analysis nil)
    (dependency_graph const-decl "c_digraph[nat]" static_analysis nil)
    (size const-decl "nat" c_digraphs_def digraphs))
   nil
   (node_dependency_graph subtype "static_analysis.A"
    "naturalnumbers.below(c_digraphs_def[V_N[V_N_b]].size(static_analysis.dependency_graph(static_analysis.P_exp)))")))
 (node_dependency_graph_TCC2 0
  (node_dependency_graph_TCC2-1 nil 3847797595
   ("" (assert)
    (("" (skeep*)
      (("" (ground)
        (("1" (expand "dependency_graph")
          (("1" (assert)
            (("1" (expand "nodes")
              (("1" (lemma "map_adjacents_nth_TCC1")
                (("1" (propax) nil nil)) nil))
              nil))
            nil))
          nil)
         ("2" (lemma "dependency_graph_TCC1")
          (("2" (inst -1 P_exp)
            (("2" (expand "dependency_graph")
              (("2" (assert)
                (("2" (expand "cdigraph")
                  (("2" (flatten)
                    (("2" (ground)
                      (("2" (skeep)
                        (("2" (inst -2 i)
                          (("2" (assert)
                            (("2" (expand "list_of_idxs")
                              (("2"
                                (assert)
                                (("2"
                                  (skeep)
                                  (("2"
                                    (inst -2 i_1)
                                    (("2"
                                      (assert)
                                      (("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((TRUE const-decl "bool" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (dependency_graph_TCC1 subtype-tcc nil static_analysis nil)
    (cdigraph const-decl "bool" c_digraphs_def digraphs)
    (no_repetitions_V_N_nat formula-decl nil static_analysis nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (length def-decl "nat" list_props nil)
    (no_repetitions? const-decl "bool" more_list_props structures)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (member def-decl "bool" list_props nil)
    (<= const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (node_ls type-eq-decl nil static_analysis nil)
    (map adt-def-decl "list[T1]" list_adt_map nil)
    (adjacents const-decl "node_ls" static_analysis nil)
    (below type-eq-decl nil naturalnumbers nil)
    (list_of_idxs const-decl "bool" c_digraphs_def digraphs)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (/= const-decl "boolean" notequal nil)
    (size const-decl "nat" c_digraphs_def digraphs)
    (interval_list const-decl "list[nat]" interval_list nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (<= formal-const-decl "(total_order?[V_T])" static_analysis nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil static_analysis nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (V_N_b formal-const-decl "posnat" static_analysis nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (dependency_graph const-decl "c_digraph[nat]" static_analysis nil)
    (nodes const-decl "node_ls" static_analysis nil)
    (map_adjacents_nth_TCC1 subtype-tcc nil static_analysis nil))
   nil
   (node_dependency_graph subtype
    "static_analysis.dependency_graph(static_analysis.P_exp)"
    "c_digraph[V_N[V_N_b]]")))
 (node_dependency_graph 0
  (node_dependency_graph-1 nil 3847797032
   ("" (skeep)
    (("" (expand "node")
      (("" (expand "dependency_graph")
        (("" (assert)
          (("" (expand "nodes") (("" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((node const-decl "{v: T | member(v, data(cd))}" c_digraphs_def
     digraphs)
    (interval_list_nth formula-decl nil interval_list nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nodes const-decl "node_ls" static_analysis nil)
    (dependency_graph const-decl "c_digraph[nat]" static_analysis nil))
   shostak))
 (data_dependency_graph 0
  (data_dependency_graph-1 nil 3847798099 ("" (grind) nil nil)
   ((interval_list const-decl "list[nat]" interval_list nil)
    (nodes const-decl "node_ls" static_analysis nil)
    (map adt-def-decl "list[T1]" list_adt_map nil)
    (dependency_graph const-decl "c_digraph[nat]" static_analysis nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   shostak))
 (pattern_WF_topological_ordering_TCC1 0
  (pattern_WF_topological_ordering_TCC1-1 nil 3848126615
   ("" (skeep*)
    (("" (assert)
      (("" (auto-rewrite "data_dependency_graph")
        (("" (assert) nil nil)) nil))
      nil))
    nil)
   ((nodes const-decl "node_ls" static_analysis nil)
    (data_dependency_graph formula-decl nil static_analysis nil)
    (interval_list_length formula-decl nil interval_list nil)
    (size const-decl "nat" c_digraphs_def digraphs)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (pattern_WF_topological_ordering subtype
    "restrict[V_N[V_N_b], digraphs_[V_N[V_N_b], digraph_type[V_N[V_N_b]], c_digraphs_imp[V_N[V_N_b]].digraph_verts, c_digraphs_imp[V_N[V_N_b]].digraph_edges, c_digraphs_imp[V_N[V_N_b]].digraph_size, c_digraphs_imp[V_N[V_N_b]].digraph_make].vert(static_analysis.dependency_graph(static_analysis.P_exp)), V_N[V_N_b]].restrict(static_analysis.σ)"
    "[digraphs_[V_N[V_N_b], digraph_type[V_N[V_N_b]], c_digraphs_imp[V_N[V_N_b]].digraph_verts, c_digraphs_imp[V_N[V_N_b]].digraph_edges, c_digraphs_imp[V_N[V_N_b]].digraph_size, c_digraphs_imp[V_N[V_N_b]].digraph_make].vert(static_analysis.dependency_graph(static_analysis.P_exp)) -> naturalnumbers.below(c_digraphs_def[V_N[V_N_b]].size(static_analysis.dependency_graph(static_analysis.P_exp)))]")))
 (pattern_WF_topological_ordering 0
  (pattern_WF_topological_ordering-1 nil 3848129794
   ("" (skeep*)
    (("" (assert)
      (("" (expand "restrict")
        (("" (assert)
          (("" (ground)
            (("1" (expand "topological_ordering?")
              (("1" (ground)
                (("1" (typepred "σ")
                  (("1" (expand "bijective?")
                    (("1" (ground)
                      (("1" (expand "injective?")
                        (("1" (skeep)
                          (("1" (inst - x1 x2) (("1" (assert) nil nil))
                            nil))
                          nil))
                        nil)
                       ("2" (expand "surjective?")
                        (("2" (skeep)
                          (("2" (inst - y)
                            (("1" (skeep)
                              (("1"
                                (inst 1 x)
                                (("1"
                                  (assert)
                                  (("1"
                                    (expand "vert?")
                                    (("1" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (assert)
                              (("2"
                                (typepred "y")
                                (("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (skolem 1 (A B))
                  (("2" (flatten)
                    (("2" (assert)
                      (("2" (expand "edge?")
                        (("2" (assert)
                          (("2" (assert)
                            (("2" (assert)
                              (("2"
                                (expand "dependency_graph")
                                (("2"
                                  (assert)
                                  (("2"
                                    (use "sub_nT_and_wellformedness")
                                    (("2"
                                      (expand "pattern_WF?")
                                      (("2"
                                        (inst - A)
                                        (("2"
                                          (assert)
                                          (("2"
                                            (inst - B)
                                            (("2" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (expand "pattern_WF?")
              (("2" (skeep)
                (("2" (use "sub_nT_and_wellformedness")
                  (("2" (assert)
                    (("2" (hide 2)
                      (("2" (skeep)
                        (("2" (expand "topological_ordering?")
                          (("2" (flatten)
                            (("2" (inst - A B)
                              (("2"
                                (assert)
                                (("2"
                                  (expand "edge?")
                                  (("2"
                                    (assert)
                                    (("2"
                                      (assert)
                                      (("2"
                                        (expand "dependency_graph")
                                        (("2" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((restrict_of_inj_is_inj application-judgement "(injective?[S, R])"
     restrict nil)
    (topological_ordering? const-decl "bool" c_topological_sort
     digraphs)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (edges const-decl "bool" c_digraphs_def digraphs)
    (map_adjacents_nth formula-decl nil static_analysis nil)
    (pattern_WF? const-decl "bool" wf_peg nil)
    (P_0c const-decl "[Δ -> bool]" wf_peg nil)
    (sub_nT_and_wellformedness formula-decl nil static_analysis nil)
    (idx_V_N_nat formula-decl nil static_analysis nil)
    (interval_list_idx formula-decl nil interval_list nil)
    (edge? const-decl "bool" digraphs_ digraphs)
    (order type-eq-decl nil wf_peg nil)
    (<= formal-const-decl "(total_order?[V_T])" static_analysis nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil static_analysis nil)
    (bijective? const-decl "bool" functions nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (V_N_b formal-const-decl "posnat" static_analysis nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (vert type-eq-decl nil digraphs_ digraphs)
    (dependency_graph const-decl "c_digraph[nat]" static_analysis nil)
    (c_digraph type-eq-decl nil c_digraphs_def digraphs)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (vert? const-decl "bool" digraphs_ digraphs)
    (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp
     digraphs)
    (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]"
     c_digraphs_imp digraphs)
    (digraph_verts const-decl "[digraph_type -> [T -> bool]]"
     c_digraphs_imp digraphs)
    (digraph_type type-eq-decl nil c_digraphs_imp digraphs)
    (cdigraph const-decl "bool" c_digraphs_def digraphs)
    (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (injective? const-decl "bool" functions nil)
    (interval_list_length formula-decl nil interval_list nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (nodes const-decl "node_ls" static_analysis nil)
    (data_dependency_graph formula-decl nil static_analysis nil)
    (interval_list_member formula-decl nil interval_list nil)
    (vert const-decl "bool" c_digraphs_def digraphs)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (x skolem-const-decl "V_N[V_N_b]" static_analysis nil)
    (size const-decl "nat" c_digraphs_def digraphs)
    (P_exp skolem-const-decl "interp[V_T, <=, V_N_b]" static_analysis
     nil)
    (below type-eq-decl nil naturalnumbers nil)
    (y skolem-const-decl "below(size(dependency_graph(P_exp)))"
     static_analysis nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (surjective? const-decl "bool" functions nil)
    (restrict const-decl "R" restrict nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak))
 (σ_TCC1 0
  (σ_TCC1-1 nil 3847800543
   ("" (skeep)
    (("" (typepred "P_exp")
      (("" (lemma "dependency_graph_wf_iff_dag")
        (("" (inst -1 "P_exp")
          (("" (assert)
            (("" (flatten)
              (("" (assert)
                ((""
                  (typepred
                   "topological_sort[V_N[V_N_b]](dependency_graph(P_exp))")
                  (("" (assert)
                    (("" (hide -1)
                      (("" (flatten)
                        (("" (expand "node")
                          (("" (expand "dependency_graph")
                            (("" (assert)
                              ((""
                                (inst -3 A)
                                (("1" (assert) nil nil)
                                 ("2"
                                  (assert)
                                  (("2"
                                    (expand "dependency_graph")
                                    (("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (<= formal-const-decl "(total_order?[V_T])" static_analysis nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil static_analysis nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (V_N_b formal-const-decl "posnat" static_analysis nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil
   (σ subtype
    "c_topological_sort[V_N[V_N_b]].topological_sort(static_analysis.dependency_graph(static_analysis.P_exp))"
    "(IN?_2)")))
 (σ_TCC2 0
  (σ_TCC2-1 nil 3847800543
   ("" (skeep)
    (("" (ground)
      (("1" (skeep*)
        (("1" (assert)
          (("1" (expand "vert?")
            (("1" (expand "digraph_verts")
              (("1" (expand "dependency_graph")
                (("1" (assert) nil nil)) nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (skeep)
        (("2"
          (typepred
           "OUT_2(topological_sort[V_N[V_N_b]](dependency_graph(P_exp)))(x1)")
          (("2" (assert)
            (("2" (expand "dependency_graph") (("2" (assert) nil nil))
              nil))
            nil))
          nil))
        nil)
       ("3"
        (typepred
         "OUT_2(topological_sort[V_N[V_N_b]](dependency_graph(P_exp)))")
        (("1" (expand "topological_ordering?")
          (("1" (flatten)
            (("1" (hide -2)
              (("1" (expand "bijective?")
                (("1" (expand "injective?")
                  (("1" (flatten)
                    (("1" (expand "surjective?")
                      (("1" (ground)
                        (("1" (skeep)
                          (("1" (inst -2 x1 x2)
                            (("1" (assert) nil nil)) nil))
                          nil)
                         ("2" (skeep)
                          (("2" (inst - y)
                            (("1" (skeep) (("1" (inst 1 x) nil nil))
                              nil)
                             ("2" (expand "dependency_graph")
                              (("2" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (typepred "P_exp")
          (("2" (lemma "dependency_graph_wf_iff_dag")
            (("2" (inst? -) (("2" (assert) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((digraph_verts const-decl "[digraph_type -> [T -> bool]]"
     c_digraphs_imp digraphs)
    (nodes const-decl "node_ls" static_analysis nil)
    (interval_list_member formula-decl nil interval_list nil)
    (vert const-decl "bool" c_digraphs_def digraphs)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (dependency_graph const-decl "c_digraph[nat]" static_analysis nil)
    (vert? const-decl "bool" digraphs_ digraphs)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (<= formal-const-decl "(total_order?[V_T])" static_analysis nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil static_analysis nil)
    (topological_sort const-decl
     "{res: [loop(G) + (topological_ordering?(G))] | IN?_2(res) ⇔ is_dag(G)}"
     c_topological_sort digraphs)
    (is_dag const-decl "bool" c_topological_sort digraphs)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (topological_ordering? const-decl "bool" c_topological_sort
     digraphs)
    (below type-eq-decl nil naturalnumbers nil)
    (size const-decl "nat" c_digraphs_def digraphs)
    (vert type-eq-decl nil digraphs_ digraphs)
    (loop type-eq-decl nil c_topological_sort digraphs)
    (path? const-decl "bool" paths_ digraphs)
    (Walk type-eq-decl nil walks_ digraphs)
    (walk? const-decl "bool" walks_ digraphs)
    (prewalk type-eq-decl nil walks_ digraphs)
    (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp
     digraphs)
    (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]"
     c_digraphs_imp digraphs)
    (digraph_type type-eq-decl nil c_digraphs_imp digraphs)
    (cdigraph const-decl "bool" c_digraphs_def digraphs)
    (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (below type-eq-decl nil nat_types nil)
    (c_digraph type-eq-decl nil c_digraphs_def digraphs)
    (V_N type-eq-decl nil nTpred_order nil)
    (V_N_b formal-const-decl "posnat" static_analysis nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (interval_list_length formula-decl nil interval_list nil)
    (data_dependency_graph formula-decl nil static_analysis nil)
    (injective? const-decl "bool" functions nil)
    (surjective? const-decl "bool" functions nil)
    (bijective? const-decl "bool" functions nil))
   nil
   (σ subtype
    "OUT_2(c_topological_sort[V_N[V_N_b]].topological_sort(static_analysis.dependency_graph(static_analysis.P_exp)))"
    "order[V_T, <=, V_N_b]")))
 (WF_nT_rewrite 0
  (WF_nT_rewrite-1 nil 3848133027
   ("" (skolemty 1 "P_exp")
    (("" (assert)
      (("" (expand "WF_nT?")
        (("" (ground)
          (("" (use "pattern_WF_topological_ordering")
            (("" (assert)
              (("" (hide 2)
                (("" (expand "restrict")
                  (("" (expand "σ")
                    (("" (assert)
                      ((""
                        (typepred
                         " OUT_2(topological_sort[V_N[V_N_b]](dependency_graph(P_exp)))")
                        (("" (assert)
                          (("" (expand "topological_ordering?")
                            (("" (flatten)
                              ((""
                                (ground)
                                ((""
                                  (expand "bijective?")
                                  ((""
                                    (expand "injective?")
                                    ((""
                                      (expand "surjective?")
                                      (("" (propax) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((structural_WF? const-decl "bool" wf_peg nil)
    (V_T formal-nonempty-type-decl nil static_analysis nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" static_analysis nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "posnat" static_analysis nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (restrict_of_inj_is_inj application-judgement "(injective?[S, R])"
     restrict nil)
    (restrict const-decl "R" restrict nil)
    (surjective? const-decl "bool" functions nil)
    (injective? const-decl "bool" functions nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (c_digraph type-eq-decl nil c_digraphs_def digraphs)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs)
    (cdigraph const-decl "bool" c_digraphs_def digraphs)
    (digraph_type type-eq-decl nil c_digraphs_imp digraphs)
    (digraph_verts const-decl "[digraph_type -> [T -> bool]]"
     c_digraphs_imp digraphs)
    (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]"
     c_digraphs_imp digraphs)
    (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp
     digraphs)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs)
    (vert? const-decl "bool" digraphs_ digraphs)
    (vert type-eq-decl nil digraphs_ digraphs)
    (size const-decl "nat" c_digraphs_def digraphs)
    (below type-eq-decl nil naturalnumbers nil)
    (topological_ordering? const-decl "bool" c_topological_sort
     digraphs)
    (dependency_graph const-decl "c_digraph[nat]" static_analysis nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (prewalk type-eq-decl nil walks_ digraphs)
    (walk? const-decl "bool" walks_ digraphs)
    (Walk type-eq-decl nil walks_ digraphs)
    (path? const-decl "bool" paths_ digraphs)
    (loop type-eq-decl nil c_topological_sort digraphs)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (is_dag const-decl "bool" c_topological_sort digraphs)
    (topological_sort const-decl
     "{res: [loop(G) + (topological_ordering?(G))] | IN?_2(res) ⇔ is_dag(G)}"
     c_topological_sort digraphs)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil) (peg type-decl nil peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (WF_nT type-eq-decl nil static_analysis nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (σ const-decl "order" static_analysis nil)
    (pattern_WF_topological_ordering formula-decl nil static_analysis
     nil)
    (WF_nT? const-decl "bool" static_analysis nil))
   shostak))
 (dependency_graph_wf_iff_dag 0
  (dependency_graph_wf_iff_dag-1 nil 3847451200
   ("" (skeep)
    (("" (expand "wf_nT?")
      (("" (expand "WF_nT?")
        (("" (ground)
          (("1" (skeep)
            (("1"
              (typepred
               "topological_sort[V_N[V_N_b]](dependency_graph(P_exp))")
              (("1" (assert)
                (("1" (hide -1)
                  (("1" (use "topological_sort_exists[V_N]")
                    (("1" (assert)
                      (("1" (inst 1 "σ!1")
                        (("1" (use "pattern_WF_topological_ordering")
                          (("1" (assert)
                            (("1" (skeep) (("1" (ground) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (inst 1 "σ(P_exp)")
            (("2" (assert)
              (("2" (use "pattern_WF_topological_ordering")
                (("2" (assert)
                  (("2" (expand "restrict")
                    (("2" (assert)
                      (("2"
                        (typepred
                         "OUT_2(topological_sort[V_N[V_N_b]](dependency_graph(P_exp)))")
                        (("2" (expand "σ")
                          (("2" (assert)
                            (("2" (expand "topological_ordering?")
                              (("2"
                                (flatten)
                                (("2"
                                  (assert)
                                  (("2"
                                    (expand "bijective?")
                                    (("2"
                                      (expand "injective?")
                                      (("2"
                                        (expand "surjective?")
                                        (("2" (ground) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((wf_nT? const-decl "bool" wf_peg nil)
    (V_N_b formal-const-decl "posnat" static_analysis nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" static_analysis nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (V_T formal-nonempty-type-decl nil static_analysis nil)
    (structural_WF? const-decl "bool" wf_peg nil)
    (loop_free? const-decl "bool" static_analysis nil)
    (dependency_graph const-decl "c_digraph[nat]" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (topological_sort const-decl
     "{res: [loop(G) + (topological_ordering?(G))] | IN?_2(res) ⇔ is_dag(G)}"
     c_topological_sort digraphs)
    (is_dag const-decl "bool" c_topological_sort digraphs)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (topological_ordering? const-decl "bool" c_topological_sort
     digraphs)
    (below type-eq-decl nil naturalnumbers nil)
    (size const-decl "nat" c_digraphs_def digraphs)
    (vert type-eq-decl nil digraphs_ digraphs)
    (vert? const-decl "bool" digraphs_ digraphs)
    (loop type-eq-decl nil c_topological_sort digraphs)
    (path? const-decl "bool" paths_ digraphs)
    (Walk type-eq-decl nil walks_ digraphs)
    (walk? const-decl "bool" walks_ digraphs)
    (prewalk type-eq-decl nil walks_ digraphs)
    (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp
     digraphs)
    (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]"
     c_digraphs_imp digraphs)
    (digraph_verts const-decl "[digraph_type -> [T -> bool]]"
     c_digraphs_imp digraphs)
    (digraph_type type-eq-decl nil c_digraphs_imp digraphs)
    (cdigraph const-decl "bool" c_digraphs_def digraphs)
    (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (below type-eq-decl nil nat_types nil)
    (c_digraph type-eq-decl nil c_digraphs_def digraphs)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (pattern_WF_topological_ordering formula-decl nil static_analysis
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (σ!1 skolem-const-decl "order[V_T, <=, V_N_b]" static_analysis nil)
    (P_exp skolem-const-decl "interp[V_T, <=, V_N_b]" static_analysis
     nil)
    (interval_list_length formula-decl nil interval_list nil)
    (data_dependency_graph formula-decl nil static_analysis nil)
    (nodes const-decl "node_ls" static_analysis nil)
    (restrict const-decl "R" restrict nil)
    (bijective? const-decl "bool" functions nil)
    (order type-eq-decl nil wf_peg nil)
    (restrict_of_inj_is_inj application-judgement "(injective?[S, R])"
     restrict nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (topological_sort_exists formula-decl nil c_topological_sort
     digraphs)
    (injective? const-decl "bool" functions nil)
    (surjective? const-decl "bool" functions nil)
    (σ const-decl "order" static_analysis nil)
    (loop_free type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil))
   shostak))
 (WF_nT_wf_nT_subtype 0
  (WF_nT_wf_nT_subtype-1 nil 3848142350
   ("" (skeep)
    (("" (typepred "x")
      (("" (use "dependency_graph_wf_iff_dag") (("" (assert) nil nil))
        nil))
      nil))
    nil)
   ((WF_nT type-eq-decl nil static_analysis nil)
    (WF_nT? const-decl "bool" static_analysis nil)
    (interp type-eq-decl nil wf_peg nil) (peg type-decl nil peg nil)
    (<= formal-const-decl "(total_order?[V_T])" static_analysis nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil static_analysis nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (V_N_b formal-const-decl "posnat" static_analysis nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (wf_nT? const-decl "bool" wf_peg nil)
    (structural_WF? const-decl "bool" wf_peg nil)
    (dependency_graph_wf_iff_dag formula-decl nil static_analysis nil))
   nil
   (WF_nT_wf_nT_subtype subtype "static_analysis.x"
    "wf_nT[V_T, <=, V_N_b]"))))

